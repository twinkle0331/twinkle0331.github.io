<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="算法一词在古籍中最早见于周髀算经，对应的algorithm一词来自于波斯数学家al-Khwarizmi ，均以数学语言描述。最早的算法在线性方程组中用到，其中的欧几里得算法为史上第一个算法。算法一词在日常生活中也越来越普遍，究竟什么才可以称为算法呢？我们又可以怎样衡量算法效率呢？">
<meta property="og:type" content="article">
<meta property="og:title" content="算法导论">
<meta property="og:url" content="http://example.com/intro/index.html">
<meta property="og:site_name" content="trinkle">
<meta property="og:description" content="算法一词在古籍中最早见于周髀算经，对应的algorithm一词来自于波斯数学家al-Khwarizmi ，均以数学语言描述。最早的算法在线性方程组中用到，其中的欧几里得算法为史上第一个算法。算法一词在日常生活中也越来越普遍，究竟什么才可以称为算法呢？我们又可以怎样衡量算法效率呢？">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/08/28/VJTp8wSemy61H7t.png">
<meta property="og:image" content="https://i.loli.net/2019/08/28/sKM9mUPSfDjLruy.png">
<meta property="article:published_time" content="2019-08-28T02:55:59.000Z">
<meta property="article:modified_time" content="2021-03-27T13:17:35.000Z">
<meta property="article:author" content="trinkle">
<meta property="article:tag" content="Data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2019/08/28/VJTp8wSemy61H7t.png">


<link rel="canonical" href="http://example.com/intro/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>算法导论 | trinkle</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="trinkle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">trinkle</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trinkle">
      <meta itemprop="description" content="Stay foolish,stay hungry.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="trinkle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          算法导论
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-08-28 10:55:59" itemprop="dateCreated datePublished" datetime="2019-08-28T10:55:59+08:00">2019-08-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>算法一词在古籍中最早见于周髀算经，对应的algorithm一词来自于波斯数学家<em>al-Khwarizmi</em> ，均以数学语言描述。最早的算法在线性方程组中用到，其中的欧几里得算法为史上第一个算法。算法一词在日常生活中也越来越普遍，究竟什么才可以称为算法呢？我们又可以怎样衡量算法效率呢？</p>
<a id="more"></a>

<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法是计算机程序的数学抽象，基于特定的计算模型，旨在解决某一信息处理问题而设计的指令序列。</p>
<p>算法具有以下特性：</p>
<ul>
<li><code>输入</code>待处理的信息(问题)</li>
<li><code>输出</code> 经处理的信息(答案)</li>
<li><code>正确性</code> 的确可以解决指定的问题</li>
<li><code>确定性</code> 任一算法均可以描述为一个由基本操作组成的序列</li>
<li><code>可行性</code> 每一基本操作都可实现，且在常数时间内完成</li>
<li><code>有穷性</code> 对于任何输入，经有穷次操作，都可以得到输出</li>
</ul>
<p>计算的过程即为信息处理的过程，输入信息经算法处理后得到输出信息。计算模型为计算机的抽象，各层次间抽象对应关系为：</p>
<table>
<thead>
<tr>
<th>程序</th>
<th>算法</th>
</tr>
</thead>
<tbody><tr>
<td>编程语言</td>
<td>伪代码</td>
</tr>
<tr>
<td>计算机</td>
<td>计算模型</td>
</tr>
</tbody></table>
<p>其中，算法建立在伪代码之上，伪代码建立于计算模型之上，类似的，程序基于编程语言，编程语言基于计算机实现。</p>
<h1 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h1><p>在实际环境中直接测得的执行时间，可作为衡量算法效率的指标。可是即便是同一输入，同一算法，在不同的硬件平台上、不同的操作系统，所需要的时间都不尽相同。在图灵机、随机存储机等计算模型中，指令语句均可分解为若干次基本操作，比如算术运算、比较、分支、子程序调用和返回等，在大多数实际计算环境中，每一次这类基本操作都可在常数时间内完成。这样一来，可以将时间复杂度理解为算法中各条指令的执行时间之和，从而统一衡量各个算法的效率。</p>
<p>计算模型指定了：</p>
<ol>
<li>算法的基本操作</li>
<li>每种操作的成本(时间，空间)</li>
</ol>
<h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p><img src="https://i.loli.net/2019/08/28/VJTp8wSemy61H7t.png" alt="TIM截图20190828113648.png"></p>
<p>RAM(random access machine)由只读的输入纸带，只写的输出纸带和内存组成。内存由一系列无限宽度的寄存器组成，寄存器按照顺序编号，总数无限制。控制单元存储程序，即一系列语句，由程序计数器来指定下一个执行的语句。</p>
<p>在常数时间内，可以执行以下操作：</p>
<ul>
<li>将值读入到寄存器中</li>
<li>寄存器进行简单的加减乘除运算</li>
<li>将寄存器的值存储到内存中</li>
<li>通过寄存器号访问对应的寄存器</li>
</ul>
<blockquote>
<p>在哪些方面，现代电子计算机仍未达到RAM模型的需求</p>
</blockquote>
<p>现代电子计算机的寄存器数量有限，无法为无限总数，字长有限，无法存储任意宽度的整数。</p>
<h2 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h2><p>图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作：</p>
<ul>
<li>在纸上写上或擦除某个符号；</li>
<li>把注意力从纸的一个位置移动到另一个位置；</li>
</ul>
<p>而在每个阶段，人要决定下一步的动作，依赖于</p>
<p>（a）此人当前所关注的纸上某个位置的符号</p>
<p>（b）此人当前思维的状态。</p>
<p>为了模拟人的这种运算过程，图灵构造出一台假想的机器，该机器由以下几个部分组成：</p>
<ol>
<li><p>一条无限长的纸带TAPE。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号表示空白。纸带上的格子从左到右依次被编号为0, 1, 2, …，纸带的右端可以无限伸展。</p>
</li>
<li><p>一个读写头HEAD。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。</p>
</li>
<li><p>一套控制规则TABLE。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态，按照以下顺序告知图灵机命令：</p>
<p>写入（替换）或擦除当前符号；</p>
<p>移动 HEAD， ‘L’向左， ‘R’向右或者’N’不移动；</p>
<p>保持当前状态或者转到另一状态</p>
</li>
<li><p>一个状态寄存器。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态h，称为停机状态。</p>
</li>
</ol>
<p>借助计算模型简化和抽象一般计算工具，使我们可以独立于具体的平台对算法的效率给出可信的评价与评判。</p>
<p>T(n)=算法为求解规模为n的问题所需执行的基本操作次数。</p>
<p>在计算模型中，算法的运行时间正比于算法需要执行的基本操作次数。</p>
<h1 id="渐进分析"><a href="#渐进分析" class="headerlink" title="渐进分析"></a>渐进分析</h1><p>渐进分析符号，也即我们常说的大O记号，以$O、\Theta、 \Omega$ 这三种符号表示。</p>
<p>$f(x)=\Theta(x^2)$ 的形式与函数类似，却不是函数。$f(x)=\Theta(x^2)$意味着$f(x)$的一个上界和一个下界。如图所示，$f(x)$介于$0.9x^2$的下界和$1.2x^2$的上界之间，二者与$O$内的函数仅仅只差了一个常数项。</p>
<p><img src="https://i.loli.net/2019/08/28/sKM9mUPSfDjLruy.png"></p>
<p>$\Theta$从上界和下界同时限制了函数，$O$从上界限制了函数,$\Omega$从下界限制了函数。</p>
<h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><p>$2019^ {2019}=O(1)$</p>
<p>渐进而言，再大的常数，也小于递增的变数。</p>
<p>这类算法的效率最高，通常不含循环、分支、子程序等，但是具体分析视执行次数而定。</p>
<h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p>常底数无所谓，$log_an=log_ablog_bn=\Theta(log_bn)$ </p>
<p>常数次幂无所谓，$log n^c=clogn=\Theta(logn)$</p>
<p>这类算法非常有效，算法复杂度无限接近于常数，</p>
<p>任意$c&gt;0$,$logn=O(n^c)$ </p>
<h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>取多项式指数最高的一项，即</p>
<p>$a_kn^k+a_{k-1}n^{k-1}+…+a_1n+a_0=O(n^k)$</p>
<p>线性：所有$O(n)$类函数</p>
<h2 id="指数复杂度"><a href="#指数复杂度" class="headerlink" title="指数复杂度"></a>指数复杂度</h2><p>指数：$T(n)=a^n$</p>
<p>此类算法的计算成本增长极快，通常被认为不可忍受，从$n_c$到$2^n$ 是从有效算法到无效算法的分水岭。</p>
<p>随着问题输入规模的增大，同一算法所需的求解时间通常都呈现单调增加的趋势，但可能随着输入规模的增大，同一算法所需的计算时间可能上下波动。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>算法分析有两个主要任务，</p>
<ul>
<li>正确性的证明，即不变性和单调性的证明</li>
<li>复杂度分析，时间复杂度和空间复杂度的分析</li>
</ul>
<p>c++等高级语言的基本指令，均等效于常数条RAM的基本指令，在渐进分析下二者大体相当，所以可通过分析基本指令的执行次数来分析算法效率。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>随着输入规模的扩大，算法的执行时间的变化趋势可表现为输入规模的一个函数，称作该算法的时间复杂度。</p>
<p>具体地，特定算法处理规模为$n$的问题所需的时间可记作$T(n)$</p>
<p>复杂度分析主要方法：</p>
<ul>
<li>迭代：将所有基本操作的执行次数累加，即级数求和</li>
<li>递归：递归跟踪，分析递归实例情况，推导递推方程</li>
</ul>
<p>算数级数：与末项平方同阶</p>
<p>幂方级数：比幂次高出一阶</p>
<p>$T(n)=1^2+2^2+…+n^2=O(n^3)$</p>
<p>$T(n)=1^3+2^3+…+n^3=O(n^4)$</p>
<p>几何级数：与末项同阶</p>
<p>$T(n)=a^0+a^1+a^2+a^3+…+a^n=O(a^n)$</p>
<p>收敛级数：</p>
<p>$\sum_{k=1}^{n} \frac{1}{k^2} &lt;1+\frac{1}{2^2}+…=O(1)$</p>
<p>可能未必收敛，但是长度有限：</p>
<p>1)调和级数：$h(n)=1+1/2+1/3+1/4+1/5+…+1/n=\Theta(logn)$</p>
<p>2)对数级数：$log1+log2+log3+log4+…+logn=log(n!)=\Theta(nlogn)$</p>
<h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><blockquote>
<p>给定n个整数，将它们按照非降序排列</p>
</blockquote>
<p><strong>起泡排序</strong></p>
<p>依次比较每一对相邻元素，若逆序则交换之。若整趟都没有进行交换，则排序完成，否则再进行一趟扫描交换。</p>
<p>不变性：经$k$趟扫描交换后，最大的$k$个元素必然就位</p>
<p>单调性：经$k$趟扫描交换后，问题规模缩减至$n-k$</p>
<p>正确性：经至多$n$趟扫描后，算法必然终止，且能给出正确解答。</p>
<p>其中，单调性通常指问题的有效规模会随着算法的推进不断递减。不变性则不仅应在算法初始状态下自然满足，而且应与最终的正确性相呼应。</p>
<p><strong>性能</strong></p>
<p>最坏情况：输入数据反序排列，共$n-1$趟扫描交换</p>
<p>第$k$趟中，需做$n-k$次比较和$3(n-k)$次移动</p>
<p>累计</p>
<p>移动次数$=3n(n-1)/2$</p>
<p>比较次数$=(n-1)+(n-2)+…+1=n(n-1)/2$</p>
<p>$T(n)=4n(n-1)/2$</p>
<p>最好情况：所有输入元素已经完全有序</p>
<p>外循环仅一次，做$n-1$次比较和$0$次元素交换</p>
<h1 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h1><blockquote>
<p>计算任意n个整数之和</p>
</blockquote>
<p><strong>线性递归</strong> 逐一取出并累加各个元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumI</span> <span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//数组求和算法（迭代版）</span></span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//初始化累计器，O(1)</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) <span class="comment">//对全部共O(n)个元素，逐一</span></span><br><span class="line">      sum += A[i]; <span class="comment">//累计，O(1)</span></span><br><span class="line">   <span class="keyword">return</span> sum; <span class="comment">//返回累计值，O(1)</span></span><br><span class="line">&#125; <span class="comment">//O(1) + O(n)*O(1) + O(1) = O(n+2) = O(n)</span></span><br></pre></td></tr></table></figure>
<h2 id="减而治之"><a href="#减而治之" class="headerlink" title="减而治之"></a>减而治之</h2><p>为了求解一个大规模的问题，</p>
<ul>
<li>将其划分为两个子问题，其一平凡，另一规模缩减，</li>
<li>分别求解子问题，</li>
<li>由子问题的解得到原问题的解答。</li>
</ul>
<p>递归跟踪分析：</p>
<p>整个算法所需的计算时间应该等于所有递归实例的创建、执行和销毁所需的时间总和。检查每个递归实例，累计所需时间(调用语句本身计入对应的子实例)，其总和即为算法执行时间。在空间上，递归调用的空间复杂度正比于最大递归深度。</p>
<p><strong>线性递归</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//数组求和算法（线性递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">1</span> &gt; n ) <span class="comment">//平凡情况，递归基</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//直接（非递归式）计算</span></span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//一般情况</span></span><br><span class="line">      <span class="keyword">return</span> sum ( A, n - <span class="number">1</span> ) + A[n - <span class="number">1</span>]; <span class="comment">//递归：前n - 1项之和，再累计第n - 1项</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归跟踪分析</p>
</blockquote>
<p>每个递归实例只需要常数时间，递归深度为$n+1$</p>
<p>$T(n) = O(1)*(n + 1) = O(n)$</p>
<blockquote>
<p>递推方程分析</p>
</blockquote>
<p>从递推的角度来看，为求解<code>sum(A,n)</code> ,需递归求解规模为$n-1$的问题<code>sum(A,n-1)</code> ,再累加上A[n-1].</p>
<p>递推方程</p>
<p>$T(n)=T(n-1)+O(1)$</p>
<p>$T(0)=O(1)$</p>
<p>$T(n)=O(n)$</p>
<h2 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h2><p><strong>二分递归</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi )</span> </span>&#123; <span class="comment">//数组求和算法（二分递归版，入口为sum(A, 0, n - 1)）</span></span><br><span class="line">   <span class="keyword">if</span> ( lo == hi ) <span class="comment">//如遇递归基（区间长度已降至1），则</span></span><br><span class="line">      <span class="keyword">return</span> A[lo]; <span class="comment">//直接返回该元素</span></span><br><span class="line">   <span class="keyword">else</span> &#123; <span class="comment">//否则（一般情况下lo &lt; hi），则</span></span><br><span class="line">      <span class="keyword">int</span> mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">//以居中单元为界，将原区间一分为二</span></span><br><span class="line">      <span class="keyword">return</span> sum ( A, lo, mi ) + sum ( A, mi + <span class="number">1</span>, hi ); <span class="comment">//递归对各子数组求和，然后合计</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//O(hi - lo + 1)，线性正比于区间的长度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归跟踪分析</p>
</blockquote>
<p>$T(n)$为各层递归实例所需时间之和，</p>
<p>$T(n)=O(1)(1+2+…+n)=o(1)(2n-1)=O(n)$</p>
<blockquote>
<p>递推方程分析</p>
</blockquote>
<p>$T(n)=2T(n/2)+O(1)$</p>
<p>$T(0)=O(1)$</p>
<p>$T(n)= O(n)$</p>
<blockquote>
<p>从数组区间A[lo,hi)找出最大的两个整数A[x1],A[x2],比较的次数尽可能少</p>
</blockquote>
<p><strong>迭代版本1</strong></p>
<p>无论如何，比较次数总是$2n-3$次</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span>&amp; x1,<span class="keyword">int</span>&amp; x2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(x1=lo;<span class="keyword">int</span> i=lo+<span class="number">1</span>;i&lt;hi;i++)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(a[x1]&lt;a[i]) x1=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(x2=lo,<span class="keyword">int</span> i=lo+<span class="number">1</span>;i&lt;x1;i++)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(a[x2]&lt;a[i]) x2=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x1+<span class="number">1</span>;i&lt;hi;i++)&#123;</span><br><span class="line">	     <span class="keyword">if</span>(a[x2]&lt;a[i] x2=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>迭代版本2</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span>&amp; x1,<span class="keyword">int</span>&amp; x2)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(a[x1=lo]&lt;a[x2=lo+<span class="number">1</span>]) swap(x1,x2);</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> i=lo+<span class="number">2</span>;i&lt;hi;i++)&#123;</span><br><span class="line">	     <span class="keyword">if</span>(a[x2]&lt;a[i])&#123;</span><br><span class="line">		   <span class="keyword">if</span>(a[x1]&lt;a[x2=i])&#123;</span><br><span class="line">		      swap(x1,x2);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好情况：$1+(n-2)=n-1$</p>
<p>最坏情况：$1+(n-2)2=2n-3$</p>
<p><strong>迭代版本3</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span>&amp; x1,<span class="keyword">int</span>&amp; x2)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(hi&lt;=lo+<span class="number">3</span>) &#123;trivial(A,lo,hi,x1,x2);<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span> mi=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span> x1L,x2L;</span><br><span class="line">     max2(A,lo,mi,x1L,X2L);</span><br><span class="line">     <span class="keyword">int</span> x1R,x2R;</span><br><span class="line">     max2(A,mi,hi,x1R,x2R);</span><br><span class="line">     <span class="keyword">if</span>(A[x1L]&gt;A[x1R])&#123;</span><br><span class="line">         x1=x1L;x2=A[x2L]&gt;A[x1R]?x2L:x1R;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         x1=x1R;X2=A[x1L]&gt;A[x2R]?X1L;x2R;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;<span class="comment">//1+1=2;</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度分析如下：</p>
<p>$T(n)=2T(n/2)+2\leq 5n/3-2$​</p>
<p>$G(n)=T(n)+2$​</p>
<p>$G(n)=2T(n/2)$</p>
<p>$G(n)=2T(n/2)=4G(n/4)=8G(n/8)$</p>
<p>如果不考虑取整问题，</p>
<p>$G(n)=(n/3)G(n/(n/3))=(n/3)G(3)$</p>
<p>$G(n)=(n/2)G(2)$</p>
<p>$G(2)$和$G(3)$为递归基，</p>
<p>$T(3)\leq 3$</p>
<p>$G(3)=T(3)+2\leq5$</p>
<p>$G(n)\leq(5/3)n$</p>
<p>$T(2)=1$</p>
<p>$G(2)=T(2)+1=3$</p>
<p>$G(n)=(3/2)n$</p>
<p>取较大者，$G(n)\leq(n/3)G(3)\leq(5/3)n$</p>
<p>$T(N)=G(n)-2\leq(5/3)n-2$</p>
<p>以上为粗略的放缩</p>
<p>$T(n)=\lceil{3n/2} \rceil -2$</p>
<p>证明如下：</p>
<p>算法的具体过程为：</p>
<ul>
<li>将原问题划分为两个子问题，分别对应于向量的前半部分和后半部分</li>
<li>递归求解两问题的解，只需两次比较操作即可得到原问题的解</li>
</ul>
<p>若前一子向量中最大、次大元素分别为$a_1$,$a_2$,后一子向量分别为$b_1$,$b_2$,则全局最大元素必然取自$a_1$，$b_1$之间，不失一般性地，设：</p>
<p>$a_1=max(a_1,b_1)$</p>
<p>于是全局的次大元素必然取自$a_2$，$b_1$</p>
<p>$max(a_2,b_1)$</p>
<p>由以上分析可得边界条件和递推方程如下：</p>
<p>$T(n)=2T(n/2)+2$</p>
<p>$T(2)=1$</p>
<p>若令$S(n)=(T(n)+2)/2$</p>
<p>则有</p>
<p>$S(n)=S(n/2)=…=S(2)=3/2$</p>
<p>故有$T(n)=\lceil{3n/2} \rceil -2$</p>
<p>这里的关键性技巧在于，合并子问题的解可以仅需要两次而不是三次操作，否则，递归关系应该是：</p>
<p>$T(n)=2T(n/2)+3$</p>
<p>$T(n)=2n-3$</p>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><p>各种数据结构可看作是若干数据项构成的集合，同时对数据项预定义一组标准的操作。将数据项和对应的操作视为一个整体，从而将数据结构的外部实现和其内部实现相分离。数据集合和对应的操作可超脱于具体的程序设计语言和具体的实现方式。</p>
<p>抽象数据类型由数据模型和定义在该模型上的一组操作，为外部的逻辑特性，不涉及数据的存储方式。</p>
<p>数据结构为内部的表示与实现，实现抽象数据类型的一系列存储和读取信息的算法。其中存储信息的操作称为更新，读取信息的操作称为查询。</p>
<p>例如，有序列表支持以下操作：</p>
<ul>
<li>查询：<code>min()</code>,<code>max()</code>,<code>search(x)</code></li>
<li>更新：<code>insert(x)</code>,<code>delete(x)</code></li>
</ul>
<p>数据结构的特性为表示不变量(representation invariant)，指明了信息如何存储。不变量是一种属性，在程序运行时总是一种状态。表示不变量确保数据结构正常运行。只要表示不变性仍然保持，那么查询就会得到正确的结果。更新操作需确保更新后表示不变量仍然满足。</p>
<p>例如，有序向量的表示不变量为存储在向量中的关键值必然有序。二分查找在向量有序时必然是正确的，另一方面，插入时需保持向量的表示不变量。</p>
<h1 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><blockquote>
<p>就地(仅用常数辅助空间)将数组A[0,N)中的元素向左循环移动k个单元</p>
</blockquote>
<p><strong>蛮力版</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift0</span> <span class="params">( <span class="keyword">int</span>* A, <span class="keyword">int</span> n, <span class="keyword">int</span> k )</span> </span>&#123; <span class="comment">//蛮力地将数组循环左移k位，O(nk)</span></span><br><span class="line">   <span class="keyword">if</span> ( k &lt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">int</span> mov = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ( k-- ) &#123; <span class="comment">//反复以1为间隔循环左移，共迭代k次</span></span><br><span class="line">      mov += shift ( A, n, <span class="number">0</span>, <span class="number">1</span> );                                 </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mov;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>迭代版</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift1</span> <span class="params">( <span class="keyword">int</span>* A, <span class="keyword">int</span> n, <span class="keyword">int</span> k )</span> </span>&#123; </span><br><span class="line">   <span class="keyword">if</span> ( k &lt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> mov = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ( mov &lt; n ) &#123; <span class="comment">//O(GCD(n, k)) = O(n*k/LCM(n, k))</span></span><br><span class="line">      mov += shift ( A, n, s++, k );                                 </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mov;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>shift</code>实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift</span> <span class="params">( <span class="keyword">int</span>* A, <span class="keyword">int</span> n, <span class="keyword">int</span> s, <span class="keyword">int</span> k )</span> </span>&#123; <span class="comment">//从A[s]出发，以k为间隔循环左移，O(n / GCD(n, k))</span></span><br><span class="line">   <span class="keyword">int</span> bak = A[s]; <span class="comment">//备份起始元素</span></span><br><span class="line">   <span class="keyword">int</span> i = s, j = ( s + k ) % n; <span class="comment">//从该元素出发</span></span><br><span class="line">   <span class="keyword">int</span> mov = <span class="number">0</span>; <span class="comment">//移动次数</span></span><br><span class="line">   <span class="keyword">while</span> ( s != j ) &#123; <span class="comment">//以k为间隔</span></span><br><span class="line">      A[i] = A[j]; <span class="comment">//依次左移k位</span></span><br><span class="line">      i = j; j = ( j + k ) % n; mov++;</span><br><span class="line">   &#125;</span><br><span class="line">   A[i] = bak; <span class="comment">//将起始元素转入对应位置</span></span><br><span class="line">   <span class="keyword">return</span> mov + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>GCD(n, k)</code>轮迭代，将数组循环左移$k$位，时间复杂度为O(n)。$[0,n)$由关于$k$的<code>gcd(n,k)</code>个同余类组成，<code>shift(s,k)</code>只能够使其中一个同余类就位。</p>
<p><strong>倒置版</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift2</span> <span class="params">( <span class="keyword">int</span>* A, <span class="keyword">int</span> n, <span class="keyword">int</span> k )</span> </span>&#123; <span class="comment">//借助倒置算法，将数组循环左移k位，O(3n)</span></span><br><span class="line">   k %= n; <span class="comment">//确保k &lt;= n</span></span><br><span class="line">   reverse ( A, k ); <span class="comment">//将区间A[0, k)倒置：O(3k/2)次操作</span></span><br><span class="line">   reverse ( A + k, n - k ); <span class="comment">//将区间A[k, n)倒置：O(3(n - k)/2)次操作</span></span><br><span class="line">   reverse ( A, n ); <span class="comment">//倒置整个数组A[0, n)：O(3n/2)次操作</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">3</span> * n; <span class="comment">//返回累计操作次数，以便与其它算法比较：3/2 * (k + (n - k) + n) = 3n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法需要更多的元素交换操作，但是实际计算效率远远优于其余版本。究其原因在于，reverse涉及的数据元素在物理上是连续分布的，操作系统的缓存机制可以轻易地被激活，并充分发挥作用。其余版本的交换操作尽管可能更少，但是数据元素往往相距很远，缓存机制几乎完全失效。</p>
<h2 id="字宽"><a href="#字宽" class="headerlink" title="字宽"></a>字宽</h2><blockquote>
<p>对任意整数，求2^n</p>
</blockquote>
<p><strong>蛮力迭代版</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">power2BF_I</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//幂函数2^n算法（蛮力迭代版），n &gt;= 0</span></span><br><span class="line">   __int64 <span class="built_in">pow</span> = <span class="number">1</span>; <span class="comment">//O(1)：累积器初始化为2^0</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; n -- ) <span class="comment">//O(n)：迭代n轮，每轮都</span></span><br><span class="line">      <span class="built_in">pow</span> &lt;&lt;= <span class="number">1</span>; <span class="comment">//O(1)：将累积器翻倍</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">pow</span>; <span class="comment">//O(1)：返回累积器</span></span><br><span class="line">&#125; <span class="comment">//O(n) = O(2^r)，r为输入指数n的比特位数</span></span><br></pre></td></tr></table></figure>
<p><strong>优化迭代版</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">power2_I</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//幂函数2^n算法（优化迭代版），n &gt;= 0</span></span><br><span class="line">   __int64 <span class="built_in">pow</span> = <span class="number">1</span>; <span class="comment">//O(1)：累积器初始化为2^0</span></span><br><span class="line">   __int64 p = <span class="number">2</span>; <span class="comment">//O(1)：累乘项初始化为2</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; n ) &#123; <span class="comment">//O(logn)：迭代log(n)轮，每轮都</span></span><br><span class="line">      <span class="keyword">if</span> ( n &amp; <span class="number">1</span> ) <span class="comment">//O(1)：根据当前比特位是否为1，决定是否</span></span><br><span class="line">         <span class="built_in">pow</span> *= p; <span class="comment">//O(1)：将当前累乘项计入累积器</span></span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>; <span class="comment">//O(1)：指数减半</span></span><br><span class="line">      p *= p; <span class="comment">//O(1)：累乘项自乘</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">pow</span>; <span class="comment">//O(1)：返回累积器</span></span><br><span class="line">&#125; <span class="comment">//O(logn) = O(r)，r为输入指数n的比特位数</span></span><br></pre></td></tr></table></figure>
<p><strong>蛮力递归版</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">power2BF</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> ( <span class="number">1</span> &gt; n ) ? <span class="number">1</span> : power2BF ( n - <span class="number">1</span> ) &lt;&lt; <span class="number">1</span>; <span class="comment">//递归</span></span><br><span class="line">&#125; <span class="comment">//O(n) = O(2^r)，r为输入指数n的比特位数</span></span><br></pre></td></tr></table></figure>
<p><strong>优化递归版</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> __int64 <span class="title">sqr</span> <span class="params">( __int64 a )</span> </span>&#123; <span class="keyword">return</span> a * a; &#125;</span><br><span class="line"><span class="function">__int64 <span class="title">power2</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//幂函数2^n算法（优化递归版），n &gt;= 0</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> == n ) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//递归基；否则，视n的奇偶分别递归</span></span><br><span class="line">   <span class="keyword">return</span> ( n &amp; <span class="number">1</span> ) ? sqr ( power2 ( n &gt;&gt; <span class="number">1</span> ) ) &lt;&lt; <span class="number">1</span> : sqr ( power2 ( n &gt;&gt; <span class="number">1</span> ) );</span><br><span class="line">&#125; <span class="comment">//O(logn) = O(r)，r为输入指数n的比特位数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对任何给定的整数n&gt;0,计算$a^n$</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">power</span> <span class="params">( __int64 a, <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//a^n算法：n &gt;= 0</span></span><br><span class="line">   __int64 <span class="built_in">pow</span> = <span class="number">1</span>; <span class="comment">//O(1)</span></span><br><span class="line">   __int64 p = a; <span class="comment">//O(1)</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; n ) &#123; <span class="comment">//O(logn)</span></span><br><span class="line">      <span class="keyword">if</span> ( n &amp; <span class="number">1</span> ) <span class="comment">//O(1)</span></span><br><span class="line">         <span class="built_in">pow</span> *= p; <span class="comment">//O(1)</span></span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>; <span class="comment">//O(1)</span></span><br><span class="line">      p *= p; <span class="comment">//O(1)</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">pow</span>; <span class="comment">//O(1)</span></span><br><span class="line">&#125; <span class="comment">//power()</span></span><br></pre></td></tr></table></figure>
<p>输入规模=n的二进制位数=r,复杂度主要取决于循环次数</p>
<p>$T(r)=1+1+4r+1=O(r)$</p>
<blockquote>
<p>直接打印power(n)至少需要n单位的时间，而以上算法为O(logn)，存在悖论？</p>
</blockquote>
<p>基于power的分析都假定，整数的除法，打印等基本操作只需要O(1)时间，即采用所谓的常数代价准则。</p>
<p>设参与运算的整数数值为k，上述操作都需要逐个读取K的二进制展开的每一比特位，线性正比于k的有效位的总数目，即采用所谓的对数代价准则。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>随机数并不等概率地生成随机序列，随机数仍是人为制造地有规律的序列，所以无法满足随机均匀分布的假定条件。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>trinkle
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://example.com/intro/" title="算法导论">http://example.com/intro/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Data-structure/" rel="tag"><i class="fa fa-tag"></i> Data structure</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/io/" rel="prev" title="I/O子系统">
                  <i class="fa fa-chevron-left"></i> I/O子系统
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/list/" rel="next" title="列表">
                  列表 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">trinkle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
