<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>trinkle</title>
  
  
  <link href="http://twinkle0331.github.io/atom.xml" rel="self"/>
  
  <link href="http://twinkle0331.github.io/"/>
  <updated>2021-10-09T01:56:15.888Z</updated>
  <id>http://twinkle0331.github.io/</id>
  
  <author>
    <name>trinkle</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>词向量与对比学习</title>
    <link href="http://twinkle0331.github.io/research/word2vec/"/>
    <id>http://twinkle0331.github.io/research/word2vec/</id>
    <published>2021-10-09T01:54:51.000Z</published>
    <updated>2021-10-09T01:56:15.888Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/test.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/images/test.png&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Next博客配置</title>
    <link href="http://twinkle0331.github.io/config/next/"/>
    <id>http://twinkle0331.github.io/config/next/</id>
    <published>2021-03-28T13:44:17.000Z</published>
    <updated>2021-03-29T01:10:21.064Z</updated>
    
    <content type="html"><![CDATA[<p>在将近一年没有写博客之后，我又重新捡起之前的博客开始写了。至于为什么想写博客呢，<a href="https://wdxtub.com/qa/why-writing-blog/2013/10/17/">小土刀</a>的博客中提到</p><blockquote><p>我睡觉的时候大家的夜生活才刚刚开始，我醒来的时候大家却仍在熟睡，每天在禅修中等待天亮。想找人聊聊最近读的书，但是却没有志趣相投的，平日的聊天也大都跟技术相关，不怪乎其他专业的人觉得我们无趣了。我找不到人聊政治制度，找不到人聊历史，找不到人聊心理学，找不到人聊经济，我只能自己跟自己聊。</p><p>这就是我写博客的原因，这是我跟自己沟通的方式。我们每天每时每刻都有可能冒出各种各样光怪陆离的想法，这些想法在当时无比清晰，但是保质期却很短，常常睡一觉就变质，而写博客就是把这些想法打磨和雕琢的方法之一。通过写博客，我得意把这些想法永久地保存下来。</p></blockquote><p>不得不说，这一年来，不写博客的确思索少了很多，没有像之前一样，学过什么之后就及时回顾，只是记得一些大概的细节。之后应该会更新一下之前停滞的数据库系统和分布式系统系列，再写研究方向(自然语言处理)的分析。</p><a id="more"></a><p>博客基于hexo框架搭建，选择主题为next，其余可以选择主题<a href="https://hexo.io/themes/">参照</a>，给出的github链接里面一般会有基于该主题搭建的博客样式和具体操作。比较推荐的有<a href="https://github.com/litten/hexo-theme-yilia">yilia主题</a>、<a href="https://sariay.github.io/hexo-theme-Annie/">annie主题</a>、<a href="https://probberechts.github.io/hexo-theme-cactus/cactus-light/public/">cactus-light主题</a>、<a href="https://hexo.fluid-dev.com/">fluid主题</a>、<a href="https://blog.orduster.top/">butterfly主题</a>，具体操作可以看博主搭建个人博客的博客。拿我来说，选择主题标准主要是简洁、博客特效不花(否则容易分散博客阅读的精力)、容易搭建，next的star数量远远高于其他主题，目前作者维持每月一更的进度，bug不太多，所以就选择了next主题。基于next有诸多<a href="https://github.com/theme-next/awesome-next#live-preview">博客样例</a>，其中个人比较喜欢<a href="https://tding.top/">小丁的个人博客</a>、<a href="http://yearito.cn/">yearito’s blog</a>、<a href="https://leay.net/">荷七博客</a>、<a href="https://www.julydate.com/">七夏浅笑</a>、<a href="https://www.idefun.com/">idefun</a>这几个，idefun的<a href="https://www.idefun.com/resume/">个人简历</a>页似乎还可以直接编辑。个性化定制主要是css具体样式定制和next主页里的选项，next个性化之后也有<a href="https://sxxkearth.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/">界面</a>类似于butterfly主题，个性美化可以<a href="https://lruihao.cn/posts/hexobuild.html">参照</a>，样式设置可以<a href="https://qianling.pw/style/">参照</a>。</p><blockquote><p>现在 star 在 1k 以上的榜单如下：</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/iissnan/hexo-theme-next">iissnan/hexo-theme-next</a>, Elegant theme for Hexo., 15.5k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/litten/hexo-theme-yilia">litten/hexo-theme-yilia</a>, 一个简洁优雅的hexo主题 A simple and elegant theme for hexo., 7.8k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/theme-next/hexo-theme-next">theme-next/hexo-theme-next</a>, Elegant and powerful theme for Hexo., 6.3k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/ppoffice/hexo-theme-icarus">ppoffice/hexo-theme-icarus</a>, A simple, delicate, and modern theme for the static site generator Hexo., 4.3k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/viosey/hexo-theme-material">viosey/hexo-theme-material</a>, Material Design theme for hexo., 3.9k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/blinkfox/hexo-theme-matery">blinkfox/hexo-theme-matery</a>, A beautiful hexo blog theme with material design and responsive design.一个基于材料设计和响应式设计而成的全面、美观的Hexo主题, 2.9k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/yscoder/hexo-theme-indigo">yscoder/hexo-theme-indigo</a>, 一个Material Design风格的Hexo主题。 <a href="https://link.zhihu.com/?target=https://imys.net/">Yusen’s Blog</a>, 2.7k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/fluid-dev/hexo-theme-fluid">fluid-dev/hexo-theme-fluid</a>,   一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design theme for Hexo, 2.1k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/probberechts/hexo-theme-cactus">probberechts/hexo-theme-cactus</a>,   A responsive, clean and simple theme for Hexo., 1.8k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/pinggod/hexo-theme-apollo">pinggod/hexo-theme-apollo</a>,   a concise hexo theme, 1.8k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/jerryc127/hexo-theme-butterfly">jerryc127/hexo-theme-butterfly</a>,   A Hexo Theme: Butterfly, 1.8k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/LouisBarranqueiro/hexo-theme-tranquilpeak">LouisBarranqueiro/hexo-theme-tranquilpeak</a>,   A gorgeous responsive theme for Hexo blog framework, 1.7k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/Molunerfinn/hexo-theme-melody">Molunerfinn/hexo-theme-melody</a>,  A simple &amp; beautiful &amp; fast theme for Hexo., 1.3k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/ahonn/hexo-theme-even">ahonn/hexo-theme-even</a>,   A super concise theme for Hexo, 1.2k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/fi3ework/hexo-theme-archer">fi3ework/hexo-theme-archer</a>,   A smart and modern theme for Hexo., 1.1k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/ppoffice/hexo-theme-hueman">ppoffice/hexo-theme-hueman</a>, A redesign of Alx’s wordpress theme Hueman, ported to Hexo., 1.1k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/forsigner/fexo">forsigner/fexo</a>, A minimalist design theme for hexo., 1.1k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/wuchong/jacman">wuchong/jacman</a>, Jacman is a fresh looking and responsive theme for Hexo with more features based on Pacman., 1k</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/shenliyang/hexo-theme-snippet">shenliyang/hexo-theme-snippet</a>, Snippet 简洁而不简单，也许是一款你寻找已久的hexo主题, 971</p><p><a href="https://link.zhihu.com/?target=https://www.github.com/volantis-x/hexo-theme-volantis">volantis-x/hexo-theme-volantis</a>, A Wonderful Theme for Hexo <a href="https://link.zhihu.com/?target=https://volantis.js.org">Volantis</a>, 960</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>前期是基本的<a href="https://hexo.io/zh-cn/docs/">hexo</a>操作，参照官方文档执行。</p><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a></li></ul><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li></ul><blockquote><p>Mac 用户</p><p>如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p></blockquote><blockquote><p>Windows 用户</p><p>对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包。</p></blockquote><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/en/download/">安装程序</a>。对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a> 下载。</p><p>其它的安装方法：</p><ul><li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者<a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li><li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li><li>Linux（DEB/RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li><li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a></li></ul><p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。</p><blockquote><p>Windows 用户</p><p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p></blockquote><blockquote><p>For Mac / Linux 用户</p><p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">由 npmjs 发布的指导</a> 修复该问题。强烈建议 <strong>不要</strong> 使用 root、sudo 等方法覆盖权限</p></blockquote><blockquote><p>Linux</p><p>If you installed Node.js using Snap, you may need to manually run <code>npm install</code> in the target folder when <a href="https://hexo.io/docs/commands#init">initializing</a> a blog.</p></blockquote><h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><h2 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h2><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo</span><br></pre></td></tr></table></figure><p>安装以后，可以使用以下两种方式执行 Hexo：</p><ol><li><p><code>npx hexo &lt;command&gt;</code></p></li><li><p>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#39;PATH&#x3D;&quot;$PATH:.&#x2F;node_modules&#x2F;.bin&quot;&#39; &gt;&gt; ~&#x2F;.profile</span><br></pre></td></tr></table></figure><h1 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h1></li></ol><h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure><p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p><p>This command is a shortcut that runs the following steps:</p><ol><li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> including <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> into the current directory or a target folder if specified.</li><li>Install dependencies using a package manager: <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>, <a href="https://pnpm.js.org/">pnpm</a> or <a href="https://docs.npmjs.com/cli/install">npm</a>, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> by default.</li></ol><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--path</code></td><td align="left">自定义新文章的路径</td></tr><tr><td align="left"><code>-r</code>, <code>--replace</code></td><td align="left">如果存在同名文章，将其替换</td></tr><tr><td align="left"><code>-s</code>, <code>--slug</code></td><td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td></tr></tbody></table><p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure><p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p><p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure><p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p><h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>生成静态文件。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-d</code>, <code>--deploy</code></td><td align="left">文件生成后立即部署网站</td></tr><tr><td align="left"><code>-w</code>, <code>--watch</code></td><td align="left">监视文件变动</td></tr><tr><td align="left"><code>-b</code>, <code>--bail</code></td><td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td align="left"><code>-f</code>, <code>--force</code></td><td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td></tr><tr><td align="left"><code>-c</code>, <code>--concurrency</code></td><td align="left">最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>发表草稿。</p><h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p><table><thead><tr><th align="left">选项</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-p</code>, <code>--port</code></td><td align="left">重设端口</td></tr><tr><td align="left"><code>-s</code>, <code>--static</code></td><td align="left">只使用静态文件</td></tr><tr><td align="left"><code>-l</code>, <code>--log</code></td><td align="left">启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>部署网站。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-g</code>, <code>--generate</code></td><td align="left">部署之前预先生成静态文件</td></tr></tbody></table><p>该命令可以简写为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure><p>渲染文件。</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>-o</code>, <code>--output</code></td><td align="left">设置输出路径</td></tr></tbody></table><h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p><h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p>平时写博客的时候，一般流程是</p><ul><li><code>hexo new page/post &quot;title&quot;</code> 新建为title的.md文件</li><li><code>hexo clean &amp;&amp; hexo s</code> 清楚之前生成的文件，部署到本地服务器</li><li><code>hexo g -d</code> 部署到远程服务器</li></ul><h1 id="next-配置"><a href="#next-配置" class="headerlink" title="next 配置"></a>next 配置</h1><p>next官方中文文档更新比较慢，不少特性和配置没有及时发布，主要参考<a href="https://theme-next.js.org/docs/">英文文档</a>。</p><p>传统方式是配置两个文件，一个是站点下，即<code>blog/</code>下的<code>_config.yml</code>文件，称为站点配置文件，另一个是<code>themes/next</code>目录下的<code>_config.yml</code>，称为主题配置文件。</p><p>从next7.3.0开始，官方推荐将主题配置文件与主题分离，以便于主题的版本更新。</p><p>我们可以将所有主题配置放在一个位置（<code>hexo/source/_data/next.yml</code>）。这样就无需编辑主题配置文件（<code>next/_config.yml</code>）。</p><p>具体步骤：</p><ol><li>在 <code>hexo/source/_data</code> 目录中创建 <code>next.yml</code>（如果<code>_data</code> 不存在，则创建目录）。</li><li>在 <code>next.yml</code> 设置 <code>override</code> 选项为 true。</li><li>将<strong>所有 NexT 主题选项</strong>从主题配置文件复制到 <code>hexo/source/_data/next.yml</code> 中。</li></ol><p>然后我们只需要根据自己的需求配置 <code>next.yml</code> 即可。</p><h2 id="基本信息配置"><a href="#基本信息配置" class="headerlink" title="基本信息配置"></a>基本信息配置</h2><p>next主题的安装，站点作者、头像、侧边栏的配置参考<a href="https://theme-next.iissnan.com/getting-started.html">文档</a>，</p><p>具体站点的部署通过github操作，具体配置参考<a href="https://hexo.io/docs/one-command-deployment">官方文档</a>，在站点<code>blog/_config.yml</code>最后一行配置以下信息： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;twinkle0331&#x2F;twinkle0331.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>更为详细的配置参考<a href="https://hexo.io/docs/configuration.html">官方文档</a>，具体参数和设置里面都很详细。</p><h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><p>设置网页链接为<code>title.html</code>格式而不是<code>2021/03/28/title.html</code>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">permalink: :title&#x2F;</span><br></pre></td></tr></table></figure><p><em>选择主题为next：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p><em>设置缓存生成模式：</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Allow to cache content generation.</span><br><span class="line">cache:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line"># Remove unnecessary files after hexo generate.</span><br><span class="line">minify: true</span><br></pre></td></tr></table></figure><p><em>选择sheme为Mist:</em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme: Mist</span><br></pre></td></tr></table></figure><p>menu显示<code>home、about、tags、categories、archives</code>五栏，之前版本的next需要设定具体对应的中文名，在版本升级后，设定语言后自动更改对应的标签栏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br></pre></td></tr></table></figure><h3 id="生成“分类”页并添加tpye属性"><a href="#生成“分类”页并添加tpye属性" class="headerlink" title="生成“分类”页并添加tpye属性"></a>生成“分类”页并添加tpye属性</h3><p>进入博客所在文件夹。执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure><p>成功后会提示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO  Created: ~&#x2F;Documents&#x2F;blog&#x2F;source&#x2F;categories&#x2F;index.md</span><br></pre></td></tr></table></figure><p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2021-03-28 13:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>添加<code>type: &quot;categories&quot;</code>到内容中，添加后是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2021-03-28 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><h3 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h3><p>打开需要添加分类的文章，为其添加categories属性。下方的<code>categories: web前端</code>表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>至此，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了<code>categories: xxx</code>的文章才会被收录到首页的分类标签栏中。</p><p>其余属性页面的添加类似</p><h3 id="添加本地搜索："><a href="#添加本地搜索：" class="headerlink" title="添加本地搜索："></a>添加本地搜索：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 本地搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: <span class="number">100</span></span><br><span class="line"></span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: <span class="number">20</span></span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: <span class="number">140</span></span><br><span class="line">  content_limit_delim: <span class="string">&#x27; &#x27;</span></span><br><span class="line">  order_by: -date</span><br><span class="line">  icon: icon.png</span><br><span class="line">  autodiscovery: <span class="literal">true</span></span><br><span class="line">  <span class="keyword">template</span>:</span><br></pre></td></tr></table></figure><h3 id="添加代码高亮："><a href="#添加代码高亮：" class="headerlink" title="添加代码高亮："></a>添加代码高亮：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># _config.yml</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#39;&#39;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line">prismjs:</span><br><span class="line">  enable: false</span><br><span class="line">  preprocess: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#39;&#39;</span><br></pre></td></tr></table></figure><h3 id="设置内容宽度"><a href="#设置内容宽度" class="headerlink" title="设置内容宽度"></a>设置内容宽度</h3><p>打开<code>/themes/next/source/css/_variables/base.styl</code>文件，找到<code>Layout sizes</code>字段修改如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$content-desktop                &#x3D; 70%;</span><br><span class="line">$content-desktop-large          &#x3D; 70%;</span><br><span class="line">$content-desktop-largest        &#x3D; 70%;</span><br></pre></td></tr></table></figure><p>由之前的固定像素值更改为比例(画面宽度占屏幕的比例)</p><p>在<code>blog/source/_data/style.styl</code>(若无则新建文件/文件夹)下添加以下样式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主页文章添加阴影效果</span></span><br><span class="line">.post &#123;</span><br><span class="line">  margin-top: <span class="number">60</span>px;</span><br><span class="line">  margin-bottom: <span class="number">60</span>px;</span><br><span class="line">  padding: <span class="number">25</span>px;</span><br><span class="line">  -webkit-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span><span class="function">px <span class="title">rgba</span><span class="params">(<span class="number">202</span>, <span class="number">203</span>, <span class="number">203</span>, <span class="number">.5</span>)</span></span>;</span><br><span class="line">  -moz-box-shadow: <span class="number">0</span> <span class="number">0</span> <span class="number">5</span><span class="function">px <span class="title">rgba</span><span class="params">(<span class="number">202</span>, <span class="number">203</span>, <span class="number">204</span>, <span class="number">.5</span>)</span></span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 标题栏背景</span></span><br><span class="line">.site-meta &#123;</span><br><span class="line">    padding: <span class="number">20</span>px <span class="number">0</span>;</span><br><span class="line">    color: <span class="meta">#fff;</span></span><br><span class="line">    background-image: url(/images/<span class="number">95033e2</span>a5404c30e2ab560e72b157a0a.jpg);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment: fixed;</span><br><span class="line">    background-position: center;</span><br><span class="line">    background-size: <span class="number">100</span>% <span class="number">100</span>%;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改主体透明度</span></span><br><span class="line">.main-inner&#123;</span><br><span class="line">    background: <span class="meta">#fff;</span></span><br><span class="line">    opacity: <span class="number">0.85</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//页脚文字</span></span><br><span class="line">.footer,.footer a,.footer .with-love&#123;</span><br><span class="line">  <span class="comment">//color: #31ff00</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改链接样式</span></span><br><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #<span class="number">0593</span>d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #ff8c00;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a, span.exturl &#123;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #ff8c00;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置标签样式</span></span><br><span class="line">.tag-cloud a &#123;</span><br><span class="line">    box-shadow: <span class="number">0</span> <span class="number">1</span>px <span class="number">3</span>px #<span class="number">6f</span>42c1, <span class="number">0</span> <span class="number">1</span>px <span class="number">2</span>px #d9534f;</span><br><span class="line">    padding: <span class="number">2</span>px <span class="number">10</span>px;</span><br><span class="line">    margin: <span class="number">8</span>px;</span><br><span class="line">    background: rgba(<span class="number">193</span>,<span class="number">66</span>,<span class="number">92</span>,<span class="number">0</span>);</span><br><span class="line">    border-bottom: none;</span><br><span class="line">    border-radius: <span class="number">20</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在将近一年没有写博客之后，我又重新捡起之前的博客开始写了。至于为什么想写博客呢，&lt;a href=&quot;https://wdxtub.com/qa/why-writing-blog/2013/10/17/&quot;&gt;小土刀&lt;/a&gt;的博客中提到&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我睡觉的时候大家的夜生活才刚刚开始，我醒来的时候大家却仍在熟睡，每天在禅修中等待天亮。想找人聊聊最近读的书，但是却没有志趣相投的，平日的聊天也大都跟技术相关，不怪乎其他专业的人觉得我们无趣了。我找不到人聊政治制度，找不到人聊历史，找不到人聊心理学，找不到人聊经济，我只能自己跟自己聊。&lt;/p&gt;
&lt;p&gt;这就是我写博客的原因，这是我跟自己沟通的方式。我们每天每时每刻都有可能冒出各种各样光怪陆离的想法，这些想法在当时无比清晰，但是保质期却很短，常常睡一觉就变质，而写博客就是把这些想法打磨和雕琢的方法之一。通过写博客，我得意把这些想法永久地保存下来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不得不说，这一年来，不写博客的确思索少了很多，没有像之前一样，学过什么之后就及时回顾，只是记得一些大概的细节。之后应该会更新一下之前停滞的数据库系统和分布式系统系列，再写研究方向(自然语言处理)的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Config" scheme="http://twinkle0331.github.io/categories/Config/"/>
    
    
    <category term="hexo" scheme="http://twinkle0331.github.io/tags/hexo/"/>
    
    <category term="blog" scheme="http://twinkle0331.github.io/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>线段树</title>
    <link href="http://twinkle0331.github.io/algorithm/segement-tree/"/>
    <id>http://twinkle0331.github.io/algorithm/segement-tree/</id>
    <published>2020-03-28T00:54:21.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>与树状数组类似，线段树同样可以高效率对区间进行查询、更新操作。与树状数组不同的是，树状数组仅限于计算前缀和，应用问题存在很大的局限。所以通常用线段树来维护一系列区间操作，特别是区间最大值最小值问题。</p><a id="more"></a><p>表示区间[1, 10]的线段树表示如下： </p><p><img src="https://i.loli.net/2020/03/28/36OVUpCFsTiRI7b.png"></p><p>每个节点维护对应区间的信息,某节点的区间为其左右孩子节点区间之和。</p><h1 id="单点更新和区间查询"><a href="#单点更新和区间查询" class="headerlink" title="单点更新和区间查询"></a>单点更新和区间查询</h1><p>以下以结构体形式来构建线段树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[maxn]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>每个节点维护对应区间的最大值$val$，区间和$sum$，$l$为区间左端点，$r$为区间右端点。</p><p>可以证明得到，线段树节点总数不超过叶结点总数的2倍，线段树数组通常设置为维护数组(即叶结点对应的值)的3倍。</p><p>以求区间最值和求区间和为例，构建线段树的操作为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        seg[i].sum=a[l];</span><br><span class="line">        seg[i].val=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    seg[i].val=min(seg[<span class="number">2</span>*i].val,seg[<span class="number">2</span>*i+<span class="number">1</span>].val);</span><br><span class="line">    seg[i].sum=seg[<span class="number">2</span>*i].sum+seg[<span class="number">2</span>*i+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br></pre></td></tr></table></figure><p>其中$i$为二叉线段树中节点的编号，$l$为区间左端点，$r$为区间右端点。节点$i$的左孩子为节点$2i$，节点$i$的右孩子为节点$2i+1$。</p><p>在构建节点左右子树后，再更新当前节点对应的区间最值和区间和。</p><p>更新线段树的操作为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r)&#123;</span><br><span class="line">        seg[i].val=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(<span class="number">2</span>*i,k,x);</span><br><span class="line">    <span class="keyword">else</span> update(<span class="number">2</span>*i+<span class="number">1</span>,k,x);</span><br><span class="line">    seg[i].sum=seg[<span class="number">2</span>*i].sum+seg[<span class="number">2</span>*i+<span class="number">1</span>].sum;</span><br><span class="line">    seg[i].val=min(seg[<span class="number">2</span>*i].val,seg[<span class="number">2</span>*i+<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line">update(<span class="number">1</span>,pos,x);</span><br></pre></td></tr></table></figure><p>更新操作在线段树的节点中维护，并不需要更新原有数组，原有数组信息仅在构建线段树的时候用到。</p><p>求区间和操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=seg[i].l&amp;&amp;seg[i].r&lt;=seg[i].r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> suml=<span class="number">0</span>,sumr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) suml=sum(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) sumr=sum(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> suml+sumr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以这么写：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==seg[i].l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) ans=sum(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) ans=sum(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ans+=sum(<span class="number">2</span>*i,l,mid);</span><br><span class="line">        ans+=sum(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>区间和操作应用树状数组同样可以高效查询、更新。</p><p>查询区间最小值的操作如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=seg[i].l&amp;&amp;seg[i].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minl=inf,minr=inf;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line">        minl=query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)&#123;</span><br><span class="line">        minr=query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(minl,minr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://poj.org/problem?id=3264">POJ 3264</a></p><p>求给定区间的最大值和最小值的差值，区间查询，没有更新操作，为静态查询。</p><p>由于查询返回应同时返回区间最小值和区间最大值，可以将区间最小值<code>ans1</code>,区间最大值<code>ans2</code>设为全局变量，在每次查询的时候更新，也可以返回将区间的最大值、最小值这两个参数以<code>pair</code>类型返回，会麻烦很多。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val1,val2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ans1,ans2;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        seg[i].val1=seg[i].val2=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    seg[i].val1=min(seg[<span class="number">2</span>*i].val1,seg[<span class="number">2</span>*i+<span class="number">1</span>].val1);</span><br><span class="line">    seg[i].val2=max(seg[<span class="number">2</span>*i].val2,seg[<span class="number">2</span>*i+<span class="number">1</span>].val2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val2&lt;=ans2&amp;&amp;seg[i].val1&gt;=ans1) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        ans1=min(seg[i].val1,ans1);</span><br><span class="line">        ans2=max(seg[i].val2,ans2);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        query(<span class="number">2</span>*i,l,mid);</span><br><span class="line">        query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q)==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            ans1=inf,ans2=-inf;</span><br><span class="line">            query(<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans2-ans1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754">hdu 1754</a></p><p>区间查询，查询区间最大值，更新操作更新单点的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r) seg[i].val=a[l];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">         build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">         build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">         seg[i].val=max(seg[<span class="number">2</span>*i].val,seg[<span class="number">2</span>*i+<span class="number">1</span>].val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=seg[i].l&amp;&amp;seg[i].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> max(query(<span class="number">2</span>*i,l,r),query(<span class="number">2</span>*i+<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==k&amp;&amp;seg[i].r==k)&#123;</span><br><span class="line">        seg[i].val=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(<span class="number">2</span>*i,k,x);</span><br><span class="line">    <span class="keyword">else</span> update(<span class="number">2</span>*i+<span class="number">1</span>,k,x);</span><br><span class="line">    seg[i].val=max(seg[<span class="number">2</span>*i].val,seg[<span class="number">2</span>*i+<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> ans=query(<span class="number">1</span>,x,y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                update(<span class="number">1</span>,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上写法是通过结构体来维护区间信息，也可以直接通过数组来存储信息，这种写法传入参数比较多，运行的时间复杂度长度可能大一些。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> val[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    val[i]=max(val[<span class="number">2</span>*i],val[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==k&amp;&amp;r==k)&#123;</span><br><span class="line">        val[i]=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(<span class="number">2</span>*i,l,mid,k,x);</span><br><span class="line">    <span class="keyword">else</span> update(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r,k,x);</span><br><span class="line">    val[i]=max(val[<span class="number">2</span>*i],val[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> val[i];</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) res=max(res,query(<span class="number">2</span>*i,l,mid,x,y));</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) res=max(res,query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n,m;</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> ans=query(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                update(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间更新和单点查询"><a href="#区间更新和单点查询" class="headerlink" title="区间更新和单点查询"></a>区间更新和单点查询</h1><p>树状数组通过差分思想来更新区间和查询单点，线段树则通过延迟标记来批量标记节点所对应的子区间。</p><p>延迟标记表示该节点$i$所对应的区间$[l,r]$同时执行了某个更新操作，比如同时赋值为某个值$x$。如此一来，不必每次更新操作都更新到$[l,r]$区间的叶子节点。</p><p>在查询区间或者更新区间仅仅涉及节点$i$的部分区间时，将延迟标记下放到节点的左孩子$2i$和右孩子$2i+1$对应的区间，同时将当前节点$i$的延迟标记清空。</p><h2 id="区间染色问题"><a href="#区间染色问题" class="headerlink" title="区间染色问题"></a>区间染色问题</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3974">hdu 3974</a></p><p>线段树维护dfs序，以邻接表形式来表示图，从根节点dfs，记录dfs过程中每个节点的dfs开始时间和结束时间，作为线段树中的次序。每个节点对应的下属必然是dfs中连续的一段区间，所以每次分配任务的时候对该节点dfs开始时间到dfs结束时间内的节点更新即可，为区间更新。每次查询查询点对应的任务值，为单点更新操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;;</span><br><span class="line">Edge edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],tot;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> start[maxn],en[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    start[u]=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">        dfs(edge[i].to);</span><br><span class="line">    &#125;</span><br><span class="line">    en[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> lazy;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].val=<span class="number">-1</span>;</span><br><span class="line">    seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        seg[i].val=v;</span><br><span class="line">        seg[i].lazy=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].lazy)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[i].val;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[<span class="number">2</span>*i].lazy=seg[<span class="number">2</span>*i+<span class="number">1</span>].lazy=<span class="number">1</span>;</span><br><span class="line">        seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) update(<span class="number">2</span>*i,l,r,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update(<span class="number">2</span>*i+<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        update(<span class="number">2</span>*i,l,mid,v);</span><br><span class="line">        update(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==u&amp;&amp;seg[i].r==u)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].lazy)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[i].val;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[<span class="number">2</span>*i].lazy=seg[<span class="number">2</span>*i+<span class="number">1</span>].lazy=<span class="number">1</span>;</span><br><span class="line">        seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;=mid) <span class="keyword">return</span> query(<span class="number">2</span>*i,u);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(<span class="number">2</span>*i+<span class="number">1</span>,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> icase=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,icase++);</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            vis[u]=<span class="literal">true</span>;</span><br><span class="line">            addedge(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(<span class="number">1</span>,start[u]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">                update(<span class="number">1</span>,start[u],en[u],v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大连续子区间问题"><a href="#最大连续子区间问题" class="headerlink" title="最大连续子区间问题"></a>最大连续子区间问题</h2><p>最大连续子区间对应的查询问题，为给定区间$[l,r]$内最大的连续子区间。。线段树中的节点维护该节点对应区间的最大连续子区间，左端最大连续子区间，右端最大连续子区间。根据左右孩子的最大连续子区间情况来更新当前节点的最大连续子区间情况。更新一般是区间合并或者区间拆分操作。</p><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1540">hdu 1540</a></p><p>初始状态所有的区间均连续，操作涉及到破坏和修复某个点两种，查询$x$所在最大连续子区间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> ll,rl,ml;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].ll=seg[i].rl=seg[i].ml=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">1</span>) seg[i].ll=seg[i].rl=seg[i].ml=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> seg[i].ll=seg[i].rl=seg[i].ml=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(<span class="number">2</span>*i,k,v);</span><br><span class="line">    <span class="keyword">else</span> update(<span class="number">2</span>*i+<span class="number">1</span>,k,v);</span><br><span class="line">    seg[i].ll=seg[<span class="number">2</span>*i].ll;</span><br><span class="line">    seg[i].rl=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl;</span><br><span class="line">    seg[i].ml=max(seg[<span class="number">2</span>*i].ml,seg[<span class="number">2</span>*i+<span class="number">1</span>].ml);</span><br><span class="line">    seg[i].ml=max(seg[i].ml,seg[<span class="number">2</span>*i].rl+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll);</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*i].ll==seg[<span class="number">2</span>*i].r-seg[<span class="number">2</span>*i].l+<span class="number">1</span>) seg[i].ll+=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*i+<span class="number">1</span>].rl==seg[<span class="number">2</span>*i+<span class="number">1</span>].r-seg[<span class="number">2</span>*i+<span class="number">1</span>].l+<span class="number">1</span>)&#123;</span><br><span class="line">        seg[i].rl+=seg[<span class="number">2</span>*i].rl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> que[maxn];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r||seg[i].ml==<span class="number">0</span>||seg[i].ml==seg[i].r-seg[i].l+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].ml;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(t&lt;=mid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;=seg[<span class="number">2</span>*i].r-seg[<span class="number">2</span>*i].rl+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> seg[<span class="number">2</span>*i].rl+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(<span class="number">2</span>*i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;=seg[<span class="number">2</span>*i+<span class="number">1</span>].l+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> seg[<span class="number">2</span>*i].rl+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(<span class="number">2</span>*i+<span class="number">1</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">                que[top++]=x;</span><br><span class="line">                update(<span class="number">1</span>,x,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(<span class="number">1</span>,x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    x=que[--top];</span><br><span class="line">                    update(<span class="number">1</span>,x,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://poj.org/problem?id=3368">POJ 3368</a></p><p>给定单调非减序列，查询区间$[l,r]$区间内出现次数最多的数字</p><p>由于序列为单调非减，相同的数字必然相邻，所以等效为最大连续子区间问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> ll,rl,ml;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        seg[i].ll=seg[i].rl=seg[i].ml=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(a[seg[<span class="number">2</span>*i].r]==a[seg[<span class="number">2</span>*i+<span class="number">1</span>].l])&#123;</span><br><span class="line">        temp=seg[<span class="number">2</span>*i].rl+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seg[i].ml=max(max(seg[<span class="number">2</span>*i].ml,seg[<span class="number">2</span>*i+<span class="number">1</span>].ml),temp);</span><br><span class="line">    seg[i].ll=seg[<span class="number">2</span>*i].ll;</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*i].ll==mid-l+<span class="number">1</span>&amp;&amp;a[seg[<span class="number">2</span>*i].r]==a[seg[<span class="number">2</span>*i+<span class="number">1</span>].l])&#123;</span><br><span class="line">        seg[i].ll+=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">    &#125;</span><br><span class="line">    seg[i].rl=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl;</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*i+<span class="number">1</span>].rl==r-mid&amp;&amp;a[seg[<span class="number">2</span>*i].r]==a[seg[<span class="number">2</span>*i+<span class="number">1</span>].l])&#123;</span><br><span class="line">        seg[i].rl+=seg[<span class="number">2</span>*i].rl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].ml;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a1=query(<span class="number">2</span>*i,l,mid);</span><br><span class="line">        <span class="keyword">int</span> a2=query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">int</span> a3=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[seg[<span class="number">2</span>*i].r]==a[seg[<span class="number">2</span>*i+<span class="number">1</span>].l])&#123;</span><br><span class="line">            a3=min(seg[<span class="number">2</span>*i].rl,mid-l+<span class="number">1</span>)+min(seg[<span class="number">2</span>*i+<span class="number">1</span>].ll,r-mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(max(a1,a2),a3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(<span class="number">1</span>,x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间更新和区间查询"><a href="#区间更新和区间查询" class="headerlink" title="区间更新和区间查询"></a>区间更新和区间查询</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1698">hdu 1698</a></p><p>区间更新，查询所有区间的区间和</p><p><code>lazy</code>作为延迟标记，<code>tag</code>标记区间更新的值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> l[maxn],r[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> lazy,tag;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">    seg[i].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        seg[i].sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    seg[i].sum=seg[<span class="number">2</span>*i].sum+seg[<span class="number">2</span>*i+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        seg[i].lazy=<span class="number">1</span>;</span><br><span class="line">        seg[i].tag=v;</span><br><span class="line">        seg[i].sum=(r-l+<span class="number">1</span>)*v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].lazy)&#123;</span><br><span class="line">        seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">        update(<span class="number">2</span>*i,seg[i].l,mid,seg[i].tag);</span><br><span class="line">        update(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,seg[i].r,seg[i].tag);</span><br><span class="line">        seg[i].tag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) update(<span class="number">2</span>*i,l,r,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update(<span class="number">2</span>*i+<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        update(<span class="number">2</span>*i,l,mid,v);</span><br><span class="line">        update(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r,v);</span><br><span class="line">    &#125;</span><br><span class="line">    seg[i].sum=seg[<span class="number">2</span>*i].sum+seg[<span class="number">2</span>*i+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            update(<span class="number">1</span>,x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: The total value of the hook is %d.\n&quot;</span>,cnt++,seg[<span class="number">1</span>].sum);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://poj.org/problem?id=3468">POJ 3468</a></p><p>区间更新，区间查询，查询区间和</p><p>对于每个节点维护两个值</p><ol><li>给这个节点对应区间内的所有元素共同加上的值</li><li> 在这个区间内除去1之外其他值的和</li></ol><p>线段树维护数组信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> l,r,x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)<span class="number">-1</span>;</span><br><span class="line">ll data[N],datb[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">        data[k] += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; b &amp;&amp; a &lt; r) &#123;</span><br><span class="line">        datb[k] += (min(b,r)-max(a,l))* x;</span><br><span class="line">        add(a, b, x, k * <span class="number">2</span> + <span class="number">1</span>, l, (l + r) / <span class="number">2</span>);</span><br><span class="line">        add(a, b, x, k * <span class="number">2</span> + <span class="number">2</span>, (l + r) / <span class="number">2</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= l || r &lt;= a) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a &lt;= l &amp;&amp; r &lt;= b)&#123;</span><br><span class="line">        <span class="keyword">return</span> data[k] * (r - l) + datb[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ll res = (min(b,r)-max(a,l)) * data[k];</span><br><span class="line">        res += sum(a, b, k * <span class="number">2</span> + <span class="number">1</span>, l, (l + r) / <span class="number">2</span>);</span><br><span class="line">        res += sum(a, b, k * <span class="number">2</span> + <span class="number">2</span>, (l + r) / <span class="number">2</span>, r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">memset</span>(datb,<span class="number">0</span>,<span class="keyword">sizeof</span>(datb));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        add(i,i+<span class="number">1</span>,a,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">            add(l<span class="number">-1</span>,r,x,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum(l<span class="number">-1</span>,r,<span class="number">0</span>,<span class="number">0</span>,n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="区间染色问题-1"><a href="#区间染色问题-1" class="headerlink" title="区间染色问题"></a>区间染色问题</h2><p><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365109">ZOJ 1610</a></p><p>每次测试结束后输出所有可以显示的颜色和该颜色的段数。</p><p>注意这里的染色是对区间操作而不是对区间端点操作，通常情况下线段树操作是对区间端点操作。</p><p>线段树维护结构体信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">8005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn],num[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].val=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l&gt;=l&amp;&amp;seg[i].r&lt;=r)&#123;</span><br><span class="line">        seg[i].val=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val!=<span class="number">-1</span>)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[i].val=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) update(<span class="number">2</span>*i,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) update(<span class="number">2</span>*i+<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(seg[i].val!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r; j++)</span><br><span class="line">ans[j] = seg[i].val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid =(l + r)/<span class="number">2</span>;</span><br><span class="line">    query(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)==<span class="number">1</span>)&#123;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,<span class="number">8000</span>);</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            update(<span class="number">1</span>,a+<span class="number">1</span>,b,c);</span><br><span class="line">        &#125;</span><br><span class="line">        query(<span class="number">1</span>,<span class="number">1</span>,<span class="number">8000</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">            num[ans[<span class="number">0</span>]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(ans[i] != <span class="number">-1</span> &amp;&amp; ans[i] != ans[i - <span class="number">1</span>])</span><br><span class="line">                num[ans[i]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线段树维护数组信息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">8005</span>;</span><br><span class="line"><span class="keyword">int</span> val[maxn*<span class="number">3</span>],num[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        val[i]=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[i]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        val[<span class="number">2</span>*i]=val[<span class="number">2</span>*i+<span class="number">1</span>]=val[i];</span><br><span class="line">        val[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid)&#123;</span><br><span class="line">        update(<span class="number">2</span>*i,L,R,l,mid,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid)&#123;</span><br><span class="line">        update(<span class="number">2</span>*i+<span class="number">1</span>,L,R,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(val[i]!=<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++)</span><br><span class="line">ans[j]=val[i];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l&lt;r&amp;&amp; val[i]==<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">query(<span class="number">2</span>*i,l,mid);</span><br><span class="line">query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(val, <span class="number">-1</span>, <span class="keyword">sizeof</span>(val));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            update(<span class="number">1</span>,a+<span class="number">1</span>,b,<span class="number">1</span>,<span class="number">8000</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        query(<span class="number">1</span>,<span class="number">1</span>,<span class="number">8000</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">            num[ans[<span class="number">0</span>]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(ans[i] != <span class="number">-1</span> &amp;&amp; ans[i] != ans[i - <span class="number">1</span>])</span><br><span class="line">                num[ans[i]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://poj.org/problem?id=2528">POJ 2528</a></p><p>区间染色问题，求最后区间存在多少种不同的颜色</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> l[maxn],r[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l&gt;=l&amp;&amp;seg[i].r&lt;=r)&#123;</span><br><span class="line">        seg[i].val=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val!=<span class="number">0</span>)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[i].val=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) update(<span class="number">2</span>*i,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) update(<span class="number">2</span>*i+<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val)&#123;</span><br><span class="line">        ans[seg[i].val]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val!=<span class="number">0</span>)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[i].val=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        num.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l[i],&amp;r[i]);</span><br><span class="line">            num.push_back(l[i]);</span><br><span class="line">            num.push_back(r[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(num.begin(),num.end());</span><br><span class="line">        num.erase(unique(num.begin(),num.end()),num.end());</span><br><span class="line">        <span class="keyword">int</span> m=num.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i+<span class="number">1</span>]-num[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                num.push_back(num[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(num.begin(),num.end());</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">0</span>,num.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            x=lower_bound(num.begin(),num.end(),l[i])-num.begin();</span><br><span class="line">            y=lower_bound(num.begin(),num.end(),r[i])-num.begin();</span><br><span class="line">            update(<span class="number">1</span>,x,y,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">        query(<span class="number">1</span>,<span class="number">0</span>,num.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大连续子区间问题-1"><a href="#最大连续子区间问题-1" class="headerlink" title="最大连续子区间问题"></a>最大连续子区间问题</h2><p><a href="https://vjudge.net/problem/HDU-4553">hdu 4553</a></p><p>比较复杂的线段树问题，对于女神和屌丝操作优先级不同，所以维护两个线段树。</p><p>对屌丝的更新操作无法覆盖女神的信息，而女神的更新信息可以覆盖屌丝的信息，更新操作则将女神和屌丝区间均清空。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> ll,rl,ml;</span><br><span class="line">    <span class="keyword">int</span> ll1,rl1,ml1;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].ml=seg[i].ll=seg[i].rl=r-l+<span class="number">1</span>;</span><br><span class="line">    seg[i].ml1=seg[i].ll1=seg[i].rl1=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    build((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ll&gt;=x)<span class="keyword">return</span> seg[i].l;</span><br><span class="line">    <span class="keyword">if</span>(seg[i&lt;&lt;<span class="number">1</span>].ml&gt;=x)<span class="keyword">return</span> query(i&lt;&lt;<span class="number">1</span>,x);</span><br><span class="line">    <span class="keyword">if</span>(seg[i&lt;&lt;<span class="number">1</span>].rl+seg[(i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>].ll&gt;=x)<span class="keyword">return</span> seg[i&lt;&lt;<span class="number">1</span>].r-seg[i&lt;&lt;<span class="number">1</span>].rl+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> query((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml1&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ll1&gt;=x)<span class="keyword">return</span> seg[i].l;</span><br><span class="line">    <span class="keyword">if</span>(seg[i&lt;&lt;<span class="number">1</span>].ml1&gt;=x)<span class="keyword">return</span> query1(i&lt;&lt;<span class="number">1</span>,x);</span><br><span class="line">    <span class="keyword">if</span>(seg[i&lt;&lt;<span class="number">1</span>].rl1+seg[(i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>].ll1&gt;=x)<span class="keyword">return</span> seg[i&lt;&lt;<span class="number">1</span>].r-seg[i&lt;&lt;<span class="number">1</span>].rl1+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> query1((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[x].l==seg[x].r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lson=<span class="number">2</span>*x;</span><br><span class="line">    <span class="keyword">int</span> rson=<span class="number">2</span>*x+<span class="number">1</span>;</span><br><span class="line">    seg[x].ll=seg[lson].ll;</span><br><span class="line">    <span class="keyword">if</span>(seg[lson].ll==seg[lson].r-seg[lson].l+<span class="number">1</span>)seg[x].ll+=seg[rson].ll;</span><br><span class="line">    seg[x].rl=seg[rson].rl;</span><br><span class="line">    <span class="keyword">if</span>(seg[rson].rl==seg[rson].r-seg[rson].l+<span class="number">1</span>)seg[x].rl+=seg[lson].rl;</span><br><span class="line">    seg[x].ml=max(seg[lson].ml,seg[rson].ml);</span><br><span class="line">    seg[x].ml=max(seg[x].ml,max(seg[x].ll,seg[x].rl));</span><br><span class="line">    seg[x].ml=max(seg[x].ml,seg[lson].rl+seg[rson].ll);</span><br><span class="line"></span><br><span class="line">    seg[x].ll1=seg[lson].ll1;</span><br><span class="line">    <span class="keyword">if</span>(seg[lson].ll1==seg[lson].r-seg[lson].l+<span class="number">1</span>)seg[x].ll1+=seg[rson].ll1;</span><br><span class="line">    seg[x].rl1=seg[rson].rl1;</span><br><span class="line">    <span class="keyword">if</span>(seg[rson].rl1==seg[rson].r-seg[rson].l+<span class="number">1</span>)seg[x].rl1+=seg[lson].rl1;</span><br><span class="line">    seg[x].ml1=max(seg[lson].ml1,seg[rson].ml1);</span><br><span class="line">    seg[x].ml1=max(seg[x].ml1,max(seg[x].ll1,seg[x].rl1));</span><br><span class="line">    seg[x].ml1=max(seg[x].ml1,seg[lson].rl1+seg[rson].ll1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].ml=seg[<span class="number">2</span>*i].ll=seg[<span class="number">2</span>*i].rl=<span class="number">0</span>;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].ml=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml==seg[i].r-seg[i].l+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].ml=seg[<span class="number">2</span>*i].ll=seg[<span class="number">2</span>*i].rl=seg[<span class="number">2</span>*i].r-seg[<span class="number">2</span>*i].l+<span class="number">1</span>;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].ml=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl=seg[<span class="number">2</span>*i+<span class="number">1</span>].r-seg[<span class="number">2</span>*i+<span class="number">1</span>].l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml1==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].ml1=seg[<span class="number">2</span>*i].ll1=seg[<span class="number">2</span>*i].rl1=<span class="number">0</span>;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].ml1=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll1=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl1=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml1==seg[i].r-seg[i].l+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].ml1=seg[<span class="number">2</span>*i].ll1=seg[<span class="number">2</span>*i].rl1=seg[<span class="number">2</span>*i].r-seg[<span class="number">2</span>*i].l+<span class="number">1</span>;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].ml1=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll1=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl1=seg[<span class="number">2</span>*i+<span class="number">1</span>].r-seg[<span class="number">2</span>*i+<span class="number">1</span>].l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l &amp;&amp; seg[i].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[i].ml=seg[i].ll=seg[i].rl=seg[i].r-seg[i].l+<span class="number">1</span>;</span><br><span class="line">        seg[i].ml1=seg[i].ll1=seg[i].rl1=seg[i].r-seg[i].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(i);</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)update(i&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        update((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update1</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l &amp;&amp; seg[i].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[i].ml=seg[i].ll=seg[i].rl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(i);</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)update1(i&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update1((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update1(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        update1((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l &amp;&amp; seg[i].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[i].ml=seg[i].ll=seg[i].rl=<span class="number">0</span>;</span><br><span class="line">        seg[i].ml1=seg[i].ll1=seg[i].rl1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(i);</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)update2(i&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update2((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update2(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        update2((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,cnt++);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">            <span class="keyword">int</span> l,r;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">                <span class="keyword">int</span> tmp=query(<span class="number">1</span>,x);</span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;fly with yourself\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    update1(<span class="number">1</span>,tmp,tmp+x<span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d,let&#x27;s fly\n&quot;</span>,tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;N&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">                <span class="keyword">int</span> tmp=query(<span class="number">1</span>,x);</span><br><span class="line">                <span class="keyword">if</span>(tmp!=<span class="number">0</span>)&#123;</span><br><span class="line">                    update2(<span class="number">1</span>,tmp,tmp+x<span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d,don&#x27;t put my gezi\n&quot;</span>,tmp);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp=query1(<span class="number">1</span>,x);</span><br><span class="line">                <span class="keyword">if</span>(tmp!=<span class="number">0</span>)&#123;</span><br><span class="line">                    update2(<span class="number">1</span>,tmp,tmp+x<span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d,don&#x27;t put my gezi\n&quot;</span>,tmp);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wait for me\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;I am the hope of chinese chengxuyuan!!\n&quot;</span>);</span><br><span class="line">                update(<span class="number">1</span>,l,r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;与树状数组类似，线段树同样可以高效率对区间进行查询、更新操作。与树状数组不同的是，树状数组仅限于计算前缀和，应用问题存在很大的局限。所以通常用线段树来维护一系列区间操作，特别是区间最大值最小值问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://twinkle0331.github.io/algorithm/binsearch/"/>
    <id>http://twinkle0331.github.io/algorithm/binsearch/</id>
    <published>2020-03-26T07:16:05.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找版本众多，其中初始值的选择，判断条件，边界修改方式都有所不同。取整方式有向上取整和向下取整两种，区间开闭有左闭右开，左闭右闭，左开右闭，左闭右闭四种，再根据实际问题分为上界和下界两种，其中涉及细节繁多。在学习数据结构的时候讨论了不同版本平均查找长度和不同版本的正确性问题，但是仅限于三种版本，本文将讨论不同条件下二分查找的写法。</p><a id="more"></a><h1 id="求下界"><a href="#求下界" class="headerlink" title="求下界"></a>求下界</h1><blockquote><p>给定长度为$n$的单调不下降子序列$a_0,a_1,…,a_{n-1}$和一个数$k$,求满足$a_i\geq k$条件的最小的$i$</p></blockquote><p>挑战程序设计竞赛中给出的二分查找算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binsearch</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化解存在的范围</span></span><br><span class="line">    <span class="keyword">int</span> lb=<span class="number">-1</span>,ub=n;</span><br><span class="line">    <span class="keyword">while</span>(ub-lb&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(lb+ub)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=k)&#123;</span><br><span class="line">            ub=mid;</span><br><span class="line">            <span class="comment">//解的范围变为(lb,mid]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            lb=mid;</span><br><span class="line">            <span class="comment">//解的范围变为(mid,ub]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>binsearch(int k)</code>在存在满足条件的$a_i$时返回对应数组下标的值，在不存在的时候返回$n$。</p><p>初始化解中$ub=n$，$n$不在数组下标索引范围内，用于在查找失败时候返回$n$。若序列$a_0,a_1,…,a_{n-1}$中不存在满足$a_i\geq k$的$i$，即$a_i&lt;k$对$i=0,1,..,n-1$均满足，每次迭代选择$lb=mid$分支，直到搜索区间缩减为$(n-1,n]$。</p><p>接下来讨论每次迭代时边界的修改，根据$a[mid]$与$k$的相对大小</p><ul><li><p>$a[mid]\geq k$,$mid$点满足$a[mid]\geq k$,所求为满足条件的最小下标，故大于$mid$的部分均可以舍去。在该情况下右边界可以取到，所以取$ub=mid$,此时解的范围为$(lb,mid]$</p></li><li><p>$a[mid]&lt;k$,$mid$不可能为解，左边界不可以取到，所以取$lb=mid$,此时解的范围为$(mid,ub]$</p><p>每次迭代的时候满足$a_i \geq k$的最小下标必然还存在于区间内</p></li></ul><p>循环在满足$ub-lb&gt;1$的时候执行，即在$ub-lb\leq1$的时候停止执行，$(lb，ub]$此时仅有$a[ub]$一个元素。若序列$a_0,a_1,…,a_{n-1}$存在满足$a_i\leq k$的$i$,则必然为$ub$,否则为$n$。</p><p>c++标准库中<algorithm>中<code>lower_bound()</code>等价于以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[0,n)</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;last)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=first+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=k)&#123;</span><br><span class="line">            last=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            first=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lower_bound()</code>在序列$a_0,a_1,…,a_{n-1}$存在满足$a_i\leq k$的$i$时返回$n$。</p><p>这里的mid写法和挑战程序设计竞赛上不一样，防止了在相加时的溢出问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mid&#x3D;(first+last)&#x2F;2&#x3D;(2*first+last-first)&#x2F;2&#x3D;first+length&#x2F;2</span><br></pre></td></tr></table></figure><p>二者在算术意义上是等价的。</p><p>将问题中的$\geq$更改为$&gt;$，得到以下问题：</p><blockquote><p>给定长度为$n$的单调不下降子序列$a_0,a_1,…,a_{n-1}$和一个数$k$,求满足$a_i&gt; k$条件的最小的$i$</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[0,n)</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;last)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=first+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;k)&#123;</span><br><span class="line">            last=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            first=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与<code>lower_bound()</code>类似，<code>upper_bound()</code>在序列$a_0,a_1,…,a_{n-1}$不存在满足$a_i &lt;k$的$i$时返回$n$。</p><p>实际算法题往往是求满足条件的最小值，一般用以下形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int search(int low, int high) &#123;</span><br><span class="line">  int ans &#x3D; -1;</span><br><span class="line">  while (low &lt;&#x3D; high) &#123;</span><br><span class="line">    int mid &#x3D; low + (high - low) &#x2F; 2;</span><br><span class="line">    if (judge(mid)) &#123;</span><br><span class="line">      ans &#x3D; mid;</span><br><span class="line">      high &#x3D; mid - 1;</span><br><span class="line">    &#125; else low &#x3D; mid + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>judge()</code>判断取值为mid的时候是否满足条件，用临时变量ans记录备选结果，随着区间的不断减小，满足条件的备选方案也会不断调整，最后ans表示想要找的结果。</p><p><a href="http://poj.org/problem?id=3273">POJ 3273</a></p><p>最小化最大值，也就是求下界问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum+a[i]&lt;=d)&#123;</span><br><span class="line">            sum+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum=a[i];</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,high=Inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            low=max(low,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">                high=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum+a[i]&lt;=d)&#123;</span><br><span class="line">            sum+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum=a[i];</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,high=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            high+=a[i];</span><br><span class="line">            low=max(low,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(high&gt;=low)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">                high=mid<span class="number">-1</span>;</span><br><span class="line">                ans=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="求上界"><a href="#求上界" class="headerlink" title="求上界"></a>求上界</h1><blockquote><p>给定长度为$n$的单调不下降子序列$a_0,a_1,…,a_{n-1}$和一个数$k$,求满足$a_i \leq k$条件的最大的$i$</p></blockquote><p>该问题可以转化为求下界问题，满足$a_i&gt;k$条件最小的$i$再减去1即是满足$a_i \leq k$条件的最大的$i$。</p><p>也可以写作以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[first,last)</span></span><br><span class="line">    <span class="keyword">while</span>(last-first&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=last+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            first=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[first,last)</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;last)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=last+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            first=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑迭代过程，根据$a[mid]$与$k$的相对大小</p><ul><li><p>$a[mid]\leq k$,$mid$点满足$a[mid]\geq k$,所求为满足条件的最大下标，故小于$mid$的部分均可以舍去。左端点可以取到，故取$first=mid$，此解的范围为$[mid,last)$</p></li><li><p>$a[mid]&gt;k$,$mid$不可能为解，右边界不可以取到，所以取$last=mid$,此时解的范围为$[first,last)$</p><p>每次迭代的时候满足$a_i\leq k$的最大下标必然还存在于区间内</p></li></ul><p>循环在满足$first-last \geq1$的时候执行，即在$first==last$的时候停止执行，$(first，last]$此时为空。</p><blockquote><p>给定长度为$n$的单调不下降子序列$a_0,a_1,…,a_{n-1}$和一个数$k$,求满足$a_i &lt; k$条件的最大的$i$</p></blockquote><p>该问题同样可以转化为求下界问题，满足$ a_i \leq k$条件最小的$i$再减去1即是满足$ a_i &lt; k$条件的最大的$i$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[first,last)</span></span><br><span class="line">    <span class="keyword">while</span>(first-last&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=last-(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;k)&#123;</span><br><span class="line">            first=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">////区间为[first,last)</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;=last)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=first+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            first=mid<span class="number">-1</span>;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在求满足条件的最大值往往用以下形式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (judge(mid)) &#123;</span><br><span class="line">      ans = mid;</span><br><span class="line">      low = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> high = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上形式便于在找不到符合条件的解时返回-1</p><p><a href="http://poj.org/problem?id=2456">POJ 2456</a></p><p>最大化最小值，也就是求上界问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf=<span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> crt=last+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(crt&lt;n&amp;&amp;x[crt]-x[last]&lt;d)&#123;</span><br><span class="line">            crt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(crt==n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        last=crt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x,x+n);</span><br><span class="line">    <span class="keyword">int</span> lb=<span class="number">1</span>,ub=Inf;</span><br><span class="line">    <span class="keyword">while</span>(ub-lb&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=lb+(ub-lb)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">            lb=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ub=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf=<span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> crt=last+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(crt&lt;n&amp;&amp;x[crt]-x[last]&lt;d)&#123;</span><br><span class="line">            crt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(crt==n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        last=crt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x,x+n);</span><br><span class="line">    <span class="keyword">int</span> lb=<span class="number">1</span>,ub=Inf;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lb&lt;=ub)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=lb+(ub-lb)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            lb=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ub=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><p>区间中点的选择并不唯一</p><ol><li>上位中位数：<code>uppermid=first+length/2</code></li><li>下位中位数：<code>lowermid=first+(length-1)/2</code></li></ol><p>在<code>length</code>为偶数时二者取值才不同，分别为中间一对下标中的大者和小者。</p><p>区间中点选择上位中位数还是下位中位数差异不大，其余部分不需要跟着调整。</p><p>若区间取两端为闭区间时，循环条件应为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(lb&lt;&#x3D;ub)</span><br></pre></td></tr></table></figure><p>若区间一端为开区间，一端为闭区间，循环条件应为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(lb&lt;ub)</span><br></pre></td></tr></table></figure><p>若区间两端均为开区间，循环条件应为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(ub-lb&lt;1)</span><br></pre></td></tr></table></figure><p>二分思想是利用区间值有序的特点，不断让区间长度减半，最后将区间长度缩小至0或1。</p><p>确保二分的正确性，</p><ol><li>每次迭代解均在可行区间内</li><li>每次判断后可行区间都会缩小</li></ol><p>在区间为1的时候，左右端点值处理不好就会存在死循环。</p><h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><p>浮点数二分循环条件一般为要求达到的精度或者迭代次数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">search</span><span class="params">(<span class="keyword">double</span> low, <span class="keyword">double</span> high)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (high - low &gt; eps) &#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (judge(mid)) high = mid;</span><br><span class="line">    <span class="keyword">else</span> low = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://poj.org/problem?id=1064">POJ 1064</a></p><p>给$n$条绳子，长度分别为$l_i$,从中切分出$k$条长度相同的绳子，这$k$条绳子最长有多长？</p><p>设条件$C(x)=$可以得到$k$条满足长度要求的绳子</p><p>问题转变为了求满足$C(x)$条件的最大的$x$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Inf=<span class="number">100005.0</span>;</span><br><span class="line"><span class="keyword">double</span> l[maxn];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum+=(<span class="keyword">int</span>)(l[i]/x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> lb=<span class="number">0</span>,ub=Inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(lb+ub)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) lb=mid;</span><br><span class="line">        <span class="keyword">else</span> ub=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="built_in">floor</span>(ub*<span class="number">100</span>)/<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找版本众多，其中初始值的选择，判断条件，边界修改方式都有所不同。取整方式有向上取整和向下取整两种，区间开闭有左闭右开，左闭右闭，左开右闭，左闭右闭四种，再根据实际问题分为上界和下界两种，其中涉及细节繁多。在学习数据结构的时候讨论了不同版本平均查找长度和不同版本的正确性问题，但是仅限于三种版本，本文将讨论不同条件下二分查找的写法。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>树状数组</title>
    <link href="http://twinkle0331.github.io/algorithm/fenwick-tree/"/>
    <id>http://twinkle0331.github.io/algorithm/fenwick-tree/</id>
    <published>2020-03-19T23:35:06.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个初始值全为$0$的数列$a_1,a_2,..,a_n$</p><ul><li>给定$i$,计算$a_1+a_2+…+a_n$</li><li>给定$i$和$x$，计算$a_i+=x$</li></ul><p>树状数组可以在$O(logn)$时间内计算区间前缀和，在$O(logn)$时间内更新单点的值。</p><a id="more"></a><p>树状数组的关系图为</p><p><img src="https://i.loli.net/2020/03/20/lQBDIEcHbmWTVxv.png"></p><h1 id="lowbit操作"><a href="#lowbit操作" class="headerlink" title="lowbit操作"></a>lowbit操作</h1><p><code>lowbit</code>操作返回$x$在二进制表示下为1的最低位对应的幂，例如$lowbit((101000)_2)$为$(1000)_2$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lowbit</code>求解原理为：将$x$按位取反再加一后与之前的$x$相与</p><p>例如$(101000)_2$</p><ol><li>按位取反得到$(010111)_2$</li><li>+1,得到$(011000)_2$</li><li>$011000 &amp;101000$，得到$ (1000)_2$</li></ol><p>树状数组中的元素满足$t[x]=\sum_{i=x-lowbit(x)+1}^{x}a[i]$,即其中第$x$位元素的值为$x$与$lowbit(x)$之间元素的和，<code>lowbit(x)</code>等于当前位置所覆盖的区间长度。</p><h1 id="单点修改和区间查询"><a href="#单点修改和区间查询" class="headerlink" title="单点修改和区间查询"></a>单点修改和区间查询</h1><p>树状数组中求前缀和和更新值的操作如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t[maxn],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res+=t[i];</span><br><span class="line">        i-=lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        t[i]+=x;</span><br><span class="line">        i+=lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>每个节点的父亲都可以表示为$x+lowbit(x)$，在更新$a[x]$的时候，逐步更新其祖先节点的值。</p><h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(r)-sum(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询某个区间的区间和通过前缀和相减来实现，例如，求$[l,r]$的区间和，只需求$\sum_{i=1}^{r}a[i]-\sum_{i=1}^{l-1}a[i]$ 。根据<code>lowbit(x)</code>的性质，可以将$[1,x]$分解为一个个不相交的子区间，将各个子区间的和相加即是$[1,x]$的前缀和。</p><p>例如<a href="http://poj.org/problem?id=1990">POJ 1990</a></p><p>给定$n$头牛的坐标，每头牛听力为$v_i$，两头牛($i$和$j$)之间必须以$max(v_i,v_j)$的音量沟通，沟通过程中消耗能量为$max(v_i,v_j)|x_i-x_j|$,求这$n$头牛两两沟通总共消耗多少能量。</p><p>任意两头牛之间以$max(v_i,v_j)$沟通，可以按照听力排序，从小到大处理$n$头牛。</p><p>对于正在处理的牛$i$，与其沟通所消耗的能量应该是其听力与所有听力小于该牛的坐标值之和的乘积。</p><p>维护两个树状数组，其中$bit0$用于计数，$bit1$用于计算坐标和。</p><p>维护处理过的所有牛的坐标和$tot$，并执行$add(bit0,x,1)$和$add(bit1,x,x)$。</p><p>对于牛$i$来说，</p><p>左边牛的坐标差值和为$sum(bit0,x[i])*x[i]-sum(bit1,x[i])$</p><p>右边牛的坐标差值和为$ tot-sum(bit1,x)-x[i] (i+1-sum(bit0,x[i]))$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>;</span><br><span class="line">ll bit0[maxn],bit1[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,x;</span><br><span class="line">&#125;;</span><br><span class="line">Node a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll *b,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        s+=b[i];</span><br><span class="line">        i-=i&amp;(-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll *b,<span class="keyword">int</span> i,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;maxn)&#123;</span><br><span class="line">        b[i]+=v;</span><br><span class="line">        i+=i&amp;(-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].v,&amp;a[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    ll tot=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(bit0,<span class="number">0</span>,<span class="keyword">sizeof</span>(bit0));</span><br><span class="line">    <span class="built_in">memset</span>(bit1,<span class="number">0</span>,<span class="keyword">sizeof</span>(bit1));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=a[i].x;</span><br><span class="line">        tot+=x;</span><br><span class="line">        add(bit0,x,<span class="number">1</span>);</span><br><span class="line">        add(bit1,x,x);</span><br><span class="line">        ll s1=sum(bit0,x);</span><br><span class="line">        ll s2=sum(bit1,x);</span><br><span class="line">        ll temp1=s1*x-s2;</span><br><span class="line">        ll temp2=tot-s2-x*(i+<span class="number">1</span>-s1);</span><br><span class="line">        ans+=(temp1+temp2)*a[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="http://poj.org/problem?id=3109">POJ 3109</a></p><p>先离散化所有黑棋的纵坐标，扫描线按照横坐标从左到右依次扫描，通过树状数组动态求和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">Node a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x) <span class="keyword">return</span> a.y&lt;a.y;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bit[maxn];</span><br><span class="line"><span class="keyword">int</span> l[maxn],r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i)</span><br><span class="line">&#123;</span><br><span class="line">res+=bit[i];</span><br><span class="line">i-=lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(i&lt;maxn)</span><br><span class="line">&#123;</span><br><span class="line">bit[i]+= x;</span><br><span class="line">i+=lowbit(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">        h.push_back(a[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">sort(a,a+n,cmp);</span><br><span class="line">sort(h.begin(),h.end());</span><br><span class="line">h.erase(unique(h.begin(), h.end()), h.end());</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        a[i].y=lower_bound(h.begin(),h.end(),a[i].y)-h.begin()+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(l,inf,<span class="keyword">sizeof</span>(l));</span><br><span class="line"><span class="built_in">memset</span>(r,-inf,<span class="keyword">sizeof</span>(r));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[a[i].y]==inf) l[a[i].y]=a[i].x;</span><br><span class="line">        r[a[i].y]=a[i].x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>  i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x = a[i].x, L = inf, R = -inf;</span><br><span class="line"><span class="keyword">int</span> j = i;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n&amp;&amp;a[i].x == x)</span><br><span class="line">&#123;</span><br><span class="line">L=min(L, a[i].y);</span><br><span class="line">R=max(R, a[i].y);</span><br><span class="line"><span class="keyword">if</span>(x==l[a[i].y])</span><br><span class="line">add(a[i].y, <span class="number">1</span>);</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">ans+=sum(R)-sum(L - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(j&lt;i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(x==r[a[j].y])</span><br><span class="line">add(a[j].y, <span class="number">-1</span>);</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间修改和单点查询"><a href="#区间修改和单点查询" class="headerlink" title="区间修改和单点查询"></a>区间修改和单点查询</h1><p>为了便于执行单点查询操作，引入差分数组的概念，差分数组中$p[i]=a[i]-a[i-1]$。</p><p>$\sum_{i=1}^{x}=a[1]+(a[2]-a[1])+(a[3]-a[2])+(a[4]-a[3])+…(a[x-1]+a[x-2])+(a[x]-a[x-1])$</p><p>显然，差分数组的前缀和即是单点查询所返回的值。</p><p>这样一来，树状数组在$O(logn)$时间内求前缀和的性质可以应用于求差分数组得前缀和，从而在$O(logn)$时间内执行单点查询操作。</p><p>若想对区间$[l,r]$中所有元素同时加上$x$，同样通过差分思想来操作。差分数组维护相邻两项的差值，所以仅仅区间首尾两项会更新，其余部分的差值不变。更新时，对$p[l]+x$,$p[r+1]-x$，通过两次单点更新操作实现区间修改。</p><p>例如<a href="http://poj.org/problem?id=2155">POJ 2155</a> </p><p>二维树状数组的区间修改和单点查询问题，思想与一维类似，更新点由两个变为四个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> bit[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&gt;<span class="number">0</span>;j-=lowbit(j))&#123;</span><br><span class="line">            s+=bit[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;maxn;i+=lowbit(i))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;maxn;j+=lowbit(j))&#123;</span><br><span class="line">            bit[i][j]+=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(bit,<span class="number">0</span>,<span class="keyword">sizeof</span>(bit));</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">                add(x1,y1,<span class="number">1</span>);</span><br><span class="line">                add(x2+<span class="number">1</span>,y1,<span class="number">-1</span>);</span><br><span class="line">                add(x1,y2+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                add(x2+<span class="number">1</span>,y2+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x,y;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                ll ans=sum(x,y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans&amp;<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="区间修改和区间查询"><a href="#区间修改和区间查询" class="headerlink" title="区间修改和区间查询"></a>区间修改和区间查询</h1><p>区间修改和区间查询同样应用了差分思想，考虑前缀和$sum(x)=\sum_{i=1}^{x}a[i]=\sum_{i=1}^{x}\sum_{j=1}^{i}p[j]$ </p><p>同时给区间$[l,r]$同时加上$x$时，树状数组中的值将会如何变化呢？</p><ol><li>$i&lt;l$,$sum’(i)=sum(i)$</li><li>$l\leq i \leq r$ ，$sum’(i)=sum(i)+x(i-l+1)=sum(i)+xi-x(l-1)$</li><li>$r&lt;i$,$sum’(i)=sum(i)+x(r-l+1)$</li></ol><p>构建两个树状数组$bit0$和$bit1$，$sum(bit,i)$为树状数组的前$i$项和</p><p>$\sum_{j=1}^{i}=sum(bit1,i)i+sum(bit0,i)$</p><p>那么在$[l,r]$区间同时加上$x$就等效于</p><ul><li>在$bit0$的$l$位置上加上$-x(l-1)$</li><li>在$bit1$的l位置上加上$x$</li><li>在$bit0$的位置上加上$xr$</li><li>在$bit1$的位置上加上$-x$</li></ul><p>因此，区间查询和区间更新操作均可在$O(logn)$时间内完成。</p><p>例如<a href="http://poj.org/problem?id=3468">POJ 3468</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> l,r,x;</span><br><span class="line">ll bit0[maxn],bit1[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll *b,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        s+=b[i];</span><br><span class="line">        i-=i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll *b,<span class="keyword">int</span> i,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        b[i]+=v;</span><br><span class="line">        i+=i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q)==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            add(bit0,i,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,c);</span><br><span class="line">            <span class="keyword">if</span>(c[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">                add(bit0,l,-x*(l<span class="number">-1</span>));</span><br><span class="line">                add(bit1,l,x);</span><br><span class="line">                add(bit0,r+<span class="number">1</span>,x*r);</span><br><span class="line">                add(bit1,r+<span class="number">1</span>,-x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">                ll res=<span class="number">0</span>;</span><br><span class="line">                res+=sum(bit0,r)+sum(bit1,r)*r;</span><br><span class="line">                res-=sum(bit0,l<span class="number">-1</span>)+sum(bit1,l<span class="number">-1</span>)*(l<span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;给定一个初始值全为$0$的数列$a_1,a_2,..,a_n$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;给定$i$,计算$a_1+a_2+…+a_n$&lt;/li&gt;
&lt;li&gt;给定$i$和$x$，计算$a_i+=x$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;树状数组可以在$O(logn)$时间内计算区间前缀和，在$O(logn)$时间内更新单点的值。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>结构化查询语言SQL</title>
    <link href="http://twinkle0331.github.io/database_system/sql/"/>
    <id>http://twinkle0331.github.io/database_system/sql/</id>
    <published>2020-02-07T01:29:26.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前的关系代数属于过程化语言，同时指定了具体计算过程。关系型语言仅仅指明用户需要什么数据，而不指定具体计算过程，由数据库管理系统负责底层的具体实现。</p><p>关系型语言一般由以下几个部分组成：</p><ul><li>数据定义语言(data definition language)</li><li>数据操纵语言(data manipulation language)</li><li>数据控制语言(data control language)</li></ul><p>其中<a href="https://zh.wikipedia.org/wiki/SQL">结构化查询语言SQL</a>广泛使用。</p><a id="more"></a><p>另外，关系代数基于集合，即无序，无重复，而关系型查询语言基于多集，即无序，允许重复。</p><p>以下为<a href="https://15445.courses.cs.cmu.edu/fall2019/homework1/">homework1</a>的解析</p><p>homework1中的数据集<a href="https://www.imdb.com/interfaces/">IMDB</a>是一个关于电影、电视节目、电子游戏和电影制作小组的在线数据库。本次howework中的sql由<a href="https://www.sqlite.org/">sqlite</a>实现。</p><p>首先创建sql文件，每个sql文件对应于hw中的一个问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir placeholder</span><br><span class="line">$ cd placeholder</span><br><span class="line">$ touch q1_sample.sql \</span><br><span class="line">        q2_uncommon_type.sql \</span><br><span class="line">        q3_tv_vs_movie.sql \</span><br><span class="line">        q4_old_is_not_gold.sql \</span><br><span class="line">        q5_percentage.sql \</span><br><span class="line">        q6_dubbed_smash.sql \</span><br><span class="line">        q7_imdb_250.sql \</span><br><span class="line">        q8_number_of_actors.sql \</span><br><span class="line">        q9_movie_names.sql \</span><br><span class="line">        q10_genre_counts.sql</span><br></pre></td></tr></table></figure><p>安装sqlite和libsqlite3-dev</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install sqlite3 libsqlite3-dev</span><br></pre></td></tr></table></figure><p>下载imdb数据库压缩包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;15445.courses.cs.cmu.edu&#x2F;fall2019&#x2F;files&#x2F;imdb-cmudb2019.db.gz</span><br></pre></td></tr></table></figure><p>校验md5校验和</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ md5 imdb-cmudb2019.db.gz </span><br><span class="line">MD5 (imdb-cmudb2019.db.gz) &#x3D; 6443351d4b55eb3c881622bd60a8dc5b</span><br></pre></td></tr></table></figure><p>解压数据库压缩包并用sqlite打开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gunzip imdb-cmudb2019.db.gz</span><br><span class="line">$ sqlite3 imdb-cmudb2019.db</span><br></pre></td></tr></table></figure><p>查看数据库中的表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .tables</span><br><span class="line">akas      crew      episodes  people    ratings   titles</span><br></pre></td></tr></table></figure><p>为每个表创建索引</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX ix_people_name ON people (name);</span><br><span class="line">CREATE INDEX ix_titles_type ON titles (type);</span><br><span class="line">CREATE INDEX ix_titles_primary_title ON titles (primary_title);</span><br><span class="line">CREATE INDEX ix_titles_original_title ON titles (original_title);</span><br><span class="line">CREATE INDEX ix_akas_title_id ON akas (title_id);</span><br><span class="line">CREATE INDEX ix_akas_title ON akas (title);</span><br><span class="line">CREATE INDEX ix_crew_title_id ON crew (title_id);</span><br><span class="line">CREATE INDEX ix_crew_person_id ON crew (person_id);</span><br></pre></td></tr></table></figure><p>检查数据库模式</p><p>people表的属性有身份证号，名字，出生日期，死亡日期，索引为姓名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .schema people</span><br><span class="line">CREATE TABLE people (</span><br><span class="line">  person_id VARCHAR PRIMARY KEY,</span><br><span class="line">  name VARCHAR,</span><br><span class="line">  born INTEGER,</span><br><span class="line">  died INTEGER</span><br><span class="line">);</span><br><span class="line">CREATE INDEX ix_people_name ON people (name);</span><br></pre></td></tr></table></figure><p>其中的一项为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm0000003|Brigitte Bardot|1934|</span><br></pre></td></tr></table></figure><p>title表为电影/电视剧/短视频/视频的具体信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; .schema titles</span><br><span class="line">CREATE TABLE titles (</span><br><span class="line">  title_id VARCHAR PRIMARY KEY,</span><br><span class="line">  type VARCHAR,</span><br><span class="line">  primary_title VARCHAR,</span><br><span class="line">  original_title VARCHAR,</span><br><span class="line">  is_adult INTEGER,</span><br><span class="line">  premiered INTEGER,</span><br><span class="line">  ended INTEGER,</span><br><span class="line">  runtime_minutes INTEGER,</span><br><span class="line">  genres VARCHAR</span><br><span class="line">);</span><br><span class="line">CREATE INDEX ix_titles_type ON titles (type);</span><br><span class="line">CREATE INDEX ix_titles_primary_title ON titles (primary_title);</span><br><span class="line">CREATE INDEX ix_titles_original_title ON titles (original_title);</span><br></pre></td></tr></table></figure><p>akas表为标题的语言，地区等信息，上映电影在其余国家的信息，标题可能会翻译成上映国家的版本。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE akas (</span><br><span class="line">  title_id VARCHAR, -- REFERENCES titles (title_id),</span><br><span class="line">  title VARCHAR,</span><br><span class="line">  region VARCHAR,</span><br><span class="line">  language VARCHAR,</span><br><span class="line">  types VARCHAR,</span><br><span class="line">  attributes VARCHAR,</span><br><span class="line">  is_original_title INTEGER</span><br><span class="line">);</span><br><span class="line">CREATE INDEX ix_akas_title_id ON akas (title_id);</span><br><span class="line">CREATE INDEX ix_akas_title ON akas (title);</span><br></pre></td></tr></table></figure><p>crew表为某剧对应的人物信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE crew (</span><br><span class="line">  title_id VARCHAR, -- REFERENCES titles (title_id),</span><br><span class="line">  person_id VARCHAR, -- REFERENCES people (person_id),</span><br><span class="line">  category VARCHAR,</span><br><span class="line">  job VARCHAR</span><br><span class="line">);</span><br><span class="line">CREATE INDEX ix_crew_title_id ON crew (title_id);</span><br><span class="line">CREATE INDEX ix_crew_person_id ON crew (person_id);</span><br></pre></td></tr></table></figure><p>其中一行的信息为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt0000003|nm5442194|producer|producer</span><br></pre></td></tr></table></figure><p>rating表为对应的id和评分，参与人数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE ratings (</span><br><span class="line">  title_id VARCHAR PRIMARY KEY, -- REFERENCES titles (title_id),</span><br><span class="line">  rating FLOAT,</span><br><span class="line">  votes INTEGER</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>其中一行的信息为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tt0000001|5.6|1529</span><br></pre></td></tr></table></figure><h1 id="q1"><a href="#q1" class="headerlink" title="q1"></a>q1</h1><p>查询titles表中不同类型有哪些</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sqlite&gt; select distinct(type) from titles order by type;</span><br><span class="line">    movie</span><br><span class="line">    short</span><br><span class="line">    tvEpisode</span><br><span class="line">    tvMiniSeries</span><br><span class="line">    tvMovie</span><br><span class="line">    tvSeries</span><br><span class="line">    tvShort</span><br><span class="line">    tvSpecial</span><br><span class="line">    video</span><br><span class="line">    videoGame</span><br></pre></td></tr></table></figure><h1 id="q2"><a href="#q2" class="headerlink" title="q2"></a>q2</h1><p>查询每种类型中最长播放时间的title</p><ul><li>对于存在并列的情况，所有并列的条目均输出</li><li>输出types,primary titles,runtime minutes,按照type升序，若type相同则按照primary titles升序</li></ul><p>简单地，查询每种类型中最长播放时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT type,max(runtime_minutes) FROM titles GROUP BY type;</span><br></pre></td></tr></table></figure><p>得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">movie|51420</span><br><span class="line">short|461</span><br><span class="line">tvEpisode|1800</span><br><span class="line">tvMiniSeries|1755</span><br><span class="line">tvMovie|2112</span><br><span class="line">tvSeries|8400</span><br><span class="line">tvShort|60</span><br><span class="line">tvSpecial|5760</span><br><span class="line">video|5135</span><br><span class="line">videoGame|1500</span><br></pre></td></tr></table></figure><p>查询目标为runtime_minutes等于最大值的title</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WITH types(type, runtime_minutes) AS ( </span><br><span class="line">  SELECT type, MAX(runtime_minutes)</span><br><span class="line">    FROM titles</span><br><span class="line">    GROUP BY type</span><br><span class="line">)</span><br><span class="line">SELECT titles.type, titles.primary_title, titles.runtime_minutes</span><br><span class="line">  FROM titles</span><br><span class="line">  JOIN types</span><br><span class="line">  ON titles.runtime_minutes &#x3D;&#x3D; types.runtime_minutes AND titles.type &#x3D;&#x3D; types.type</span><br><span class="line">  ORDER BY titles.type, titles.primary_title</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>可通过with子句定义临时关系，再通过join运算限定title条目。</p><p>查询结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">movie|Logistics|51420</span><br><span class="line">short|Kuriocity|461</span><br><span class="line">tvEpisode|Téléthon 2012|1800</span><br><span class="line">tvMiniSeries|Kôya no yôjinbô|1755</span><br><span class="line">tvMovie|ArtQuench Presents Spirit Art|2112</span><br><span class="line">tvSeries|The Sharing Circle|8400</span><br><span class="line">tvShort|Paul McCartney Backstage at Super Bowl XXXIX|60</span><br><span class="line">tvShort|The People Next Door|60</span><br><span class="line">tvSpecial|Katy Perry Live: Witness World Wide|5760</span><br><span class="line">video|Midnight Movie Madness: 50 Movie Mega Pack|5135</span><br><span class="line">videoGame|Flushy Fish VR: Just Squidding Around|1500</span><br></pre></td></tr></table></figure><h1 id="q3"><a href="#q3" class="headerlink" title="q3"></a>q3</h1><p>列出所有类型的title，并给出相关条目的数量</p><ul><li>按照类型升序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT type, count(*) AS title_count FROM titles GROUP BY type ORDER BY title_count ASC;</span><br></pre></td></tr></table></figure><p>查询结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tvShort|4075</span><br><span class="line">videoGame|9044</span><br><span class="line">tvSpecial|9107</span><br><span class="line">tvMiniSeries|10291</span><br><span class="line">tvMovie|45431</span><br><span class="line">tvSeries|63631</span><br><span class="line">video|90069</span><br><span class="line">movie|197957</span><br><span class="line">short|262038</span><br><span class="line">tvEpisode|1603076</span><br></pre></td></tr></table></figure><h1 id="q4"><a href="#q4" class="headerlink" title="q4"></a>q4</h1><p>按照每十年为间隔，统计首映的titles数目，例如<code>2010s|2789741</code></p><ul><li>年份按照类似2010s的格式输出，按照数目降序，<code>premiered</code>为<code>NULL</code>的条目不计入结果</li></ul><p>通过<code>group by</code>子句按照每十年分组,通过字符串运算在年份后添加s</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  CAST(premiered&#x2F;10*10 AS TEXT) || &#39;s&#39; AS decade,</span><br><span class="line">  COUNT(*) AS num_movies</span><br><span class="line">  FROM titles</span><br><span class="line">  WHERE premiered is not null</span><br><span class="line">  GROUP BY decade</span><br><span class="line">  ORDER BY num_movies DESC</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>查询结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2010s|1050732</span><br><span class="line">2000s|494639</span><br><span class="line">1990s|211453</span><br><span class="line">1980s|119258</span><br><span class="line">1970s|99707</span><br><span class="line">1960s|75237</span><br><span class="line">1950s|39554</span><br><span class="line">1910s|26596</span><br><span class="line">1920s|13153</span><br><span class="line">1930s|11492</span><br><span class="line">1940s|10011</span><br><span class="line">1900s|9586</span><br><span class="line">2020s|2492</span><br><span class="line">1890s|2286</span><br><span class="line">1880s|22</span><br><span class="line">1870s|1</span><br></pre></td></tr></table></figure><h1 id="q5"><a href="#q5" class="headerlink" title="q5"></a>q5</h1><p>按照每十年为间隔，统计对应首映的titles数目百分比，例如 <code>2010s|45.7042</code></p><ul><li>百分比为对应的首映数目除以总titles数目，titles算入<code>premiered</code>为<code>NULL</code>的条目，结果舍入到小数点后四位</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  CAST(premiered&#x2F;10*10 AS TEXT) || &#39;s&#39; AS decade,</span><br><span class="line">  ROUND(CAST(COUNT(*) AS REAL) &#x2F; (SELECT COUNT(*) FROM titles) * 100.0, 4) as percentage</span><br><span class="line">  FROM titles</span><br><span class="line">  WHERE premiered is not null</span><br><span class="line">  GROUP BY decade</span><br><span class="line">  ORDER BY percentage DESC, decade ASC</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>查询结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">2010s|45.7891</span><br><span class="line">2000s|21.5555</span><br><span class="line">1990s|9.2148</span><br><span class="line">1980s|5.1971</span><br><span class="line">1970s|4.3451</span><br><span class="line">1960s|3.2787</span><br><span class="line">1950s|1.7237</span><br><span class="line">1910s|1.159</span><br><span class="line">1920s|0.5732</span><br><span class="line">1930s|0.5008</span><br><span class="line">1940s|0.4363</span><br><span class="line">1900s|0.4177</span><br><span class="line">2020s|0.1086</span><br><span class="line">1890s|0.0996</span><br><span class="line">1880s|0.001</span><br><span class="line">1870s|0.0</span><br></pre></td></tr></table></figure><h1 id="q6"><a href="#q6" class="headerlink" title="q6"></a>q6</h1><p>列出转播次数的titles前十</p><ul><li>输出primary title和对应的数目</li></ul><p>和q2类似，可通过with子句定义临时关系，<code>LIMIT 10</code>限定输出条目的数目再通过join运算限定title条目。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WITH translations AS (</span><br><span class="line">  SELECT title_id, count(*) as num_translations </span><br><span class="line">    FROM akas </span><br><span class="line">    GROUP BY title_id </span><br><span class="line">    ORDER BY num_translations DESC, title_id </span><br><span class="line">    LIMIT 10</span><br><span class="line">)</span><br><span class="line">SELECT titles.primary_title, translations.num_translations</span><br><span class="line">  FROM translations</span><br><span class="line">  JOIN titles</span><br><span class="line">  ON titles.title_id &#x3D;&#x3D; translations.title_id</span><br><span class="line">  ORDER BY translations.num_translations DESC</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>查询结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Mutant Virus: Vol. 1|126</span><br><span class="line">The Good, the Bad and the Ugly|73</span><br><span class="line">Star Wars: Episode V - The Empire Strikes Back|71</span><br><span class="line">Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb|68</span><br><span class="line">Raiders of the Lost Ark|62</span><br><span class="line">Star Wars: Episode VII - The Force Awakens|62</span><br><span class="line">The Shawshank Redemption|61</span><br><span class="line">Once Upon a Time in the West|60</span><br><span class="line">Indiana Jones and the Kingdom of the Crystal Skull|60</span><br><span class="line">Airplane!|59</span><br></pre></td></tr></table></figure><h1 id="q7"><a href="#q7" class="headerlink" title="q7"></a>q7</h1><p>列出IMDB中电影权重最高的250个</p><p>权重的计算方式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weighted rating (WR) &#x3D; (v&#x2F;(v+m)) * R + (m&#x2F;(v+m)) * C</span><br></pre></td></tr></table></figure><ul><li>R为电影平均评分</li><li>v为评分人数</li><li>m为25000</li><li>C为所有电影的平均权重</li></ul><p><code>weight</code>的计算放入<code>select</code>语句中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">WITH</span><br><span class="line">  av(average_rating) AS (</span><br><span class="line">    SELECT SUM(rating * votes) &#x2F; SUM(votes)</span><br><span class="line">      FROM ratings</span><br><span class="line">      JOIN titles</span><br><span class="line">      ON titles.title_id &#x3D;&#x3D; ratings.title_id AND titles.type &#x3D;&#x3D; &quot;movie&quot; </span><br><span class="line">  ),</span><br><span class="line">  mn(min_rating) AS (SELECT 25000.0)</span><br><span class="line">SELECT</span><br><span class="line">  primary_title,</span><br><span class="line">  (votes &#x2F; (votes + min_rating)) * rating + (min_rating &#x2F; (votes + min_rating)) * average_rating as weighed_rating</span><br><span class="line">  FROM ratings, av, mn</span><br><span class="line">  JOIN titles</span><br><span class="line">  ON titles.title_id &#x3D;&#x3D; ratings.title_id and titles.type &#x3D;&#x3D; &quot;movie&quot;</span><br><span class="line">  ORDER BY weighed_rating DESC</span><br><span class="line">  LIMIT 250</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure><p>榜单如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br></pre></td><td class="code"><pre><span class="line">The Shawshank Redemption|9.27408375213064</span><br><span class="line">Pulp Fiction|8.87296068706845</span><br><span class="line">The Lord of the Rings: The Return of the King|8.87023538818413</span><br><span class="line">Schindler&#39;s List|8.85944837786486</span><br><span class="line">12 Angry Men|8.8274654312365</span><br><span class="line">Forrest Gump|8.77394665505175</span><br><span class="line">The Good, the Bad and the Ugly|8.73410047935658</span><br><span class="line">The Matrix|8.67379043068514</span><br><span class="line">The Lord of the Rings: The Two Towers|8.67073273467584</span><br><span class="line">Star Wars: Episode V - The Empire Strikes Back|8.66258036565461</span><br><span class="line">Goodfellas|8.65679704067696</span><br><span class="line">One Flew Over the Cuckoo&#39;s Nest|8.65294416076491</span><br><span class="line">The Mountain II|8.61725087838868</span><br><span class="line">City of God|8.54342805417796</span><br><span class="line">Gladiator|8.47143742708625</span><br><span class="line">Back to the Future|8.46332853886572</span><br><span class="line">Léon: The Professional|8.46292056565729</span><br><span class="line">Avengers: Infinity War|8.4506845289751</span><br><span class="line">Psycho|8.4373696976068</span><br><span class="line">Rear Window|8.41674755149826</span><br><span class="line">Once Upon a Time in the West|8.38089735258473</span><br><span class="line">WALL·E|8.36472733136252</span><br><span class="line">Raiders of the Lost Ark|8.36071764723241</span><br><span class="line">The Shining|8.35937143360229</span><br><span class="line">Alien|8.35552530090484</span><br><span class="line">Cinema Paradiso|8.3444698366033</span><br><span class="line">Apocalypse Now|8.34271721766924</span><br><span class="line">Grave of the Fireflies|8.34191265540178</span><br><span class="line">Oldboy|8.33209348956415</span><br><span class="line">Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb|8.3250687044724</span><br><span class="line">Once Upon a Time in America|8.29149205920628</span><br><span class="line">Spider-Man: Into the Spider-Verse|8.27944770565499</span><br><span class="line">Inglourious Basterds|8.27361869242351</span><br><span class="line">American Beauty|8.26993451202779</span><br><span class="line">Reservoir Dogs|8.26439627161116</span><br><span class="line">Requiem for a Dream|8.25798876833464</span><br><span class="line">A Clockwork Orange|8.25742341547537</span><br><span class="line">Toy Story 3|8.25734107724815</span><br><span class="line">Scarface|8.25590438979589</span><br><span class="line">Full Metal Jacket|8.25210853826772</span><br><span class="line">Sunset Blvd.|8.23933898857354</span><br><span class="line">Amadeus|8.21589004599775</span><br><span class="line">Vertigo|8.21216347202948</span><br><span class="line">Like Stars on Earth|8.20481373841464</span><br><span class="line">Your Name.|8.19983566375586</span><br><span class="line">North by Northwest|8.1975172347387</span><br><span class="line">Batman Begins|8.17704665931913</span><br><span class="line">V for Vendetta|8.17129916924205</span><br><span class="line">Die Hard|8.16240649720068</span><br><span class="line">Lock, Stock and Two Smoking Barrels|8.14585507926427</span><br><span class="line">Casino|8.13629764272654</span><br><span class="line">Unforgiven|8.12365074764615</span><br><span class="line">The Apartment|8.12061011853697</span><br><span class="line">Chinatown|8.10376481333931</span><br><span class="line">My Neighbor Totoro|8.09442185609386</span><br><span class="line">Green Book|8.09074160238658</span><br><span class="line">Finding Nemo|8.07145216202776</span><br><span class="line">Catch Me If You Can|8.06592479759894</span><br><span class="line">The Grand Budapest Hotel|8.06129693202741</span><br><span class="line">Blade Runner|8.06098971608469</span><br><span class="line">Fargo|8.05647629910042</span><br><span class="line">Prisoners|8.05390469414222</span><br><span class="line">The Kid|8.05287532584739</span><br><span class="line">Rush|8.03898582269203</span><br><span class="line">Hacksaw Ridge|8.03551702468201</span><br><span class="line">The Seventh Seal|8.03407390030423</span><br><span class="line">The Princess Bride|8.03359206319394</span><br><span class="line">Platoon|8.03211473247254</span><br><span class="line">PK|8.02907703728921</span><br><span class="line">Monty Python&#39;s Life of Brian|8.02901738104703</span><br><span class="line">Gone with the Wind|8.01162552164356</span><br><span class="line">Before Sunrise|8.00325016258364</span><br><span class="line">Ben-Hur|7.98708858673506</span><br><span class="line">The Elephant Man|7.98656566725627</span><br><span class="line">The Treasure of the Sierra Madre|7.98183759819495</span><br><span class="line">Aynabaji|7.97740941967294</span><br><span class="line">Yojimbo|7.97326922828868</span><br><span class="line">Star Wars: Episode VII - The Force Awakens|7.97147281541043</span><br><span class="line">Slumdog Millionaire|7.97003387503103</span><br><span class="line">Monsters, Inc.|7.96993549888079</span><br><span class="line">Sin City|7.96864677307258</span><br><span class="line">X-Men: Days of Future Past|7.96426564397762</span><br><span class="line">Ratatouille|7.96198738026476</span><br><span class="line">Jaws|7.95693515580935</span><br><span class="line">Her|7.95337602084149</span><br><span class="line">Cool Hand Luke|7.95284437581594</span><br><span class="line">Akira|7.9466594640111</span><br><span class="line">In the Name of the Father|7.94653731881204</span><br><span class="line">Big Fish|7.94417520197508</span><br><span class="line">Zootopia|7.94391037425039</span><br><span class="line">Barry Lyndon|7.93804803727936</span><br><span class="line">La Haine|7.93713874007203</span><br><span class="line">Network|7.93673499353362</span><br><span class="line">Ikiru|7.93587006088359</span><br><span class="line">Harakiri|7.93442534185635</span><br><span class="line">On the Waterfront|7.93384958766431</span><br><span class="line">Drishyam|7.9316664137302</span><br><span class="line">The Chaos Class Failed the Class|7.92209636316521</span><br><span class="line">Magnolia|7.92151783450757</span><br><span class="line">Swades|7.91791802696218</span><br><span class="line">Children of Heaven|7.91488724265187</span><br><span class="line">Tosun Pasa|7.91175384887872</span><br><span class="line">Dog Day Afternoon|7.90497209143548</span><br><span class="line">Before Sunset|7.90135907545106</span><br><span class="line">Memories of Murder|7.89983909706083</span><br><span class="line">Ip Man|7.89530989242938</span><br><span class="line">Chak de! India|7.89380214739519</span><br><span class="line">Munna Bhai M.B.B.S.|7.88766873353758</span><br><span class="line">The 400 Blows|7.88236058087742</span><br><span class="line">Elite Squad|7.88128931930257</span><br><span class="line">Cinderella Man|7.87893854172733</span><br><span class="line">Judgment at Nuremberg|7.87703872647609</span><br><span class="line">Ayla: The Daughter of War|7.87111640888977</span><br><span class="line">Toy Story 4|7.86727079414856</span><br><span class="line">District 9|7.86716566170036</span><br><span class="line">Edge of Tomorrow|7.86401183134919</span><br><span class="line">Searching for Sugar Man|7.86361014282595</span><br><span class="line">Thor: Ragnarok|7.86067171002219</span><br><span class="line">Harry Potter and the Prisoner of Azkaban|7.86009831177006</span><br><span class="line">The Handmaiden|7.86005695016839</span><br><span class="line">Toy Story 2|7.85903363434152</span><br><span class="line">The Bourne Identity|7.85871357953152</span><br><span class="line">Three Colors: Red|7.8571771641382</span><br><span class="line">Edward Scissorhands|7.85308436175456</span><br><span class="line">Nightcrawler|7.85238182329928</span><br><span class="line">Castle in the Sky|7.8494569785608</span><br><span class="line">Paris, Texas|7.84540229570821</span><br><span class="line">The Breakfast Club|7.84009539226878</span><br><span class="line">Ghost in the Shell|7.8358170251987</span><br><span class="line">Mulholland Dr.|7.83476463500115</span><br><span class="line">Strangers on a Train|7.8340265331899</span><br><span class="line">Papillon|7.83230035374453</span><br><span class="line">The Raid 2|7.82177754544252</span><br><span class="line">The Artist|7.81451845636192</span><br><span class="line">The Man Who Shot Liberty Valance|7.8078751132418</span><br><span class="line">True Romance|7.80358074659557</span><br><span class="line">All the President&#39;s Men|7.80348137201329</span><br><span class="line">A Streetcar Named Desire|7.80156298305092</span><br><span class="line">My Name Is Khan|7.80054788180083</span><br><span class="line">Patton|7.79504441225479</span><br><span class="line">Tokyo Story|7.79422849952735</span><br><span class="line">The Blues Brothers|7.79298260954459</span><br><span class="line">The Man from Earth|7.78857212574483</span><br><span class="line">Capernaum|7.78563829871188</span><br><span class="line">Spider-Man: Far from Home|7.78561846386015</span><br><span class="line">Vikram Vedha|7.78373473224346</span><br><span class="line">Titanic|7.78157715805354</span><br><span class="line">The Hobbit: An Unexpected Journey|7.77554863836764</span><br><span class="line">The Passion of Joan of Arc|7.77408091487195</span><br><span class="line">High and Low|7.77213704112255</span><br><span class="line">Sing Street|7.76915812623775</span><br><span class="line">The Legend of 1900|7.76815835496063</span><br><span class="line">Elite Squad: The Enemy Within|7.76812044894699</span><br><span class="line">Fanny and Alexander|7.76800472456941</span><br><span class="line">Taken|7.76769012246336</span><br><span class="line">The Straight Story|7.76752395340217</span><br><span class="line">Kahaani|7.76720011579587</span><br><span class="line">Ocean&#39;s Eleven|7.76364685071376</span><br><span class="line">The Sea Inside|7.76289022497323</span><br><span class="line">O.J.: Made in America|7.76250676256312</span><br><span class="line">Before Midnight|7.76132220796731</span><br><span class="line">Home|7.76025351500213</span><br><span class="line">Back to the Future Part II|7.76009005121133</span><br><span class="line">Spring, Summer, Fall, Winter... and Spring|7.7592446422894</span><br><span class="line">Manhattan|7.7591232226754</span><br><span class="line">Crash|7.757187612945</span><br><span class="line">The Girl with the Dragon Tattoo|7.75600754037541</span><br><span class="line">Big Hero 6|7.7544767707715</span><br><span class="line">Predator|7.75096576853116</span><br><span class="line">Spartacus|7.75079774492003</span><br><span class="line">Isle of Dogs|7.7494869658895</span><br><span class="line">The Fighter|7.74677127042658</span><br><span class="line">The Game|7.7466716184388</span><br><span class="line">The Big Short|7.7461656518056</span><br><span class="line">Moonrise Kingdom|7.74269388072724</span><br><span class="line">Pather Panchali|7.74145616936336</span><br><span class="line">Doctor Zhivago|7.74112370242397</span><br><span class="line">Apocalypto|7.73848649857271</span><br><span class="line">About Time|7.7377698449424</span><br><span class="line">Gattaca|7.73647859452984</span><br><span class="line">What Ever Happened to Baby Jane?|7.73539364991903</span><br><span class="line">The Marathon Family|7.73428987458458</span><br><span class="line">Crouching Tiger, Hidden Dragon|7.73132118708057</span><br><span class="line">Sunrise|7.72522570382843</span><br><span class="line">Manchester by the Sea|7.72481321224648</span><br><span class="line">La Dolce Vita|7.72473610906825</span><br><span class="line">Halloween|7.72149520973176</span><br><span class="line">Sherlock Jr.|7.72122901074544</span><br><span class="line">What&#39;s Eating Gilbert Grape|7.71837046863796</span><br><span class="line">Diabolique|7.71738924368521</span><br><span class="line">Remember the Titans|7.7131373150204</span><br><span class="line">Amour|7.71206424086562</span><br><span class="line">Earthlings|7.71112168098164</span><br><span class="line">Hidden Figures|7.70836846509536</span><br><span class="line">The Boy in the Striped Pajamas|7.70750686722645</span><br><span class="line">Throne of Blood|7.70486190012118</span><br><span class="line">Nosferatu|7.70479615314119</span><br><span class="line">The Best Years of Our Lives|7.70404091573498</span><br><span class="line">La Strada|7.7035894202021</span><br><span class="line">Blue Velvet|7.70348849922288</span><br><span class="line">Ed Wood|7.70011913851453</span><br><span class="line">Carry On, Munna Bhai|7.6960703370653</span><br><span class="line">The Insider|7.69589363902872</span><br><span class="line">Rio Bravo|7.69547902962826</span><br><span class="line">Do the Right Thing|7.69470637286005</span><br><span class="line">G.O.R.A.|7.69143691201405</span><br><span class="line">John Wick: Chapter 3 - Parabellum|7.69042140474976</span><br><span class="line">The Big Sleep|7.69022732193082</span><br><span class="line">The Best of Youth|7.68939089676166</span><br><span class="line">The Wild Bunch|7.68732321899666</span><br><span class="line">Evil Dead II|7.68698809399903</span><br><span class="line">Airlift|7.68482585880285</span><br><span class="line">Who&#39;s Singin&#39; Over There?|7.68275319170322</span><br><span class="line">The King of the Street Cleaners|7.68007124396815</span><br><span class="line">Blue Is the Warmest Color|7.67888277323536</span><br><span class="line">300|7.67811080177943</span><br><span class="line">The Hangover|7.67745136243525</span><br><span class="line">The Chaos Class Is on Vacation|7.67701815540533</span><br><span class="line">Kramer vs. Kramer|7.6734998783239</span><br><span class="line">Special 26|7.67149062884843</span><br><span class="line">Harold and Maude|7.67125075421178</span><br><span class="line">Breathless|7.66994880180493</span><br><span class="line">3-Iron|7.66894856428393</span><br><span class="line">Glory|7.66830445780438</span><br><span class="line">Awakenings|7.66753775055519</span><br><span class="line">Star Trek Into Darkness|7.66655348768595</span><br><span class="line">To Be or Not to Be|7.66618772896992</span><br><span class="line">A Silent Voice|7.66616985054611</span><br><span class="line">Get Out|7.66418042868228</span><br><span class="line">The Fifth Element|7.66340814153364</span><br><span class="line">Zodiac|7.66276470401316</span><br><span class="line">Empire of the Sun|7.66123857830932</span><br><span class="line">Lost in Translation|7.66075124608843</span><br><span class="line">Man with a Movie Camera|7.66048361595785</span><br><span class="line">Tangled|7.66012044434097</span><br><span class="line">Once|7.65980150013791</span><br><span class="line">Midnight in Paris|7.65893069763627</span><br><span class="line">The King of Kong: A Fistful of Quarters|7.65818054427474</span><br><span class="line">Wreck-It Ralph|7.6578968805438</span><br><span class="line">The Salt of the Earth|7.6573311856226</span><br><span class="line">The Fault in Our Stars|7.65410038215701</span><br><span class="line">Time of the Gypsies|7.65354312829129</span><br><span class="line">Lucky Number Slevin|7.64972806598217</span><br><span class="line">Whisper of the Heart|7.64876091986559</span><br><span class="line">O Brother, Where Art Thou?|7.64584931637816</span><br><span class="line">Talvar|7.64560053612369</span><br><span class="line">Donnie Brasco|7.6439766475949</span><br><span class="line">As Good as It Gets|7.64393017265743</span><br><span class="line">The Motorcycle Diaries|7.64367118785382</span><br><span class="line">The Girl with the Red Scarf|7.64023075719264</span><br></pre></td></tr></table></figure><p>榜单第一是肖申克的救赎,惊了！</p><h1 id="q8"><a href="#q8" class="headerlink" title="q8"></a>q8</h1><p>列出和Mark Hamill合作过的男演员/女演员的数量</p><ul><li>仅输出数量</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WITH hamill_titles AS (</span><br><span class="line">  SELECT DISTINCT(crew.title_id)</span><br><span class="line">    FROM people</span><br><span class="line">    JOIN crew</span><br><span class="line">    ON crew.person_id &#x3D;&#x3D; people.person_id AND people.name &#x3D;&#x3D; &quot;Mark Hamill&quot; AND people.born &#x3D;&#x3D; 1951</span><br><span class="line">)</span><br><span class="line">SELECT COUNT(DISTINCT(crew.person_id))</span><br><span class="line">  FROM crew</span><br><span class="line">  WHERE (crew.category &#x3D;&#x3D; &quot;actor&quot; OR crew.category &#x3D;&#x3D; &quot;actress&quot;) AND crew.title_id in hamill_titles</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>查询结果为<code>206</code></p><h1 id="q9"><a href="#q9" class="headerlink" title="q9"></a>q9</h1><p>按照字典序列出Mark Hamill(生于1951年)和George Lucas(生于1944年)共同参演的作品</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WITH hamill_movies(title_id) AS (</span><br><span class="line">  SELECT crew.title_id</span><br><span class="line">    FROM crew</span><br><span class="line">    JOIN people</span><br><span class="line">    ON crew.person_id &#x3D;&#x3D; people.person_id AND people.name &#x3D;&#x3D; &quot;Mark Hamill&quot; AND people.born &#x3D;&#x3D; 1951</span><br><span class="line">)</span><br><span class="line">SELECT titles.primary_title</span><br><span class="line">  FROM crew</span><br><span class="line">  JOIN people</span><br><span class="line">  ON crew.person_id &#x3D;&#x3D; people.person_id AND people.name &#x3D;&#x3D; &quot;George Lucas&quot; AND people.born &#x3D;&#x3D; 1944 AND crew.title_id IN hamill_movies</span><br><span class="line">  JOIN titles</span><br><span class="line">  ON crew.title_id &#x3D;&#x3D; titles.title_id AND titles.type &#x3D;&#x3D; &quot;movie&quot;</span><br><span class="line">  ORDER BY titles.primary_title</span><br><span class="line">;</span><br></pre></td></tr></table></figure><p>查询结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Star Wars: Episode V - The Empire Strikes Back</span><br></pre></td></tr></table></figure><p>仅有一部电影</p><h1 id="q10"><a href="#q10" class="headerlink" title="q10"></a>q10</h1><p>列出所有不同的标签和相关的<code>titles</code>数目</p><p>不同标签之间以逗号间隔，所以需要从<code>genre</code>中提取出对应的标签信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">WITH RECURSIVE split(genre, rest) AS (</span><br><span class="line">  SELECT &#39;&#39;, genres || &#39;,&#39; FROM titles WHERE genres !&#x3D; &quot;\N&quot;</span><br><span class="line">   UNION ALL</span><br><span class="line">  SELECT substr(rest, 0, instr(rest, &#39;,&#39;)),</span><br><span class="line">         substr(rest, instr(rest, &#39;,&#39;)+1)</span><br><span class="line">    FROM split</span><br><span class="line">   WHERE rest !&#x3D; &#39;&#39;</span><br><span class="line">)</span><br><span class="line">SELECT genre, count(*) as genre_count</span><br><span class="line">  FROM split </span><br><span class="line"> WHERE genre !&#x3D; &#39;&#39;</span><br><span class="line"> GROUP BY genre</span><br><span class="line"> ORDER BY genre_count DESC;</span><br></pre></td></tr></table></figure><p>查询结果为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Drama|620063</span><br><span class="line">Comedy|486163</span><br><span class="line">Short|310619</span><br><span class="line">Documentary|222187</span><br><span class="line">Talk-Show|215144</span><br><span class="line">Romance|211462</span><br><span class="line">Family|159035</span><br><span class="line">News|148941</span><br><span class="line">Animation|115998</span><br><span class="line">Reality-TV|113180</span><br><span class="line">Music|105724</span><br><span class="line">Crime|99019</span><br><span class="line">Action|97544</span><br><span class="line">Adventure|81686</span><br><span class="line">Game-Show|75169</span><br><span class="line">Adult|65704</span><br><span class="line">Sport|48855</span><br><span class="line">Fantasy|48341</span><br><span class="line">Mystery|47155</span><br><span class="line">Horror|41552</span><br><span class="line">Thriller|40664</span><br><span class="line">History|31675</span><br><span class="line">Sci-Fi|31441</span><br><span class="line">Biography|27001</span><br><span class="line">Musical|17939</span><br><span class="line">Western|9811</span><br><span class="line">War|9309</span><br><span class="line">Film-Noir|322</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前的关系代数属于过程化语言，同时指定了具体计算过程。关系型语言仅仅指明用户需要什么数据，而不指定具体计算过程，由数据库管理系统负责底层的具体实现。&lt;/p&gt;
&lt;p&gt;关系型语言一般由以下几个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据定义语言(data definition language)&lt;/li&gt;
&lt;li&gt;数据操纵语言(data manipulation language)&lt;/li&gt;
&lt;li&gt;数据控制语言(data control language)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中&lt;a href=&quot;https://zh.wikipedia.org/wiki/SQL&quot;&gt;结构化查询语言SQL&lt;/a&gt;广泛使用。&lt;/p&gt;</summary>
    
    
    
    <category term="Systems" scheme="http://twinkle0331.github.io/categories/Systems/"/>
    
    
    <category term="database systems" scheme="http://twinkle0331.github.io/tags/database-systems/"/>
    
  </entry>
  
  <entry>
    <title>并发控制</title>
    <link href="http://twinkle0331.github.io/database_system/concurrency-control/"/>
    <id>http://twinkle0331.github.io/database_system/concurrency-control/</id>
    <published>2020-02-06T01:31:08.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>事务的基本特性是隔离性，然而当数据库中由多个事务并发执行时，事务的隔离性不一定能保持。为保持事务的隔离性，系统必须对并发事务之间的相互作用加以控制，这种控制通过并发控制机制来实现。</p><a id="more"></a><p>之前我们了解到视图串行化并不存在有效验证方法，那么还需要有一种方式来确保在不提前知道所有调度的情况下所有执行调度仍然是正确的，因此引入锁机制。</p><p>之前的调度序列在引入锁机制后</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> T1                      T2</span><br><span class="line">BEGIN</span><br><span class="line">LOCK(A)</span><br><span class="line">R(A)</span><br><span class="line">                       BEGIN</span><br><span class="line">                       LOCK(A)</span><br><span class="line">W(A)</span><br><span class="line">R(A)</span><br><span class="line">UNLOCK(A)</span><br><span class="line">                       R(A)</span><br><span class="line">                       W(A)                       </span><br><span class="line">COMMIT</span><br><span class="line">                       UNLOCK(A)</span><br><span class="line">                       COMMIT</span><br></pre></td></tr></table></figure><p>在T2申请对A锁的时候，T1已经取得了对A的锁，在T1释放对A锁之后，T2才可得到对A的锁。</p><p>锁的基本类型有两种</p><ul><li>S-LOCK: 共享读锁</li><li>X-LOCK: 排他写锁</li></ul><p>对于给定的一个锁类型集合,令A与B代表任意的锁类型，假设事务Ti请求对数据项加A类型锁，而事务Tj当前在数据库Q上拥有B类型锁，而事务Ti可立即获得数据项Q上的锁，那么A类型锁和B类型锁是相容的。</p><p>S-LOCK和X-LOCK的相容性矩阵如下</p><table><thead><tr><th></th><th>S</th><th>X</th></tr></thead><tbody><tr><td>S</td><td>true</td><td>false</td></tr><tr><td>X</td><td>false</td><td>false</td></tr></tbody></table><p>关于锁的流程为</p><ol><li><p>事务申请锁(或者更新)</p></li><li><p>锁管理器授予锁或者拒绝请求</p></li><li><p>事务释放锁</p></li><li><p>锁管理器释放内部的锁表</p><p>锁表中存储持有锁的事务信息和等待锁的事务信息</p></li></ol><p>在系统中每一个事物遵从称为封锁协议的一组规则，这些规则规定事务何时对数据项进行加锁、解锁，封锁协议限制了可能的调度数目。</p><h1 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h1><p>确保串行性的一个协议是两阶段封锁协议，该协议要求每个事务分两个阶段提出加锁和释放锁申请。</p><ol><li><p>增长阶段：事务可以获得锁，但是不能释放锁</p><p>锁管理器允许/拒绝请求</p></li><li><p>缩减阶段：事务可以释放锁，但是不能释放锁</p><p>在增长阶段后不允许申请/升级锁。</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> T1                      T2</span><br><span class="line">BEGIN</span><br><span class="line">X-LOCK(A)</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">                       BEGIN</span><br><span class="line">                       X-LOCK(A)</span><br><span class="line">R(A)</span><br><span class="line">UNLOCK(A)</span><br><span class="line">                       W(A)                       </span><br><span class="line">COMMIT</span><br><span class="line">                       UNLOCK(A)</span><br><span class="line">                       COMMIT</span><br></pre></td></tr></table></figure><p>两阶段封锁协议可保证冲突可串行化，产生无环的依赖图。</p><p>在两阶段封锁协议中，可能存在级联回滚现象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> T1                      T2</span><br><span class="line">BEGIN</span><br><span class="line">X-LOCK(A)</span><br><span class="line">X-LOCK(B)</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">UNLOCK(A)</span><br><span class="line">                       BEGIN</span><br><span class="line">                       X-LOCK(A)</span><br><span class="line">                       R(A)</span><br><span class="line">                       W(A)</span><br><span class="line">R(B)                    .</span><br><span class="line">W(B)                    .</span><br><span class="line">ABORT                   .</span><br></pre></td></tr></table></figure><p>在事务T1的W(B)后发生故障，从而导致T2级联回滚，从而导致无效的操作。同时存在可能的可串行化调度，但是不被两阶段封锁协议允许。</p><p>可通过严格两阶段封锁协议或者强两阶段封锁协议解决。</p><h2 id="强两阶段封锁协议"><a href="#强两阶段封锁协议" class="headerlink" title="强两阶段封锁协议"></a>强两阶段封锁协议</h2><p>除了要求封锁是两阶段以外，还要求事务持有的所有锁必须在事务提交后方可释放。</p><ul><li>仅仅允许可冲突可串行化调度</li><li>不存在级联回滚现象</li><li>一个事务写入的值在该事务结束前不可被其余事务读入或者写入</li><li>可能存在死锁现象</li></ul><p><img src="https://i.loli.net/2020/02/06/JLQBVAg3ubpvkMz.png"></p><h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p><strong>死锁检测</strong></p><p>系统创建等待图，节点为事务，若事务Ti等待事务Tj释放锁，那么添加从Ti到Tj的边。系统定期检查等待图中是否出现环路，再决定如何破坏循环。</p><ul><li><p>当系统检测到死锁，系统将会选择一个回滚的事务来破坏环路</p></li><li><p>取决于应用处理方式，选择的事务将重启或者终止</p></li><li><p>有多种事务属性可作为选择替代的根据，不存在哪个优于其余选择</p><p>按照时间(最早或者最晚)</p><p>按照进程(最少/最多执行的查询)</p><p>按照已经锁住的条目个数</p><p>按照回滚事务的个数</p><p>按照事务过去重启的次数</p></li><li><p>在选择事务后，系统还需决定回滚的长度，要么整个事务的操作均撤销，要么撤销操作数目达到死锁解除的要求即可。</p></li></ul><p><strong>死锁预防</strong></p><p>当一个事务请求已经被其他事务持有的锁，此时执行死锁预防算法。</p><p>基于时间给定优先级，例如，时间越久意味着优先级越高。如此可确保不存在死锁，因为只有一个方向的等待。当一个事务重启，它将继承之前的优先级。</p><ul><li>wait-die:若T1优先级高于T2,T1等待T2，否则T1终止</li><li>wound-wait:若T1优先级高于T2，T2终止，否则T1等待</li></ul><p><img src="https://i.loli.net/2020/02/06/zgCqmRNaUSLfI3Y.png"></p><h2 id="多粒度"><a href="#多粒度" class="headerlink" title="多粒度"></a>多粒度</h2><p>之前提到的例子均将一个个数据项作为同步执行的单元，如果一个事务想更新一百万个元组，那么该事务将请求一百万个条目。为了避免多余的开销，系统将通过层次化锁来允许一个事务粗粒度加锁。例如，该事务将为一百个元组申请一个锁，而不是为每个元组申请一个锁。当一个事务请求层次化结构中的某个节点，该事务隐式地为其后代加锁。</p><p>若事务Ti希望封锁整个数据库，而Tj持有其中某个节点的锁，那么系统如何判定根节点是否可以加锁呢？</p><p>一种可能的方法是遍历整棵树，显然违背了多粒度锁机制的初衷。通过引入意向锁来允许高层次节点在无需检查后代节点即可加共享锁或者排他锁。如果一个节点加上了意向锁，那么意味着在树的更低层进行显式加锁，即以更小的粒度加锁。在一个节点显示加锁之前，其所有祖先节点均加上了意向锁。因此，事务不必遍历整棵树即可判定能否成功地给一个节点加锁。</p><ul><li><strong>共享型意向锁(IS)</strong> 将在树的较低层进行显式封锁，但是只能加共享锁</li><li><strong>排他型意向锁(IX)</strong> 在树的较低层进行显式封锁，可以是共享锁或排他锁</li><li><strong>共享排他型意向锁(SIX)</strong> 以该节点为根的子树显式地加上共享锁，在树的更低层显示地加上排他锁</li></ul><p>这些锁的相容矩阵为</p><p><img src="https://i.loli.net/2020/02/06/5G4bs23khoDpdOw.png"></p><p>多粒度封锁协议根据以下规则对数据项Q加锁：</p><ul><li>事务Ti必须首先封锁树的根节点，并可以加任意类型的锁</li><li>仅当Ti当前对Q的父节点具有IX或IS锁时，Ti可以对节点Q可加S锁或者IS锁、</li><li>仅当Ti当前对Q的父节点具有IX或SIX锁时，Ti可以对节点Q加X、SIX或IX锁</li></ul><p>加锁按照从上到下的顺序，而锁的释放则按照从下到上的顺序。</p><p>在低层次的锁申请过多时，为了更高粒度的并行，可以升级锁。</p><h1 id="时间戳排序协议"><a href="#时间戳排序协议" class="headerlink" title="时间戳排序协议"></a>时间戳排序协议</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;事务的基本特性是隔离性，然而当数据库中由多个事务并发执行时，事务的隔离性不一定能保持。为保持事务的隔离性，系统必须对并发事务之间的相互作用加以控制，这种控制通过并发控制机制来实现。&lt;/p&gt;</summary>
    
    
    
    <category term="Systems" scheme="http://twinkle0331.github.io/categories/Systems/"/>
    
    
    <category term="database systems" scheme="http://twinkle0331.github.io/tags/database-systems/"/>
    
  </entry>
  
  <entry>
    <title>事务</title>
    <link href="http://twinkle0331.github.io/systems/transaction/"/>
    <id>http://twinkle0331.github.io/systems/transaction/</id>
    <published>2020-02-05T08:09:36.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据库管理系统的并发控制和恢复机制存在于数据库管理系统设计中的各个部分。并发控制确保在多个线程写入/读取时数据的正确性，而恢复机制确保数据库管理系统在系统突然断电后数据仍然正常。基于事务的特性，并发控制和恢复机制是数据库管理系统的重要部分。</p><a id="more"></a><p>事务是在数据库上执行一系列的一个或多个操作（例如SQL查询）以执行一些更高级别的功能。事务是数据库管理系统变化的基本单位。只执行部分事务是不允许的。</p><p>比如，从小明的账户转100元给小红</p><ul><li>检查小明是否有100元</li><li>小明的账户减少100元</li><li>小红的账户增加100元</li></ul><h1 id="简易设计"><a href="#简易设计" class="headerlink" title="简易设计"></a>简易设计</h1><p>可按照事务到达数据库管理系统顺序依次执行，同一时刻仅可以执行一个事务。</p><p>在事务开始之前，将整个数据库复制到一个新文件，之后的更改均在新文件上执行。</p><ul><li>写入成功时用新文件覆盖原有文件</li><li>写入失败时，删除新文件</li></ul><p>以上设计存在一定的问题，可允许相互独立的事务并发执行以提高执行效率。</p><p>任意交错的操作将会导致暂时不一致，系统必然会在某一时刻处于不一致状态。但是这样不一致的状态不可一直存在。事务的作用域仅限于数据库管理系统中，在数据库管理系统以外不可回滚，所以事务不可更改数据库系统以外的文件。</p><h1 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h1><p>事务可能在从数据库中检索到的数据中执行很多操作，但是数据库管理系统仅仅关注从数据库中读入/写入的数据。</p><p>我们将数据库定义为固定的数据集合，例如A,B,C。相应地，事务定义为读/写操作的序列。例如R(A),R(B)。事务是数据库管理系统对应用程序的抽象。</p><p>在SQL中，事务以BEGIN为开始，要么以COMMIT,要么以ABORT结束。</p><ul><li><strong>COMMIT</strong> 如果提交了，数据库管理系统要么保存所有的更改，要么放弃更改</li><li><strong>ABORT</strong> 如果失败，所有操作将取消，和之前并未执行这些操作一样</li></ul><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>在事务中所有操作要么都执行，要么都不执行。</p><p>考虑以下两种情形</p><ol><li>从小明的账户中取出了100元后，数据库管理系统在转账时失败</li><li>从小明账户中转出100元后，系统关机</li></ol><p>以上事务执行后小明账户正确的数目应该是多少？</p><p>可通过以下两种方式来确保操作的原子性</p><ul><li><p><strong>日志</strong> </p><p>数据库管理系统记录所有的操作，在事务失败时取消失败事务的相关操作</p><p>在内存和磁盘中均存储取消的操作记录</p><p>目前大多数数据管理系统的方式，效率高</p></li><li><p><strong>不可见页</strong></p><p>数据库操作系统复制页，事务对这些页更改。仅当事务提交时这些页才对其余事务可见。</p></li></ul><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>数据库表示的世界在逻辑上是正确的，所有对数据的查询也应得到正确的应答。</p><p>通过以下一致性来确保正确性：</p><p><strong>数据库一致性</strong></p><p>数据库准确地模拟了真实世界，符合完整性约束。</p><p>将来的事务可查看过去在数据库中提交的事务。</p><p><strong>事务一致性</strong></p><p>如果每个事务都是一致的，并且在事务开始时数据库是一致的，则可确保事务完成时数据库是一致的。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>用户提交事务，每个事务独立执行，互不干扰。</p><p>数据库管理系统通过交错事务的操作来实现并发。</p><p>并发模型即是如何决定从多个事务中决定合适的交错顺序。</p><ul><li><strong>消极型</strong> 首要的一点是不让问题出现</li><li><strong>乐观型</strong> 假定冲突很少见，在发生时再对冲突处理</li></ul><p>考虑以下情况，假定A,B中初始时刻均有1000元</p><p>T1从A的账户中转100元到B的账户，T2给两个账户6%的利息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">BEGIN                  BEGIN</span><br><span class="line">A&#x3D;A-100                A&#x3D;A*1.06 </span><br><span class="line">B&#x3D;B+100                B&#x3D;B*1.06</span><br><span class="line">COMMIT                 COMMIT</span><br></pre></td></tr></table></figure><p>执行T1和T2的结果可能是什么呢？</p><p>可能有很多执行结果，但是A+B应该是$2000*1.06=2120$</p><p>若两个事务同时提交，无法确保T1一定在T2之前执行，反之亦然。但是最后的结果必须等同于按照一定顺序串行执行的这两个事务。</p><p>合理的结果可能为：</p><ul><li>$A=954,B=1166$</li><li>$A=960,B=1160$</li></ul><p>结果取决于A先执行还是B先执行。</p><p>调度a</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">BEGIN                </span><br><span class="line">A&#x3D;A-100                </span><br><span class="line">B&#x3D;B+100                </span><br><span class="line">COMMIT                </span><br><span class="line">                       BEGIN</span><br><span class="line">                       A&#x3D;A*1.06 </span><br><span class="line">                       B&#x3D;B*1.06</span><br><span class="line">                       COMMIT</span><br></pre></td></tr></table></figure><p>执行后，$A=954,B=1166$</p><p>调度b</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">                       BEGIN</span><br><span class="line">                       A&#x3D;A*1.06 </span><br><span class="line">                       B&#x3D;B*1.06</span><br><span class="line">                       COMMIT</span><br><span class="line">BEGIN                </span><br><span class="line">A&#x3D;A-100                </span><br><span class="line">B&#x3D;B+100                </span><br><span class="line">COMMIT                                      </span><br></pre></td></tr></table></figure><p>执行后，$A=960,B=1160$</p><p>交叉执行的调度同样正确，例如调度c</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">BEGIN                </span><br><span class="line">A&#x3D;A-100</span><br><span class="line">                       BEGIN</span><br><span class="line">                       A&#x3D;A*1.06</span><br><span class="line">B&#x3D;B+100                </span><br><span class="line">COMMIT</span><br><span class="line">                       B&#x3D;B*1.06</span><br><span class="line">                       COMMIT</span><br></pre></td></tr></table></figure><p>执行后结果为，$A=954,B=1166$</p><p>调度c和调度b最后的结果均满足$A+B=2120$，所以二者等价。</p><p>但是若T1和T2按照以下顺序执行，会得到错误的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">BEGIN                </span><br><span class="line">A&#x3D;A-100</span><br><span class="line">                       BEGIN</span><br><span class="line">                       A&#x3D;A*1.06</span><br><span class="line">                       B&#x3D;B*1.06</span><br><span class="line">                       COMMIT</span><br><span class="line">B&#x3D;B+100                </span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>$A=954,B=1060,A+B=2014$ 损失了106元。</p><p>如何判定调度是正确的呢？</p><p>如果调度等价于某个顺序的串行执行，则该调度是正确的。</p><ul><li><p>串行执行调度</p><p>不同事务的操作不交错的调度</p></li><li><p>等价执行调度</p><p>对于任何数据库状态来说，先执行前者和先执行后者的结果相同</p></li><li><p>可串行化调度</p><p>等价于某一事务串行执行的调度</p></li></ul><p>如果每个事务均可持久，每个串行调度也将是持久的。</p><p>为了有效描述冲突操作之间的等价，我们给出以下定义</p><p>假如两个操作冲突，那么它们属于不同事务，对同一对象作用，至少有一个是写操作。</p><p>交错执行异常有以下几种：</p><ul><li>读写冲突</li><li>写读冲突</li><li>写写冲突</li></ul><p><strong>读写冲突</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">     T1                    T2</span><br><span class="line">    BEGIN</span><br><span class="line">10&lt;-R(A)</span><br><span class="line">                         BEGIN</span><br><span class="line">                         R(A) -&gt;10</span><br><span class="line">                         W(A) &lt;-19</span><br><span class="line">                         COMMIT</span><br><span class="line">19&lt;-R(A)</span><br><span class="line">    COMMIT</span><br></pre></td></tr></table></figure><p>两次读结果应该是一致的，在这里却不一致。</p><p><strong>写读冲突</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">      T1                  T2</span><br><span class="line">    BEGIN</span><br><span class="line">10&lt;-R(A)</span><br><span class="line">12-&gt;W(A)</span><br><span class="line">                         BEGIN</span><br><span class="line">                         R(A)-&gt;12</span><br><span class="line">                         W(A)&lt;-14</span><br><span class="line">                         COMMIT</span><br><span class="line">    ABORT</span><br></pre></td></tr></table></figure><p>T2读取T1未提交的更改数据。</p><p><strong>写写冲突</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      T1                  T2</span><br><span class="line">    BEGIN</span><br><span class="line">10-&gt;W(A)</span><br><span class="line"></span><br><span class="line">                         BEGIN</span><br><span class="line">                         W(A)&lt;-19</span><br><span class="line">                         W(A)&lt;-Andy</span><br><span class="line">                         COMMIT</span><br><span class="line">Bieber-&gt;W(B)</span><br><span class="line">    COMMIT</span><br></pre></td></tr></table></figure><p>T1提交的数据A被T2覆盖，T2提交的数据B被T1覆盖。</p><p>给定以上例子，串行化调度用于检查调度是否正确，而不是用于产生正确的调度。</p><p>串行性有不同级别</p><ul><li><p>冲突串行化</p><p>大部分数据库管理系统支持</p></li><li><p>视图串行化</p><p>仅仅是理论</p></li></ul><p>两个调度是等价的，当且仅当：</p><ul><li>由相同事务的相同操作组成</li><li>每组冲突的操作都按照相同顺序执行</li></ul><p>如果调度S与某个串行调度冲突等价，那么调度S是可串行化冲突。</p><p>可通过交换相邻的不同事务的不冲突操作得到可串行化冲突S。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> T1                   T2</span><br><span class="line">BEGIN                BEGIN</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">                     R(A)</span><br><span class="line">                     W(A)</span><br><span class="line">R(B)</span><br><span class="line">W(B)</span><br><span class="line">COMMIT</span><br><span class="line">                     R(B)</span><br><span class="line">                     W(B)</span><br><span class="line">                     COMMIT</span><br></pre></td></tr></table></figure><p>W(A)与R(B)不冲突，可调换顺序。R(B)和R(A)也不冲突，可再次调换顺序，我们得到以下调度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> T1                   T2</span><br><span class="line">BEGIN               BEGIN</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">R(B)</span><br><span class="line">                     R(A)</span><br><span class="line">                     W(A)</span><br><span class="line">W(B)</span><br><span class="line">COMMIT</span><br><span class="line">                     R(B)</span><br><span class="line">                     W(B)</span><br><span class="line">                     COMMIT</span><br></pre></td></tr></table></figure><p>类似地，我们也可以得到以下调度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> T1                   T2</span><br><span class="line">BEGIN                BEGIN</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">R(B)</span><br><span class="line">W(B)</span><br><span class="line">COMMIT</span><br><span class="line">                     R(A)</span><br><span class="line">                     W(A)</span><br><span class="line">                     R(B)</span><br><span class="line">                     W(B)</span><br><span class="line">                     COMMIT</span><br></pre></td></tr></table></figure><p>仅有两个事务的时候可通过简单的交换来构造串行化的调度。</p><p>对于更多事务的操作，存在更好的算法吗？</p><p><strong>依赖图</strong></p><p>每个事务对应一个节点，满足</p><ul><li><p>$T_i$中的$O_i$操作与$T_j$中的$O_j$冲突</p></li><li><p>$O_i$比$O_j$出现早</p><p>那么就从$T_i$引一条到$T_j$的边。</p></li></ul><p>一个调度是可串行化冲突当且仅当依赖图是无环的。</p><p><strong>视图串行性</strong></p><p>弱化的串行性，对于调度$S_1$和调度$S_2$，满足</p><ul><li>$T_1$读入$S_1$中$A$的初始值时，$T_1$也读入$S_2$中$A$的初始值</li><li>$T_1$读取$S_1$中$T_2$写入到$A$的值时,$T_1$也读取$S_2$中$T_2$写入到$A$的值时</li><li>$T_1$写入到$S_1$中$A$的最终值时，也写入$A$的最终值到$S_2$</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">T1              T2              T3</span><br><span class="line">BEGIN</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">COMMIT</span><br><span class="line">               BEGIN</span><br><span class="line">               W(A)</span><br><span class="line">               COMMIT</span><br><span class="line">                               BEGIN</span><br><span class="line">                               W(A)</span><br><span class="line">                               COMMIT</span><br></pre></td></tr></table></figure><p>与以下调度视图等价。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">T1              T2              T3</span><br><span class="line">BEGIN</span><br><span class="line">               BEGIN</span><br><span class="line">               W(A)</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">COMMIT</span><br><span class="line">               </span><br><span class="line">               COMMIT</span><br><span class="line">                               BEGIN</span><br><span class="line">                               W(A)</span><br><span class="line">                               COMMIT</span><br></pre></td></tr></table></figure><p>视图串行化即所有的串行化冲突再附加上随意写的事务，即不限定写入的事务的顺序。</p><p>与冲突串行化不同，视图串行化不存在有效验证的方法，目前没有任何数据库支持视图串行化。</p><p>以上分析用文氏图表示如下</p><p><img src="https://i.loli.net/2020/02/06/MrI5yFLmDUfbcCJ.png"></p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>一个事务成功完成后，对数据库的更改是永久的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库管理系统的并发控制和恢复机制存在于数据库管理系统设计中的各个部分。并发控制确保在多个线程写入/读取时数据的正确性，而恢复机制确保数据库管理系统在系统突然断电后数据仍然正常。基于事务的特性，并发控制和恢复机制是数据库管理系统的重要部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Systems" scheme="http://twinkle0331.github.io/categories/Systems/"/>
    
    
    <category term="database systems" scheme="http://twinkle0331.github.io/tags/database-systems/"/>
    
  </entry>
  
  <entry>
    <title>数据库导论</title>
    <link href="http://twinkle0331.github.io/database_system/database/"/>
    <id>http://twinkle0331.github.io/database_system/database/</id>
    <published>2020-02-05T01:29:49.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>数据库管理系统在日常生活中的应用非常广泛，用于管理计算机数据。随着当今时代数据爆炸性增长，数据库系统也日益成为计算机应用的核心部分。</p><a id="more"></a><p>数据库是由一组模拟生活中某些方面的数据组织成的集合，例如，模拟学生或者歌曲库。数据库管理系统就是用于管理数据库的软件。</p><p>为什么引入数据库管理系统呢？</p><h1 id="简易设计"><a href="#简易设计" class="headerlink" title="简易设计"></a>简易设计</h1><p>假设我们用文件来管理数据库中的数据，以歌手和他们发布的专辑信息为例，我们将分别为歌手和专辑建立CSV文件。</p><p><code>歌手.csv</code>文件信息为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;Wu Tang Clan&quot;,1992,&quot;USA&quot;</span><br><span class="line">&quot;Notorious BIG&quot;,1992,&quot;USA&quot;</span><br><span class="line">&quot;Ice Cube&quot;,1989,&quot;USA&quot;</span><br></pre></td></tr></table></figure><p>每行的信息分别为歌手名、出道年份、国家。</p><p><code>专辑.csv</code>文件信息为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;Enter the Wu Tang&quot;,&quot;Wu Tang Clan&quot;,1993</span><br><span class="line">&quot;St.Ides Mix Tape&quot;,&quot;Wu Tang Clan&quot;,1994</span><br><span class="line">&quot;AmeriKKKa&#39;s Most Wanted&quot;,&quot;Ice Cube&quot;,1990</span><br></pre></td></tr></table></figure><p>每行的信息分别为专辑名、歌手名、发布年份。</p><p>查询<code>Ice Cube</code>出道年份可用如下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for line in file: </span><br><span class="line"> record &#x3D; parse(line) </span><br><span class="line"> if “Ice Cube” &#x3D;&#x3D; record[0]: </span><br><span class="line">   print int(record[1])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是这种通过文件来存储数据的方式存在不少问题</p><ul><li><p>数据完整性</p><p>如何存储多个歌手的专辑信息？</p><p>如何防止无效信息的写入？</p></li><li><p>查询/更新实现</p><p>如何查询特定的记录？</p><p>如何实现基于同一数据库的应用？</p><p>如何控制线程并发写入数据库？</p></li><li><p>持久性</p><p>如何在机器更新时确保信息正确？</p><p>如何在多个设备之间同步？</p></li></ul><p>基于以上考虑，我们引入了数据库管理系统，通过数据库管理系统来定义、创建、查询、更新数据库。</p><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>接下来我们将通过数据模型来描述数据库中的数据。数据模型是数据库结构的基础。给定数据模型后，对特定数据集合的描述称为模式。</p><p>数据模型分为以下几类</p><ul><li><p><strong>关系模型</strong>  用表的集合来表示数据和数据建的联系</p></li><li><p><strong>实体-联系模型</strong>  现实世界由一组称为实体的基本对象和这些对象之间的联系构成，实体-联系模型即用于描述这些数据。</p></li><li><p><strong>半结构数据模型</strong></p></li><li><p><strong>网状数据模型</strong></p></li><li><p><strong>层次数据模型</strong></p><p>其中网状数据模型和层次数据模型和底层实现很紧密，实现复杂，所以现在很少使用。数据库设计基本围绕关系模型展开。</p></li></ul><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系模型的核心在于</p><ol><li>以简单的数据结构来存储数据(关系)</li><li>通过高级语言来操作数据</li><li>物理层存储取决于具体实现</li></ol><p>关系模型主要由以下部分组成</p><ul><li>结构：关系的定义和结构内容，即关系对应的属性和这些属性中的值</li><li>完整性：确保数据库内容满足约束，例如，所有的年份属性都应该是数字</li><li>操作：如何访问和修改数据库的内容</li></ul><p>一个关系即是一组代表实体的属性的无序序列。正因为关系无序，所以数据库管理系统可以任何方式存储关系。一个有$n$个属性的关系被称为$n$列关系。</p><p>一个元组是关系中一组属性的值，也就是关系中某一行。元组中的值通常是原子的，即不可再拆分。特殊的空值NULL是每个域的成员。</p><p>一个关系的主键区别了不同的元组。某些数据库管理系统在用户未定义主键时自行创建主键。</p><h1 id="数据库操纵语言"><a href="#数据库操纵语言" class="headerlink" title="数据库操纵语言"></a>数据库操纵语言</h1><p>数据库系统提供数据定义语言来定义数据库模式，以及数据库操纵语言来表达数据库的管理和更新。实际上，数据定义和数据操作语言并不是分离的，而是简单地构成了单一的数据库语言的不同部分。</p><p>数据库操作语言分为两类</p><ul><li><strong>过程化数据库操纵语言</strong> 指明用户需要什么数据，以及怎么获取这些数据</li><li><strong>声明化数据库操纵语言</strong> 只要求用户指定需要什么数据，而不指明如何获取这些数据</li></ul><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>关系代数是一个运算的集合，以一个或两个关系为输入，以一个新的关系为结果。可通过嵌套来实现更复杂的操作。</p><p>关系基本运算有：选择、投影、并、集合交、集合并、集合差、笛卡尔积和重命名。</p><p><strong>选择运算</strong></p><p>选择运算选出满足给定谓词的元组。</p><ul><li>谓词过滤不符合条件的元组，仅留下满足谓词条件的元组</li><li>可通过连词将多个谓词连接</li></ul><p><strong>投影运算</strong></p><p>投影运算以某个关系为输入，输出仅含特定属性的元组的关系。</p><ul><li>可重新排列属性顺序</li><li>可对属性的值操作</li></ul><p><strong>集合交</strong></p><p>集合交以两个关系为输入，输出仅含在两个关系中均出现的元组的关系。</p><p><strong>集合并</strong></p><p>集合并以两个关系为输入，输出在两个关系中至少出现一次的元组的关系。</p><p><strong>集合差</strong></p><p>集合并以两个关系为输入，输出在第一个关系中出现而第二个关系中不出现的元组的关系。</p><p><strong>连接运算</strong></p><p>以两个关系为输入，生成一个关系，该关系中的元组是两个元组（每个输入关系中各选一个）的组合，并且具有一个或多个属性的公共值。</p><p><strong>笛卡尔积</strong></p><p>以两个关系为输入，输出所有可能的组合。</p><p>关系代数为过程化语言，因为关系代数定义了计算查询的步骤。</p><p>例如，若想查询R和S连接后满足b_id等于102的元组，</p><p>关系代数可以是先连接R，S，再选择其中b_id等于102的元组，或者先选择S中b_id等于102的元组，再与R连接。</p><p>更好的方式是声明想让数据库管理系统返回的元组，类似查询R和S连接后满足b_id等于102的元组。</p><p>关系代数定义了数据库查询的原语。</p><p>关系模型仅描述了高层次的操作，与具体实现语言无关。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;数据库管理系统在日常生活中的应用非常广泛，用于管理计算机数据。随着当今时代数据爆炸性增长，数据库系统也日益成为计算机应用的核心部分。&lt;/p&gt;</summary>
    
    
    
    <category term="Systems" scheme="http://twinkle0331.github.io/categories/Systems/"/>
    
    
    <category term="database systems" scheme="http://twinkle0331.github.io/tags/database-systems/"/>
    
  </entry>
  
  <entry>
    <title>向量</title>
    <link href="http://twinkle0331.github.io/algorithm/vector/"/>
    <id>http://twinkle0331.github.io/algorithm/vector/</id>
    <published>2019-11-06T03:11:37.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在导论中，我们了解到数据结构是若干数据项的结构化集合，其结构性表现为数据项之间的某种逻辑次序。根据这种逻辑次序的复杂程度可大致将数据结构分为线性、半线性、非线性结构三大类。在线性结构中，各数据项按照一个线性次序组织为一个整体。在向量中，所有数据项的物理存放位置与其逻辑次序完全吻合。</p><a id="more"></a><p>在C/C++语言中，数组支持对一组相关元素的存储组织和访问操作。若集合S由$n$个元素组成，则可将它们存放于起始于地址A、物理地址连续的一段存储空间，并统称为数组。数组A[]中每一元素都唯一对应于某一下标编号。反之，每个元素均由非负编号唯一指代，并可直接访问。</p><p>向量是数组的抽象与泛化，由一组元素按线性次序封装而成，各元素与[0,n)内的秩一一对应。</p><h1 id="静态空间管理"><a href="#静态空间管理" class="headerlink" title="静态空间管理"></a>静态空间管理</h1><p>内部数组所占物理空间的容量，若在向量的生命周期内不允许调整，则称为静态空间管理策略。</p><p><strong>上溢</strong>  数组不足以存放所有元素，尽管系统此时仍有足够的空间</p><p><strong>下溢</strong> 元素寥寥无几，即装填因子(向量实际规模和内部数组容量的比值)远远小于50%.</p><h1 id="动态空间管理"><a href="#动态空间管理" class="headerlink" title="动态空间管理"></a>动态空间管理</h1><p>一般的应用环境难以准确预测空间的需求量，使向量可随实际需求动态调整容量，在即将发生上溢时适当扩大向量的容量。</p><h2 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h2><p><strong>倍增策略</strong>  每次新数组的容量总是取作原数组的两倍</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::expand() &#123; <span class="comment">//向量空间不足时扩容</span></span><br><span class="line">   <span class="keyword">if</span> ( _size &lt; _capacity ) <span class="keyword">return</span>; <span class="comment">//尚未满员时，不必扩容</span></span><br><span class="line">   <span class="keyword">if</span> ( _capacity &lt; DEFAULT_CAPACITY ) _capacity = DEFAULT_CAPACITY; <span class="comment">//不低于最小容量</span></span><br><span class="line">   T* oldElem = _elem;  _elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>]; <span class="comment">//容量加倍</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++ )</span><br><span class="line">      _elem[i] = oldElem[i]; <span class="comment">//复制原向量内容（T为基本类型，或已重载赋值操作符&#x27;=&#x27;）</span></span><br><span class="line">   <span class="keyword">delete</span> [] oldElem; <span class="comment">//释放原空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最坏情况：在初始容量为0的空向量中，连续插入$n=mI&gt;&gt;2$个元素</p><p>于是在第$1，2,4,8…$次插入时都需扩容，</p><p>即便不计申请空间操作，各次扩容过程中复制原向量的时间成本依次为</p><p>$1,2,4,8,…,2^m=n$</p><p>总体耗时$O(n)$,每次扩容的分摊成本为O(1)</p><p><strong>递增策略</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T* oldElem = _elem;  _elem = <span class="keyword">new</span> T[_capacity+increment]; </span><br></pre></td></tr></table></figure><p>最坏情况：在初始容量为0的空向量中，连续插入$n=mI&gt;&gt;2$个元素</p><p>于是在第$1，I+1,2I+1,3I+1…$次插入时都需扩容，</p><p>即便不计申请空间操作，各次扩容过程中复制原向量的时间成本依次为</p><p>$0,I,2I,3I,..(m-1)I$</p><p>每次扩容的分摊成本为$O(n)$</p><h2 id="分摊分析"><a href="#分摊分析" class="headerlink" title="分摊分析"></a>分摊分析</h2><blockquote><p>平均分析和分摊分析</p></blockquote><p><strong>平均复杂度</strong> </p><p>在假定各种输入实例的出现符合某种概率分布后，对对应成本加权平均。</p><p>各种可能的操作，作为独立事件分别考查，割裂了操作之间的相关性和连贯性</p><p>往往不能准确地评价数据结构和算法的平均性能</p><p><strong>分摊复杂度</strong></p><p>对数据结构连续地实施足够多次操作，所需总体成本分摊至单次操作</p><p>从实际可行的角度，对一系列操作做整体的考量</p><p>更加忠实得刻画了可能出现的操作序列</p><p>更为精准地评判数据结构和算法地真实性能</p><p>条件不规整时，可添加约束，比如$n=2^k$</p><h1 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h1><h2 id="置乱算法"><a href="#置乱算法" class="headerlink" title="置乱算法"></a>置乱算法</h2><p>在软件模拟、仿真测试等应用中，随机向量的生成都是一项至关重要的操作。理论上说，调用permute可以枚举出同一向量所有可能的排列，而且能够保证生成各种序列的概率相等。但是基于种子的伪随机数发生器无法保证所生成随机数之间的独立性，所以无法等可能地生成所有排列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">permute</span> <span class="params">( Vector&lt;T&gt;&amp; V )</span> </span>&#123; <span class="comment">//随机置乱向量，使各元素等概率出现于各位置</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = V.size(); i &gt; <span class="number">0</span>; i-- ) <span class="comment">//自后向前</span></span><br><span class="line">      swap ( V[i - <span class="number">1</span>], V[rand() % i] ); <span class="comment">//V[i - 1]与V[0, i)中某一随机元素交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//无序向量的顺序查找：返回最后一个元素e的位置；失败时，返回lo - 1</span></span><br><span class="line">Rank Vector&lt;T&gt;::find ( T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi ) <span class="keyword">const</span> &#123; <span class="comment">//assert: 0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">   <span class="keyword">while</span> ( ( lo &lt; hi-- ) &amp;&amp; ( e != _elem[hi] ) ); <span class="comment">//从后向前，顺序查找</span></span><br><span class="line">   <span class="keyword">return</span> hi; <span class="comment">//若hi &lt; lo，则意味着失败；否则hi即命中元素的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定在命中多个元素时可返回秩最大者</p><p>输入敏感算法，,最好$O(1)$,最差$O(n)$</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//将e作为秩为r元素插入</span></span><br><span class="line">Rank Vector&lt;T&gt;::insert ( Rank r, T <span class="keyword">const</span>&amp; e ) &#123; <span class="comment">//assert: 0 &lt;= r &lt;= size</span></span><br><span class="line">   expand(); <span class="comment">//若有必要，扩容</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = _size; i &gt; r; i-- ) _elem[i] = _elem[i<span class="number">-1</span>]; <span class="comment">//自后向前，后继元素顺次后移一个单元</span></span><br><span class="line">   _elem[r] = e; _size++; <span class="comment">//置入新元素并更新容量</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//返回秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免元素被覆盖，自后向前对元素操作。时间复杂度主要取决于后继元素的后移，故总体为$O(size-r+1)$，r取最大值size时只需$O(1)$时间，r取最小值时需要$O(size)$时间，平均时间正比于向量规模。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><strong>区间删除</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::remove ( Rank lo, Rank hi ) &#123; <span class="comment">//删除区间[lo, hi)</span></span><br><span class="line">   <span class="keyword">if</span> ( lo == hi ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//出于效率考虑，单独处理退化情况，比如remove(0, 0)</span></span><br><span class="line">   <span class="keyword">while</span> ( hi &lt; _size ) _elem[lo++] = _elem[hi++]; <span class="comment">//[hi, _size)顺次前移hi - lo个单元</span></span><br><span class="line">   _size = lo; <span class="comment">//更新规模，直接丢弃尾部[lo, _size = hi)区间</span></span><br><span class="line">   shrink(); <span class="comment">//若有必要，则缩容</span></span><br><span class="line">   <span class="keyword">return</span> hi - lo; <span class="comment">//返回被删除元素的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单元素删除可视为区间删除操作的特例</p><p>此处自前向后的顺序不可颠倒，否则在后继元素多于待删除元素后部分单元会相互覆盖。每次操作正比于删除区间的后缀长度$=n-hi=O(n)$，与被删除区间本身的长度无关，循环次数等于区间宽度$=hi-lo=O(n)$,总体复杂度为$O(n^2)$</p><p><strong>单元素删除</strong></p><p>时间复杂度$O(n-r)$，被删除元素在向量中的位置越靠后所需的时间越短，最好为$O(1)$,最坏为$O(n)$</p><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>应用实例：以网络搜索引擎为例，多个计算节点各自获得的局部搜索结果需首先剔除其中重复的部分，方可汇总成一份完整的报告。</p><p><strong>错误版</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123; <span class="comment">//删除无序向量中重复元素（错误版）</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank i = <span class="number">1</span>; i &lt; _size; i++ ) &#123; <span class="comment">//逐一考查_elem[i]</span></span><br><span class="line">      Rank j = find ( _elem[i], <span class="number">0</span>, i ); <span class="comment">//在_elem[i]的前驱中寻找与之雷同者（至多一个）</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &lt;= j ) remove ( j ); <span class="comment">//若存在，则删除之（但在此种情况，下一迭代不必做i++）</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前驱存在相同元素时，删除该元素时该元素所有后继均会向前移动一个单位，所以此时$i$不必后移，后移将会跳过元素，此算法错误。</p><p><strong>繁琐版</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123; <span class="comment">//删除无序向量中重复元素（繁琐版）</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">-1</span>; <span class="comment">//从最前端开始</span></span><br><span class="line">   <span class="keyword">while</span> ( ++i &lt; _size - <span class="number">1</span> ) &#123; <span class="comment">//从前向后，逐一</span></span><br><span class="line">      <span class="keyword">int</span> j = i + <span class="number">1</span>; <span class="comment">//assert: _elem[0, i]中不含重复元素</span></span><br><span class="line">      <span class="keyword">while</span> ( j &lt; _size )</span><br><span class="line">         <span class="keyword">if</span> ( _elem[i] == _elem[j] ) remove ( j ); <span class="comment">//若雷同，则删除后者</span></span><br><span class="line">         <span class="keyword">else</span> j++; <span class="comment">//并继续扫描</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br></pre></td></tr></table></figure><p>此算法在处理时不同于前一方法，在雷同元素中删除后者，避免了跳过元素的问题，元素的移动操作与之前的算法相比也有所减少,同时查找操作会有所增加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123; </span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;size)</span><br><span class="line">   find(_elem[i],<span class="number">0</span>,i)&lt;<span class="number">0</span> ? i++ :remove(i);</span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>算法分析</p></blockquote><p><strong>正确性</strong> 凡被剔除者均为重复元素(不多)，故只需证明，算法不致遗漏重复元素(不少)。</p><p><strong>不变性</strong> 在当前元素V[i]的前缀V[0,i)中，各元素彼此互异 </p><p><strong>单调性</strong> 随着反复的while迭代，</p><ol><li>当前元素的前缀长度单调非降，且迟早增至size</li><li>当前元素后缀的长度单调下降，且迟早降至0</li></ol><p>故算法必然终止，且至多迭代$O(n)$轮</p><p><strong>复杂度</strong> 每轮迭代中<code>find()</code>和<code>remove()</code>累计耗费线性时间，总体$O(n^2)$</p><p>即便在最好情况下，仍然需要运行$\Omega(n^2)$时间，每次迭代都需要做一次查找操作和一次可能的删除操作，对于_elem[k],若需要做删除操作，为此需花费$O(n-k)$，反之，若不需要做删除操作，则此前的查找操作以失败告终，其间已花费了$O(k)$时间，无论如何，每次迭代需要$\Omega(min(n-k,k))$时间，累计为$\Omega (n^2)$</p><ul><li>仿照<code>uniquify</code>高效版思路，元素移动的次数可降低至$O(n)$，但是比较次数仍然是$O(n^2)$。在发现重复元素后不必立即剔除，借助位图结构先对需删除的重复元素标记，然后再统一删除，稳定性保持，但是查找长度更长，从而导致更多比对操作。时间消耗主要来源于静态的比较操作，所以实际运行时间仍将大幅提高。</li></ul><p><strong>改进方法</strong></p><p>可先对无序向量进行排序，后再调用有序向量的唯一化方法，总时间为$O(nlogn)+O(n)=O(nlogn)$</p><h1 id="有序向量"><a href="#有序向量" class="headerlink" title="有序向量"></a>有序向量</h1><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序/无序序列中，任意/总有一对相邻元素顺序/逆序。</p><p>因此，相邻逆序对的数目，在一定程度上可用来度量向量的逆序程度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="keyword">int</span> Vector&lt;T&gt;::disordered() <span class="keyword">const</span> &#123; <span class="comment">//返回向量中逆序相邻元素对的总数</span></span><br><span class="line">   <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">//计数器</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; _size; i++ ) <span class="comment">//逐一检查_size - 1对相邻元素</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[i - <span class="number">1</span>] &gt; _elem[i] ) n++; <span class="comment">//逆序则计数</span></span><br><span class="line">   <span class="keyword">return</span> n; <span class="comment">//向量有序当且仅当n = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h2><p><strong>低效算法</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123; </span><br><span class="line">   <span class="keyword">int</span> oldsize=_size,<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;_size)</span><br><span class="line">     _elem[i<span class="number">-1</span>]==elem[i]?remove[i]:i++;</span><br><span class="line">   <span class="keyword">return</span> oldsize-_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行时间主要取决于<code>while</code>循环次数，共计数$n-1$次</p><p>最坏情况下，每次都需要调用<code>remove()</code>,各自耗时$O(n-1)$~$O(1)$，累计$O(n^2)$</p><p>低效的根源在于同一元素可作为被删除元素的后继多次被前移。</p><p><strong>高效算法</strong><br>有序向量每一组重复元素必然相互紧邻构成一个重复区间，所谓去重就是为每一重复区间保留单个元素，以重复区间为单位，成批删除雷同元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123; <span class="comment">//有序向量重复元素剔除算法（高效版）</span></span><br><span class="line">   Rank i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">//各对互异“相邻”元素的秩</span></span><br><span class="line">   <span class="keyword">while</span> ( ++j &lt; _size ) <span class="comment">//逐一扫描，直至末元素</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[i] != _elem[j] ) <span class="comment">//跳过雷同者</span></span><br><span class="line">         _elem[++i] = _elem[j]; <span class="comment">//发现不同元素时，向前移至紧邻于前者右侧</span></span><br><span class="line">   _size = ++i; shrink(); <span class="comment">//直接截除尾部多余元素</span></span><br><span class="line">   <span class="keyword">return</span> j - i; <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共计$n-1$次迭代，累计$O(n)$时间。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>版本a</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//每步迭代可能要做两次比较判断，有三个分支</span></span><br><span class="line">      Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">//以中点为轴点</span></span><br><span class="line">      <span class="keyword">if</span>      ( e &lt; A[mi] ) hi = mi; <span class="comment">//深入前半段[lo, mi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( A[mi] &lt; e ) lo = mi + <span class="number">1</span>; <span class="comment">//深入后半段(mi, hi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span>                <span class="keyword">return</span> mi; <span class="comment">//在mi处命中</span></span><br><span class="line">   &#125; <span class="comment">//成功查找可以提前终止</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，不能保证返回秩最大者；查找失败时，简单地返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure><p>尽管二分查找将之前的向量分为了两部分，却不是二分递归，而是线性递归。每一实例有两个可能的递归方向，却只能从中选择其一，故每个层次上的递归实例构成一个线性次序关系。</p><blockquote><p>递推方程分析</p></blockquote><p>$T(n)=T(n/2)+O(1)=O(logn)$,大大优于顺序查找</p><blockquote><p>递归跟踪分析</p></blockquote><p>轴点总取作中点，递归深度$O(logn)$,各递归实例均耗时$O(1)$</p><p><strong>查找长度</strong>  </p><p>为了更为精细地评估查找算法地性能，考查关键码的比较次数。</p><p>分别针对成功查找和失败查找，从最好、最坏、平均情况等角度评估。</p><p>对于长度为$n$的有序向量，共有$n$种可能的成功查找，分别对应于某一元素。实际上，每一种成功的查找长度仅仅取决于$n$和目标元素所对应的秩，而与元素的具体数值无关。</p><blockquote><p>将平均的成功查找长度和失败查找长度分别记作S和S’,则(S+1)n=F(n+1)</p></blockquote><p>成功查找长度和失败查找长度均为$O(1.5logn)$</p><p>在每一步迭代过程中为了确定左右分支方向，需要做一次或两次比较，从而造成不同情况对应查找长度的不均衡。</p><p>转向左右分支的关键码比较次数不等，而递归深度却相同。</p><p>为了改善均衡性，有两种解决思路：</p><ul><li>通过递归深度的不均衡，对转向成本进行补偿，缩短平均查找长度</li><li>统一沿两个方向深入需要执行的比较次数</li></ul><p><strong>版本b</strong></p><p>每次迭代时仅做1次关键码比较，如此，所有的分支只有2个方向而不是3个方向</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> &lt; hi - lo ) &#123; <span class="comment">//每步迭代仅需做一次比较判断，有两个分支；成功查找不能提前终止</span></span><br><span class="line">      Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">//以中点为轴点</span></span><br><span class="line">      ( e &lt; A[mi] ) ? hi = mi : lo = mi; <span class="comment">//经比较后确定深入[lo, mi)或[mi, hi)</span></span><br><span class="line">   &#125; <span class="comment">//有效区间的宽度缩减至1时算法才会终止</span></span><br><span class="line">   <span class="keyword">return</span> ( e == A[lo] ) ? lo : <span class="number">-1</span> ; <span class="comment">//查找成功时返回对应的秩；否则统一返回-1</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，不能保证返回秩最大者；查找失败时，简单地返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure><p>只有当元素数目$hi-lo=1$时才判断元素是否命中。</p><p>knuth指出将三分支改为两分支的改进效果需要到n非常大(2^66)后方能体现，针对当前规模来说，这一优化得不偿失。</p><p><strong>版本c</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//每步迭代仅需做一次比较判断，有两个分支</span></span><br><span class="line">      Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">//以中点为轴点</span></span><br><span class="line">      ( e &lt; A[mi] ) ? hi = mi : lo = mi + <span class="number">1</span>; <span class="comment">//经比较后确定深入[lo, mi)或(mi, hi)</span></span><br><span class="line">   &#125; <span class="comment">//成功查找不能提前终止</span></span><br><span class="line">   <span class="keyword">return</span> --lo; <span class="comment">//循环结束时，lo为大于e的元素的最小秩，故lo - 1即不大于e的元素的最大秩</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置</span></span><br></pre></td></tr></table></figure><p>待查找区间宽度缩减为0时算法结束，返回不大于e的最后一个元素，此前的版本均未实现此约定。</p><p><strong>不变性</strong> </p><p>在算法执行的任意过程中，<code>A[lo-1]/A[hi]</code>​总是当前不大于e的最大者/大于e的最小者</p><p>当算法终止时，<code>A[lo-1]/A[hi]​</code>即是全局的大于e的最大者/大于e的最小者</p><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>二分查找版本A转向左右分之前的关键码比较次数不相等，而递归长度却相同，通过递归深度的不平衡对转向成本的不平衡进行补偿，平均查找长度可进一步缩短。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">fibSearch</span> <span class="params">( T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">   <span class="function">Fib <span class="title">fib</span> <span class="params">( hi - lo )</span></span>; <span class="comment">//用O(log_phi(n = hi - lo)时间创建Fib数列</span></span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//每步迭代仅仅做一次比较判断，有两个分支</span></span><br><span class="line">      <span class="keyword">while</span> ( hi - lo &lt; fib.get() ) fib.prev(); <span class="comment">//通过向前顺序查找（分摊O(1)）——至多迭代几次？</span></span><br><span class="line">      Rank mi = lo + fib.get() - <span class="number">1</span>; <span class="comment">//确定形如Fib(k) - 1的轴点</span></span><br><span class="line">      ( e &lt; A[mi] ) ? hi = mi : lo = mi + <span class="number">1</span>; <span class="comment">//比较后确定深入前半段[lo, mi)或后半段(mi, hi)</span></span><br><span class="line">   &#125; <span class="comment">//成功查找不能提前终止</span></span><br><span class="line">   <span class="keyword">return</span> --lo; <span class="comment">//循环结束时，lo为大于e的元素的最小秩，故lo - 1即不大于e的元素的最大秩</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，总能保证返回最秩最大者；查找失败时，能够返回失败的位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>成功平均查找长度为$O(log_{\phi}n)=O(log_{\phi}nlog_{2} \phi)=O(1.44log_2{n})$\</p><p>失败平均查找长度不超过$\lambda log_2{n+1}=O(\lambda log_2{n})$</p><p>其中$\lambda=1+1/\phi^2=3-\phi=1.382$</p><h2 id="通用策略"><a href="#通用策略" class="headerlink" title="通用策略"></a>通用策略</h2><p><img src="https://i.loli.net/2019/11/05/GlLOQrfTt17D3x9.png"></p><p><img src="https://i.loli.net/2019/11/05/B23VfkubCRrhXdj.png"></p><h2 id="索引查找"><a href="#索引查找" class="headerlink" title="索引查找"></a>索引查找</h2><p>$m$级索引，每一级索引内部采用顺序查找，可将查找的时间复杂度降低至$n^{1/m}$</p><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>假设：已知有序向量中各元素随机分布的规律，比如：均匀且独立的随机分布，</p><p>于是[lo,hi)内各元素应大致按照线性趋势增长</p><p>$\displaystyle \frac{mi-hi}{hi-lo}  \approx \frac{e-A[lo]}{A[hi]-A[lo]}$</p><p>因此，通过猜测轴点mi,可以极大地提高收敛速度</p><p>$\displaystyle mi  \approx lo+(hi-lo)\frac{e-A[lo]}{A[hi]-A[lo]} $</p><p>以英文字典为例，<code>binary</code>大致位于$2/26$处</p><p><code>search</code>大致位于$19/26$处</p><p><img src="https://i.loli.net/2019/11/06/NIBimO1kYDL5jsS.png"></p><p><strong>性能分析</strong></p><p>最坏:$O(hi-lo)=O(n)$</p><p>平均:每经过一次比较，待查找区间宽度由$n$缩至$\sqrt{n}$</p><p>$n,\sqrt{n},\sqrt{\sqrt{n}},…,2$</p><p>$n,n^{1/2},n^{1/2^2},n^{1/2^{k}},…,2$</p><p>经过$k$次比较后，$n^{1/2^k}&lt;2$,$k=O(loglogn)$</p><p>每经过一次比较，待查找区间宽度地数值开放，有效字长减半</p><p>插值查找为在字长意义上地折半查找</p><p>二分查找为在字长意义上的顺序查找</p><blockquote><p>从$O(logn)$到$O(loglogn)$,是否值得？</p></blockquote><p>通常优势不明显，除非查找区间宽度极大，或者比较操作成本极高</p><p>比如,$n=2^(2^5)=2^{32}=4G$时，$log2{n}=32,log_2(log_2(n))=5$</p><p>易受小扰动的干扰和蒙骗</p><p>须引入乘法和除法运算</p><p>可先通过插值查找将查找范围缩小至一定的尺度，然后再进行二分查找</p><blockquote><p>每经过一次插值和查找，待搜索区间的宽度大致以平方根的速度递减</p></blockquote><p>最坏情况下仍然为$O(n)$，即极端不平衡的情况，{1,2,2000,2001,999999,9999999}</p><p>假设数据在某个范围内均匀分布，插值查找每经过一次比较，待搜索区间以平方根速度递减。时间复杂度为$O(loglogN)$。需要注意，$O(loglogN)$的复杂度是平均期望复杂度，而不是最坏情况复杂度。</p><h1 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort ( Rank lo, Rank hi ) <span class="comment">//assert: 0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">&#123; <span class="keyword">while</span> ( !bubble ( lo, hi-- ) ); &#125; <span class="comment">//逐趟做扫描交换，直至全序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Vector&lt;T&gt;::bubble ( Rank lo, Rank hi ) &#123; <span class="comment">//一趟扫描交换</span></span><br><span class="line">   <span class="keyword">bool</span> sorted = <span class="literal">true</span>; <span class="comment">//整体有序标志</span></span><br><span class="line">   <span class="keyword">while</span> ( ++lo &lt; hi ) <span class="comment">//自左向右，逐一检查各对相邻元素</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[lo - <span class="number">1</span>] &gt; _elem[lo] ) &#123; <span class="comment">//若逆序，则</span></span><br><span class="line">         sorted = <span class="literal">false</span>; <span class="comment">//意味着尚未整体有序，并需要</span></span><br><span class="line">         swap ( _elem[lo - <span class="number">1</span>], _elem[lo] ); <span class="comment">//通过交换使局部有序</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> sorted; <span class="comment">//返回有序标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对$n$个元素做起泡排序的过程中，可能会发生：</p><ul><li>所有元素均无需移动</li><li>某元素会一度(朝着远离其最终位置的方向)逆向移动</li><li>某元素的初始位置与其最终位置相邻，却需要参与$n-1$次交换</li><li>所有元素均参加$n-1$次交换</li></ul><p>稳定算法的特征是，重复元素之间的相对次序在排序前后保持一致。反之，不具有这一特征的排序算法都是不稳定算法。以上排序算法是稳定的，在起泡排序算法中，元素相对位置调整的唯一可能是某元素<code>_elem[i-1]</code>严格大于其后继<code>_elem[i]</code>。也就是说，在这种亦步亦趋的交换算法中，重复元素可能靠拢，但绝对不会相互跨越。由此可知，起泡排序算法为稳定算法。</p><p>乱序在$A[0,\sqrt{n}]$时，仍然需要调用<code>bubble()</code>,共做$\Omega(n)$次交换操作和$\Omega(n^{3/2})$次比较操作，外循环$\sqrt{n}$次，内循环$n$次</p><p><strong>优化</strong> 返回最右侧逆序对的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort ( Rank lo, Rank hi ) <span class="comment">//assert: 0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">&#123; <span class="keyword">while</span> ( lo &lt; ( hi = bubble ( lo, hi ) ) ); &#125; <span class="comment">//逐趟做扫描交换，直至全序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank Vector&lt;T&gt;::bubble ( Rank lo, Rank hi ) &#123; <span class="comment">//一趟扫描交换</span></span><br><span class="line">   Rank last = lo; <span class="comment">//最右侧的逆序对初始化为[lo - 1, lo]</span></span><br><span class="line">   <span class="keyword">while</span> ( ++lo &lt; hi ) <span class="comment">//自左向右，逐一检查各对相邻元素</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[lo - <span class="number">1</span>] &gt; _elem[lo] ) &#123; <span class="comment">//若逆序，则</span></span><br><span class="line">         last = lo; <span class="comment">//更新最右侧逆序对位置记录，并</span></span><br><span class="line">         swap ( _elem[lo - <span class="number">1</span>], _elem[lo] ); <span class="comment">//通过交换使局部有序</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> last; <span class="comment">//返回最右侧的逆序对位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样以乱序只存在$A[0,\sqrt{n}]$时，仅需一趟扫描交换$O( n )$即可确定逆序数存在的空间，累计耗时：</p><p>$O(n+(\sqrt n)^2)$=$O(n)$</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量归并排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   <span class="keyword">if</span> ( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//单元素区间自然有序，否则...</span></span><br><span class="line">   <span class="keyword">int</span> mi = ( lo + hi ) / <span class="number">2</span>; <span class="comment">//以中点为界</span></span><br><span class="line">   mergeSort ( lo, mi ); mergeSort ( mi, hi ); <span class="comment">//分别排序</span></span><br><span class="line">   merge ( lo, mi, hi ); <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//有序向量的归并</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::merge ( Rank lo, Rank mi, Rank hi ) &#123; <span class="comment">//各自有序的子向量[lo, mi)和[mi, hi)</span></span><br><span class="line">   T* A = _elem + lo; <span class="comment">//合并后的向量A[0, hi - lo) = _elem[lo, hi)</span></span><br><span class="line">   <span class="keyword">int</span> lb = mi - lo; T* B = <span class="keyword">new</span> T[lb]; <span class="comment">//前子向量B[0, lb) = _elem[lo, mi)</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank i = <span class="number">0</span>; i &lt; lb; B[i] = A[i++] ); <span class="comment">//复制前子向量</span></span><br><span class="line">   <span class="keyword">int</span> lc = hi - mi; T* C = _elem + mi; <span class="comment">//后子向量C[0, lc) = _elem[mi, hi)</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; ( j &lt; lb ) || ( k &lt; lc ); ) &#123; <span class="comment">//B[j]和C[k]中的小者续至A末尾</span></span><br><span class="line">      <span class="keyword">if</span> ( ( j &lt; lb ) &amp;&amp; ( ! ( k &lt; lc ) || ( B[j] &lt;= C[k] ) ) ) A[i++] = B[j++];</span><br><span class="line">      <span class="keyword">if</span> ( ( k &lt; lc ) &amp;&amp; ( ! ( j &lt; lb ) || ( C[k] &lt;  B[j] ) ) ) A[i++] = C[k++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">delete</span> [] B; <span class="comment">//释放临时空间B</span></span><br><span class="line">&#125; <span class="comment">//归并后得到完整的有序向量[lo, hi)</span></span><br></pre></td></tr></table></figure><p><strong>综合评价</strong></p><p>优点</p><ul><li>实现最坏情况下最优$O(nlogn)$性能的第一个排序算法</li><li>不许随机读写，完全顺序访问，尤其适用于列表之类的序列和磁盘之类的设备</li><li>只要实现得当，可保证稳定，在出现雷同元素时，左侧子向量优先</li><li>可扩展性极佳，十分适宜于外部排序(海量网页搜索结果的合并)</li><li>易于并行化</li></ul><p>缺点</p><ul><li>非就地，需要对等规模的辅助空间</li><li>即便输入完全(接近)有序，仍需$O(nlogn)$时间</li></ul><p><strong>优化</strong></p><p>在最好情况下仍然需要$O(nlogn)$时间，在业已有序的情况下不必再合并，每个递归实例为常数时间，复杂度优化至$O(n)$。以mi为界划分为两个子序列A[lo,mi),A[mi,hi)，若后一个子序列的最小值大于等于前一个子序列的最大值，则已有序，无需再合并。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量归并排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   <span class="keyword">if</span> ( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//单元素区间自然有序，否则...</span></span><br><span class="line">   <span class="keyword">int</span> mi = ( lo + hi ) / <span class="number">2</span>; <span class="comment">//以中点为界</span></span><br><span class="line">   mergeSort ( lo, mi ); mergeSort ( mi, hi ); <span class="comment">//分别排序</span></span><br><span class="line">   <span class="keyword">if</span>(_elem[mi<span class="number">-1</span>]&gt;_elem[mi])merge ( lo, mi, hi ); <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="排序与下界"><a href="#排序与下界" class="headerlink" title="排序与下界"></a>排序与下界</h1><p>从数据处理的角度来看，有序性在很多场合都可以极大地提高计算效率。在解决许多应用问题时普遍采用的一种策略就是首先将向量转换为有序向量，再调用有序向量支持的各种高效算法，这一过程就是向量的排序。</p><p>以下给出排序的准确定义：</p><p>任意给定N个元素${R1,R2,…,Rn}$,对应关键码${K1,…,Kn}$,需按某种次序排列。亦即是找出$&lt;1,2,3,..,n&gt;$的一个排列，使得$K_{i1}\leq K_{i2}\leq K_{i3}\leq…\leq K_{in}$</p><p>例如，$3,1,4,1,5,9,2,6$ 经排序后的序列为$1,1,2,3,4,5,6,9$</p><p>在实际应用中，25%到50%的计算都可以归于排序。</p><p>排序算法是个庞大的家族，其中根据处理数据的规模和存储的特点不同，分为内部排序算法和外部排序算法，内部排序是数据记录在内存中进行排序，而外部排序因为排序的数据很大，一次不能容纳全部的排序记录，在排序的过程中需要访问外存。</p><p>根据输入方式的不同，可分为在线算法和离线算法。前一情况下，待排序算法通常以批处理的形式整理给出，在网络计算等环境中，待排序的算法通常需要实时生成，在排序算法启动后数据才陆续到达。</p><p>再如，针对所依赖的体系结构的不同，排序算法又可分为串行和并行两类排序算法。另外，根据算法是否采用随机策略，还有确定式和随机式之分。</p><h2 id="下界"><a href="#下界" class="headerlink" title="下界"></a>下界</h2><p>在着手优化算法时，我们首先需要解决以下几个问题</p><ul><li>起泡排序的复杂度为$O(n^2)$,归并排序算法的复杂度为$O(nlogn)$,这一效率是否已经足够高？</li><li>能否以更快的速度完成排序</li></ul><p>考虑以下问题：三只苹果外观一致，其中两只重量相同另一只不同，利用一架天平如何从中找出重量不同的那只？</p><p>以上问题所需的最少比较次数为多少次？</p><p>尽管很多算法都可以优化，但是对任一特定应用问题随着算法的不断改进，其效率的提高必然存在某一极限。这一极限不仅必然存在，其具体的数值应取决于应用问题本身以及所采用的计算模型。</p><p>一般地，任一问题在最快情况下的最低计算成本，即为该问题的复杂度下界，一旦某一算法的性能达到这一下界，即意味着它已经是最坏情况下最优的。</p><h2 id="比较树"><a href="#比较树" class="headerlink" title="比较树"></a>比较树</h2><p>若用结点表示算法中的不同状态，用有方向的边表示不同状态之间的转换相互转换。</p><p>一般地，树根结点对应于算法入口处的起始状态，内部结点对应于过程中的某步计算，通常属于基本操作，叶结点则对应于经一系列计算后某次运行的终止状态。</p><p>算法所有可能的执行过程都可涵盖于比较树中。具体地，该树具有以下性质</p><ul><li>每一内部节点对应于一次比对操作</li><li>内部节点的左右分支分别对应于在两种比对操作下的执行方向</li><li>叶节点(根到叶节点的路径)对应于算法某次执行的完整过程及输出</li><li>反过来，算法的每一次运行都对应于从根到某一叶节点的路径</li></ul><p>按上述规则与算法对应的树称为比较树。无论什么算法，只要其中的分支都完全取决于不同变量或常量的比对或比较结果，则该算法所有可能的执行过程都对应于从根到某一叶节点的路径。反之，可如此描述的算法都称为基于比较式算法，简称CBA式算法。</p><p><strong>估计下界</strong></p><p>考查任一CBA式算法A,设CT(A)为与之对应的一棵比较树。</p><p>根据比较树的性质，算法A每次运行的时间都取决于其对应叶节点到根节点的距离，而算法A在最坏情况下的运行时间将取决于比较树中所有叶节点的最大深度，即该树的高度，记作h(CT(A))。就渐进意义而言，算法A的时间复杂度应不低于h(CT(A))。</p><p>以苹果鉴别为例，可能的输出结果有N=3种，故解决该问题的任一CBA式算法所对应比较树的高度为：</p><p>$h \geq \lceil log_23 \rceil=2$ </p><p>因此，只要是采用CBA式算法，则无论如何优化，在最坏情况下都至少需要2次称量。</p><p>再以CBA式排序算法为例,$n$个元素而言，可能的输出有$n!$种，元素之间不仅可以判等还可以比较大小，因此每一节点都对应有三个分支(分别对应大于、等于、小于的情况)。任一CBA式排序算法对应比较树的高度为：</p><p>$h \geq \lceil log_3{n!}\rceil=\Omega(nlogn)$</p><p>可见，最坏情况下CBA式排序算法至少需要$\Omega(nlogn)$时间，其中$n$为待排序元素的数目。</p><p>这一复杂度下界是针对基于比较树的模型而言的，很多不属于此类型的算法在最坏情况下的复杂度可能低于这一下界。</p><h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p>除了比较树，归约同样也是证明下界的有力工具。</p><p>一般地，考查难度待界定的问题B，若另一问题A满足以下性质：</p><ul><li>问题A的任一输入，在线性时间内可以转换为问题B的输入</li><li>问题B的任一输出，在线性时间内可以转换为问题A的输出</li></ul><p>则称问题A在线性时间内归约为问题B，若问题A的难度已界定为严格地高于$\Omega(n)$,亦即</p><p>$|A|=\Omega(f(n))=\omega(n)$</p><p>则问题B也不会低于这个复杂度下界,亦即</p><p>$|B|\geq|A|=\Omega(f(n))$</p><p>实际上，若问题A可线性归约为问题B，则由后者的任一算法必然可以导出前者的一个算法。为求解问题A，可将其输入转化为问题B的输入，再调用后者的算法，将其转换为前者的输出。</p><p><img src="https://i.loli.net/2019/11/06/BmWlncHbugyGSZA.png"></p><p>因此，假若问题B具有一个更低的下界，则至少存在一个$\alpha(f(n))$的算法，于是由以上可知，问题A存在一个$\alpha(f(n))$的算法，这与问题A的已知下界不符。</p><p>为运用线性归约问题B的下界，须经历以下步骤：</p><ul><li>找到难度已知的问题A</li><li>证明问题A可归约为问题B</li></ul><blockquote><p>证明有序向量唯一化的最低复杂度为nlogn</p></blockquote><p>作为参照，考查所谓元素的唯一性问题(element uniqueness,简称EU)A:对于任意n个实数，判定其中是否有重复者，无序向量唯一化为难度待界定的问题B，简称为UNIQ</p><p>作为EU问题的输入，任意n个实数可在线性时间内组织为一个无序向量，从而转换为UNIQ问题的输入，另一方面，一旦得到UNIQ的问题输出(即去重以后的向量)，只需线性时间核对向量的规模是否仍然为n，即可判定原实数中是否存在重复者。</p><p>EU问题具有$\Omega(nlogn)$的复杂度下界，故以上所给的$nlogn$已属最优。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在导论中，我们了解到数据结构是若干数据项的结构化集合，其结构性表现为数据项之间的某种逻辑次序。根据这种逻辑次序的复杂程度可大致将数据结构分为线性、半线性、非线性结构三大类。在线性结构中，各数据项按照一个线性次序组织为一个整体。在向量中，所有数据项的物理存放位置与其逻辑次序完全吻合。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>平衡二叉搜索树</title>
    <link href="http://twinkle0331.github.io/algorithm/bbst/"/>
    <id>http://twinkle0331.github.io/algorithm/bbst/</id>
    <published>2019-09-13T01:32:19.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>平衡二叉搜索树有诸多变种，以下将介绍其中几位成员。首先，鉴于数据访问的局部性在实际应用中普遍存在，按照最常用者优先的策略引入伸展树。接下来，通过对平衡二叉树的推广，引入平衡多路搜索树，并着重讨论其中比较典型的B树。对照4阶B树，引入红黑树，红黑树不仅仅能保证全树的适度平衡，从而有效地控制单次操作的时间成本并可将每次重平衡操作的时间复杂度控制在常数时间范围内。</p><a id="more"></a><h1 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h1><p>伸展树和AVL树一样，也是平衡二叉搜索树的一种形式。相对于AVL树，伸展树无需时刻都保持全树的平衡，但却可在任何足够长的真实操作序列中保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构做任何附加要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。</p><h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>为考查和评价各操作接口的效率通常假设所有操作彼此独立、次序随即且概率均等，并从平均情况的角度出发。实际上，通常在数据的生命期内，不仅执行不同操作的概率往往极不平衡，而且各操作之间具有极强的相关性，并在整体上多呈现极强的规律性。其中最典型的为数据局部性，即：</p><ul><li>刚刚访问的元素，极有可能在不久之后被访问到</li><li>将被访问的某个元素，极有可能就处于不久之前被访问过的某个元素附近</li></ul><p>就二叉搜索树而言，数据局部性具体体现为：</p><ul><li>刚刚被访问的节点，极有可能在不久后再次被访问到</li><li>将被访问的下一节点，极有可能就处于不久之前被访问过的某个节点的附近</li></ul><p>因此，只需将被访问过的节点转至根节点，即可加速后续的操作。例如，连续的$m(m&gt;&gt;n)$次查找，采用AVL需要$O(mlogn)$次。</p><h2 id="逐层伸展"><a href="#逐层伸展" class="headerlink" title="逐层伸展"></a>逐层伸展</h2><p>每访问过一个节点$E$后，随即反复地以它的父节点为轴，经适当的旋转将其提升一层，直至最终成为树根。随着节点$E$的不断上升，两侧子树的结构也不断地调整，所以这一过程也被称为伸展。伸展过程的效率取决于树的初始形态和节点的访问次序。</p><p>对于很多访问序列，单次访问的分摊复杂度在极端情况下可达到$\Omega(n)$。例如以下情况，从空树开始插入关键码${1,2,3,4,5}$ ,通过<code>search()</code>接口，由小到大依次访问各节点一次。</p><p><img src="https://i.loli.net/2019/09/13/ylN9vtDBVwfJbgS.png"></p><p>可见，在每次访问之后，为将对应节点伸展调整至树根，分别需做$4、4、3、2、1$次旋转。一般地，若节点总数为$n$,则旋转操作的总次数应为：$(n-1)+(n-1)+(n-2)+…+1=(n^2+n-2)=\Omega(n^2)$</p><p>如此分摊下来，每次访问平均需要$\Omega(n)$时间。这一效率不仅远远低于AVL树，甚至与原始的二叉搜索树相当。以上例子在经过$5$次访问后全树的结构将会复原，这意味着以上情况可以持续地再现。</p><p>若其推广至规模任意的二叉搜索树，对于规模为任意$n$的伸展树，只要按照关键码单调的次序，周期性地反复进行查找，则无论总的访问次数$m&gt;&gt;n$有多大，就分摊意义而言，每次都需要$\Omega(n)$时间。</p><h2 id="双层伸展"><a href="#双层伸展" class="headerlink" title="双层伸展"></a>双层伸展</h2><p>以上单层伸展的问题在于全树的拓扑结构始终呈单链表结构，等价于一维列表。被访问节点的深度，呈周期性的算术级数演变${n-1,n-2,n-3,…,3,2,1}$</p><p>为了克服上述伸展调整策略的缺陷，可将逐层伸展改为双层伸展，每次都从当前节点$v$向上追溯两层而不是一层，并根据其父节点$p$和祖父$g$的相对位置进行相应的旋转。</p><p>旋转的情况分为三种：</p><p><strong>zig-zig/zag-zag</strong></p><p>设$v$是$p$的左孩子，且$p$也是$g$的左孩子，设$W$和$Y$分别是$v$的左、右子树，$Y$和$Z$分别是$p$和$g$的左、右子树。</p><p><img src="https://i.loli.net/2019/09/13/uhrTU92Dpzajild.png"></p><p>一旦访问坏节点，对应的路径的长度随即减半。</p><p><strong>zig-zag/zag-zig</strong></p><p>设$v$是$p$的左孩子，而$p$是$v$的右孩子，设$W$是$g$的左子树，$X$和$Y$分别是$v$的左、右子树,$Z$是$p$的右子树。</p><p><img src="https://i.loli.net/2019/09/13/8cMjCFDBpqywiR7.png"></p><p><strong>zig/zag</strong></p><p>若$v$最初的深度为奇数，则经过若干次双层调整至最后一次调整后，$v$的父亲即是树根$r$。将$v$的左右子树记作$X$和$Y$，节点$p=r$的另一棵子树记作$Z$。</p><p><img src="https://i.loli.net/2019/09/13/AdHjvMufVEXqDyn.png"></p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>综合以上情况，每经过一次双层调整操作，节点$v$都会上升两层。若v的初始深度<code>depth(v)</code>为偶数，则最终v将上升至树根。若<code>depth(v)</code>为奇数，则当$v$上升至深度为$1$时，不妨最后再相应地做一次zig或zag单旋转操作。无论如何，经过<code>depth(v)</code>次旋转后，$v$总能成为树根。</p><p>最坏实例导致$\Omega(n)$平均单次访问时间的原因为：在这一可持续重复的过程中，二叉搜索树的高度始终不小于$\lfloor n/2 \rfloor$,而且至少有一半的节点在接受访问时没有如预期地靠近树根，反而恰恰处于最底层。从树高的角度来看，树高依算术级数逐步从$n-1$递减至$\lfloor n/2 \rfloor$,然后再逐步递增地增回到$n-1$。</p><p><img src="https://i.loli.net/2019/09/13/E4gPuBJhlKF16Wy.png"></p><p>以以上二叉搜索树为例，逐层调整和双层调整的区别如图所示。最深节点在经过双层调整后，不仅同样可将该节点伸展至树根，而且可使树的高度接近于减半，可有效避免对长分支的访问。在将节点$v$调整至树根的同时，对应分支长度以几何级数的速度(大致折半)收缩。</p><p>在任一时刻伸展树中都可能存在很深的节点，但是经过随后的双层伸展，其对应的分支长度都会收缩至长度大致这般，最坏情况也不会持续发生。可见，伸展树虽不能杜绝最坏情况，却能有效地控制最坏情况发生的频率，从而在分摊意义上保证整体的高效率。</p><p>分摊复杂度为$O(logn)$,与AVL树相当。在局部性强、缓存命中率高的时候，效率可以更高($k&lt;&lt;n&lt;&lt;m$),自适应的$O(logk)$。因为达到经常访问的$k$个元素分布在根节点附近需要常规的$n$次操作，每次复杂度不超过$logn$,所以时间复杂度还得再算入一个$O(nlogn)$因子。任何连续的$m$次查找都可在$O(mlogk+nlogn)$时间内完成。仍不能杜绝单次最坏情况的出现，不适用于对效率敏感的场合。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodePosi&gt; <span class="keyword">inline</span> <span class="comment">//在节点*p与*lc（可能为空）之间建立父（左）子关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachAsLChild</span> <span class="params">( NodePosi p, NodePosi lc )</span> </span>&#123; p-&gt;lc = lc; <span class="keyword">if</span> ( lc ) lc-&gt;parent = p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodePosi&gt; <span class="keyword">inline</span> <span class="comment">//在节点*p与*rc（可能为空）之间建立父（右）子关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachAsRChild</span> <span class="params">( NodePosi p, NodePosi rc )</span> </span>&#123; p-&gt;rc = rc; <span class="keyword">if</span> ( rc ) rc-&gt;parent = p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//Splay树伸展算法：从节点v出发逐层伸展</span></span><br><span class="line">BinNodePosi(T) Splay&lt;T&gt;::splay ( BinNodePosi(T) v ) &#123; <span class="comment">//v为因最近访问而需伸展的节点位置</span></span><br><span class="line">   <span class="keyword">if</span> ( !v ) <span class="keyword">return</span> <span class="literal">NULL</span>; BinNodePosi(T) p; BinNodePosi(T) g; <span class="comment">//*v的父亲与祖父</span></span><br><span class="line">   <span class="keyword">while</span> ( ( p = v-&gt;parent ) &amp;&amp; ( g = p-&gt;parent ) ) &#123; <span class="comment">//自下而上，反复对*v做双层伸展</span></span><br><span class="line">      BinNodePosi(T) gg = g-&gt;parent; <span class="comment">//每轮之后*v都以原曾祖父（great-grand parent）为父</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *v ) )</span><br><span class="line">         <span class="keyword">if</span> ( IsLChild ( *p ) ) &#123; <span class="comment">//zig-zig</span></span><br><span class="line">            attachAsLChild ( g, p-&gt;rc ); attachAsLChild ( p, v-&gt;rc );</span><br><span class="line">            attachAsRChild ( p, g ); attachAsRChild ( v, p );</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//zig-zag</span></span><br><span class="line">            attachAsLChild ( p, v-&gt;rc ); attachAsRChild ( g, v-&gt;lc );</span><br><span class="line">            attachAsLChild ( v, g ); attachAsRChild ( v, p );</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( IsRChild ( *p ) ) &#123; <span class="comment">//zag-zag</span></span><br><span class="line">         attachAsRChild ( g, p-&gt;lc ); attachAsRChild ( p, v-&gt;lc );</span><br><span class="line">         attachAsLChild ( p, g ); attachAsLChild ( v, p );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//zag-zig</span></span><br><span class="line">         attachAsRChild ( p, v-&gt;lc ); attachAsLChild ( g, v-&gt;rc );</span><br><span class="line">         attachAsRChild ( v, g ); attachAsLChild ( v, p );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !gg ) v-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//若*v原先的曾祖父*gg不存在，则*v现在应为树根</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则，*gg此后应该以*v作为左或右孩子</span></span><br><span class="line">         ( g == gg-&gt;lc ) ? attachAsLChild ( gg, v ) : attachAsRChild ( gg, v );</span><br><span class="line">      updateHeight ( g ); updateHeight ( p ); updateHeight ( v );</span><br><span class="line">   &#125; <span class="comment">//双层伸展结束时，必有g == NULL，但p可能非空</span></span><br><span class="line">   <span class="keyword">if</span> ( p = v-&gt;parent ) &#123; <span class="comment">//若p果真非空，则额外再做一次单旋</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *v ) ) &#123; attachAsLChild ( p, v-&gt;rc ); attachAsRChild ( v, p ); &#125;</span><br><span class="line">      <span class="keyword">else</span>                   &#123; attachAsRChild ( p, v-&gt;lc ); attachAsLChild ( v, p ); &#125;</span><br><span class="line">      updateHeight ( p ); updateHeight ( v );</span><br><span class="line">   &#125;</span><br><span class="line">   v-&gt;parent = <span class="literal">NULL</span>; <span class="keyword">return</span> v;</span><br><span class="line">&#125; <span class="comment">//调整之后新树根应为被伸展的节点，故返回该节点的位置以便上层函数更新树根</span></span><br></pre></td></tr></table></figure><p><strong>查找</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) &amp; Splay&lt;T&gt;::search ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//在伸展树中查找e</span></span><br><span class="line">   BinNodePosi(T) p = searchIn ( _root, e, _hot = <span class="literal">NULL</span> );</span><br><span class="line">   _root = splay ( p ? p : _hot ); <span class="comment">//将最后一个被访问的节点伸展至根</span></span><br><span class="line">   <span class="keyword">return</span> _root;</span><br><span class="line">&#125; <span class="comment">//与其它BST不同，无论查找成功与否，_root都指向最后被访问的节点</span></span><br></pre></td></tr></table></figure><p>首先调用二叉树的通用算法<code>searchIn()</code>尝试查找具有关键码$e$的节点。无论是否查找成功，都继而调用<code>splay()</code>算法，将查找终止处的节点伸展到树根，此时的查找操作不再为静态操作。</p><p><strong>插入</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) Splay&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入伸展树中</span></span><br><span class="line">   <span class="keyword">if</span> ( !_root ) &#123; _size++; <span class="keyword">return</span> _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e ); &#125; <span class="comment">//处理原树为空的退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( e == search ( e )-&gt;data ) <span class="keyword">return</span> _root; <span class="comment">//确认目标节点不存在</span></span><br><span class="line">   _size++; BinNodePosi(T) t = _root; <span class="comment">//创建新节点。以下调整&lt;=7个指针以完成局部重构</span></span><br><span class="line">   <span class="keyword">if</span> ( _root-&gt;data &lt; e ) &#123; <span class="comment">//插入新根，以t和t-&gt;rc为左、右孩子</span></span><br><span class="line">      t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, <span class="literal">NULL</span>, t, t-&gt;rc ); <span class="comment">//2 + 3个</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *t ) ) &#123; t-&gt;rc-&gt;parent = _root; t-&gt;rc = <span class="literal">NULL</span>; &#125; <span class="comment">//&lt;= 2个</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//插入新根，以t-&gt;lc和t为左、右孩子</span></span><br><span class="line">      t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, <span class="literal">NULL</span>, t-&gt;lc, t ); <span class="comment">//2 + 3个</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *t ) ) &#123; t-&gt;lc-&gt;parent = _root; t-&gt;lc = <span class="literal">NULL</span>; &#125; <span class="comment">//&lt;= 2个</span></span><br><span class="line">   &#125;</span><br><span class="line">   updateHeightAbove ( t ); <span class="comment">//更新t及其祖先（实际上只有_root一个）的高度</span></span><br><span class="line">   <span class="keyword">return</span> _root; <span class="comment">//新节点必然置于树根，返回之</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有_root-&gt;data == e</span></span><br></pre></td></tr></table></figure><p>为将关键码$e$插入至伸展树T中，首先调用伸展树查找接口<code>search(e)</code>查找该关键码，最后被访问的节点$t$通过伸展被提升为树根，其左、右子树分别记作$T_l$和$T_r$。</p><p>接下来，根据$e$与$t$的大小关系，以$t$为界将$T$分为左右两棵子树。比如，不失一般性地，设$e$大于$t$,可切断$t$与其右孩子的关系，再将$e$为关键码的新节点作为树根，并以$t$为其左孩子，以$T_r$为右子树。</p><p><strong>删除</strong></p><p>为从伸展树$T$中删除关键码为$e$的节点，先调用<code>search()</code>定位目标节点，在成功返回后，树根节点恰好为待删除节点，其左、右子树分别记作$T_l$和$T_r$。接下来，将v摘除。再在$T_r$中查找关键码$e$，尽管这一查找必定失败，确可将$T_r$中的最小节点提升为该子树的根。</p><p>得益于二叉搜索树的顺序性，此时$m$的左子树必然为空，此时只需将$T_l$作为左子树与$m$相互联接，即可得到一棵完整的二叉搜索树，如此不仅删除了节点$v$，还将$m$的后继提升为新的树根，数据局部性也得到了利用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Splay&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从伸展树中删除关键码e</span></span><br><span class="line">   <span class="keyword">if</span> ( !_root || ( e != search ( e )-&gt;data ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若树空或目标不存在，则无法删除</span></span><br><span class="line">   BinNodePosi(T) w = _root; <span class="comment">//assert: 经search()后节点e已被伸展至树根</span></span><br><span class="line">   <span class="keyword">if</span> ( !HasLChild ( *_root ) ) &#123; <span class="comment">//若无左子树，则直接删除</span></span><br><span class="line">      _root = _root-&gt;rc; <span class="keyword">if</span> ( _root ) _root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !HasRChild ( *_root ) ) &#123; <span class="comment">//若无右子树，也直接删除</span></span><br><span class="line">      _root = _root-&gt;lc; <span class="keyword">if</span> ( _root ) _root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//若左右子树同时存在，则</span></span><br><span class="line">      BinNodePosi(T) lTree = _root-&gt;lc;</span><br><span class="line">      lTree-&gt;parent = <span class="literal">NULL</span>; _root-&gt;lc = <span class="literal">NULL</span>; <span class="comment">//暂时将左子树切除</span></span><br><span class="line">      _root = _root-&gt;rc; _root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//只保留右子树</span></span><br><span class="line">      search ( w-&gt;data ); <span class="comment">//以原树根为目标，做一次（必定失败的）查找</span></span><br><span class="line"><span class="comment">///// assert: 至此，右子树中最小节点必伸展至根，且（因无雷同节点）其左子树必空，于是</span></span><br><span class="line">      _root-&gt;lc = lTree; lTree-&gt;parent = _root; <span class="comment">//只需将原左子树接回原位即可</span></span><br><span class="line">   &#125;</span><br><span class="line">   release ( w-&gt;data ); release ( w ); _size--; <span class="comment">//释放节点，更新规模</span></span><br><span class="line">   <span class="keyword">if</span> ( _root ) updateHeight ( _root ); <span class="comment">//此后，若树非空，则树根的高度需要更新</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回成功标志</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure><blockquote><p>试证明，伸展树所有基本接口的分摊时间复杂度，均为$O(log n)$</p></blockquote><p>事实上，伸展树单次操作所需的时间量T起伏很大，并不能始终保持控制在$O(logn)$以内。可从分摊分析的角度对此统一分析和评判。具体地，将总体所需计算时间分摊之其间的每一操作，如此即可得到单次操作的分摊复杂度A,并依据此评判伸展树的整体性能。借助势能分析法可知单次分摊复杂度为$O( logn)$。</p><h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>在之前的计算模型中，RAM模型有无限可数个寄存器，而图灵机模型为无限长的纸带。然而从实际应用来看，问题规模的增长速度却远远快于存储能力的增长，随着时间的推移这一矛盾将日益凸显。鉴于在同等成本下，存储器的容量越大则访问速度越慢，因此一味提高存储器容量并非良策。</p><p>实践证明，分级存储为行之有效的方法。不同容量的存储器，访问速度差异悬殊，所以在由内存和外存组成的二级存储系统中，数据全集往往存放于外存中，计算过程中可将内存作为外存的高速缓存，存放最常用数据项的复本。</p><p>两个相邻存储器之间的数据传输统称I/O操作。各级存储器的访问速度相差悬殊，故因尽可能地减少I/O操作。</p><h2 id="多路搜索树"><a href="#多路搜索树" class="headerlink" title="多路搜索树"></a>多路搜索树</h2><p>当数据规模大到内存已不足以容纳时，常规二叉搜索树地效率将大打折扣，其原因在于，查找过程对外存的访问次数过多。为此，需充分利用磁盘之类存储器的另一特性：读取物理地址连续的一千字节与读取单个字节几乎没有区别。因此不妨通过时间成极低的多次内存操作，将通常的二叉搜索树转变为多路搜索树，在中序遍历意义上，同样为等价变换。</p><p>可通过适当合并得到超级节点，比如每$2$层合并，得到$4$路搜索树，每$3$层合并得到$8$路搜索树。一般地，以$k$ 层为间隔可将二叉搜索树转换为$2^k$路搜索树，统称多路搜索树。</p><p>多路搜索树同样支持对二叉树的查找，效果与原二叉树相同，然而对外存的访问方式已发生本质变化。实际上，在此时的搜索每下降一层，都以大节点为单位从外存中读入一组关键码，这组关键码在逻辑上在物理上相邻，故可以批量从外存一次性读出，所需时间与读取单个关键码几乎一样。当然，每组关键码的最佳数目，取决于不同外存的批量访问特性。</p><h2 id="多路平衡搜索树"><a href="#多路平衡搜索树" class="headerlink" title="多路平衡搜索树"></a>多路平衡搜索树</h2><p>所谓$m$阶B树，即$m$阶平衡搜索树($m\geq 2$)。</p><p>所有外部节点均深度相等。同时，每个内部节点都存有不超过$m-1$个关键码，以及用以指示对应分支的不超过$m$个引用。具体地，存有$n\leq m-1$个关键码</p><p>$K_1&lt;K_2&lt;K_3&lt;…&lt;K_n$的内部节点，</p><p>同时还有$n+1\leq m$个引用：</p><p>$A_0&lt;A_1&lt;A_2&lt;A_3&lt;A_4&lt;…&lt;A_n$</p><p>反过来，除根以外的所有节点，都应满足$n+1 \geq \lceil m/2 \rceil$</p><p>而在非空的B树中，根节点应满足$n+1\geq 2$,故亦称作$(\lceil m/2 \rceil,m)$树。</p><p>B树的外部节点未必意味着查找失败，而可能目标关键码存在于更低层次的某一外部存储系统中，因此在计算B树树高时计入最底层的外部节点，树高即为外部节点的深度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTNodePosi(T) BTNode<span class="meta-string">&lt;T&gt;* //B-树节点位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span> <span class="comment">//B-树节点模板类</span></span><br><span class="line"><span class="comment">// 成员（为简化描述起见统一开放，读者可根据需要进一步封装）</span></span><br><span class="line">   BTNodePosi(T) parent; <span class="comment">//父节点</span></span><br><span class="line">   Vector&lt;T&gt; key; <span class="comment">//关键码向量</span></span><br><span class="line">   Vector&lt;BTNodePosi(T)&gt; child; <span class="comment">//孩子向量（其长度总比key多一）</span></span><br><span class="line"><span class="comment">// 构造函数（注意：BTNode只能作为根节点创建，而且初始时有0个关键码和1个空孩子指针）</span></span><br><span class="line">   BTNode() &#123; parent = <span class="literal">NULL</span>; child.insert ( <span class="number">0</span>, <span class="literal">NULL</span> ); &#125;</span><br><span class="line">   BTNode ( T e, BTNodePosi(T) lc = <span class="literal">NULL</span>, BTNodePosi(T) rc = <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      parent = <span class="literal">NULL</span>; <span class="comment">//作为根节点，而且初始时</span></span><br><span class="line">      key.insert ( <span class="number">0</span>, e ); <span class="comment">//只有一个关键码，以及</span></span><br><span class="line">      child.insert ( <span class="number">0</span>, lc ); child.insert ( <span class="number">1</span>, rc ); <span class="comment">//两个孩子</span></span><br><span class="line">      <span class="keyword">if</span> ( lc ) lc-&gt;parent = <span class="keyword">this</span>; <span class="keyword">if</span> ( rc ) rc-&gt;parent = <span class="keyword">this</span>;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>同一节点的所有孩子组成一个向量，各相邻孩子之间组成一个向量。按照B树的定义，孩子向量的实际长度总是比关键码向量多一。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>B树结构非常适宜在相对更小的内存中，实现对大规模数据的高效操作。</p><p>B树的查找过程和二叉搜索树的查找过程类似，首先将根节点作为当前节点，只要当前节点不是外部节点，就在当前节点中顺序查找，若找到目标关键码，则返回查找成功，否则沿着引用转至相应子树，将其根节点读入内存，并更新当前节点。若当前节点为外部节点，则返回查找失败。</p><p>只有在切换和更新当前节点时才会涉及I/O操作，而在同一节点内部的查找则完全在内存中进行。因内存的访问效率远远高于内存，再考虑到各节点的关键码数量通常在128到512之间，所以直接采用顺序查找策略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BTNodePosi(T) BTree&lt;T&gt;::search ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//在B-树中查找关键码e</span></span><br><span class="line">   BTNodePosi(T) v = _root; _hot = <span class="literal">NULL</span>; <span class="comment">//从根节点出发</span></span><br><span class="line">   <span class="keyword">while</span> ( v ) &#123; <span class="comment">//逐层查找</span></span><br><span class="line">      Rank r = v-&gt;key.search ( e ); <span class="comment">//在当前节点中，找到不大于e的最大关键码</span></span><br><span class="line">      <span class="keyword">if</span> ( ( <span class="number">0</span> &lt;= r ) &amp;&amp; ( e == v-&gt;key[r] ) ) <span class="keyword">return</span> v; <span class="comment">//成功：在当前节点中命中目标关键码</span></span><br><span class="line">      _hot = v; v = v-&gt;child[r + <span class="number">1</span>]; <span class="comment">//否则，转入对应子树（_hot指向其父）——需做I/O，最费时间</span></span><br><span class="line">   &#125; <span class="comment">//这里在向量内是二分查找，但对通常的_order可直接顺序查找</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//失败：最终抵达外部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上算法直接调用了有序向量的<code>search()</code>接口。</p><p><strong>性能分析</strong></p><p>B树查找的过程主要消耗于：</p><ul><li>将某一节点载入内存</li><li>在内存中对当前节点进行查找</li></ul><p>鉴于内存、外存在访问速度上的差异，相对于前一类时间消耗，后一时间消耗可忽略不计。B树查找操作的效率主要取决于查找过程中的外存访问次数。</p><p>约定B树的树根节点常驻RAM，那么对于高度为$h$的子树，外存访问不超过$O(h-1)$次。</p><p>每次查找过程中共需访问$O(log_mN)$个节点，相应地需要做$O(log_mN)$次外存读取操作。由此可知，存有$N$个关键码的$m$阶B树每次查找操作，耗时不过$O(log_mN)$。</p><p><strong>树高</strong></p><p>若存有$N$个关键码的$m$阶B树的高度为$h$，则必有：</p><p>$log_m(N+1) \leq h \leq log_{\lceil m/2 \rceil} {\lfloor (N+1)/2 \rfloor} +1$</p><p>首先证明$h \leq log_{\lceil m/2 \rceil} {\lfloor (N+1)/2 \rfloor} +1$ 。关键码总数固定时，为使B树更高，各内部节点都应包含尽可能少的关键码。于是按照B树的定义，各高度层次上节点数目至少是：</p><p>$n_0=1$</p><p>$n_1=2$</p><p>$n_2=2 \lceil m/2 \rceil$</p><p>$n_3=2 \lceil m/2 \rceil ^2$</p><p>$n_4=2 \lceil m/2 \rceil ^3$</p><p>…</p><p>$n_{h-1}=2 \lceil m/2 \rceil ^{h-2}$</p><p>$n_h=2 \lceil m/2 \rceil ^{h-1}$</p><p>设向量节点个数为$n_m$,则除了根节点以外每个向量节点均有$\lceil m/2 \rceil$个分支，总的分支数目为$\lceil m/2 \rceil n_m$。</p><p>考虑除了根节点以外的向量节点，</p><p>根据树的性质有$n=n_m+n_0=\lceil m/2 \rceil n_m+1$</p><p>则$n_0=(\lceil m/2 \rceil -1)n_m+1$</p><p>叶节点，即是外部的向量节点，均只有一个关键码，而内部节点均有$\lceil m/2 \rceil -1$个关键码，则对应的节点有$(\lceil m/2 \rceil) -1n_m$个，设内部节点总数为$n_{sum}$，对应有$n_h=n_{sum}+1$</p><p>现考查外部节点，这些节点对应于失败的查找,故其数量$n_h$应等于失败查找情形可能的总数$n_{sum}$，即应比成功查找可能情形的总数恰好多一，而后者等于关键码的总数$N$。</p><p>于是有，</p><p>$N+1=n_h \geq 2(\lceil m/2 \rceil)^{h-1} $</p><p>即$h \leq log_{\lceil m/2 \rceil} {\lfloor (N+1)/2 \rfloor} +1$</p><p>再来证明$log_m(N+1) \leq h$。同理，关键码总数一定时，为使B树更矮，每个内部节点都应该包含尽可能多的关键码。按照B树的定义，各高度节点上的节点数目至多是：</p><p>$n_0=1$</p><p>$n_1=m$</p><p>$n_2=m^2$</p><p>…</p><p>$n_h=m^h$</p><p>与上同理，有$N+1=n_h \leq m^h$</p><p>即$\Omega (log_mN)=log_m(N+1) \leq h$ </p><p>也就是说存有$N$个关键码的$m$阶B树的高度$h= \Theta(log_mN)$</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BTree&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入B树中</span></span><br><span class="line">   BTNodePosi(T) v = search ( e ); <span class="keyword">if</span> ( v ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标节点不存在</span></span><br><span class="line">   Rank r = _hot-&gt;key.search ( e ); <span class="comment">//在节点_hot的有序关键码向量中查找合适的插入位置</span></span><br><span class="line">   _hot-&gt;key.insert ( r + <span class="number">1</span>, e ); <span class="comment">//将新关键码插至对应的位置</span></span><br><span class="line">   _hot-&gt;child.insert ( r + <span class="number">2</span>, <span class="literal">NULL</span> ); <span class="comment">//创建一个空子树指针</span></span><br><span class="line">   _size++; <span class="comment">//更新全树规模</span></span><br><span class="line">   solveOverflow ( _hot ); <span class="comment">//如有必要，需做分裂</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为在B树中插入一个关键码$e$，首先调用<code>search(e)</code>在树中查找该关键码，若查找成功则按照禁止重复关键码的约定不予插入，操作即告完成并返回<code>false</code>。若查找终止于一外部节点v，且其父亲由变量hot指示。此时hot必然指向某一叶节点(当然也可能时根节点)。接下来，在该节点中再次查找关键码e,确定e在其中的插入位置r,只需将e插入至这一位置。</p><p>在<code>hot</code>所指示的节点中增加了一个关键码。若该节点的关键码仍然合法，则插入操作随即完成。否则，则称该节点发生了一次上溢，此时需要经过适当的处理来使该节点以及整树满足B树的条件。</p><p><strong>上溢和分裂</strong></p><p>一般地，刚发生上溢的节点应恰好有$m$个关键码。若取$s=\lfloor m/2 \rfloor$ ,则它们依次为：</p><p>${k_0,k_1,…,k_{s-1},k_s,k_{s+1},…,k_{m-1}}$</p><p>可见，以$k_s$为界，可将该节点分为前、后两个子节点，二者大致等长。于是，可令关键码$k_s$上升一层，归入其父节点中的适当位置，并分别以这两个子节点作为左、右孩子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//关键码插入后若节点上溢，则做节点分裂处理</span></span><br><span class="line"><span class="keyword">void</span> BTree&lt;T&gt;::solveOverflow ( BTNodePosi(T) v ) &#123;</span><br><span class="line">   <span class="keyword">if</span> ( _order &gt;= v-&gt;child.size() ) <span class="keyword">return</span>; <span class="comment">//递归基：当前节点并未上溢</span></span><br><span class="line">   Rank s = _order / <span class="number">2</span>; <span class="comment">//轴点（此时应有_order = key.size() = child.size() - 1）</span></span><br><span class="line">   BTNodePosi(T) u = <span class="keyword">new</span> BTNode&lt;T&gt;(); <span class="comment">//注意：新节点已有一个空孩子</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank j = <span class="number">0</span>; j &lt; _order - s - <span class="number">1</span>; j++ ) &#123; <span class="comment">//v右侧_order-s-1个孩子及关键码分裂为右侧节点u</span></span><br><span class="line">      u-&gt;child.insert ( j, v-&gt;child.remove ( s + <span class="number">1</span> ) ); <span class="comment">//逐个移动效率低</span></span><br><span class="line">      u-&gt;key.insert ( j, v-&gt;key.remove ( s + <span class="number">1</span> ) ); <span class="comment">//此策略可改进</span></span><br><span class="line">   &#125;</span><br><span class="line">   u-&gt;child[_order - s - <span class="number">1</span>] = v-&gt;child.remove ( s + <span class="number">1</span> ); <span class="comment">//移动v最靠右的孩子</span></span><br><span class="line">   <span class="keyword">if</span> ( u-&gt;child[<span class="number">0</span>] ) <span class="comment">//若u的孩子们非空，则</span></span><br><span class="line">      <span class="keyword">for</span> ( Rank j = <span class="number">0</span>; j &lt; _order - s; j++ ) <span class="comment">//令它们的父节点统一</span></span><br><span class="line">         u-&gt;child[j]-&gt;parent = u; <span class="comment">//指向u</span></span><br><span class="line">   BTNodePosi(T) p = v-&gt;parent; <span class="comment">//v当前的父节点p</span></span><br><span class="line">   <span class="keyword">if</span> ( !p ) &#123; _root = p = <span class="keyword">new</span> BTNode&lt;T&gt;(); p-&gt;child[<span class="number">0</span>] = v; v-&gt;parent = p; &#125; <span class="comment">//若p空则创建之</span></span><br><span class="line">   Rank r = <span class="number">1</span> + p-&gt;key.search ( v-&gt;key[<span class="number">0</span>] ); <span class="comment">//p中指向u的指针的秩</span></span><br><span class="line">   p-&gt;key.insert ( r, v-&gt;key.remove ( s ) ); <span class="comment">//轴点关键码上升</span></span><br><span class="line">   p-&gt;child.insert ( r + <span class="number">1</span>, u );  u-&gt;parent = p; <span class="comment">//新节点u与父节点p互联</span></span><br><span class="line">   solveOverflow ( p ); <span class="comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度</strong></p><p>若将B树的阶次$m$视为常数，则关键码的移动和复制操作的时间都可以忽略。至于<code>solveOverflow()</code>算法，每一递归实例均只需常数时间，递归层数不超过B树高度，由此可知，对于存有$n$个关键码的B树，每次插入操作可在$O(log_mn)$时间完成。</p><p>实际上，因插入操作而导致$\Omega(log_mn)$次分裂的情况极为罕见，单次插入操作平均引发的分裂次数远远低于这一估计，故时间通常消耗于对目标关键码的查找。</p><blockquote><p>现拟将一组共$n$个互异的关键码，插入至一棵初始为空的$m$阶B树中，按照何种次序插入可使得到的B树高度最大？按照何种次序插入可使得到的B树高度最小</p></blockquote><p>按照单调次序插入所有关键码可使得B树高度达到最大，得到B树的高度为$h=log_{\lceil m/2 \rceil} {\lfloor (n+1)/2\rfloor}+1$。</p><p>每$m$个关键码为一组，相邻两组为一个单位，设前者为$l$，后者为$r$,先插入$l$中的前$\lfloor (m-1)/2 \rfloor$个元素，再插入$r$中的前$\lfloor(m-1)/2 \rfloor$个元素，然后插入$l$和$r$中第$m$大的元素，若最后划分得到的元素剩余个数不满足一个单位的要求则可按照单调次序插入，如此插入可使得的$b$树高度最小。</p><blockquote><p>考查任意阶的B树，若T的初始高度为1，而经过若干次插入操作之后，高度增加至$h$，且共有$n$个内部节点，则再次过程中T的分裂操作有多少次</p></blockquote><p>考查因关键码插入而引起的任何一次分裂操作，</p><p>被分裂的节点无非两种情况，</p><ul><li>若它不是根节点，则树中的节点增加一个，同时树高保持不变，故有$n+=1$和$h+=0$</li><li>若是根节点，则除了原节点一分为二，还会新生成一个仅含单关键码的树根，同时树的高度也将相应的升高一层，故有:$n+=2$和$h+=1$</li></ul><p>可见，无论如何，$n$和$h$的差值均会恰好地增加一个单位，因此$n-h$可视为分裂操作的一个计数器。该计数器的初始值为$1-1=0$,故最终的$n-h$即是整个操作过程中所做分裂次数的总次数。</p><p>推广，若初始节点数为$n_0$,高度为$h_0$,则经过若干次插入操作后，高度为$h$,节点数为$n$，则B树的分裂次数为$n-h-(n_0-h_0)$</p><blockquote><p>每次插入平均引发了多少次分裂操作</p></blockquote><p>累计发生的分裂次数，不仅取决于连续插入操作的次数，同时也取决于最终的树高。<br>若关键码固定为$N$,为使节点尽可能多，内部节点各自所含的关键码应尽可能少，根节点必定含有1个关键码，其余内部节点至少包含$\lceil m/2 \rceil -1$个关键码，故必有：</p><p>$n \leq 1+(N-1)/(\lceil m/2 \rceil-1)$</p><p>在如上连续的$N$次插入中，分裂操作的平均次数必然不超过：</p><p>$(n-h)/N &lt; n/N &lt; 1/(\lceil m/2 \rceil -1)$</p><p>平均而言，大致每经过$\lceil m/2 \rceil-1$ 次插入,才会引发一次分裂。</p><p>某一节点的插入在最坏情况下可能引发多达$\Omega(log_mN)$次分裂操作，但是平均意义而言，这类最坏情况发生的概率极低。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>为了从B树中删除关键码$e$，首先需要调用<code>search(e)</code>查找$e$所属的节点，若查找失败则说明关键码$e$不存在，删除操作随即完成。目标关键码所在的节点由$v$指示。此时通过顺序查找可进一步确定$e$在节点$v$中的秩$r$。</p><p>不妨假定$v$是叶节点，否则$e$的直接前驱(后继)在左、右子树中必然存在，可在$O(height(v))$时间内确定它们的位置，其中$height(v)$为二者的高度。此处不妨选用直接后继，于是，$e$的直接后继关键码所属的节点$u$是叶节点。</p><p>接下来可将$e$与$u[0]$互换位置，即可确保待删除的节点v就是叶节点。</p><p>直接将$e$(以及其左侧的空节点)从$v$中删去，如此,节点$v$中所含的关键码以及空分支将减少一个。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BTree&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从BTree树中删除关键码e</span></span><br><span class="line">   BTNodePosi(T) v = search ( e ); <span class="keyword">if</span> ( !v ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标关键码存在</span></span><br><span class="line">   Rank r = v-&gt;key.search ( e ); <span class="comment">//确定目标关键码在节点v中的秩（由上，肯定合法）</span></span><br><span class="line">   <span class="keyword">if</span> ( v-&gt;child[<span class="number">0</span>] ) &#123; <span class="comment">//若v非叶子，则e的后继必属于某叶节点</span></span><br><span class="line">      BTNodePosi(T) u = v-&gt;child[r+<span class="number">1</span>]; <span class="comment">//在右子树中一直向左，即可</span></span><br><span class="line">      <span class="keyword">while</span> ( u-&gt;child[<span class="number">0</span>] ) u = u-&gt;child[<span class="number">0</span>]; <span class="comment">//找出e的后继</span></span><br><span class="line">      v-&gt;key[r] = u-&gt;key[<span class="number">0</span>]; v = u; r = <span class="number">0</span>; <span class="comment">//并与之交换位置</span></span><br><span class="line">   &#125; <span class="comment">//至此，v必然位于最底层，且其中第r个关键码就是待删除者</span></span><br><span class="line">   v-&gt;key.remove ( r ); v-&gt;child.remove ( r + <span class="number">1</span> ); _size--; <span class="comment">//删除e，以及其下两个外部节点之一</span></span><br><span class="line">   solveUnderflow ( v ); <span class="comment">//如有必要，需做旋转或合并</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，若该节点所含的关键码的总数依然合法(即不少于$\lceil m/2 \rceil-1$)，则删除操作随即完成，否则，称该节点发生了下溢，并需要经过适当的处理，将该节点以及整数重新满足B树的条件。</p><p><strong>下溢和合并</strong></p><p><img src="https://i.loli.net/2019/09/13/kqnsiNx6fF5LEQb.png"></p><p><img src="https://i.loli.net/2019/09/13/RYFQBuN12a9jIm6.png"></p><p>另外解释一下，$L$和$R$必有其一，根据B树的定义，所有外部节点均深度相等，$v$不为外部节点，所以必然存在与$v$同高度并不为空的节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//关键码删除后若节点下溢，则做节点旋转或合并处理</span></span><br><span class="line"><span class="keyword">void</span> BTree&lt;T&gt;::solveUnderflow ( BTNodePosi(T) v ) &#123;</span><br><span class="line">   <span class="keyword">if</span> ( ( _order + <span class="number">1</span> ) / <span class="number">2</span> &lt;= v-&gt;child.size() ) <span class="keyword">return</span>; <span class="comment">//递归基：当前节点并未下溢</span></span><br><span class="line">   BTNodePosi(T) p = v-&gt;parent;</span><br><span class="line">   <span class="keyword">if</span> ( !p ) &#123; <span class="comment">//递归基：已到根节点，没有孩子的下限</span></span><br><span class="line">      <span class="keyword">if</span> ( !v-&gt;key.size() &amp;&amp; v-&gt;child[<span class="number">0</span>] ) &#123;</span><br><span class="line">         <span class="comment">//但倘若作为树根的v已不含关键码，却有（唯一的）非空孩子，则</span></span><br><span class="line">         _root = v-&gt;child[<span class="number">0</span>]; _root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//这个节点可被跳过</span></span><br><span class="line">         v-&gt;child[<span class="number">0</span>] = <span class="literal">NULL</span>; release ( v ); <span class="comment">//并因不再有用而被销毁</span></span><br><span class="line">      &#125; <span class="comment">//整树高度降低一层</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Rank r = <span class="number">0</span>; <span class="keyword">while</span> ( p-&gt;child[r] != v ) r++;</span><br><span class="line">   <span class="comment">//确定v是p的第r个孩子——此时v可能不含关键码，故不能通过关键码查找</span></span><br><span class="line">   <span class="comment">//另外，在实现了孩子指针的判等器之后，也可直接调用Vector::find()定位</span></span><br><span class="line"><span class="comment">// 情况1：向左兄弟借关键码</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt; r ) &#123; <span class="comment">//若v不是p的第一个孩子，则</span></span><br><span class="line">      BTNodePosi(T) ls = p-&gt;child[r - <span class="number">1</span>]; <span class="comment">//左兄弟必存在</span></span><br><span class="line">      <span class="keyword">if</span> ( ( _order + <span class="number">1</span> ) / <span class="number">2</span> &lt; ls-&gt;child.size() ) &#123; <span class="comment">//若该兄弟足够“胖”，则</span></span><br><span class="line">         v-&gt;key.insert ( <span class="number">0</span>, p-&gt;key[r - <span class="number">1</span>] ); <span class="comment">//p借出一个关键码给v（作为最小关键码）</span></span><br><span class="line">         p-&gt;key[r - <span class="number">1</span>] = ls-&gt;key.remove ( ls-&gt;key.size() - <span class="number">1</span> ); <span class="comment">//ls的最大关键码转入p</span></span><br><span class="line">         v-&gt;child.insert ( <span class="number">0</span>, ls-&gt;child.remove ( ls-&gt;child.size() - <span class="number">1</span> ) );</span><br><span class="line">         <span class="comment">//同时ls的最右侧孩子过继给v</span></span><br><span class="line">         <span class="keyword">if</span> ( v-&gt;child[<span class="number">0</span>] ) v-&gt;child[<span class="number">0</span>]-&gt;parent = v; <span class="comment">//作为v的最左侧孩子</span></span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">//至此，通过右旋已完成当前层（以及所有层）的下溢处理</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="comment">//至此，左兄弟要么为空，要么太“瘦”</span></span><br><span class="line"><span class="comment">// 情况2：向右兄弟借关键码</span></span><br><span class="line">   <span class="keyword">if</span> ( p-&gt;child.size() - <span class="number">1</span> &gt; r ) &#123; <span class="comment">//若v不是p的最后一个孩子，则</span></span><br><span class="line">      BTNodePosi(T) rs = p-&gt;child[r + <span class="number">1</span>]; <span class="comment">//右兄弟必存在</span></span><br><span class="line">      <span class="keyword">if</span> ( ( _order + <span class="number">1</span> ) / <span class="number">2</span> &lt; rs-&gt;child.size() ) &#123; <span class="comment">//若该兄弟足够“胖”，则</span></span><br><span class="line">         <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">&quot; ... case 2\n&quot;</span> );</span><br><span class="line">         v-&gt;key.insert ( v-&gt;key.size(), p-&gt;key[r] ); <span class="comment">//p借出一个关键码给v（作为最大关键码）</span></span><br><span class="line">         p-&gt;key[r] = rs-&gt;key.remove ( <span class="number">0</span> ); <span class="comment">//ls的最小关键码转入p</span></span><br><span class="line">         v-&gt;child.insert ( v-&gt;child.size(), rs-&gt;child.remove ( <span class="number">0</span> ) );</span><br><span class="line">         <span class="comment">//同时rs的最左侧孩子过继给v</span></span><br><span class="line">         <span class="keyword">if</span> ( v-&gt;child[v-&gt;child.size() - <span class="number">1</span>] ) <span class="comment">//作为v的最右侧孩子</span></span><br><span class="line">            v-&gt;child[v-&gt;child.size() - <span class="number">1</span>]-&gt;parent = v;</span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">//至此，通过左旋已完成当前层（以及所有层）的下溢处理</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="comment">//至此，右兄弟要么为空，要么太“瘦”</span></span><br><span class="line"><span class="comment">// 情况3：左、右兄弟要么为空（但不可能同时），要么都太“瘦”——合并</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt; r ) &#123; <span class="comment">//与左兄弟合并</span></span><br><span class="line">      BTNodePosi(T) ls = p-&gt;child[r - <span class="number">1</span>]; <span class="comment">//左兄弟必存在</span></span><br><span class="line">      ls-&gt;key.insert ( ls-&gt;key.size(), p-&gt;key.remove ( r - <span class="number">1</span> ) ); p-&gt;child.remove ( r );</span><br><span class="line">      <span class="comment">//p的第r - 1个关键码转入ls，v不再是p的第r个孩子</span></span><br><span class="line">      ls-&gt;child.insert ( ls-&gt;child.size(), v-&gt;child.remove ( <span class="number">0</span> ) );</span><br><span class="line">      <span class="keyword">if</span> ( ls-&gt;child[ls-&gt;child.size() - <span class="number">1</span>] ) <span class="comment">//v的最左侧孩子过继给ls做最右侧孩子</span></span><br><span class="line">         ls-&gt;child[ls-&gt;child.size() - <span class="number">1</span>]-&gt;parent = ls;</span><br><span class="line">      <span class="keyword">while</span> ( !v-&gt;key.empty() ) &#123; <span class="comment">//v剩余的关键码和孩子，依次转入ls</span></span><br><span class="line">         ls-&gt;key.insert ( ls-&gt;key.size(), v-&gt;key.remove ( <span class="number">0</span> ) );</span><br><span class="line">         ls-&gt;child.insert ( ls-&gt;child.size(), v-&gt;child.remove ( <span class="number">0</span> ) );</span><br><span class="line">         <span class="keyword">if</span> ( ls-&gt;child[ls-&gt;child.size() - <span class="number">1</span>] ) ls-&gt;child[ls-&gt;child.size() - <span class="number">1</span>]-&gt;parent = ls;</span><br><span class="line">      &#125;</span><br><span class="line">      release ( v ); <span class="comment">//释放v</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//与右兄弟合并</span></span><br><span class="line">      BTNodePosi(T) rs = p-&gt;child[r + <span class="number">1</span>]; <span class="comment">//右兄度必存在</span></span><br><span class="line">      rs-&gt;key.insert ( <span class="number">0</span>, p-&gt;key.remove ( r ) ); p-&gt;child.remove ( r );</span><br><span class="line">      <span class="comment">//p的第r个关键码转入rs，v不再是p的第r个孩子</span></span><br><span class="line">      rs-&gt;child.insert ( <span class="number">0</span>, v-&gt;child.remove ( v-&gt;child.size() - <span class="number">1</span> ) );</span><br><span class="line">      <span class="keyword">if</span> ( rs-&gt;child[<span class="number">0</span>] ) rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs; <span class="comment">//v的最左侧孩子过继给ls做最右侧孩子</span></span><br><span class="line">      <span class="keyword">while</span> ( !v-&gt;key.empty() ) &#123; <span class="comment">//v剩余的关键码和孩子，依次转入rs</span></span><br><span class="line">         rs-&gt;key.insert ( <span class="number">0</span>, v-&gt;key.remove ( v-&gt;key.size() - <span class="number">1</span> ) );</span><br><span class="line">         rs-&gt;child.insert ( <span class="number">0</span>, v-&gt;child.remove ( v-&gt;child.size() - <span class="number">1</span> ) );</span><br><span class="line">         <span class="keyword">if</span> ( rs-&gt;child[<span class="number">0</span>] ) rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs;</span><br><span class="line">      &#125;</span><br><span class="line">      release ( v ); <span class="comment">//释放v</span></span><br><span class="line">   &#125;</span><br><span class="line">   solveUnderflow ( p ); <span class="comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若T的初始高度为$h$且含有$n$个内部节点，而在经过连续的若干次操作之后高度下降至1，则在此过程中T总计合并过多少次</p></blockquote><p>被合并的节点无非两种情况</p><ul><li>若它不是根节点，则树中的节点减少一个，同时树高保持不变，故有$n-=1$和$h-=0$</li><li>若是根节点，则除了原节点一分为二，还会新生成一个仅含单关键码的树根，同时树的高度也将相应的升高一层，故有:$n-=2$和$h-=1$</li></ul><p>因此，无论如何，$n$与$h$的差值$n-h$均会恰好减少一个单位。既然最终有：</p><p>$n=h=1$</p><p>故其间发生合并操作的次数等于$n-h$的初值。</p><p>以上结论和各关键码的数值大小以及具体的删除过程无关，仅取决于B树的最初和最终状态。</p><blockquote><p>设T的初始高度为1,在随后经过若干次插入和删除操作(次序任意，可能相间)，若在此其间做过S次分裂和M次合并，则必定有$S-M=n-h$</p></blockquote><p>在B树整个生命期内，$n-h$始终忠实地反应了分裂操作次数和合并操作次数之差。</p><p>推广，若初始节点数为$n_0$,高度为$h_0$,则经过若干次$S$次插入和$M$次删除操作后，高度为$h$,节点数为$n$，则B树的分裂次数为$S-M=n-h-(n_0-h_0)$</p><p>以上B树的插入和删除算法并不对称，比如，删除关键码时若发生下溢，则可能采用旋转(通过父节点间接地从兄弟借得一个关键码)或者合并两种手段加以恢复，然而在插入关键码时却只是统一地通过分裂来进行修复。</p><p>实际上理论来讲，也可优先通过旋转来修复上溢:只要某个兄弟仍处于非饱和状态，即可通过父亲间接地从该兄弟借出一个关键码。</p><p>表面上看，B树的插入操作和删除操作方向相反、过程互逆，但二者并非简单的对称关系。在删除操作的过程中，若当前节点下溢，未必能通过合并予以修复，除非其兄弟节点也出于下溢的临界状态。在插入过程中，若当前节点发生上溢，则无论其兄弟节点的状态和规模如何，总是可以立即对其实施分裂操作。</p><p>实际上就算法控制逻辑而言，优先进行分裂更为明了，在B树生命周期内，分裂操作通常不至于频繁发生，因此不妨采用优先分裂的策略。</p><p>另外，优先分裂也不至于导致空间利用率的显著下降。实际上，无论分裂出多少个节点，根据B树的定义，其空间利用率最差也不至于低于50%。</p><p>最后，优先分裂策略也不至于导致树高的明显增加，树高决定I/O负担以及访问效率的主要因素。B树高度主要取决于所存关键码的总数，和其中节点的数目几乎没有关系。</p><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>伸展树实现简便、无需修改节点结构、分摊复杂度低，但可惜最坏情况下单次操作需要$\Omega(n)$时间，故难以应用核电站、医院等可靠性和稳定性要求极高的场合。AVL树尽管可以保证最坏情况下的单次操作速度，但需在节点中嵌入平衡因子等标识，删除之后的重平衡可能需多达$\Omega(logn)$次旋转，从而频繁地导致全树拓扑结构地大幅变化。</p><p>红黑树通过为节点指定颜色，并巧妙地动态调整，可在每次插入或删除之后仅需常数个节点。尽管最坏情况下需对$\Omega(logn)$个节点重染色，但是分摊意义而言仅为$O(1)$个。</p><p>与之前类似，便于分析，红黑树同样引入外部节点。</p><p>红黑树的规则</p><ul><li>树根必定为黑色</li><li>外部节点必定为黑色</li><li>红之子、父必为黑</li><li>从任一外部节点到根节点的沿途，黑节点的数目相等</li></ul><h2 id="4阶B树"><a href="#4阶B树" class="headerlink" title="4阶B树"></a>4阶B树</h2><p>在红黑树和4阶B树之间，存在即为密切的联系：经适当转换之后，二者相互等价。</p><p>具体地，自顶而下考查红黑树各节点。每遇到一个红节点，都将对应的子树整体提升一层，从而与其父节点(必定为黑)水平对齐，二者之间的联边相应地调整为横向。如此转换以后，横向边向左或者向右，但由红黑树的条件，同向边必然不相邻，即便不考虑联边的左、右方向，沿水平方向相邻的边至多两条(向左、右)各一条，涉及的节点最多(一个节点加上零到两个红节点)。此时，若将红黑树中的节点视为关键码，则沿水平方向相邻的每一组节点恰好构成4阶B树的一个节点。</p><p>所有的可能情况有四种，相应的转换过程：</p><p><img src="https://i.loli.net/2019/09/14/AoJOaW2veMipu1K.png"></p><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>不妨假定经调用接口<code>search()</code>查找之后，确认目标节点尚不存在。在查找失败处的位置$x$创建节点，并随即将其染成红色(除非全树仅含一个节点)。</p><p>此时可能不满足红之父、子必黑的条件，此时x的父亲科恩那个也是红色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) RedBlack&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将e插入红黑树</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标不存在（留意对_hot的设置）</span></span><br><span class="line">   x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">-1</span> ); _size++; <span class="comment">//创建红节点x：以_hot为父，黑高度-1</span></span><br><span class="line">   solveDoubleRed ( x ); <span class="keyword">return</span> x ? x : _hot-&gt;parent; <span class="comment">//经双红修正后，即可返回</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>因新节点的引入而导致父子节点同为红色的情况，称为双红。为修正双红缺陷，可调用<code>solveDoubleRed(x)</code>。每引入一个关键码，该接口都可能调用多次。在此过程中，当前节点$x$的兄弟以及两个孩子始终均为黑色。</p><p>将$x$的父亲与祖父分别记作$p$和$g$。既然此前的红黑树合法，那么作为红节点的父亲，$g$必然存在，且为黑色。$g$作为内部节点，其另一孩子(即$p$的孩子，$x$的叔父)也必然存在，记作$u$。以下将视节点$u$的颜色不同，分两类情况处理。</p><p><strong>双红修正(RR-1)</strong></p><p>首先，考查$u$为黑色的情况。此时，$x$的兄弟、两个孩子的黑高度均与$u$相等。以下为其中的两种可能：</p><p><img src="https://i.loli.net/2019/09/14/USMY7jIRwepvfE1.png"></p><p>此时红黑树条件的违反，从B树等效来看，同一节点不应包含紧邻的红色关键码。只需令黑色关键码和相邻紧邻的红色关键码互换颜色，从红黑树的角度来看，等效于按照中序遍历序列，对节点$x$、$p$和$g$及其四棵子树做一次局部3+4重构。调整之后，局部子树的黑高度将复原，全树的平衡必然得以恢复。同时，新子树的根节点为黑色，也不致于引发新的双红现象。至此，整个插入操作遂告完成。</p><p><strong>双红修正(RR-2)</strong></p><p>再考查节点$u$为红色的情况，此时，$u$的左、右孩子非空且均为黑色，其黑高度必与x的兄弟以及两个孩子相等。以下为其中的两种可能：</p><p><img src="https://i.loli.net/2019/09/14/pF3Y1nMVKxT9SDQ.png"></p><p>从B树的角度来看，亦该节点超过4度而发生上溢。从红黑树的角度来看，只需将红节点$p$和$u$转为黑色，黑节点g转为红色，$x$保持红色，等效于在B树中的节点分裂操作，关键码$g$上升一层。</p><p>如此调整之后局部的黑高度复原，然而子树根节点转为红色后，可能再次引发双红现象，等效于B树在关键码被移出并归入上层节点后进而引发上层节点的上溢，即上溢的向上传播。</p><p>等效地将g视为刚插入的节点，分以上两类情况如法处置。每经过这样一次迭代，节点$g$都将在B树中上升一层，而在红黑树中存在双红缺陷的位置也将相应地上升两层，故累计至多迭代$O(logn)$次。</p><p>若最后一步迭代导致树根的分裂，并由$g$独立地构成新的树根节点，则应强行转为黑色，如此，全树的黑高度随即增加一层。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::solveDoubleRed ( BinNodePosi(T) x ) &#123; <span class="comment">//x当前必为红</span></span><br><span class="line">   <span class="keyword">if</span> ( IsRoot ( *x ) ) <span class="comment">//若已（递归）转至树根，则将其转黑，整树黑高度也随之递增</span></span><br><span class="line">      &#123;  _root-&gt;color = RB_BLACK; _root-&gt;height++; <span class="keyword">return</span>;  &#125; <span class="comment">//否则，x的父亲p必存在</span></span><br><span class="line">   BinNodePosi(T) p = x-&gt;parent; <span class="keyword">if</span> ( IsBlack ( p ) ) <span class="keyword">return</span>; <span class="comment">//若p为黑，则可终止调整。否则</span></span><br><span class="line">   BinNodePosi(T) g = p-&gt;parent; <span class="comment">//既然p为红，则x的祖父必存在，且必为黑色</span></span><br><span class="line">   BinNodePosi(T) u = uncle ( x ); <span class="comment">//以下，视x叔父u的颜色分别处理</span></span><br><span class="line">   <span class="keyword">if</span> ( IsBlack ( u ) ) &#123; <span class="comment">//u为黑色（含NULL）时 //*DSA*/printf(&quot;  case RR-1:\n&quot;);</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *x ) == IsLChild ( *p ) ) <span class="comment">//若x与p同侧（即zIg-zIg或zAg-zAg），则</span></span><br><span class="line">         p-&gt;color = RB_BLACK; <span class="comment">//p由红转黑，x保持红</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//若x与p异侧（即zIg-zAg或zAg-zIg），则</span></span><br><span class="line">         x-&gt;color = RB_BLACK; <span class="comment">//x由红转黑，p保持红</span></span><br><span class="line">      g-&gt;color = RB_RED; <span class="comment">//g必定由黑转红</span></span><br><span class="line"><span class="comment">///// 以上虽保证总共两次染色，但因增加了判断而得不偿失</span></span><br><span class="line"><span class="comment">///// 在旋转后将根置黑、孩子置红，虽需三次染色但效率更高</span></span><br><span class="line">      BinNodePosi(T) gg = g-&gt;parent; <span class="comment">//曾祖父（great-grand parent）</span></span><br><span class="line">      BinNodePosi(T) r = FromParentTo ( *g ) = rotateAt ( x ); <span class="comment">//调整后的子树根节点</span></span><br><span class="line">      r-&gt;parent = gg; <span class="comment">//与原曾祖父联接</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//若u为红色 </span></span><br><span class="line">      p-&gt;color = RB_BLACK; p-&gt;height++; <span class="comment">//p由红转黑</span></span><br><span class="line">      u-&gt;color = RB_BLACK; u-&gt;height++; <span class="comment">//u由红转黑</span></span><br><span class="line">      <span class="keyword">if</span> ( !IsRoot ( *g ) ) g-&gt;color = RB_RED; <span class="comment">//g若非根，则转红</span></span><br><span class="line">      solveDoubleRed ( g ); <span class="comment">//继续调整g（类似于尾递归，可优化为迭代形式）</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度</strong></p><table><thead><tr><th></th><th>旋转次数</th><th>染色次数</th><th></th></tr></thead><tbody><tr><td>u为黑</td><td>1~2</td><td>2</td><td>调整随即完成</td></tr><tr><td>u为红</td><td>0</td><td>3</td><td>或再次双红，但必上升两层</td></tr></tbody></table><p>对第一种情况，只需做一轮修正，后一种情况虽有可能需要反复修正，但由于修正位置的高度会严格单调上升，故总共不过$O(logn)$轮。每一轮只涉及常数次节点旋转或染色操作。</p><p>因此，在节点插入后的双红修正，累计耗时不会超过$O(logn)$。即便计入此前的关键码查找操作，红黑树的每次节点插入操作都可在$O(logn)$时间内完成。</p><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> RedBlack&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从红黑树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   BinNodePosi(T) r = removeAt ( x, _hot ); <span class="keyword">if</span> ( ! ( --_size ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//实施删除</span></span><br><span class="line"><span class="comment">// assert: _hot某一孩子刚被删除，且被r所指节点（可能是NULL）接替。以下检查是否失衡，并做必要调整</span></span><br><span class="line">   <span class="keyword">if</span> ( ! _hot ) <span class="comment">//若刚被删除的是根节点，则将其置黑，并更新黑高度</span></span><br><span class="line">      &#123; _root-&gt;color = RB_BLACK; updateHeight ( _root ); <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="comment">// assert: 以下，原x（现r）必非根，_hot必非空</span></span><br><span class="line">   <span class="keyword">if</span> ( BlackHeightUpdated ( *_hot ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//若所有祖先的黑深度依然平衡，则无需调整</span></span><br><span class="line">   <span class="keyword">if</span> ( IsRed ( r ) ) <span class="comment">//否则，若r为红，则只需令其转黑</span></span><br><span class="line">      &#123; r-&gt;color = RB_BLACK; r-&gt;height++; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="comment">// assert: 以下，原x（现r）均为黑色</span></span><br><span class="line">   solveDoubleBlack ( r ); <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//经双黑调整后返回</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure><p>为删除关键码e，首先调用<code>BST::search(e)</code>进行查找，若查找成功，则调用内部接口<code>removeAt(x)</code>删除。$x$为实际被摘除者，其父亲为$r$，而$r$的兄弟首次必然为NULL。根据红黑树的定义，关键码$e$必然有左、右子树，$x$为关键码$e$的后继，即为关键码$e$的右子树中最左者，必定左孩子为空。</p><p>因随后的复衡位置可能逐层上升，可等效理解为:$w$为一棵与$r$等高的红黑子树，随x一并摘除。</p><p>此时红之子、父必黑和全树黑高度相同条件未必满足。</p><p>若$x$为原树根，则无论$r$颜色如何，只需将其置为黑色并更新黑高度即可。不妨假定，$x$的父亲$p$存在。</p><p><img src="https://i.loli.net/2019/09/14/fY3hx9C2E1doqr6.png"></p><p>$x$为红色，则在摘除子树$w$之后，并将$x$替换为$r$之后，局部子树的黑高度即可复原。即便$x$为黑色，只需在删除之后将$r$翻转为黑色，亦可使局部子树的高度复原。若$x$和$r$均为黑色，则在删除操作之后，局部子树的黑高度将上升一个单位。</p><p>被删除节点$x$及其替代者同为黑色的情况，称为双黑，此时，需调用<code>solveDoubleBlack(x)</code>予以修正。为此，需考查原黑节点$x$的兄弟$s$(必然存在，但可能是外部节点)，按照$s$和$p$的不同颜色，按四种情况分别处理。</p><p><strong>双黑修正(BB-1)</strong></p><p>若$s$至少有一个红孩子$t$，既然节点$x$的另一孩子<code>w=NULL</code>,节点x删除后可等效为B树中关键码$x$原属的节点发生下溢，此时，$t$和$s$必然属于B树的同一节点，该节点就是下溢节点的兄弟。参照B树的调整方法，下溢节点从父节点借出一个关键码，然后父节点从下溢节点的兄弟节点借出一个关键码。</p><p><img src="https://i.loli.net/2019/09/14/bmKkAOzeqQ78p2l.png"></p><p>其中六边形节点的颜色不确定，可为红色也可为黑色。若$p$为红，则问号之一为黑，若$p$为黑，则自成一个节点。</p><p>从红黑树的角度来看，上述调整过程等效于对节点$t$、$s$、$p$实施3+4重构。若这三个节点按照中序遍历序列重命名为$a$、$b$、$c$,则还需将$a$和$c$染成黑色，$b$则继承此前的颜色。整个过程中节点$r$保持黑色不变。</p><p><strong>双黑修正(BB-2-A)</strong></p><p>若$s$为黑，且两个孩子均为黑，根据$p$的颜色不同，又存在两种情况，先讨论$p$为红的情况</p><p><img src="https://i.loli.net/2019/09/14/F9lHps87O24BI6i.png"></p><p>在对应的B树中，关键码$x$的删除导致其所属的节点下溢，但因此时关键码$s$所在的节点只有两个分支，所以下溢节点无法从父节点借出关键码。按照B树平衡算法，应该将关键码$p$取出并下降一层，并将原左、右孩子合并为一个节点。从红黑树的角度来看，这等效于$s$和$p$颜色互换。</p><p>经过以上处理，红黑树所有条件均在此局部得以恢复。另外，关键码$p$原为红色，在p的左侧或右侧必然还有一个黑色关键码(当然，不可能左、右兼有)，在关键码$p$从其中取出之后，不致引发新的下溢。至此，红黑树的条件亦必在全局得以恢复，删除操作即告完成。</p><p><strong>双黑修正(BB-2-B)</strong></p><p>同样，在对应的B树中，因关键码$x$的删除，导致其所属节点发生下溢。可将下溢节点与其兄弟合并，从红黑树来看，这等效于节点$s$由黑转红。</p><p>经过以上处理后，红黑树所有的条件都将在此局部得以恢复。</p><p>既然$s$和$x$在此前均为黑色，故$p$原所属的B树节点必然仅含$p$这一个关键码，于是在$p$被借出后，该节点必将发生下溢，从而有待于后续的进一步修正。从红黑树的角度看，此时的状态等效于节点$p$的(黑色父亲)刚被删除。</p><p><img src="https://i.loli.net/2019/09/14/ELKZVwIXD9CoghB.png"></p><p>这也是在双黑修正过程中唯一需要再次迭代的可能，但下溢的位置不断上升，故至多迭代$O(logn)$次必然终止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::solveDoubleBlack ( BinNodePosi(T) r ) &#123;</span><br><span class="line">   BinNodePosi(T) p = r ? r-&gt;parent : _hot; <span class="keyword">if</span> ( !p ) <span class="keyword">return</span>; <span class="comment">//r的父亲</span></span><br><span class="line">   BinNodePosi(T) s = ( r == p-&gt;lc ) ? p-&gt;rc : p-&gt;lc; <span class="comment">//r的兄弟</span></span><br><span class="line">   <span class="keyword">if</span> ( IsBlack ( s ) ) &#123; <span class="comment">//兄弟s为黑</span></span><br><span class="line">      BinNodePosi(T) t = <span class="literal">NULL</span>; <span class="comment">//s的红孩子（若左、右孩子皆红，左者优先；皆黑时为NULL）</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRed ( s-&gt;rc ) ) t = s-&gt;rc; <span class="comment">//右子</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRed ( s-&gt;lc ) ) t = s-&gt;lc; <span class="comment">//左子</span></span><br><span class="line">      <span class="keyword">if</span> ( t ) &#123; <span class="comment">//黑s有红孩子：BB-1</span></span><br><span class="line">         RBColor oldColor = p-&gt;color; <span class="comment">//备份原子树根节点p颜色，并对t及其父亲、祖父</span></span><br><span class="line">      <span class="comment">// 以下，通过旋转重平衡，并将新子树的左、右孩子染黑</span></span><br><span class="line">         BinNodePosi(T) b = FromParentTo ( *p ) = rotateAt ( t ); <span class="comment">//旋转</span></span><br><span class="line">         <span class="keyword">if</span> ( HasLChild ( *b ) ) &#123; b-&gt;lc-&gt;color = RB_BLACK; updateHeight ( b-&gt;lc ); &#125; <span class="comment">//左子</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *b ) ) &#123; b-&gt;rc-&gt;color = RB_BLACK; updateHeight ( b-&gt;rc ); &#125; <span class="comment">//右子</span></span><br><span class="line">         b-&gt;color = oldColor; updateHeight ( b ); <span class="comment">//新子树根节点继承原根节点的颜色</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//黑s无红孩子</span></span><br><span class="line">         s-&gt;color = RB_RED; s-&gt;height--; <span class="comment">//s转红</span></span><br><span class="line">         <span class="keyword">if</span> ( IsRed ( p ) ) &#123; <span class="comment">//BB-2R</span></span><br><span class="line">            p-&gt;color = RB_BLACK; <span class="comment">//p转黑，但黑高度不变</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//BB-2B</span></span><br><span class="line">            p-&gt;height--; <span class="comment">//p保持黑，但黑高度下降</span></span><br><span class="line">            solveDoubleBlack ( p ); <span class="comment">//递归上溯</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//兄弟s为红：BB-3</span></span><br><span class="line">      s-&gt;color = RB_BLACK; p-&gt;color = RB_RED; <span class="comment">//s转黑，p转红</span></span><br><span class="line">      BinNodePosi(T) t = IsLChild ( *s ) ? s-&gt;lc : s-&gt;rc; <span class="comment">//取t与其父s同侧</span></span><br><span class="line">      _hot = p; FromParentTo ( *p ) = rotateAt ( t ); <span class="comment">//对t及其父亲、祖父做平衡调整</span></span><br><span class="line">      solveDoubleBlack ( r ); <span class="comment">//继续修正r处双黑——此时的p已转红，故后续只能是BB-1或BB-2R</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>双黑修正(BB-3)</strong></p><p>最后，考虑$s$为红的情况</p><p>此时作为红节点$s$的父亲，节点$p$必定为黑色，同时,$s$的两个孩子也为黑色。</p><p>从B树的角度来看，只需令关键码$s$与$p$互换颜色，即可得到一棵与之完全等价的B树。从红黑树的角度来看，这一转换对应于以节点$p$为轴做一次旋转，并交换节点$s$和$p$的颜色。</p><p>经如此处理之后，子树$r$的黑高度并未恢复，缺陷位置也并未上升。</p><p><img src="https://i.loli.net/2019/09/14/OJHFB9piry1g8dl.png"></p><p>此时r有了一个新的黑兄弟，故转化为前面的情况，由于$p$为红色，所以取决于$S$的孩子颜色，若有一为红，则BB-1,若均为黑，则BB-2R。</p><p>再经过一轮调整后，红黑树性质必然全局恢复。</p><p><strong>复杂度</strong></p><table><thead><tr><th></th><th>旋转次数</th><th>染色次数</th><th>此后</th></tr></thead><tbody><tr><td>黑$s$有红子$t$</td><td>1~2</td><td>3</td><td>调整随即完成</td></tr><tr><td>黑$s$无红子，$p$红</td><td>0</td><td>2</td><td>调整随即完成</td></tr><tr><td>黑$s$无红子，$p$黑</td><td>0</td><td>1</td><td>必然再次双黑，但将上升一层</td></tr><tr><td>红$s$</td><td>1</td><td>2</td><td>转化为1或者2R</td></tr></tbody></table><p>红黑树的每一删除操作都将在$O(logn)$时间内完成，其中至多做$O(logn)$,一次3+4重构，一次单旋。</p><p>就分摊意义而言，红黑树重平衡过程中所做的重染色操作不过常数次。</p><h1 id="kd树"><a href="#kd树" class="headerlink" title="kd树"></a>kd树</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><p>给定直线上$l$上的点集$P={p_{0},p_{1},p_{2},p_{3},…,p_{n-1}}$,对于任一区间$[x_1,x_2]$，</p><ul><li>计数：有多少点落在其中？</li><li>报告：枚举所有落在其中的点</li></ul><p>很多实际问题可归结为以上问题，比如在校友数据库中查找1970到2000级的学生，或者查询IP介于166.111.68.1至168.111.68.255之间的在线节点等。</p><p><strong>蛮力算法</strong></p><p>表面看来，一维范围查询只需遍历点集$P$,并逐个花费$O(1)$时间判断各点是否落在区间内，如此总体运行时间为$O(n)$。</p><p>当点集规模大到需要借助外部存储器时，遍历整个点集必然引发大量I/O操作。</p><p>另外，当数据点的坐标分布范围较大时，通常所查询的点在整个输入点集中仅占比较大甚至极低的比例。</p><p>在典型的范围查询应用中，输入点集数据和查询区域特点迥异。一方面，输入点集$P$通常会在相当长的时间内保持相对固定，即以批处理或离线形式给出的数据。同时，往往需要针对大量随机定义的区间$R$，即以在线方式给出地数据，反复地进行查询。可通过适当的预处理将输入点集提前整理和组织为某种适当的数据结构，来有效提高此后各次查询的效率。</p><p><strong>有序向量</strong></p><p>最为简便易行的预处理方法，就是在$O(nlogn)$时间内将点集$P$组织为一个有序向量。</p><p>此后，对于任何$R=[x_1,x_2]$,首先利用有序向量的查找算法，在$O(logn)$时间内找到不大于$x2$的最大点$p_t$，自右向左地遍历向量中各点，直至第一个离开查询范围的$p_s$。其间经过的所有点均属于区间范围，故可以直接输出。</p><p>如此，在每一次查询中,$p_t$的定位需要$O(log n)$。若接下来的遍历总共报告出$r$个点，则总体查询成本为$O(r+logn)$。</p><h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p>在实际应用中往往需要同时对多个维度做范围查找。以人事数据库查询为例，诸如”年龄介于某个区间且工资介于某个区间”之类的组合查询非常普遍。若将年龄和工资分别表示为两个正交维度，则人事数据库中的记录将对应于二维平面上的点。针对某一相对固定点集的范围查询，其查询范围可描述为矩形$R=[x_1,x_2][y_1,y_2]$。</p><p>这时候，以上基于二分查找的方法并不能直接推广至二维情况。</p><p>不妨在$O(nlogn)$时间内将输出点集组织并转化为二叉搜索树。尽管其中各节点的关键码可能重复，但是每个关键码至多重复一次，总体依然只需$O(n)$时间。尽管相对常规的二叉搜索树多出一层，但树高依然是$O(logn)$。</p><p><strong>查询算法</strong></p><p><img src="https://i.loli.net/2019/11/15/u6mtMnZhkaFCWJ7.png"></p><p>例如，设查询区间为$[1,23]$</p><p>首先，在树中查找这一区间的左、右端点$1$和$23$，分别终止与叶节点$3$和$24$。</p><p>接下来，考查这两个叶节点共同祖先中的最低者，即所谓的最低共同祖先(lowest common ancestor,LCA)，具体地亦即</p><p>$lca(3,24)=15$</p><p>然后，沿着这一共同祖先节点出发，分别重走一遍通往$3$和$24$的路径。在沿着$path(3)/path(24)$下行的过程中，忽略所有的左/右转，而对于每一次左/右转都需要遍历对应的右子树/左子树，并将其中的叶节点悉数报告出来。沿着$path(3)$被报告出来的叶节点子集，依次为：</p><p>$9,12,14,15$ 、$4,7$、$3$</p><p>沿着$path(24)$报告出来的叶节点子集依次为${17,20}$、${22}$</p><p>在每一次查询过程中，针对左、右端点的两次查找以及其路径的重走，各自不过$O(logn)$时间。在树的每一层次上，两条路径各自至多报告一棵子树，故累计不过$O(logn)$棵。为枚举这些子树中的点，对它们的遍历累计不超过$O(r)$时间，其中$r$为实际报告的点数。</p><p>每次查询可在$O(r+logn)$时间内完成。该查询算法的运行时间也与输出规模相关，故同样属于输出敏感的算法。</p><p><strong>kd树</strong></p><p>循着用二叉平衡搜索树实现一维查询的构思，可将待查询的二维点集组织为所谓的kd树结构。在任何的维度下，kd树都是一棵递归定义的二叉树。</p><p>以二维为例，就2d树的原理以及构造和查询算法做一介绍。</p><p>2d树中的每一个节点都对应于二维平面上的某一矩形区域，且其边界斗鱼坐标轴平行。</p><p>同层节点对应的矩形区域经合并之后恰好可覆盖整个平面，同时其间又不得有任何交叠。统一约定，每个矩形区域的左边和底边开放，右边和底边封闭。</p><h2 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h2><p>树根必然对应于整个平面，若$P$为输入点集与树中当前节点所对应的矩形区域的交集(即落在其中的所有点)，则可递归地将该矩形区域切分为两个矩形子区域，且各包含$P$中一半点。</p><p>若当前节点深度为偶(奇)树，则沿垂直(水平)方向切分，所得子区域随同包含的输入点分别构成左、右孩子，如此不断直到子区域仅含单个输入点。每次切分都在中位点(按照对应坐标排序中居中者)处进行，以保证全树高度不超过$O(logn)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">KdTree* <span class="title">buildKdTree</span><span class="params">(P,d)</span></span>&#123;<span class="comment">//在深度为d的层次，构造一棵对应于(子)集合P的2d树</span></span><br><span class="line">  <span class="keyword">if</span>(p==&#123;p&#125;) <span class="keyword">return</span> CreateLeaf(p);<span class="comment">//递归基</span></span><br><span class="line">  root=CreateKdNode();<span class="comment">//创建(子)树根</span></span><br><span class="line">  root-&gt;splitDirection=Even(d)?VERTICAQL:HORITIZAL;<span class="comment">//确定划分方向</span></span><br><span class="line">  root-&gt;splitLine=FindMedian(root-&gt;SplitDirection,P);<span class="comment">//确定中位点</span></span><br><span class="line">  (P1,P2)=Divide(P,root-&gt;splitDirection,root-&gt;splitLine);<span class="comment">//子集划分</span></span><br><span class="line">  root-&gt;lc=buildKdTree(P1,d+<span class="number">1</span>);<span class="comment">//在深度为d+1的层次，递归构造左子树</span></span><br><span class="line">  root-&gt;rc=buildKdTree(p2,d+<span class="number">1</span>);<span class="comment">//在深度为d+1的层次，递归构造右子树</span></span><br><span class="line">  <span class="keyword">return</span> root;<span class="comment">//返回子树的树根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如</p><p><img src="https://i.loli.net/2019/11/15/vAWzLa3b2KCUOYX.png"></p><p>第一轮切分以水平方向的中位点$C$为界，将整个平面分为左、右两半，点集$P$也相应地划分为子集${A,B,C,G}$和${D,E,F}$，随同对应的半平面，被指派给深度为1的两个节点。</p><p>第二轮切分对于左半平面以及对应的子集${A,B,C,G}$,以垂直方向的中位点$B$为界，将其分为上下两半，并分别随同子集${B,G}$和${A,C}$,指派给深度为2的一对节点；对于右半平面及其对应的子集${D,E,F}$,以垂直方向的中位点$F$为界，将其分为上、下两半，并随同子集${E,F}$和${D}$,指派给深度为2的另一对节点。</p><p>最后一轮切分对树中含有至少两个输入点的三个深度为2的节点，分别沿水平方向的中位点，将他们分为左、右两半，并随同对应的子集分配给三对深度为3的节点。至此，所有叶节点均只包含单个输入点，对平面的划分遂告完成，同时与原输入点集$P$对应的一棵2d树也构造完毕。</p><blockquote><p>若中位点可在线性时间内确定，则kd树构造算法buildKdTree()的总体执行时间可改进至$O(nlogn)$，其中$n$为点集输入规模</p></blockquote><p>在该分治问题中，每个问题(kd树的构造)都可在线性时间内均衡地划分为两个子问题，而且每个子问题地解都能在常数时间内合并原问题的解，于是，其时间复杂度$T(n)$对应的递推式：</p><p>$T(n)=T(n/2)+O(n)$</p><p>$T(n)=O(nlogn)$</p><blockquote><p>基于2d树的范围查询</p></blockquote><p>经过如上预处理，将待处理点集$P$转化为一棵2树之后，对于任一矩形查询区域$R$,范围查询的过程均从树根节点出发，按如下方式递归进行。</p><p>在任一节点$v$处，若子树$v$仅含单个节点，则意味着矩形区域$v$中仅覆盖单个输入点，此时可直接判断该点是否落在$R$内。否则，不妨假设矩形区域$v$含有多个输入点。</p><p>此时，视矩形区域$v$与查询区域$R$的相对位置，分为三种情况</p><ul><li>若矩形区域$v$完全包含于$R$内，则其中所有的输入点均落在$R$内，于是只需遍历一趟子树$v$，即可报告这部分输入点</li><li>若二者相交，则有必要深入到$v$的左、右子树中，继续递归地查询</li><li>若二者彼此分离，则子集$v$中的点不可能落在$R$内，对应的递归分支至此即可终止</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">kdSearch&#123;</span><br><span class="line">  <span class="keyword">if</span>(isLeaf(v))</span><br><span class="line">    &#123;<span class="keyword">if</span>(inside(v,R) report(v),<span class="keyword">return</span>;)&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(region(v-&gt;lc) in R )</span><br><span class="line">    reportSubtree(v-&gt;lc);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(region(v-&gt;lc) intersect R != emptyset)</span><br><span class="line">    KdSearch(v-&gt;lc,R);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(region(v-&gt;rc) in R)</span><br><span class="line">    reportSubTree(v-&gt;rc);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(region(v-&gt;rc) intersect R!=emptyset)</span><br><span class="line">    Kdsearch(v-rc,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在树中某一节点发生递归，当且仅当与该节点对应的子区域，与查询边界相交</p></blockquote><p>按照该算法的控制逻辑，只要当前子区域与$R$的边界相交时，即会发生递归；反之，无论是当前子区域是完全处于$R$之内(直接遍历当前子树并枚举其中的点)还是完全处于$R$之外(当前递归实例直接返回)，都不会发生递归。</p><blockquote><p>若令$Q(n)=$规模为$n$的子树中与查询边界相交的子区域(节点总数)，则有$Q(n)=2+2Q(n/4)=O(\sqrt n)$</p></blockquote><p>设$R$为任一查询区域，根据其对应子区域与$R$边界的相交情况，kd树中的所有节点可划分为以下几类：</p><ul><li>与$R$的边界不相交</li><li>只与$R$的一条边相交</li><li>同时与$R$的多条边相交</li></ul><p>根据定义，kd树自顶而下地经过$k$层，切分的维度方向即循环一轮。因此，不妨考查与$R$边界相交的任一节点，以及该节点起向下的$k$代子孙节点。对于2d树而言，也就是考查与R边相交的任一节点，以及它的$2$个子辈节点(各自大致包含$n/2$个点)和4个孙辈节点(各自大致包含n/4个点)。</p><p>无论这四个孙辈节点的相对位置和大小如何，该直线至多与其中的$2$个相交;反过来，至少有两个节点(子区域)不再发生递归。于是，可得到以下递归关系：</p><p>$Q(n) \leq 2+2Q(n/4)$</p><p>再结合边界条件</p><p>$Q(1)=1$</p><p>$Q(n)=\sqrt n$</p><p>以上未统计第二类节点，这一类节点只占少数，渐进意义而言并不影响总体的上界。</p><blockquote><p>kdSearch()的实际运行时间为$O(r+logn)$</p></blockquote><p>从递归的角度来看，若忽略对<code>reportSubtree()</code>的调用，kd树范围查询算法的每一递归实例本身仅需$O(1)$时间。查询需要$O(\sqrt n)$时间。</p><p><code>reportSubtree()</code>是通过遍历子树$v$，在线性时间内枚举其中的命中点。整个算法对该例程的调用累计时间应线性正比于输出规模$ O(r)$。</p><p>kd树中节点$v$所对应的矩形区域即便与查询范围$R$相交，其中所含输入点也不见得会落在$R$内。比如在极端的情况下，$v$中可能包含大量的输入点，但却没有一个落在$R$内，在此类情况下所做的递归都是不必进行的。</p><p>可在依然保持各边平行于坐标轴，同时包含输入点子集不变的前提下，尽可能地收缩各矩形子区域，等效于将原来的矩形替换为仍然覆盖其中所有输入点的最小矩形。</p><p><strong>四叉树</strong></p><p>四叉树是2d树的简化形式，其简化策略为：</p><ol><li>直接沿区域的(水平或区域平分)，从而省略了中位点的计算</li><li>沿垂直方向切处的每一对节点(各自再沿着水平方向切分)都经合并后归入其父节点</li><li>被合并的节点即便原先(因所含的输入点不足两个)而为继续切分，在此也需强行(沿水平方向)切分一次</li></ol><p>与kd树不同，四叉树可能包含大量的空节点，此类节点的规模无法由输入规模$n$界定。</p><p>对于任一输入点集，若将其中所有点对中的最长距离、最短距离分别记作$D$和$d$，则$\lambda=D/d$称作$P$的散布度，$P$所对应的四叉树高度为$O(log\lambda)$。</p><p>与kd树一样，四叉树中的节点也唯一地对应于某个矩形子区域；同一深度上各节点所对应的子区域面积相等，彼此无交，且它们的并覆盖整个空间。</p><p>其中，根节点对应的子区域边长为$D$,其下$4$个子节点所对应的子区域为$D/2$,再下一层的$16$个孙辈节点对应的子区域边长为$D/4$,…最底层节点对应的子区域边长为$d$。</p><p>由上可知，整个四叉树的高度不超过$O(log \lambda)$。</p><p>基于四叉树的范围查询算法和基于kd树的查询算法基本相同，从递归的角度来看，对于任一节点的查询任务都可分解为对$4$个子节点(细分子区域)的查询子任务。其中，有些子任务需要继续递归(子区域与查询区域的边界相交)，有些子任务则立即以失败返回(子区域与查询的边界相交)，有些子任务则立即以成功返回(子区域完全落在查询范围以内)。</p><blockquote><p>针对范围查询这一应用，分别从时间、空间角度将四叉树和2d树比较</p></blockquote><p>尽管四叉树与kd树的算法基本相同，但是却有着本质区别，从而导致其时间、空间性能远不如kd树。主要的原因体现在以下方面：</p><p>首先，四叉树中存在大量的空节点，因此在查找过程中即便能够确定某一结点完全落在查询区域内部，也不能在线性时间内枚举出其中有效的各点，通常情况下会远远超过$O(r)$。</p><p>另外，四叉树的高度取决于点集的散布度$\lambda$，而不是点集的规模。因此树高没有明确的上限，递归深度和查找长度也难以有效控制，在各点分布极其不均匀的场合，树高往往会远远超过$O(logn)$。</p><p>以下对平均情况做一估计：</p><p>不妨假定所有点均取自单位正方形$[0,1][0,1]$,对应四叉树高度为$h$。查询矩形区域$R$的长度和宽度分别为$x$和$y$。</p><p>在深度为$k$的任一层($0 \leq k\leq h$),共有$4^k$个节点，分别对应于$4^k$个互不相交的子正方形(有些不含任何点)，面积统一为$4^{-k}$。故节点总数为：</p><p>$\displaystyle N=\sum_{k=0}^{h}=(4^{h+1}/3) \approx 4^{h+1}/3 $</p><p>在深度为$k$的每一层，与查询区域$R$相交(并因此需要耗费时间)的节点总数大致为：</p><p>$\displaystyle (x2^k+1)(x2^k+1)=xy4^k+(x+y)2^k+1$</p><p>故所有各层与$R$相交者的总数大致为：</p><p>$\sum_{k=0}^{h}[xy4^k+(x+y)2^k+1]$</p><p>$\approx xy4^{h+1}/3+(x+y)2^{h+1}+(h+1)$</p><p>$=xyN+(x+y)\sqrt{3N}+log_4{3N}$</p><p>$=O(xyN)$</p><p>主要取决于查询区域$R$的面积$xy$,以及四叉树的划分粒度$N$。</p><p>将2d树推广至kd树，kd树即k维度上，类似2d树，递归地从${1,2,3,…,k}$对空间进行划分。</p><p>针对kd树的范围查询可在$O(r+n^{1-1/d})$时间内完成,kd树的空间复杂度为$O(n)$,在$O(nlogn)$时间内构造一棵kd树。</p><h1 id="多层搜索树"><a href="#多层搜索树" class="headerlink" title="多层搜索树"></a>多层搜索树</h1><p>范围查询的另一解法需要借助范围树，首先按照$x$坐标将平面上所有点组织为一棵二叉平衡搜索树，称为主树。该树每个节点各自对应于一个竖直的条带区域：左右孩子所对应的条带互不重叠，均由父节点所对应的条带垂直平分而得；同一深度上所有节点所对应的条带也互相不重叠，而且它们合并后恰好覆盖整个平面。</p><p>接下来，分别对于主树中的每一节点，将落在其所对应条带的输入点视为一个输入子集，并同样采用以上方法，按照y坐标将各个子集组织为一棵平衡二叉搜索树，称为关联树，每个关联树所对应的数值条带都会进一步细分为多个矩形区域，这些矩形区域也同样有以上主树各节点所对应的性质。至此，主树与这$O(n)$棵子树构成了一个两层的嵌套结构，即所谓的范围树。</p><p>对于任一范围查询$R=[x_1,x_2][y_1,y_2]$,首先按照$[x_1,x_2]$对主树做一次$x$方向上的查询，可得到$O(logn)$个节点，所对应的竖直条带互不重叠，合并后恰好覆盖$x$坐标落在$[x_1,x_2]$范围内的所有输入点。</p><p>深入这些节点各自对应的关联树，分别按照$[y_1,y_2]$做一次$y$方向的范围查询。如此从每棵关联树中取出的一系列节点也具有与以上取自主树节点类似的性质，这些节点所对应的矩形区域互不重叠，且它们合并之后恰好覆盖了当前竖直条带内$y$坐标落在$[y_1,y_2]$范围内的所有输入点，这些点合并后将给出所有落在$R$中的输入点，不重也不漏。</p><blockquote><p>范围树的空间复杂度为$O(nlogn)$</p></blockquote><p>主树自身仅需$O(n)$空间，对于每一点，统计它可能存在于多少棵关联树中</p><p>任一点$p$出现在关联树中，当且仅当在主树中，该关联树对应的节点是$p$所对应叶节点的祖先。在平衡二叉搜索树中，每个节点的祖先均不超过$O(logn)$个。</p><p>与kd树的查询算法类似，范围树的查询算法首先沿$x$方向做一次范围查找，并在主树中挑选出不超过$O(logn)$个节点。</p><p>然后，对于其中的每个节点，在与之对应的关联树种，沿$y$方向各做一次范围查询。关联树中每一棵命中的子树都可通过遍历在线性时间内枚举其中节点。</p><p>以上范围查询算法的时间复杂度为$O(r+logn)$。</p><ol><li><p>对主树的查找耗时$O(logn)$</p></li><li><p>对$O(logn)$棵关联树的查找分别耗时$O(logn)$，累计即耗时$O(log^2n)$</p><p>再计入枚举所需的$O(r)$时间。</p></li></ol><p>拓展到$d$维范围查找，使用$d$级搜索树，构造时间和空间复杂度为$O(nlog^{d-1}n)$,查找时间复杂度为$O(log^d{n}+r)$</p><p>在每一次范围查询中，所涉及关联树的查找具有极其强的关联性质,入口参数均为$ [y_1,y_2]$</p><p>参考<a href="https://dsa.cs.tsinghua.edu.cn/~deng/cg/cgaa/cgaa.3rd-edn.cn.pdf">计算几何</a>,可借助分散层叠来加速查找。</p><p>为此需要在主树中每一父子节点所对应的关联树种添加一系列的索引。</p><p><img src="https://i.loli.net/2019/11/16/Rnp8H3196dbYezZ.png"></p><p>设主树种的节点$V_l$和$V_r$是$V$的左右孩子，它们各自对应的关联书可简化地表示为有序向量(等效于关联树的中序遍历序列)，于是，在$V$关联树中查找结果可以直接为其孩子节点所利用，相应的查找成本由$O(logn)$降低至$O(1)$。当然，对于最低公共祖先的那棵树，还是需要做一次$O(logn)$的查找。</p><p>综上所述，范围树可在$O(logn+logn)=O(logn)$时间内完成查找，并在$O(r)$时间内报告查询结果。</p><p>推广至更高维度的情况，分散层叠只针对查找的最后一层有效，其余层上的树仍然需要$O(logn)$的时间来查找。</p><p>给定$d$维空间的$n$个点，范围查询可在$O(r+log^{d-1}n)$时间内完成。</p><p>对应的范围树需要$O(nlog^{d-1}n)$空间，构造时间复杂度为$O(nlog^{d-1}n)$。</p><p>以下对输入点集规模为$n$时$d$($d&gt;2$)维范围查询时各种树的性能对比，可以看出范围树较多层搜索树更优，与kd树的关系是空间换时间。</p><table><thead><tr><th></th><th>空间复杂度</th><th>构造时间复杂度</th><th>查询时间复杂度</th></tr></thead><tbody><tr><td>kd树</td><td>$ O(n)$</td><td>$O(nlogn)$</td><td>$O(n^{1-1/k}+r)$</td></tr><tr><td>多层搜索树</td><td>$O( nlog^{d-1}n)$</td><td>$O(nlog^{d-1}n)$</td><td>$O(log^{d}n+r)$</td></tr><tr><td>范围树</td><td>$O(nlog^{d-1}n)$</td><td>$O(nlog^{d-1}n)$</td><td>$O(log^{d}n+r)$</td></tr></tbody></table><h1 id="区间树"><a href="#区间树" class="headerlink" title="区间树"></a>区间树</h1><p>kd树、多层搜索树、范围树旨在解决输入点集$P$中哪些点落在给定区间$S$中的问题，而区间树、线段树旨在解决输入区间$S$中哪些区间包含给定点$q$的问题。其中线段树是一个静态结构，用于数据存储查询，不能进行修改；而区间树是支持动态修改和查询的数据结构。</p><h2 id="构造算法-1"><a href="#构造算法-1" class="headerlink" title="构造算法"></a>构造算法</h2><p>在所有点线段的端点中($n$条线段有$2n$个端点)中选取中位数，所有区间可分为三个子集</p><p>$S_{left}={S_i|x_{i’}&lt;x_{mid}}$</p><p>$S_{right}={S_i|x_{mif}&lt;x_{i}}$</p><p>$S_{mid}={x_i\leq x_{mid}\leq x_{i’}}$</p><p>前两种情况均可递归解决，第三种情况则将第$3$个子集所有端点按序保存在当前层的节点中，如此构造一棵区间树。每个节点中存储$S_{mid}$中的线段，$S_{left}$和$S_{right}$则分别在左、右子树中。</p><p>每个端点在树中仅出现一次，共$2n$个端点，故空间复杂度位$O(n)$。按照中点来划分区间，树是哦ing哼的，树高为$O(logn)$，构造算法避免了重复的排序，时间复杂度为$O(nlogn)$。</p><p>查询过程中只需判断当前搜索点是否在当前节点$S_{mid}$的每个区间中，然后根据待搜索点与$S_{mid}$中位点的大小关系，决定分支转向，总体时间复杂度为$O(logn)$。</p><p>查询时间复杂度为$O(r+logn)$。</p><h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>$n$个输入区间至多有$2n$个不同的端点，将$x$轴分成至多$2n+1$个首尾相接的小区间，根据区间排序结果构造二叉平衡搜索树，每个叶节点对应一个小区间，为每个小区间维护对应输入区间的集合可能需要$O(n^2)$空间复杂度。</p><h2 id="构造算法-2"><a href="#构造算法-2" class="headerlink" title="构造算法"></a>构造算法</h2><p>若某个输入区间$a$覆盖了一个节点$b$所有的叶节点，同时不可覆盖节点$b$的父节点，则将该输入区间$a$加入节点$b$对应输入区间的集合，则不必在$b$的子树的每个叶节点都存储$a$的信息，每个区间最多在每层存储两次，至多消耗$O(logn)$，于是$n$个节点空间复杂度为$O(nlogn)$。构造时间复杂度为$O(nlogn)$，查询时间复杂度为$O(r+logn)$。</p><p>输入区间规模为$n$区间树和线段性能对比</p><table><thead><tr><th></th><th>空间复杂度</th><th>构造时间复杂度</th><th>查询时间复杂度</th></tr></thead><tbody><tr><td>区间树</td><td>$O(n)$</td><td>$O(n logn)$</td><td>$O(logn+r)$</td></tr><tr><td>线段树</td><td>$O(n)$</td><td>$O(n logn)$</td><td>$O(logn+r)$</td></tr></tbody></table>]]></content>
    
    
    <summary type="html">&lt;p&gt;平衡二叉搜索树有诸多变种，以下将介绍其中几位成员。首先，鉴于数据访问的局部性在实际应用中普遍存在，按照最常用者优先的策略引入伸展树。接下来，通过对平衡二叉树的推广，引入平衡多路搜索树，并着重讨论其中比较典型的B树。对照4阶B树，引入红黑树，红黑树不仅仅能保证全树的适度平衡，从而有效地控制单次操作的时间成本并可将每次重平衡操作的时间复杂度控制在常数时间范围内。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://twinkle0331.github.io/algorithm/sorting/"/>
    <id>http://twinkle0331.github.io/algorithm/sorting/</id>
    <published>2019-09-11T12:55:02.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>此前我们涉及了诸多排序算法，针对向量和列表的起泡排序、归并排序以及选择排序等算法，基于散列的桶排序算法，借助堆的性质的就地堆排序算法。在此外，排序算法还有快速排序算法，希尔排序算法，其构思和技巧各具特色，在不同应用中的效率也各有千秋。</p><a id="more"></a><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>与归并排序一样，快速排序也是分治策略的典型应用，但二者有本质的区别，归并排序的计算量主要消耗于有序向量的归并操作，而子向量的划分却几乎不费时间。快速排序相反，可以在$O(1)$时间内由子问题的解得到原问题的解，但为了将原问题划分为两个子问题却需要$O(n)$时间。</p><h2 id="轴点"><a href="#轴点" class="headerlink" title="轴点"></a>轴点</h2><p>考查任一向量区间$S[lo,hi)$。对于任何$lo \leq mi&lt;hi$,以元素S[mi]为界限，都可分割出前、后两个子向量$S[lo,mi)$和$S(mi,hi)$。若$S[lo,mi)$中的元素均不大于$S[mi]$,且$S(mi,hi)$中的元素均不小于$S[mi]$，则元素$S[mi]$称作向量$S$的一个轴点。</p><p>以轴点$S[mi]$为界，前后向量的排序各自可独立进行，一旦前后向量各自完成排序，则可立即在常数时间内得到整个向量的排序结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量快速排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::quickSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   <span class="keyword">if</span> ( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//单元素区间自然有序，否则...</span></span><br><span class="line">   Rank mi = partition ( lo, hi - <span class="number">1</span> ); <span class="comment">//在[lo, hi - 1]内构造轴点</span></span><br><span class="line">   quickSort ( lo, mi ); <span class="comment">//对前缀递归排序</span></span><br><span class="line">   quickSort ( mi + <span class="number">1</span>, hi ); <span class="comment">//对后缀递归排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原始序列中轴点未必存在，任何一个元素作为轴点的必要条件是在初始向量和排序后向量中的秩应相等。只要所有元素都是错位的，则任何元素都不可能是轴点。但是可通过交换使任一元素转换为轴点。</p><p><img src="https://i.loli.net/2019/09/12/WmFryYfD16gpUuk.png"></p><p>任取一候选者，前缀$L$小于等于候选者，初始时为空，后缀$G$大于等于候选者，初始为空，中间区域待确定，初始为全集。交替向内移动$lo$和$hi$，逐个检查当前元素，若更小/大，则转移归入$L/G$。当$lo=hi$时，只需将候选者嵌入$L$、$G$之间，即为轴点。整个过程中，每个元素最多移动一次(候选者两次)，累计$O(n)$时间，$O(1)$辅助空间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//轴点构造算法：通过调整元素位置构造区间[lo, hi]的轴点，并返回其秩</span></span><br><span class="line">Rank Vector&lt;T&gt;::partition ( Rank lo, Rank hi ) &#123; <span class="comment">//版本B：可优化处理多个关键码雷同的退化情况</span></span><br><span class="line">   swap ( _elem[lo], _elem[lo + rand() % ( hi - lo + <span class="number">1</span> ) ] ); <span class="comment">//任选一个元素与首元素交换</span></span><br><span class="line">   T pivot = _elem[lo]; <span class="comment">//以首元素为候选轴点——经以上交换，等效于随机选取</span></span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//从向量的两端交替地向中间扫描</span></span><br><span class="line">      <span class="keyword">while</span> ( lo &lt; hi )</span><br><span class="line">         <span class="keyword">if</span> ( pivot &lt; _elem[hi] ) <span class="comment">//在大于pivot的前提下</span></span><br><span class="line">            hi--; <span class="comment">//向左拓展右端子向量</span></span><br><span class="line">         <span class="keyword">else</span> <span class="comment">//直至遇到不大于pivot者</span></span><br><span class="line">            &#123; _elem[lo++] = _elem[hi]; <span class="keyword">break</span>; &#125; <span class="comment">//将其归入左端子向量</span></span><br><span class="line">      <span class="keyword">while</span> ( lo &lt; hi )</span><br><span class="line">         <span class="keyword">if</span> ( _elem[lo] &lt; pivot ) <span class="comment">//在小于pivot的前提下</span></span><br><span class="line">            lo++; <span class="comment">//向右拓展左端子向量</span></span><br><span class="line">         <span class="keyword">else</span> <span class="comment">//直至遇到不小于pivot者</span></span><br><span class="line">            &#123; _elem[hi--] = _elem[lo]; <span class="keyword">break</span>; &#125; <span class="comment">//将其归入右端子向量</span></span><br><span class="line">   &#125; <span class="comment">//assert: lo == hi</span></span><br><span class="line">   _elem[lo] = pivot; <span class="comment">//将备份的轴点记录置于前、后子向量之间</span></span><br><span class="line">   <span class="keyword">return</span> lo; <span class="comment">//返回轴点的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>为不稳定算法，$lo/hi$的移动方向相反，左/右侧的大/小重复元素可能前后颠倒。同时为就地算法，只需$O(1)$附加空间。递归实例在最坏情况下需要$\Omega(n)$空间。</p><p><code>partition</code>算法可在线性时间内将原向量分解为两个相互独立、总体规模保持线性的子向量排序问题，根据轴点的性质，由排序后的向量可在常数时间内得到整个有序向量。分治策略高效实现的两个必要条件满足，即子问题划分的高效性和子问题相互之间的独立性，但是子任务规模相近在此处却无法保证。<br><code>partition</code>算法划分所得子序列长度与划分的具体过程无关，完全取决于入口处所选的轴点。若在最终有序向量中该候选元素的秩为$r$，则子向量的规模必然为$r$和$n-r-1$。</p><p>最好情况：每次划分都接近平均，轴点总是接近中央。</p><p>$\displaystyle T(n)=2T(\frac{n-1}{2})+O(n)=O(nlogn)$</p><p>最坏情况：每次划分都极不均衡</p><p>$T(n)=T(n-1)+T(0)+O(n)=O(n^2)$</p><p>可以通过随即选取一个候选轴点，或者从待排序向量中任取三个元素，将其数值居中者作为候选者，来降低最坏情况出现的概率，但是无法杜绝最坏情况的概率。</p><p>以下分析平均效率</p><p>准居中：<code>pivot</code>的秩落在宽度为$\lambda n$的居中区间，每以递归路径上，至多出现$log_{\frac{2}{1+\lambda} n}$ 个准居中的轴点。</p><p>每递归一层，都有$\lambda|(1-\lambda)$的概率准居中|准侧偏</p><p>深入$\displaystyle \frac{1}{\lambda}log_{\frac{2}{1+\lambda} n}$ 层后，即可期望出现$\displaystyle log_{\frac{2}{1+\lambda}} n$次居中，且有极高的概率出现，因此有极高的概率递归深度不超过$\displaystyle \frac{1}{\lambda}log_{\frac{2}{1+\lambda} n}=3log_{3/2} n$</p><p>假设待排序的元素都符合独立均匀分布，<code>partition</code>算法经过$n-1$次比较和$n+1$次移动之后，对规模为$n$的向量划分结果无非两种可能，划分所分左侧子序列的长度分别是$0,1,..,n-1$次，分别决定于所取元素在候选节点在最终有序序列中的秩。</p><p>$\displaystyle T(n)=(n+1)+\frac{1}{n} \sum_{k=0}^{n-1}[T(k)+T(n-k-1)]$</p><p>$\displaystyle =(n+1)+\frac{2}{n} \sum_{k=0}^{n-1}T(k)$</p><p>等式两侧同时乘以$n$，则有：</p><p>$nT(n)=n(n+1)+2\sum_{k=0}^{n-1}T(k)$</p><p>$(n-1)T(n-1)=(n-1)+2\sum_{k=0}^{n-2}T(k)$</p><p>两式相减，得$nT(n)-(n-1)T(n-1)=2n+2T(n-1)$</p><p>$nT(n)=2n+(n+1)T(n-1)$</p><p>两边同时除以$n(n+1)$,得</p><p>$T(n)/(n+1)=2/(n+1)+T(n-1)/n$</p><p>$=2/(n+1)+2/n+T(n-2)/(n-1)$</p><p>$=2/(n+1)+2/n+2/(n-1)+…2/2+T(0)/1$</p><p>$&lt;2lnn$</p><p>$T(n) \approx 2nlnn=(2ln2)nlogn  \approx 1.386logn=O(nlogn)$</p><h2 id="退化情况"><a href="#退化情况" class="headerlink" title="退化情况"></a>退化情况</h2><p>考查所有元素均退化的情况，主循环内部前一子循环的条件<code>pivot&lt;=_elem[hi]</code> 形同虚设，此时，划分的结果必然是以最左端为轴点，原向量划分为极不对称的两个子向量，这一最坏情况还可能持续发生，从而使整个算法过程等效地退化为线性递归，递归深度为$O(n)$，导致总体运行时间高达$O(n^2)$。</p><p>可以再每次深入递归时统一核验，若确为退化情况，则无需递归而直接返回，但在重复元素不多时，如此会增加额外的计算量，总体权衡后得不偿失。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//轴点构造算法：通过调整元素位置构造区间[lo, hi]的轴点，并返回其秩</span></span><br><span class="line">Rank Vector&lt;T&gt;::partition ( Rank lo, Rank hi ) &#123; <span class="comment">//版本B1：版本B的等价形式，可直接转至与版本A等价的版本A1</span></span><br><span class="line">   swap ( _elem[lo], _elem[lo + rand() % ( hi-lo+<span class="number">1</span> ) ] ); <span class="comment">//任选一个元素与首元素交换</span></span><br><span class="line">   T pivot = _elem[lo]; <span class="comment">//以首元素为候选轴点——经以上交换，等效于随机选取</span></span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//从向量的两端交替地向中间扫描</span></span><br><span class="line">      <span class="keyword">while</span> ( ( lo &lt; hi ) &amp;&amp; ( pivot &lt; _elem[hi] ) ) <span class="comment">//在大于pivot的前提下</span></span><br><span class="line">         hi--; <span class="comment">//向左拓展右端子向量</span></span><br><span class="line">      <span class="keyword">if</span> ( lo &lt; hi ) _elem[lo++] = _elem[hi]; <span class="comment">//不大xia于pivot者归入左端子向量</span></span><br><span class="line">      <span class="keyword">while</span> ( ( lo &lt; hi ) &amp;&amp; ( _elem[lo] &lt; pivot ) ) <span class="comment">//在小于pivot的前提下</span></span><br><span class="line">         lo++; <span class="comment">//向右拓展左端子向量</span></span><br><span class="line">      <span class="keyword">if</span> ( lo &lt; hi ) _elem[hi--] = _elem[lo]; <span class="comment">//不小于pivot者归入右端子向量</span></span><br><span class="line">   &#125; <span class="comment">//assert: lo == hi</span></span><br><span class="line">   _elem[lo] = pivot; <span class="comment">//将备份的轴点记录置于前、后子向量之间</span></span><br><span class="line">   <span class="keyword">return</span> lo; <span class="comment">//返回轴点的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与版本A比较，版本B主要是调整了两个内循环的终止条件。将原条件<code>pivot&lt;=elem[hi]</code>更改<code>pivot&lt;elem[hi]</code>,一旦遇到重复元素，右端子向量随即终止拓展，并将右端重复元素移至左端，lo和hi会交替移动，二者移动距离大致相当。但是以上改进需做更多的交换操作，倾向于交换重复元素，所以重复元素在原输入向量中的相对次序更难保持。</p><p>构造轴点的另一快捷思路：</p><p>始终将整个向量划分为四个区间，$v[lo],L=v(lo,mi],G=v(mi,k],u=v[k,hi]$</p><p>其中$v[lo]$为候选轴点，$L/G$中的元素均不大/不小于$v[lo]$，$U$中元素大小未知。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//轴点构造算法：通过调整元素位置构造区间[lo, hi]的轴点，并返回其秩</span></span><br><span class="line">Rank Vector&lt;T&gt;::partition ( Rank lo, Rank hi ) &#123; <span class="comment">//版本C</span></span><br><span class="line">   swap ( _elem[lo], _elem[lo + rand() % ( hi - lo + <span class="number">1</span> ) ] ); <span class="comment">//任选一个元素与首元素交换</span></span><br><span class="line">   T pivot = _elem[lo]; <span class="comment">//以首元素为候选轴点——经以上交换，等效于随机选取</span></span><br><span class="line">   <span class="keyword">int</span> mi = lo;</span><br><span class="line">   <span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line">   <span class="comment">//   [ ---- &lt; [lo] ----- ] [ ----- [lo] &lt;= --- ] [ ----- unknown ----- ]</span></span><br><span class="line">   <span class="comment">// X x . . . . . . . . . x . . . . . . . . . . . x . . . . . . . . . . x</span></span><br><span class="line">   <span class="comment">// |                     |                       |                     |</span></span><br><span class="line">   <span class="comment">// lo (pivot)            mi                      k                     hi</span></span><br><span class="line">   <span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> k = lo + <span class="number">1</span>; k &lt;= hi; k++ ) <span class="comment">//自左向右扫描</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[k] &lt; pivot ) <span class="comment">//若当前元素_elem[k]小于pivot，则</span></span><br><span class="line">         swap ( _elem[++mi], _elem[k] ); <span class="comment">//将_elem[k]交换至原mi之后，使L子序列向右扩展</span></span><br><span class="line">   <span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line">   <span class="comment">//   [ --------- &lt; [lo] ---------- ] [ ----------- [lo] &lt;= ----------- ]</span></span><br><span class="line">   <span class="comment">// X x . . . . . . . . . . . . . . x . . . . . . . . . . . . . . . . . x</span></span><br><span class="line">   <span class="comment">// |                               |                                   |</span></span><br><span class="line">   <span class="comment">// lo                              mi                                  hi</span></span><br><span class="line">   <span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line">   swap ( _elem[lo], _elem[mi] ); <span class="comment">//候选轴点归位</span></span><br><span class="line">   <span class="keyword">return</span> mi; <span class="comment">//返回轴点的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始时取$k-1=mi=lo$,$L$和$G$均为空，此后随着$k$不断递增，逐一检查元素$v[k]$，并根据$v[k]$相对于候选轴点的大小，相应地扩展区间$L$或区间$G$，同时压缩区间$U$。最终，当$k-1=hi$时，$U$中不含任何元素，于是只需将候选轴点放至$V[mi]$，即成为真正的轴点。</p><p>基于以上实现的快速排序算法不稳定，子向量L和R都是向右侧延伸，新元素都是插至向量的末尾。除此以外，子向量$L$不会有任何修改，故其中所有元素之间的相对次序必然与原向量一致。然而，在子向量$L$的每次生长之前，子向量$R$都需要相应地向前滚动一个单元，故可能造成雷同元素之间相同次序的紊乱。在元素大量甚至完全重复的情况下该算法虽不致出错，但划分所得的子向量的规模相差悬殊，几乎退化成起泡排序算法，整体运行时间将增加到$O(n^2)$。</p><h1 id="选取与中位数"><a href="#选取与中位数" class="headerlink" title="选取与中位数"></a>选取与中位数</h1><p><strong>k选取</strong></p><p>在任意一组可比较大小的元素中，如何从小到大找出其中次序为$k$者？亦即在这组元素的非降排序序列$S$中找出$S[k]$。</p><p><strong>中位数</strong></p><p>长度为$n$的有序序列中，元素$S[n/2]$称作中位数(数值上可能有重复)。在任意一组可比较大小的元素中，如何找到中位数？</p><p>中位数是$k$选取问题的一个特例，也是其中难度最大者。由于中位数可将原数据集划分为大小明确、规模相仿且彼此独立的两个子集，故能否高效地确定中位数将直接关系到分治策略可否高效实现。</p><h2 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h2><p>由中位数的定义，可直接得到查找中位数的算法如下：对所有元素排序，将其转化为有序序列S，则$S[n/2]$即为所要找的中位数。对无序向量的排序在最坏情况下需要$\Omega(nlogn)$时间，故基于该算法的任何分治算法，时间复杂度都不会低于$T(n)=nlogn+2T(n/2)=O(nlog^2n)$</p><blockquote><p>不妨考虑中位数问题的一个简化版，在任一无序向量A中，若有一半元素的数值同为$m$,则将$m$称为A的众数。那么，任给无序向量，如何快速判断其中是否存在众数，并在存在时将其找出？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">majority</span> <span class="params">( Vector&lt;T&gt; A, T&amp; maj )</span> </span>&#123; <span class="comment">//众数查找算法：T可比较可判等</span></span><br><span class="line">   maj = majEleCandidate ( A ); <span class="comment">//必要性：选出候选者maj</span></span><br><span class="line">   <span class="keyword">return</span> majEleCheck ( A, maj ); <span class="comment">//充分性：验证maj是否的确当选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用<code>majEleCandidate()</code> ,从向量A中找到中位数maj，并将其作为众数唯一候选者。再调用<code>majEleCheck()</code></p><p>在线性时间内扫描一遍向量，从而最终判断向量A的众数是否的确存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">majEleCheck</span> <span class="params">( Vector&lt;T&gt; A, T maj )</span> </span>&#123; <span class="comment">//验证候选者是否确为众数</span></span><br><span class="line">   <span class="keyword">int</span> occurrence = <span class="number">0</span>; <span class="comment">//maj在A[]中出现的次数</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++ ) <span class="comment">//逐一遍历A[]的各个元素</span></span><br><span class="line">      <span class="keyword">if</span> ( A[i] == maj ) occurrence++; <span class="comment">//每遇到一次maj，均更新计数器</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">2</span> * occurrence &gt; A.size(); <span class="comment">//根据最终的计数值，即可判断是否的确当选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设$P$为向量A中长度为$2m$的前缀，若元素$x$在P中恰好出现$m$次，则$A$有众数当且仅当后缀$A-P$有众数，同时$A-P$的众数就是$A$的众数。</p><p>若$A$的众数就是$x$,则在剪除前缀$P$之后，$x$与非众数均减少相同的数目，二者数目的差距在后缀$A-P$中保持不变。反过来，若$A-P$的众数不为$x$，则二者数目的差距在后缀$A-P$中也不会缩小。</p><p>按照以上减而治之策略，可唯一确定众数的候选者。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">majEleCandidate</span> <span class="params">( Vector&lt;T&gt; A )</span> </span>&#123; <span class="comment">//选出具备必要条件的众数候选者</span></span><br><span class="line">   T maj; <span class="comment">//众数候选者</span></span><br><span class="line"><span class="comment">// 线性扫描：借助计数器c，记录maj与其它元素的数量差额</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> c = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; A.size(); i++ )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> == c ) &#123; <span class="comment">//每当c归零，都意味着此时的前缀P可以剪除</span></span><br><span class="line">         maj = A[i]; c = <span class="number">1</span>; <span class="comment">//众数候选者改为新的当前元素</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         maj == A[i] ? c++ : c--; <span class="comment">//相应地更新差额计数器</span></span><br><span class="line">   <span class="keyword">return</span> maj; <span class="comment">//至此，原向量的众数若存在，则只能是maj —— 尽管反之不然</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，变量<code>maj</code>始终为当前前缀中出现次数不少于一半的某个元素，c始终记录该元素与其他元素的数目之差。一旦c归零，则意味着在当前向量找到了一个可以减除的前缀$P$。在剪除该前缀后，问题范围将响应地缩小至$A-P$。此后，只需将<code>maj</code>重新初始化为$A-P$的首元素，并令<code>c=1</code>,即可继续重复上述迭代过程。</p><p>对于向量的每个秩，该算法迭代且仅迭代一步。故其运行时间，应线性正比于向量规模。</p><p>该候选者未必是众数，但也未必是原向量中出现最频繁者。该算法采取简而治之的策略，原向量等效地切分为若干区段，各区段首元素至少在其中占一半的比例。因此，最后返回的<code>maj</code>，实际上只是最后一个区段的准众数，未必就是整个向量的准众数。</p><p>若众数的定义修改为众数应严格地不少于其他元素，则需要对之前算法进行一定改进。</p><p>当向量规模为奇数时，准众数必然就是众数，当n为偶数时，针对准众数的查找的一种简明的调整方法是：首先任选一个元素(比如末元素)，并在$O(n)$时间内甄别其是否为准众数。不妨设该元素不是准众数，于是只需将其忽略(原向量的有效长度降低至$n-1$，为奇数)，即可将在原向量中查找众数的问题转化为在$n-1$的向量中查找众数的问题。</p><blockquote><p>讨论中位数问题的另一简化版本，任给有序向量$S_1$和$S_2$，如何找出归并后有序向量的中位数</p></blockquote><p><strong>蛮力版</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 中位数算法蛮力版：效率低，仅适用于max(n1, n2)较小的情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//子向量S1[lo1, lo1 + n1)和S2[lo2, lo2 + n2)分别有序，数据项可能重复</span></span><br><span class="line"><span class="function">T <span class="title">trivialMedian</span> <span class="params">( Vector&lt;T&gt;&amp; S1, <span class="keyword">int</span> lo1, <span class="keyword">int</span> n1, Vector&lt;T&gt;&amp; S2, <span class="keyword">int</span> lo2, <span class="keyword">int</span> n2 )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> hi1 = lo1 + n1, hi2 = lo2 + n2;</span><br><span class="line">   Vector&lt;T&gt; S; <span class="comment">//将两个有序子向量归并为一个有序向量</span></span><br><span class="line">   <span class="keyword">while</span> ( ( lo1 &lt; hi1 ) &amp;&amp; ( lo2 &lt; hi2 ) ) &#123;</span><br><span class="line">      <span class="keyword">while</span> ( ( lo1 &lt; hi1 ) &amp;&amp; S1[lo1] &lt;= S2[lo2] ) S.insert ( S1[lo1 ++] );</span><br><span class="line">      <span class="keyword">while</span> ( ( lo2 &lt; hi2 ) &amp;&amp; S2[lo2] &lt;= S1[lo1] ) S.insert ( S2[lo2 ++] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> ( lo1 &lt; hi1 ) S.insert ( S1[lo1 ++] );</span><br><span class="line">   <span class="keyword">while</span> ( lo2 &lt; hi2 ) S.insert ( S1[lo2 ++] ); <span class="comment">/*DSA*/</span>print ( S );</span><br><span class="line">   <span class="keyword">return</span> S[ ( n1 + n2 ) / <span class="number">2</span>]; <span class="comment">//直接返回归并向量的中位数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若调用蛮力算法将二者归并，则需花费$O(n_1+n_2)$时间。</p><p>实际上，上述算法只需$O((n_1+n_2)/2)$步即可终止。计算的目标是归并之后向量的中位数，并不意味着一定要显式地完成合并。实际上就此计算任务而言，只需设置一个计数器，而不必真地引入并维护一个向量结构。具体地，依然可以沿用原算法的主体流程，向量$S$只是假想式地存在。无需真正地将子向量中地元素转移至S中，只需动态地记录这一向量地规模：每当有一个元素假想式地归入其中，则计数器相应地递增。一旦计数器抵达$\lfloor (n_1+n_2)/2$,即可忽略后续元素并立即假想地归入其中，则计数器相应地递增。</p><p><strong>减而治之</strong></p><p>假设两子向量等长，长度均为$n$</p><p><img src="https://i.loli.net/2019/09/12/aGZR7xAysMHPbm9.png"></p><p>简而治之的原理为，两子向量归并后所得的向量$S$长度为$2n$，则中位数对应的秩为$\lfloor 2n/2 \rfloor=n$，即存在$n$个元素不大于中位数，$n-1$个元素不小于中位数。若$m_1&lt;m_2$,则在$S_2$中存在$\lceil n/2 \rceil$个数大于$m_2$，假设其中一数为$m$，可能不小于$m$的数的个数最大为$\lfloor n/2 \rfloor+\lceil n/2 \rceil -1=n-1$ ,即$m$的后继个数和在$S_2$中可能大于$m$的数的个数。因为$m$在$m_2$右侧,所以后继个数必然小于$\lfloor n/2 \rfloor$ 个，所以必然不是$S$的中位数，或者与$m_1$或$m_2$同为$S$的中位数。</p><p>同时，在$S_1$和$ S_2$减去的不小于中位数的数和不大于中位数的个数相等，所以在减去前后两个子向量所对应的中位数不变。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//序列S1[lo1, lo1 + n)和S2[lo2, lo2 + n)分别有序，n &gt; 0，数据项可能重复</span></span><br><span class="line"><span class="function">T <span class="title">median</span> <span class="params">( Vector&lt;T&gt;&amp; S1, <span class="keyword">int</span> lo1, Vector&lt;T&gt;&amp; S2, <span class="keyword">int</span> lo2, <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//中位数算法（高效版）</span></span><br><span class="line">   <span class="keyword">if</span> ( n &lt; <span class="number">3</span> ) <span class="keyword">return</span> trivialMedian ( S1, lo1, n, S2, lo2, n ); <span class="comment">//递归基</span></span><br><span class="line">   <span class="keyword">int</span> mi1 = lo1 + n / <span class="number">2</span>, mi2 = lo2 + ( n - <span class="number">1</span> ) / <span class="number">2</span>; <span class="comment">//长度（接近）减半</span></span><br><span class="line">   <span class="keyword">if</span> ( S1[mi1] &lt; S2[mi2] )</span><br><span class="line">      <span class="keyword">return</span> median ( S1, mi1, S2, lo2, n + lo1 - mi1 ); <span class="comment">//取S1右半、S2左半</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( S1[mi1] &gt; S2[mi2] )</span><br><span class="line">      <span class="keyword">return</span> median ( S1, lo1, S2, mi2, n + lo2 - mi2 ); <span class="comment">//取S1左半、S2右半</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> S1[mi1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推广至一般情况，则</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量S1[lo1, lo1 + n1)和S2[lo2, lo2 + n2)分别有序，数据项可能重复</span></span><br><span class="line"><span class="function">T <span class="title">median</span> <span class="params">( Vector&lt;T&gt;&amp; S1, <span class="keyword">int</span> lo1, <span class="keyword">int</span> n1, Vector&lt;T&gt;&amp; S2, <span class="keyword">int</span> lo2, <span class="keyword">int</span> n2 )</span> </span>&#123; <span class="comment">//中位数算法</span></span><br><span class="line">   <span class="keyword">if</span> ( n1 &gt; n2 ) <span class="keyword">return</span> median ( S2, lo2, n2, S1, lo1, n1 ); <span class="comment">//确保n1 &lt;= n2</span></span><br><span class="line">   <span class="keyword">if</span> ( n2 &lt; <span class="number">6</span> ) <span class="comment">//递归基：1 &lt;= n1 &lt;= n2 &lt;= 5</span></span><br><span class="line">      <span class="keyword">return</span> trivialMedian ( S1, lo1, n1, S2, lo2, n2 );</span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">//                lo1            lo1 + n1/2      lo1 + n1 - 1</span></span><br><span class="line">   <span class="comment">//                 |                 |                 |</span></span><br><span class="line">   <span class="comment">//                 X &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X</span></span><br><span class="line">   <span class="comment">// Y .. trimmed .. Y &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Y &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Y .. trimmed .. Y</span></span><br><span class="line">   <span class="comment">// |               |                 |                 |               |</span></span><br><span class="line">   <span class="comment">// lo2     lo2 + (n2-n1)/2       lo2 + n2/2     lo2 + (n2+n1)/2    lo2 + n2 -1</span></span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">2</span> * n1 &lt; n2 ) <span class="comment">//若两个向量的长度相差悬殊，则长者（S2）的两翼可直接截除</span></span><br><span class="line">      <span class="keyword">return</span> median ( S1, lo1, n1, S2, lo2 + ( n2 - n1 - <span class="number">1</span> ) / <span class="number">2</span>, n1 + <span class="number">2</span> - ( n2 - n1 ) % <span class="number">2</span> );</span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">//    lo1                  lo1 + n1/2              lo1 + n1 - 1</span></span><br><span class="line">   <span class="comment">//     |                       |                       |</span></span><br><span class="line">   <span class="comment">//     X &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X</span></span><br><span class="line">   <span class="comment">//                             |</span></span><br><span class="line">   <span class="comment">//                            m1</span></span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">//                            mi2b</span></span><br><span class="line">   <span class="comment">//                             |</span></span><br><span class="line">   <span class="comment">// lo2 + n2 - 1         lo2 + n2 - 1 - n1/2</span></span><br><span class="line">   <span class="comment">//     |                       |</span></span><br><span class="line">   <span class="comment">//     Y &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Y ...</span></span><br><span class="line">   <span class="comment">//                                .</span></span><br><span class="line">   <span class="comment">//                               .</span></span><br><span class="line">   <span class="comment">//                              .</span></span><br><span class="line">   <span class="comment">//                             .</span></span><br><span class="line">   <span class="comment">//                            .</span></span><br><span class="line">   <span class="comment">//                           .</span></span><br><span class="line">   <span class="comment">//                          .</span></span><br><span class="line">   <span class="comment">//                         ... Y &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Y</span></span><br><span class="line">   <span class="comment">//                             |                       |</span></span><br><span class="line">   <span class="comment">//                       lo2 + (n1-1)/2               lo2</span></span><br><span class="line">   <span class="comment">//                             |</span></span><br><span class="line">   <span class="comment">//                            mi2a</span></span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="keyword">int</span> mi1  = lo1 + n1 / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> mi2a = lo2 + ( n1 - <span class="number">1</span> ) / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> mi2b = lo2 + n2 - <span class="number">1</span> - n1 / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span> ( S1[mi1] &gt; S2[mi2b] ) <span class="comment">//取S1左半、S2右半</span></span><br><span class="line">      <span class="keyword">return</span> median ( S1, lo1, n1 / <span class="number">2</span> + <span class="number">1</span>, S2, mi2a, n2 - ( n1 - <span class="number">1</span> ) / <span class="number">2</span> );</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( S1[mi1] &lt; S2[mi2a] ) <span class="comment">//取S1右半、S2左半</span></span><br><span class="line">      <span class="keyword">return</span> median ( S1, mi1, ( n1 + <span class="number">1</span> ) / <span class="number">2</span>, S2, lo2, n2 - n1 / <span class="number">2</span> );</span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//S1保留，S2左右同时缩短</span></span><br><span class="line">      <span class="keyword">return</span> median ( S1, lo1, n1, S2, mi2a, n2 - ( n1 - <span class="number">1</span> ) / <span class="number">2</span> * <span class="number">2</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法首先比较$n_1$和$n_2$的大小，并在必要时交换两个子向量，从而保证有$n_1&lt;n_2$。</p><p>若两个向量相差悬殊，则可对称地适当截短长者的两翼，以保证有：</p><p>$n_1\leq n_2 \leq 2n_1$</p><p>因为$S_2$两翼截除的长度相等，所以此后$S_1 \cup S_2$的中位数，依然是$S_1\cup S_2$的中位数。</p><p>这里采用了简而治之的策略，可使问题规模按照几何级数递减，故总体复杂度应为$O(log(min(n_1,n_2)))$ 。无论是交换两个向量，还是截短$S_2$,都只需常数时间。因此实质的计算，只是针对长度均同阶于$min(n_1,n_2)$的一对向量计算中位数。此后每做一次比较，即可将问题的规模缩减至原来的一半。因此，问题的规模将以1/2为比例按几何级数的速度递减，直至平凡的递归基。整个算法的递归深度不超过$log_2{min(n_1,n_2)}$,总体时间复杂度为$O(log(min(n_1,n_2)))$。</p><p>若输入的有序序列$S_1$和$S_2$以列表的形式实现而不是向量，则在读取每个元素之前都要沿着列表进行计数查找。为保证$|S_1|&lt;|S_2|$而交换两个序列，依然只需$ O(1)$时间，然而序列$S_2$两翼的截短则大致需要$O(n_2-n_1)$时间。而更重要的是，在此后的递归过程中，每一次为将问题规模缩减一半，都必须花费线性的时间，总体需要$O(n_1+n_2)$时间，这一效率减低到和蛮力算法相同。</p><blockquote><p>为median()算法添加整型输入参数$k$，实现在$S_1\cup S_2$选取第$k$个元素的功能</p></blockquote><p>记$n_1=|S_1|$和$n_2=|S_2|$,不失一般性的，设$n_1\leq  n_2$</p><p>不妨设$2k \leq n_1+n_2$,否则，可以颠倒比较器的方向，原问题转化为在$S_1 \cup S_2$中选取第$n_1+n_2-k$个元素，与以下方法同理。</p><p>若$k\leq n_1=min(n_1,n_2)$,则只需令：</p><p>$S_1’=S_1[0,k)$</p><p>$S_2’=S_2[0,k)$</p><p>于是原问题即转化为计算$S_1’\cup S_2’$的中位数。</p><p>否则，若$n_1&lt;k&lt;n_2$,则可令</p><p>$S_1’=S_1[0,k)$</p><p>$S_2’=S_2[0,k)$</p><p>于是原问题即转化为计算$S_1’\cup S_2’$的中位数。</p><p>可见，无论如何，针对$S_1 \cup S_2$的$k$选取问题总是可在常数时间内转化为中位数问题，并调用相关的算法。</p><p>一般性的选取问题中，蛮力算法效率之所以低下是因为一组元素中第$k$大元素包含的信息量远远小于经过全排序后所得到的整个有序序列。花费足以得到全排序的计算成本，却仅得到了少量的局部信息。</p><h2 id="堆选取"><a href="#堆选取" class="headerlink" title="堆选取"></a>堆选取</h2><p>基于堆结构的选取算法大致有以下几种：</p><p>首先花费$O(n)$时间将全体元素组织为一个小顶堆，然后经过$k$次delMin()操作，则得到位序为k的元素，这一算法的时间为：</p><p>$O(n)+kO(logn)=O(n+klogn)$</p><p>另一算法为，任取k个元素，并在$O(k)$时间内组织为一个大顶堆，然后将剩余n-k个元素插入其中，每插入一个，随即删除堆顶，以使堆的规模恢复为k,待所有元素处理完毕后，堆顶即为目标元素。该算法的运行时间为：</p><p>$O(k)+2(n-k)O(logk)=O(k+2(n-k)logk)$</p><p>最后一种方法为，分别构建一个规模为$n-k$ 的小顶堆G和$k$的大顶堆H。接下来，反复比较它们的堆顶g和h，只要g小于h，则将二者交换，并重新调整为两个堆。如此，G的堆顶G将持续增大，H的堆顶将持续减小。当$g\geq h$时，h即为所要找的元素。这一算法的运行时间为：</p><p>$O(n-k)+O(k)+min(k,n-k)2log((O(log k+log(n-k))))$</p><p>在目标元素的秩很小或很大的时候($|n/2-k| \approx n/2$)，以上算法的性能都还不错。比如$k=0$时，上述两算法均只需线性时间，当$k \approx n/2$，以上算法的复杂度均退化为蛮力算法的$O(nlogn)$。</p><h2 id="快速划分"><a href="#快速划分" class="headerlink" title="快速划分"></a>快速划分</h2><p>选取问题所查找的位序$k$,就是其在对应的有序序列中的秩，就这一性质而言，与轴点颇为相似。可反复应用这一点，逐步逼近目标$k$。</p><p>首先，调用<code>partition()</code>构造向量$A[i]=x$，若$i=k$，则该轴点恰好就是待选取的目标元素，即可直接返回。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">quickSelect</span> <span class="params">( Vector&lt;T&gt; &amp; A, Rank k )</span> </span>&#123; <span class="comment">//基于快速划分的k选取算法</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank lo = <span class="number">0</span>, hi = A.size() - <span class="number">1</span>; lo &lt; hi; ) &#123;</span><br><span class="line">      Rank i = lo, j = hi; T pivot = A[lo];</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; j ) &#123; <span class="comment">//O(hi - lo + 1) = O(n)</span></span><br><span class="line">         <span class="keyword">while</span> ( ( i &lt; j ) &amp;&amp; ( pivot &lt;= A[j] ) ) j--; A[i] = A[j];</span><br><span class="line">         <span class="keyword">while</span> ( ( i &lt; j ) &amp;&amp; ( A[i] &lt;= pivot ) ) i++; A[j] = A[i];</span><br><span class="line">      &#125; <span class="comment">//assert: i == j</span></span><br><span class="line">      A[i] = pivot;</span><br><span class="line">      <span class="keyword">if</span> ( k &lt;= i ) hi = i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( i &lt;= k ) lo = i + <span class="number">1</span>;</span><br><span class="line">   &#125; <span class="comment">//A[k] is now a pivot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若$i$不等于$k$，则无非两种情况。</p><ul><li>$k&lt;i$,则选取的目标元素不可能来自处于$x$右侧、不小于$x$的子向量，此时不妨将该子向量剪除，然后递归地在剩余区间做k选取</li><li>若$i&gt;k$,则选取的目标元素不可能来自处于$x$左侧、不大于$x$的子向量中，同样可以将子向量剪除，然后递归地在剩余区间做$k-i$选取。</li></ul><p>该算法流程与轴点构造算法类似，每经过一步主迭代，都会构造出一个轴点$A[i]$，然后$lo$和$hi$将彼此靠拢，查找范围将收缩至$A[i]$的某一侧。当轴点的秩$k$恰好为$k$时，算法随即终止。尽管内循环仅需$O(hi-lo+1)$时间，但是在最坏情况下需执行$\Omega(n)$次，总体运行时间为$O(n^2)$。平均时间复杂度为$O(n)$。</p><p>$T(n)=(n+1)+\frac{1}{n} \sum_{k=0}^{n} T(max(k,n-k)) =O(n)$</p><h2 id="k选取算法"><a href="#k选取算法" class="headerlink" title="k选取算法"></a>k选取算法</h2><p>$k$选取算法的主要流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">select(A,k)</span><br><span class="line">输入：规模为n的无序序列A,秩k&gt;&#x3D;0</span><br><span class="line">输出：A所对应的有序序列中秩为k的元素</span><br><span class="line">&#123;</span><br><span class="line">      0)if(n&#x3D;|A|&lt;Q) return trivialSelect(A,k);</span><br><span class="line">      1)将A均匀地划分为n&#x2F;Q个子序列，各含Q个元素</span><br><span class="line">      2)各子序列分别排序，计算中位数，并将这些中位数组成一个序列</span><br><span class="line">      3)通过递归调用select()，计算中位数序列的中位数，记作M</span><br><span class="line">      4)根据其相对于M的大小，将A中元素分为三个子集：L(小于)M(等于)和G(大于)</span><br><span class="line">      5)if(|L|&gt;k) return select(L,k);</span><br><span class="line">      else if (|L|+|E|&gt;&#x3D;K) return M;</span><br><span class="line">      else return select(G,k-|L|-|E|);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将以上算法运行时间记作$T(n)$，则</p><ul><li>第0步：$O(1)=O(QlogQ)$</li><li>第1步：$O(n)$ 子序列划分</li><li>第2步：$O(n)=Q^2n/Q$ 子序列各自排序，并找到中位数</li><li>第3步：$T(n/Q)$ 从$n/Q$个中位数中递归地找到全局中位数</li><li>第4步：$O(n)$,划分子集L/E/G，并分别计数</li><li>第5步：$T(3n/4)$</li></ul><p><strong>复杂度</strong></p><p><img src="https://i.loli.net/2019/09/12/alQEFLN8biB7W6p.png"></p><p>$T(n)=O(n)+T(n/Q)+T(3n/4)$</p><p>为了使解为线性函数，只需保证：</p><p>$n/Q+3n/4&lt;n$</p><p>若取$Q=5$,则存在常数$c$，使得</p><p>$T(n)=cn+T(n/5)+T(3n/4)$</p><p>$T(n)=O(20cn)=O(n)$</p><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序将整个序列视为一个矩阵，逐列各自排序。</p><p><strong>递减增量</strong></p><p>由粗到细：重新排列矩阵，使其更窄，再次逐列排序</p><p>逐步求精：如此往复，直至矩阵为一列</p><p>若原一维向量宽度为$A[0,n)$，则对于任一固定的矩阵宽度$w$,$A$和$B$中元素总有一一对应关系：$B[i] [j]=A[iw+j]$,从秩的角度来看，矩阵$B$的各列依次对应于关于宽度$w$的一个同余类。不妨假设$w$整除$n$，则矩阵宽度$w$自上而下对应于$A$中以$w$为间隔的$n/w$个元素，因此，矩阵的宽度$w$亦称作增量。</p><p>希尔排序的流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Shellsort(A,n)</span><br><span class="line">输入：规模为n的无序向量A</span><br><span class="line">输出：A对应的有序向量</span><br><span class="line">&#123;</span><br><span class="line">   取一个递增的增量序列：H&#x3D;&#123;W1&#x3D;1,W2,23,..,2K,..&#125;</span><br><span class="line">   设置k&#x3D;max&#123;i|Wi&lt;n&#125;,即Wk为增量中小于n的最后一项</span><br><span class="line">   for(t&#x3D;k;t&gt;0;t--)&#123;</span><br><span class="line">       将向量A视为Wt为宽度的矩阵Bt</span><br><span class="line">       对Bt的每一列分别排序，Bt[i]，i&#x3D;0,1,..,Wt-1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中各列内部排序如何实现？</p><p>必须采用输入敏感的算法，以保证有序性持续改善，且总体成本足够低廉。比如，插入排序，更多地取决于输入序列所含逆序对的总数。</p><p>希尔排序的总体效率取决于具体使用何种步长序列</p><p>主要考查和评测</p><ul><li>比较操作、移动操作的次数</li><li>收敛的速度，或者反过来，迭代的轮数</li></ul><h2 id="希尔序列"><a href="#希尔序列" class="headerlink" title="希尔序列"></a>希尔序列</h2><p><img src="https://i.loli.net/2019/09/12/TyKi1xRD3hftNuv.png"></p><h2 id="邮资问题"><a href="#邮资问题" class="headerlink" title="邮资问题"></a>邮资问题</h2><p>考查以下问题：</p><p>假设在某个国家，邮局仅发行面值为4分和13分的两种邮票，那么</p><ol><li>可否用这两种邮票组合出对应的50分邮资</li><li>可否用这两种邮票组合出对应的35分邮资</li></ol><p><strong>线性组合</strong></p><p>用数论的语言，以上问题可描述为：$4m+13n=35$是否存在自然数解？</p><p>对于任意自然数$g$和$h$,只要$m$和$n$也是自然数，则$f=mg+nh$都称作$g$和$h$的一个线性组合，我们称不可由$g$和$h$组合出来的最大自然数记作$x(g,h)$</p><p>如果$g$和$h$互素，则必有：</p><p>$x(g,h)=(g-1)(h-1)-1=gh-g-h$</p><p>$g=4$和$h=13$互素，故有$x(4,13)=35$，$35$恰好为无法由$4$和$13$组成的最大自然数。</p><p><strong>h有序和h排序</strong></p><p>在向量$S[0,n)$中，若$S[i]&lt;=S[i+h]$对于任何$0\leq i&lt;n-h$成立，则称该向量$h$有序，也就是说，其中相距$h$个单元的每队元素之间均有序。</p><p>考查希尔排序中对应于任一增量$h$的迭代，等同于在原向量之间以$h$间隔排序，故这一过程称为$h$排序，经$h$排序之后的向量必然$h$有序。</p><p>已经$g$有序的向量，再经过$h$排序后，依然保持$g$有序。考查$(g,h)$有序的任一向量，借助有序性的传递律可知，相距$g+h$的任何一对元素必然有序，故$S$必然$g+h$有序。推而广之，对于任何非负整数$m$和$n$,相距$mg+nh$的任何一对元素都必有序，故$S$必然$mg+nh$有序。</p><p><strong>有序性的保持和加强</strong></p><p>在分别做过$g$排序和$h$排序之后，该向量必定$g+h$有序。对于$g$和$h$的任一线性组合，该向量也应$mg+nh$有序，因此反过来，逆序对之间的间距绝不可能是$g$和$h$的组合。只要$g$和$h$互素，逆序对的间距就绝不可能大于$(g-1)(h-1)$。</p><p>希尔排序过程中向量的有序性之所以会不断改善，其原因为向量中每个元素所能参与构成的逆序对持续减少。于此同时，底层所采用的插入排序算法的实际执行时间将不断减少。</p><p>若某向量S已属于$(g,h)$有序，假设$g$和$h$的数量级均处于$O(d)$数量级。以下考查对该向量做$d$排序所需的时间。</p><p>根据定义，$d$排序将$S$等间距地划分为长度各为$O(n/d)$的$d$个子向量，并分别排序，在$(g,h)$有序的向量中，逆序对的间距不超过$(g-1)(h-1)/d=O(d)$ 。</p><p>于是，再次根据插入排序的结论，插入排序可在$O(d)O(n/d)=O(n)$时间内完成每一子向量的排序，所有子向量的排序应该不超过$O(dn)$。</p><h2 id="PS序列"><a href="#PS序列" class="headerlink" title="PS序列"></a>PS序列</h2><p>$H_{PS}=H_{shell}-1={2^k-1|k \in N}={1,3,15,31,63,127,255}$</p><p>其中相邻两项的确互素，采用这一序列，希尔排序的算法可达到$O(n^{3/2})$ ，其中$n$为待排序向量的规模。</p><p>在PS序列中，设$W_t$为其中$n^{1/2}$ 最接近者，亦即是$W_t=\Theta(n^{1/2})$ 。以下将希尔排序过程中所有的迭代分为两类，分别估计其运行时间。</p><p>首先，考查在$W_t$之前执行的各步迭代。</p><p>此类迭代所对应的增量均满足$W_k&gt;W_t$。在每一次这类迭代中，矩阵共有$W_k$列，各列包含$O(n/W_k)$个元素。因此，若采用插入排序算法，各列耗时$O((n/W_k)^2)$ ,所有列共计$O(n^2/W_k)$。于是，此类迭代各自所需的时间$O(n^2/(W_k))$构成一个以大致以2为比例的等比级数，其总和应线性正比于其中最大的一项，亦即不超过$O(2n^2/W_t)=O(n^{3/2})$。</p><p>对称地，再来考查$W_t$之后的各步迭代，</p><p>这类迭代所对应的增量均满足$W_k&lt;W_t$ ,考虑到此前刚完成$W_{k+1}$排序和$W_{k+2}$排序，来自PS序列的$W_{k+1}$和$W_{k+2}$互素，且与$W_{k}$同处一个数量级，根据之前的结论，每一次这样的迭代至多需要$O(nW_{k})$时间。同样地，这类迭代所需的时间$O(nW_{k})$同样构成一个大致以2为比例的等比级数，其总和也应线性正比于其中最大的一项，亦即不超过$O(2nW_{t})=O(n^{3/2})$。</p><h2 id="Pratt序列"><a href="#Pratt序列" class="headerlink" title="Pratt序列"></a>Pratt序列</h2><p>$H_{pratt}={2^p3^q|p,q\in N}={1,2,3,4,8,9,12,36,…}$</p><p>采取pratt序列，希尔序列算法至多运行$O(nlog^2n)$时间</p><p>在$(2,3)$有序的序列中，逆序元素之间的间距不超过$(2-1)(3-1)-1=1$。</p><p>整个向量的逆序对不超过$O(n)$个，对该向量的$1$排序仅需$ O(n)$时间。</p><p>对于pratt序列，若S已是$(2h_k,3h_k)$有序，故若按照相对于$h_k$的模余值，可以划分为$h_k$个同余类；相应地，原整个向量可拆分为$h_k$个等长的子向量。其中每个元素都是$(2,3)$有序的，根据以上结论，可在线性时间内转化为$1$有序的，总体效果而言，等同于在$O(n)$时间内转化为全局的$h_k$有序。</p><p>pratt序列中大于$n$的项数至多不超过$log_2nlog_3n=o(log^2n)$。</p><h2 id="Sedgewick序列"><a href="#Sedgewick序列" class="headerlink" title="Sedgewick序列"></a>Sedgewick序列</h2><p>Pratt序列效率比较高，但因其中各项的间距太小，会导致迭代趟数过多，为此，Sedgewick提出了以下增量序列：</p><p>${1,5,19,41,109,209,505,929,2161,3905,8929,…}$</p><p>其中各项均为$9<em>4^k-9</em>2^k+1$的形式，如此改进之后，希尔排序算法在最坏情况下的复杂度为$n^{4/3}$,平均复杂度为$O(n^{7/6})$。更重要的是，在通常应用环境中，这一增量序列的综合效率最佳。</p><table><thead><tr><th>排序方法</th><th>最坏时间复杂度</th><th>最好时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>$O( n^2)$</td><td>$ O(n)$</td><td>$ O(1)$</td><td>输入敏感，稳定</td></tr><tr><td>插入排序</td><td>$O( n^2)$</td><td>$ O(n^2)$</td><td>$ O(1) $</td><td>输入敏感，稳定</td></tr><tr><td>选择排序</td><td>$o(n^2)$</td><td>$ O(n^2) $</td><td>$ O(1) $</td><td>输入不敏感，稳定</td></tr><tr><td>归并排序</td><td>$O( nlogn)$</td><td>$O( nlogn)$</td><td>$ O(1)$</td><td>输入不敏感，稳定</td></tr><tr><td>快速排序</td><td>$O( n^2)$</td><td>$O (nlogn) $</td><td>$ O(1)$</td><td>输入不敏感，不稳定</td></tr><tr><td>桶排序</td><td>$ O(n+M)$</td><td>$ O(n+M)$</td><td>$ O(n+M)$</td><td>输入不敏感，稳定</td></tr><tr><td>基数排序</td><td>$O(t(n+M))$</td><td>$ O(t(n+M))$</td><td>$O(M)$</td><td>输入不敏感，稳定</td></tr><tr><td>计数排序</td><td>$ O(n) $</td><td>$ O(M) $</td><td>$ O(M)$</td><td>输入不敏感，稳定</td></tr><tr><td>锦标赛排序</td><td>$O( nlogn )$</td><td>$O( nlogn )$</td><td>$ O(n) $</td><td>输入不敏感，稳定</td></tr><tr><td>就地堆排序</td><td>$O( nlogn )$</td><td>$O( nlogn )$</td><td>$ O(1)$</td><td>输入不敏感，不稳定</td></tr><tr><td>shell排序</td><td>不详</td><td>不详</td><td>$ O( 1) $</td><td>底层排序算法为输入敏感算法</td></tr></tbody></table><p>以上不稳定的算法均可通过合成数的方法转换为稳定的算法，转换需要$ O(n) $时间，以上复杂度不低于$O(n)$的算法复杂度仍与之前一致。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此前我们涉及了诸多排序算法，针对向量和列表的起泡排序、归并排序以及选择排序等算法，基于散列的桶排序算法，借助堆的性质的就地堆排序算法。在此外，排序算法还有快速排序算法，希尔排序算法，其构思和技巧各具特色，在不同应用中的效率也各有千秋。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>串</title>
    <link href="http://twinkle0331.github.io/algorithm/string/"/>
    <id>http://twinkle0331.github.io/algorithm/string/</id>
    <published>2019-09-10T07:49:33.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>串或字符串属于线性结构，但字符串作为数据结构，结构简单，规模庞大，元素重复率高。所谓结构简单，是指字符表本身的规模不大，甚至可能极小。以生物信息序列为例，参与蛋白质合成的氨基酸只有20种，而构成DNA序列仅有4种。因此，以字符串形式表示的海量文本处理技术，一直都是相关领域的研究重点。</p><a id="more"></a><p>一般地，由$n$个字符组成构成的串记作：</p><p>$S=a_0a_1a_2…a_{n-1}$,其中$a_i \in \sum,0\leq i &lt;n$</p><p>这里的$\sum$是所有可用字符的集合，称作字符表，例如二进制比特集，ASCII字符集。字符串S中所含字符的总数$n$，称作S的长度，记作$|S|=n$。这里只考虑长度有限的串，特别地，长度为零的串称作空串。</p><p>字符串中任一连续的片段，称作其子串。具体地，对于任意$0\leq i&lt;i+k&lt;n$,由字符串S中起始于位置i的长度为k的子串称作后缀，分别记作：</p><p>$S.substr(i,k)=a_ia_{i+1}…a_{ i+k}=S[i,i+k)$</p><p>特殊地，起始于位置0、长度为k的子串称作前缀，而终止于位置n-1、长度为k的子串称为后缀，分别记作：</p><p>$prefix(S,k)=S.substr(0,k)=S[0,k)$</p><p>$Suffix(S,k)=S.substr(n-k,k)=S[n-k,n)$</p><p>由以上定义可知：空串是任何字符串的子串，也是任何字符串的前缀和后缀。任何字符串都是自己的子串，也是自己的前缀和后缀。</p><p>最后，字符串$S[0,n)$和$T[0,m)$相等，当且仅当二者长度相等$(n=m)$,且对应的字符相同(对任意$0\leq i&lt;n$都有$S[i]=T[i]$)。</p><h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><p>在涉及字符串的众多实际应用中，模式匹配是最常使用的一项基本操作。比如UNIX Shell的grep工具和DOS的find命令基本功能都是在指定的字符串中查找特定模式的字符串。生物信息处理领域，也经常需要在蛋白质序列中寻找特定的氨基酸模式。</p><p>以上所有应用问题，本质上都可描述为如下形式：</p><p><strong>如何在字符串数据中，检测和提取以字符串为形式给出的某一局部特征</strong>。</p><p>这类操作都属于串模式匹配范畴，简称串匹配。一般地，即</p><p>对于基于同一字符表的任何文本串$T(|T|=n)$和模式串$(|P|=m)$：</p><ul><li>判定$T$中是否存在某一子串与$T$相同</li><li>若存在(匹配)，则报告该子串在$T$中的起始位置</li></ul><p>串的长度$n$和$m$都很大，但相对而言$m$更大，即满足$2&lt;&lt;m&lt;&lt;n$ 。</p><p>根据具体应用需求的不同，串匹配模式可以多种形式呈现。</p><p>有些场合属于模式检测问题：只关心是否存在匹配而不关心具体的匹配位置，比如垃圾邮件的检测。有些场合属于模式定位问题，若经判断的确存在匹配，则还需确定具体的匹配位置，比如带病毒程序的鉴别和修复。有些场合属于模式计数问题：若存在多处匹配，则统计出匹配的子串总数，比如网络热门词汇榜的更新。有些场合则属于模式枚举问题，若存在多处匹配时，报告出所有匹配的具体位置。</p><p>如何对任一串匹配算法进行评估呢？</p><p>假设文本串T和模式串P都是随即生成的，然后综合其各种组合从数学和统计等角度得出结论。</p><p>以二进制编码为例，长度为$m$的P有$2^m$ 种，长度为$m$同时在$T$中出现的P为$n-m+1&lt;n$种。</p><p>匹配成功的概率极其低，所以并不适合作为衡量的方法。</p><p>另外一种简便策略为，随机选取文本串$T$，并从$T$中随机取出长度为$m$的子串作为模式串$P$，此为成功情况。失败情况则采用随机的模式串$P$，由此统计平均复杂度。</p><h1 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h1><p>不妨按自左向右的顺序考查各子串。在初始状态下，$T$的前$m$个字符将与$P$的$m$个字符两两对齐。接下来，自左向右检查相互对齐的这$m$对字符，若当前字符对相互匹配，则转向下一字符，反之，一旦失配，则说明在此位置文本串与模式串不可能完全匹配，于是可将$P$整体向右移动一个字符，并从其首字符开始与T中对应的新子串重新对比。</p><h2 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************************</span></span><br><span class="line"><span class="comment"> * Text     :  0   1   2   .   .   .   i-j .   .   .   .   i   .   .   n-1</span></span><br><span class="line"><span class="comment"> *             ------------------------|-------------------|------------</span></span><br><span class="line"><span class="comment"> * Pattern  :                          0   .   .   .   .   j   .   .</span></span><br><span class="line"><span class="comment"> *                                     |-------------------|</span></span><br><span class="line"><span class="comment"> ******************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Brute-force-1）</span></span><br><span class="line">   <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//模式串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m &amp;&amp; i &lt; n ) <span class="comment">//自左向右逐个比对字符</span></span><br><span class="line">      <span class="keyword">if</span> ( T[i] == P[j] ) <span class="comment">//若匹配</span></span><br><span class="line">         &#123; i ++;  j ++; &#125; <span class="comment">//则转到下一对字符</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         &#123; i -= j - <span class="number">1</span>; j = <span class="number">0</span>; &#125; <span class="comment">//文本串回退、模式串复位</span></span><br><span class="line">   <span class="keyword">return</span> i - j; <span class="comment">//如何通过返回值，判断匹配结果？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本一借助整数$i$和$j$，分别指示T和P中当前接受比对的字符T[i]和P[i]。若当前字符对匹配，则i和j同时递增以指向下一对字符。一旦$j$增长到$m$则意味着发现了匹配，即可返回P相对于T的对齐位置$i-j$。一旦当前字符失配，则i回退并指向T中当前对齐位置的下一字符，同时j复位至P的首字符处，然后开始下一轮比对。</p><p>退出情况对应于整体匹配成功与否</p><ul><li>若失败，则$j&lt;m,i=n$,$i-j$必然大于$n-m$</li><li>若成功，则$j=m,i&lt;=n$,$i-j$必然小于等于$n-m$</li></ul><h2 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************************</span></span><br><span class="line"><span class="comment"> * Text     :  0   1   2   .   .   .   i   i+1 .   .   .   i+j .   .   n-1</span></span><br><span class="line"><span class="comment"> *             ------------------------|-------------------|------------</span></span><br><span class="line"><span class="comment"> * Pattern  :                          0   1   .   .   .   j   .   .</span></span><br><span class="line"><span class="comment"> *                                     |-------------------|</span></span><br><span class="line"><span class="comment"> ******************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Brute-force-2）</span></span><br><span class="line">   <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串长度、与模式串首字符的对齐位置</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j; <span class="comment">//模式串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n - m + <span class="number">1</span>; i++ ) &#123; <span class="comment">//文本串从第i个字符起，与</span></span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; m; j++ ) <span class="comment">//模式串中对应的字符逐个比对</span></span><br><span class="line">         <span class="keyword">if</span> ( T[i + j] != P[j] ) <span class="keyword">break</span>; <span class="comment">//若失配，模式串整体右移一个字符，再做一轮比对</span></span><br><span class="line">      <span class="keyword">if</span> ( j &gt;= m ) <span class="keyword">break</span>; <span class="comment">//找到匹配子串</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//如何通过返回值，判断匹配结果？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>版本二借助整体$i$指示$P$相对于$T$的对齐位置，并随着$i$不断递增,对齐位置逐步右移。在每一对齐位置$i$处，另一整数从$0$递增至$m-1$，依次指示当前接受比对的字符为$T[i+j]$与$P[j]$。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>蛮力算法在最好情况下，只需经过一轮比对，比对次数=$m=O(m)$</p><p>然而在最坏情况下，整个算法共需做$m(n-m+1)$次比对，其中$(n-m+1)(m-1)+1$次成功比对和$n-m$次失败比对。因为$m&lt;&lt;n$，渐进的时间复杂度为$O(nm)$。</p><p>$|\sum|$越小，最坏情况出现的概率越高，$m$越大，最坏情况的后果越严重。</p><p>实际上，在通常情况下，蛮力算法效率并不算低</p><p>任意字符比对成功的概率与失败概率分别为1/s和(s-1)/s，其中$s=|\sum|$ 为字符表的规模。每个字符各有1/s的概率出现，故任一字符串相同、不同的概率分别为1/s和(s-1)/s。</p><p>在$P$与$T$的每一对齐位置，恰好执行$k$次字符对比，当且仅当前$k-1$次成功，第$k$次失败，所以需连续执行恰好$k$次字符比对操作的概率为$(s-1)/s^k$ 。</p><p>每一次字符比对可视为一次伯努利实验，成功与失败的概率分别为$1/s$和$(s-1)/s$，而每趟的比对次数X则符合几何分布，X的期望值不超过$s/(s-1)$。在$P$和$T$的每一对齐位置，需连续比对的次数不超过$s/s-1 \leq 2=O(1)$。</p><p>直接从期望值的定义出发同样可得出相应结论，具体地，连续执行字符比对操作地次数等于所有可能的次数关于对应概率的加权平均，亦即：</p><p>$\sum_{k=1}^{m}k(s-1)/s^k=(s-1)\sum_{k=1}^{m} k/s^k=s/(s-1)$</p><h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>蛮力算法在最坏情况下所需时间，为文本串长度与模式串长度的乘积，故无法应用于稍大的场合，很有必要改进。分析以上最坏情况，可知问题在于存在大量的局部匹配：每一轮的m次比对中，仅最后一次失配。一旦发现失配，文本串、模式串的长度都将回退，并重新开始下一轮的尝试。</p><p>实际上，这类重复的字符匹配没有必要，因为这些字符在前一轮迭代中已经接受过比对并且成功。那么，如何利用这些信息提高匹配的算法效率呢？</p><h2 id="next表"><a href="#next表" class="headerlink" title="next表"></a>next表</h2><p>在每轮比较进行到最后一对字符并发现失配后，蛮力算法会使两个字符指针同步后退，事实上，指针i完全不必后退。经过此前一轮的比较，已确定匹配的范围应为$P[0,j)=T[i-j,i)$</p><p>于是，若模式串经过适当右移后，可与$T$的某一子串(包含$T[i]$)完全匹配，则一项必要条件就是：</p><p>$P[0,t)=T[i-t,i)=P[j-t,j)$</p><p>亦即，在$P[0,j)$中长度为$t$的真前缀，应该与长度为$t$的真后缀完全匹配，故$t$必定来自集合:</p><p>$N(P,j)=\left{ 0\leq t&lt;j|P[0,t)=P[j-t,j) \right}$</p><p>一般地，该集合可能包含多个这样的$t$,但是需要特别注意的是，其中具体由哪些$t$值构成仅取决于模式串P和首个比对失败的$P[j]$而与文本串无关。</p><p>若下一轮比对从$T[i]$和$P[t]$的对比开始，等效于将$P$右移$j-t$个单元。因此，为保证P和T的对齐位置，即$i$绝不倒退，同时不错过任何可能的匹配，应从集合中挑选最大的$t$。当有多个值得试探的右移方案时，应选择其中移动距离最短者。于是，若令</p><p>$next[j]=max(N(p,j))$</p><p>则一旦发现$P[j]$与$T[i]$失配，即可转而将$P[next[j]]$与$T[i]$彼此对准，并从这一位置开始继续下一轮匹配。</p><p>既然集合$N[P,j)$只取决于模式串和失配位置，而与文本串无关，作为其中的最大元素$t$必然具有这一性质。对于任一字符串，均可通过预处理将所有位置$j$所对应的$next[j]$值整理为表格以便于此后查询。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123;  <span class="comment">//KMP算法</span></span><br><span class="line">   <span class="keyword">int</span>* next = buildNext ( P ); <span class="comment">//构造next表</span></span><br><span class="line">   <span class="keyword">int</span> n = ( <span class="keyword">int</span> ) <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串指针</span></span><br><span class="line">   <span class="keyword">int</span> m = ( <span class="keyword">int</span> ) <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m  &amp;&amp; i &lt; n ) <span class="comment">//自左向右逐个比对字符</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; j || T[i] == P[j] ) <span class="comment">//若匹配，或P已移出最左侧（两个判断的次序不可交换）</span></span><br><span class="line">         &#123; i ++;  j ++; &#125; <span class="comment">//则转到下一字符</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         j = next[j]; <span class="comment">//模式串右移（注意：文本串不用回退）</span></span><br><span class="line">   <span class="keyword">delete</span> [] next; <span class="comment">//释放next表</span></span><br><span class="line">   <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>next[0]</strong></p><p>只要$j&gt;0$，必有$0\in N[P,j)$，因为空串是任何非空串的子串</p><p>但若$j=0$,则有$N(P，0)= \emptyset$</p><p>不妨取$next[0]=-1$,向右移动一个字符</p><p><strong>next[j+1]</strong></p><p>根据已知的$next[0,j]$,如何高效地计算$next[j+1]$?</p><p>$next[j]=t$，则意味着在$P[0,j)$中，自匹配的真前缀和真后缀的最大长度为t，故必有$next[j+1] \leq next[j]+1 $,特别地，当且仅当$P[j]=P[t]$时取等号。</p><p>那么，更一般地，若$P[j]$不等于$p[t]$，又该如何得到$next[j+1]$?</p><p>由next表的功能定义，$next[j+1]$的下一候选者应该依次是</p><p>$next[next[j]]+1,next[next[next[j]]]+1,…$</p><p>因此，只需反复用$next[t]$替换$t$，即可按优先次序遍历以上候选者：一旦发现$P[j]$与$P[i]$匹配，可令$next[j+1]=next[t]+1$。既然总有$next[t]&lt;t$,故在此过程中$t$必然严格递减，同时，即便$t$降低至$0$，亦必然会终止于通配的next[0]=-1。</p><p>next表构造算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildNext</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造模式串P的next表</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//“主”串指针</span></span><br><span class="line">   <span class="keyword">int</span>* N = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//next表</span></span><br><span class="line">   <span class="keyword">int</span> t = N[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m - <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; t || P[j] == P[t] ) &#123; <span class="comment">//匹配</span></span><br><span class="line">         j ++; t ++;</span><br><span class="line">         N[j] = t; <span class="comment">//此句可改进...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//失配</span></span><br><span class="line">         t = N[t];</span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>KMP算法借助next表的确可以避免大量不必要的比对操作，但是直觉来看，在最坏情况下，共有$\Omega(n)$个对齐位置，而且在每一位置都有可能需要比对$\Omega(m)$次。实际上，在最坏情况下,KMP算法也只需运行线性时间。</p><p>考查作为字符指针的变量i和j，若令$k=2i-j$并考查k在KMP算法过程中的变化趋势，while每迭代一轮，k都会严格递增。</p><p>实际上，对应于while循环内部的if-else分支，无非两种情况：</p><ul><li>若转入if分支，则$k=2i-j$ 必将增加</li><li>若转入else分支，尽管$i$不变，但在赋值$j=next[j]$之后$j$必然减小，所以$k=2i-j$必然增加</li></ul><p>纵观算法的整个过程，启动时有$i=j=0$,即$k=0$,算法结束时$i\leq n$且$j \geq 0$，故有$k\leq 2n$。在此期间尽管$k$从0开始持续地递增，但累计增幅不过$2n$,故while循环至多执行$2n$轮。另外,while()循环体内部不含有任何循环和扽之调用，故只需$O(1)$时间。也就是说，尽管可能有$\Omega(n)$对齐位置，但就分摊意义而言，在每一对齐位置仅需$O(1)$次比对。</p><p>next表的构造算法与KMP算法并无本质区别，所以仿照上述分析可知，next表的构造算法仅需$O(m)$时间。综上可知，KMP算法的总体运行时间为$O(n+m)$。</p><p>特别适用于顺序存储介质，在单次匹配概率越大的场合，优势越明显，否则，与蛮力算法的性能相差无几。</p><p>在算法执行过程中：</p><ul><li>观察量$i$始终等于已经做过的成功比对次数(含最左端虚拟通配符的比对)次数</li><li>观察量$i-j$始终不小于已经做过的失败比对次数</li></ul><p>循环中if判断的两个分支，分别对应于成功和失败比对。其中，只有成功的比对会修改i,即i加一，当且仅当当前的比对是成功的。考虑到i初始值始终为0，始终等于成功比对的次数。</p><p>观察量i-j的初始值也是0。对于成功分支，变量i和j会同时递增一个单位，故$i-j$的数值将保持不变。而在失败分支中，观察量i不变，另一方面，必有$next[j]&lt;j$，故在变量$j$替换为$next[j]$之后，观察量$i-j$亦必严格单调地增加。综合以上两种情况，观察量$i-j$必然可以作为失败次数的上界。</p><p>成功比对次数和失败比对次数之和即为所有比较次数。</p><h2 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h2><p>尽管以上KMP算法可保证线性的运行时间，但在某些情况下仍然有优化的余地。</p><p>考查模式串P=”000010”</p><p><img src="https://i.loli.net/2019/09/10/6BhE1GOXm3dAULb.png"></p><p>实际上，即便说$P[3]$与$T[3]$的比较还算必然，后续的这三次对比却都是不必要的，它们的失败结果早已注定。</p><p>在之前的next表中，我们利用了以往成功比对所提供的信息，将记忆力转化为预知力，但是失败比对的教训却被忽略了。</p><p>为了吸取教训，将集合$N[P,j)$的定义修改为：</p><p>$N(P,j)=\left{ 0\leq t&lt;j|P[0,t)=P[j-t,j)\right}$ 且$P[t]!=P[j]$</p><p>除对应于自匹配长度外，$t$只有还满足当前字符对不匹配的条件方能归入集合$N[P,j)$并作为next表项的候选。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildNext</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造模式串P的next表（改进版本）</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//“主”串指针</span></span><br><span class="line">   <span class="keyword">int</span>* N = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//next表</span></span><br><span class="line">   <span class="keyword">int</span> t = N[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m - <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; t || P[j] == P[t] ) &#123; <span class="comment">//匹配</span></span><br><span class="line">         N[j] = ( P[++j] != P[++t] ? t : N[t] ); <span class="comment">//注意此句与未改进之前的区别</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//失配</span></span><br><span class="line">         t = N[t];</span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h1><p>KMP算法的思路可概括为：当前比对一旦失配。即利用此前的比对(无论成功或失败)所提供的信息，尽可能长距离地移动模式串。无需显式地反复保存或更新比对的历史，而是独立于具体的文本串，事先根据模式串预测出所有可能出现的失配情况。</p><p>串匹配过程为多次失败的对齐和0/1次成功的对齐。就单个对齐位置的排除而言，平均只需常数次比对，且具体的比对位置和次序无所谓。然而就排除更多后续位置而言，不同的对比位置及次序，作用差异极大。其中，越是靠前/后的位置，作用越小/大。</p><p>BM算法中，模式串P与文本串T的对准位置依然自左向右推移，而在每一对准位置却是自右向左地逐一比对各个字符。在每一轮自右向左的比对过程中，一旦发现失配，则将P右移一定距离并再次与T对准，然后重新一轮自右向左的扫描比对。</p><p>BM算法如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//Boyer-Morre算法（完全版，兼顾Bad Character与Good Suffix）</span></span><br><span class="line">   <span class="keyword">int</span>* bc = buildBC ( P ); <span class="keyword">int</span>* gs = buildGS ( P ); <span class="comment">//构造BC表和GS表</span></span><br><span class="line">   <span class="keyword">size_t</span> i = <span class="number">0</span>; <span class="comment">//模式串相对于文本串的起始位置（初始时与文本串左对齐）</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="built_in">strlen</span> ( T ) &gt;= i + <span class="built_in">strlen</span> ( P ) ) &#123; <span class="comment">//不断右移（距离可能不止一个字符）模式串</span></span><br><span class="line">      <span class="keyword">int</span> j = <span class="built_in">strlen</span> ( P ) - <span class="number">1</span>; <span class="comment">//从模式串最末尾的字符开始</span></span><br><span class="line">      <span class="keyword">while</span> ( P[j] == T[i + j] ) <span class="comment">//自右向左比对</span></span><br><span class="line">         <span class="keyword">if</span> ( <span class="number">0</span> &gt; --j ) <span class="keyword">break</span>; <span class="comment">/*DSA*/</span>showProgress ( T, P, i, j ); <span class="built_in">printf</span> ( <span class="string">&quot;\n&quot;</span> ); getchar();</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; j ) <span class="comment">//若极大匹配后缀 == 整个模式串（说明已经完全匹配）</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//返回匹配位置</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则，适当地移动模式串</span></span><br><span class="line">         i += __max ( gs[j], j - bc[ T[i + j] ] ); <span class="comment">//位移量根据BC表和GS表选择大者</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">delete</span> [] gs; <span class="keyword">delete</span> [] bc; <span class="comment">//销毁GS表和BC表</span></span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中借助了整数i和j指示文本串中当前对齐位置T[i]和模式串中接受比对的字符P[j]。不过，一旦局部失配，根据bc表和gs表确定最大的安全移动距离。为此，需要通过预处理，根据模式串P整理出坏字符和好后缀两类信息。</p><h2 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h2><p>若当前模式串P当前在文本串中的对齐位置为i，且在这一轮自右向左将P和substr(T,i,m)的比对过程中，在P[j]处首次发现失配：$T[i+j] =X \neq Y=P[j]$，则将$X$称为坏字符。</p><p>若P与T的某一子串(包括$T[i+j]$在内)匹配，则必然在$T[i+j]=X$中匹配，反之，若与$T[i+j]$对准的字符不是X,则必然失配。只需找出P中的每一字符X，分别与$T[i+j]=X$对准，并执行一轮从右向左的扫描比对。对应每个这样的字符，P的位移量仅取决于原来失配位置$j$，以及$X$在P中的秩，而与$T$和$i$​无关。</p><p><strong>bc表</strong></p><p>若P中含有多个X,仅尝试p中最靠右的字符X(若存在)。如此可在确保不致遗漏匹配的前提下，始终单向地滑动模式串。若P中最靠右的字符X为$P[k]=X$,则P的右移量为$j-k$。</p><p>对于任一给定的模式串P，$k$值只取决于字符$T[i+j]=X$,因此可视为从字符表到整数(P中字符的秩)的一个函数</p><p>$bc(x)=$</p><ul><li>$k$，若$P[k]=x$,且对所有的$i&gt;k$都有$p[i]!=c$</li><li>$-1$,若P中不含字符$c$</li></ul><p>若当前对齐位置为$i$，则一旦出现坏字符$P[j]=Y$,则重新对齐于$i+=j-bc[T[i+j]]$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*****************************************************************************************</span></span><br><span class="line"><span class="comment">//    0                       bc[&#x27;X&#x27;]                                m-1</span></span><br><span class="line"><span class="comment">//    |                       |                                      |</span></span><br><span class="line"><span class="comment">//    ........................X***************************************</span></span><br><span class="line"><span class="comment">//                            .|&lt;------------- &#x27;X&#x27; free ------------&gt;|</span></span><br><span class="line"><span class="comment">//*****************************************************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildBC</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造Bad Charactor Shift表：O(m + 256)</span></span><br><span class="line">   <span class="keyword">int</span>* bc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//BC表，与字符表等长</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j ++ ) bc[j] = <span class="number">-1</span>; <span class="comment">//初始化：首先假设所有字符均未在P中出现</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; j &lt; m; j ++ ) <span class="comment">//自左向右扫描模式串P</span></span><br><span class="line">      bc[ P[j] ] = j; <span class="comment">//将字符P[j]的BC项更新为j（单调递增）——画家算法</span></span><br><span class="line">   <span class="comment">/*DSA*/</span>printBC ( bc );</span><br><span class="line">   <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该算法在对BC表初始化后，对模式串做一遍线性扫描，并不断用当前字符的秩更新BC表中的对应项。因为是按照秩递增的顺序从左到右扫描，所以只要c在P中出现过，则最终的BC表将记录下其中最靠右的秩。</p><p>运行时间可划分为两个部分，分别消耗于其中的两个循环，前者是对字符表中每个字符进行初始化，时间不超过$O(|\sum|)$ 。后一循环对模式串P做一轮扫描，其中每个字符消耗$O(1)$时间，故共需$O(m)$时间。由此可知，BC表可在$O(|\sum|+m)$时间内构造出来，其中$|\sum|$为字符表的规模，m为模式串的长度。</p><p>暂且不计构造BC表的过程，BM算法本身进行串模式匹配所需时间与具体的输入十分相关。若将文本串和模式串的长度分别记作n和m，则在通常情况下实际运行时间往往低于$O(n)$。在最好情况下，每经过常数次比对就可以将模式串整体向右移动m个字符，此类情况下只需$O(n/m)$次比对算法即可终止，故运行时间不过$ O(n/m)$。</p><p>在最坏情况下，每轮迭代都需要在扫过整个P之后，方能确定右移一个字符，须经过m次比较，方能排除单个对齐位置，时间复杂度为$ O(nm) $。</p><p>单次匹配概率越大的场合，性能越接近蛮力算法。</p><p>针对坏字符在模式串中的位置太过于靠右，以至位移量为负的情况，建议将P右移一个字符，此后并不能保证坏字符出恢复匹配，可在P[j]的左侧找到最靠右的字符并将其与原坏字符对齐。</p><p>以上思路的实现方式等效于将原来一维的bc表，替换为二维的bc表，具体地，这是一张m*$|\sum|$ 的表格。尽管预处理时间和所需空间增长量并不大，但是匹配算法的控制流程却进一步复杂化。最重要的是，此类二维bc表若能发挥作用，则当时的好后缀必然很长，此类情况同时使用的gs表必然可以代替bc表。</p><h2 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h2><p>参照KMP算法的思路，坏字符策略仅仅利用了此前失败比对所提供的教训而忽视了成功的比对。类似于KMP算法，只不过前后颠倒而已。</p><p>每轮比对中的若干次成功匹配，都对应于模式串P的一个后缀，称为好后缀(good suffix)。</p><p>一般地，设本轮自右向左的扫描匹配终止于失配位置：</p><p>$T[i+j]=X \neq Y=P[j]$</p><p>若分别记</p><p>$W=substr(T,i+j+1,m-j-1)=T[i+j+1,m+i)$</p><p>$U=suffix(P,m-j-1)=P[j+1,m)$</p><p>则$U$为当前的好后缀，$W$为$T$中与之匹配的子串。好后缀的长度为m-j-1,故只要$j\leq m-2$,则$U$必然非空，$U=W$。</p><p>此时若存在某一整数，使得在将P整体右移j-k个单元，并使$P[k]$与$T[i+j]$相互对齐之后，$P$可以与文本串的某一子串(包括$T[m+j-1]$在内)匹配，亦即</p><p>$P=substr(T,i+j-k,m)=T[i+j-k,m+i+j-k)$</p><p>于是，若记：</p><p>$V(k)=substr(P,k+1,m-j-1)=P[k+1,m-j+k)$</p><p>必然有$V(k)=W=U$</p><p>也就是说，若值得将$P[k]$与$T[i+j]$对齐并做新的一轮比对，则P的子串首先必须和P自己的后缀U相匹配。</p><p>另外，还有一必要条件，P中这两个匹配的子串的前驱字符不得相等，即P[k]$\neq$ P[j],与之前类似，在此处必将再次失败。</p><p>若模式串存在多个满足上述必要条件的子串V(k),不妨选取其中最靠右者(对应最大的$k$,最小的右移距离$j-k$)。</p><p>若P中不存在任何子串与U完全匹配，则从P的所有前缀中，找出可与U的某一真后缀相匹配的最长者作为V(k)，并取$gs[j]=m-|V(k)|$。</p><p>与之前类似，位移量只取决于$j$和$P$本身，亦可预先计算并制表待查。</p><p><strong>gs表</strong></p><blockquote><p>蛮力算法</p></blockquote><p>根据以上定义，可导出gs表构造算法如下：</p><p>对于每个好后缀$P(j,m)$，按照从后向前($k$从$j-1$递减至0)的次序，将其与P的每个子串$P(k,m+k-j)$一一对齐，并核对是否出现匹配，一旦出现，对应的位移量即为$gs[j]$的取值。</p><p>这里共有$O(m)$个好后缀，可与$O(m)$个子串相互对齐，每次对齐后在最坏情况下需要比对$O(m)$次，因此该算法可能需要$O(m^3)$次。</p><p>实际上，仅需线性时间即可构造出gs表。</p><p><strong>ss表</strong></p><p>对于任一整数$j\in[0,m)$,在$P[0,j]$的所有后缀中，考查那些与P的某一后缀匹配者。若将其中最长者记作MS[j]，则$ss[j]$就是该串的长度$|MS[j]|$.特别地，在$MS[j]$不存在时，取$ss[j]=0$。</p><p>综上所述，可定义$ss[j]$如下：</p><p>$ss[j]=max{ 0\leq s\leq  j+1|P(j-s,j]=P[m-s,m)}$</p><p>特别地，当$j=m-1$时，必有$s=m$，此时，有$P(-1,m-1]=P[0,m)$</p><p>任一字符$P[j]$对应的$ss[j]$值，可分两种情况提供有效的信息：</p><ul><li>$ss[j]=j+1$ 也就是说MS[j]就是整个前缀，后缀长度应该大于$j+1$，所以此时对应于$P[m-j-1]$左侧的每个字符$P[i]$而言，$P[m-1]$下一步可与$P[j]$对齐，所以$m-j-1$都应是$gs[i]$取值的一个候选。</li><li>$ss[j] \leq j MS[j]$只是$P[0,j]$的一个真后缀。同时，既然$MS[j]$是极长的，故必有：$P[m-ss[j]-1]\neq P[j-ss[j]]$ ,此时的字符$m-j-1$也应是$gs[m-ss[j]-1]$取值的一个候选</li></ul><p>根据此前定义，每一位置i所对应的gs[i]值只可能来自于以上候选。</p><p><strong>ss表的构造</strong></p><p>由上可见，ss表的确是构造gs表的基础和关键，同样，若采用蛮力策略，则对每个字符$P[j]$都需要做一趟扫描对比，直到出现失配。如此，累计需要$O(m)$时间。</p><p>为了提高效率，不妨从后至前逆向扫描，并逐一地计算出各字符$P[j]$对应的$ss[j]$的值。</p><p>通过$lo,hi$来动态记录当前的极长匹配后缀：$P(lo,hi]=P[m-hi+lo,m)$</p><p>此时必有$P[j]=P[m-hi+j-1]$,故可利用此前已经计算的$ss[m-hi+j-1]$，分两种情况快速得导出$ss[j]$</p><ul><li>如图(a)所示，$ss[m-hi+j-1]\leq j-lo$,此时，$ss[m-hi+j-1]$也是$ss[j]$可能的最大取值，可直接得到$ss[j]=ss[m-hi+j-1]$。</li><li>如图(b)所示，$j-lo&lt;ss[m-hi+j-1]$，此时，至少仍有$P(lo,j]=P[m-hi+lo,m-hi+j)$,故只需将$p[j-ss[m-hi+j-1],lo]$与$P[m-hi+j-ss[m-hi+j-1],m-hi+lo]$做一比对，也可确定$ss[j]$。</li></ul><p><img src="https://i.loli.net/2019/09/11/JhYefNSm7dsBGEM.png"></p><p>由以上构思，可在$O(m)$时间内构造出ss表。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildSS</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造最大匹配后缀长度表：O(m)</span></span><br><span class="line">   <span class="keyword">int</span> m = <span class="built_in">strlen</span> ( P ); <span class="keyword">int</span>* ss = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//Suffix Size表</span></span><br><span class="line">   ss[m - <span class="number">1</span>]  =  m; <span class="comment">//对最后一个字符而言，与之匹配的最长后缀就是整个P串</span></span><br><span class="line"><span class="comment">// 以下，从倒数第二个字符起自右向左扫描P，依次计算出ss[]其余各项</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> lo = m - <span class="number">1</span>, hi = m - <span class="number">1</span>, j = lo - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line">      <span class="keyword">if</span> ( ( lo &lt; j ) &amp;&amp; ( ss[m - hi + j - <span class="number">1</span>] &lt;= j - lo ) ) <span class="comment">//情况一</span></span><br><span class="line">         ss[j] =  ss[m - hi + j - <span class="number">1</span>]; <span class="comment">//直接利用此前已计算出的ss[]</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//情况二</span></span><br><span class="line">         hi = j; lo = __min ( lo, hi );</span><br><span class="line">         <span class="keyword">while</span> ( ( <span class="number">0</span> &lt;= lo ) &amp;&amp; ( P[lo] == P[m - hi + lo - <span class="number">1</span>] ) ) <span class="comment">//二重循环？</span></span><br><span class="line">            lo--; <span class="comment">//逐个对比处于(lo, hi]前端的字符</span></span><br><span class="line">         ss[j] = hi - lo;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂且忽略内循环，首先考查外循环，若将j作为其控制变量，则不难验证</p><ol><li>$j$的初始值为$m-2$</li><li>每经过一步迭代，$j$都会递减一个单位</li><li>在其他任何语句中，$j$都没有作为左值被修改</li><li>一旦$j$减至负数，外循环随即终止</li></ol><p>由此可知，外循环至多迭代$O(m)$步，累计耗时$O(m)$。</p><p>尽管从表面的形式来看，外循环的每一步都有可能执行一趟内循环，但实际上所有的内循环累计运行时间也不超过$O(m)$。为此，只需将lo视为其控制变量，则不难验证：</p><ol><li>$lo$的初始值为$m-1$</li><li>每经过一步内循环的迭代，$lo$值都会递减一个单位</li><li>在其他部分，$lo$只能在<code>lo=__min ( lo, hi )</code> 一句中作为左值被修改，但仍是非增</li><li>一旦$lo$减至负数，内循环就不再启动</li></ol><p>由此可知，内循环至多迭代$O(m)$步，相应地，累计耗时不过$O(m)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildGS</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造好后缀位移量表：O(m)</span></span><br><span class="line">   <span class="keyword">int</span>* ss = buildSS ( P ); <span class="comment">//Suffix Size table</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ); <span class="keyword">int</span>* gs = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//Good Suffix shift table</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m; j ++ ) gs[j] = m; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; j &lt; UINT_MAX; j -- ) <span class="comment">//逆向逐一扫描各字符P[j]</span></span><br><span class="line">      <span class="keyword">if</span> ( j + <span class="number">1</span> == ss[j] ) <span class="comment">//若P[0, j] = P[m - j - 1, m)，则</span></span><br><span class="line">         <span class="keyword">while</span> ( i &lt; m - j - <span class="number">1</span> ) <span class="comment">//对于P[m - j - 1]左侧的每个字符P[i]而言（二重循环？）</span></span><br><span class="line">            gs[i++] = m - j - <span class="number">1</span>; <span class="comment">//m - j - 1都是gs[i]的一种选择</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j ++ ) <span class="comment">//画家算法：正向扫描P[]各字符，gs[j]不断递减，直至最小</span></span><br><span class="line">      gs[m - ss[j] - <span class="number">1</span>] = m - j - <span class="number">1</span>; <span class="comment">//m - j - 1必是其gs[m - ss[j] - 1]值的一种选择</span></span><br><span class="line">   <span class="keyword">delete</span> [] ss; <span class="keyword">return</span> gs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以j为外循环的控制变量，则可知外循环至多迭代$O(m)$步，以i作为内循环的控制变量，可知内循环累计至多迭代$O(m)$步，累计耗时$O(m)$。</p><p>在模式枚举类应用中，需要从文本串T中找出所有的模式串P，有时允许两次出现的位置不超过m个字符。比如在000000中查找000，若限制多次出现的模式串之间至少相距3个字符，则应找到2处匹配，若不加以限制，则应找到4处匹配。在这种情况下，最坏情况下复杂度可能达到$O(nm)$。</p><p>可通过Galil规则对上述情况改进，总体耗时不致于超过线性的规模。</p><h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><p>空间复杂度为$|bc[]|+|gs[]|=O(|\sum|+m)$</p><p>预处理的时间为$O(|\sum|+m)$</p><p>查找在最好情况下为$O(n/m)$，最差情况下为$O(n+m)$</p><p>在通常情况下，单次比对的成功概率直接取决于字符集的规模。当字符集规模较小时，单次比对的成功概率较高，蛮力算法的效率低。此时，KMP算法稳定的线性复杂度更能体现出优势，而采用BC表的BM算法并不能大跨度地向前移动。</p><p>反之，若字符串的规模较大，则单词比对的成功概率较小，蛮力算法也可接近线性复杂l度，此时，尽管KMP算法仍然保持线性复杂度，但相对而言的优势并不明显，而采用BC表的BM算法则会因为比对失败概率的增加，从而大跨度地向前移动。</p><table><thead><tr><th></th><th>最好情况</th><th>最坏情况</th><th>特点l</th></tr></thead><tbody><tr><td>蛮力算法</td><td>$ O(n)$</td><td>$ O( nm )$</td><td>适用于规模较大的字符集，通常情况下实际运行效率不低</td></tr><tr><td>KMP算法</td><td>$ O(n+m)$</td><td>$O(n+m)$</td><td>适用于规模较小的字符集，字符集规模较大时与蛮力算法不相上下</td></tr><tr><td>BM算法(bc)</td><td>$O(n/m )$</td><td>$O( nm)$</td><td>适用于规模较大的字符集，性能浮动范围大</td></tr><tr><td>BM算法(bc+gs)</td><td>$O(n/m)$</td><td>$ O(n+m)$</td><td>四种算法中最优</td></tr></tbody></table><h1 id="Karp-rabin算法"><a href="#Karp-rabin算法" class="headerlink" title="Karp-rabin算法"></a>Karp-rabin算法</h1><p>将任一有限字符串视作自然数，进而在字符串和自然数之间建立联系。若字符串规模$|\sum|$ 对应于一个$d+1$进制的整数。</p><p>以由大写英文字母组成的字母表为例，若将这些字符表依次映射为[1,26]内的自然数，则每个这样的字符串都将对应于一个26+1=27进制的整数，比如：</p><p>$CANTOR \leq 3,1,14,20,15,18\geq43,868,727(10)$</p><p>以上散列并非满射，但是不含’0’的任一$d+1$进制值自然数，唯一地对应于某个字符串。字符串经如此转换得到的散列码，称为其指纹。之所以取$d+1$而不是$d$，是为了回避’0’字符以保证这一映射为单射，否则若字符串中存在由’0’字符组成的前缀，则无论该前缀长度如何，都不会影响对应的整数取值。</p><p>由此可将判断模式串是否与文本匹配的问题转换为判断T中是否由某个子串相同的指纹的问题，具体地，只要逐一取出T中长度为m的子串，并将其对应的指纹与P所对应的指纹一一比对即可确定是否存在匹配位置，称为karp-robin算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Karp-Rabin）</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), n = <span class="built_in">strlen</span> ( T ); <span class="comment">//assert: m &lt;= n</span></span><br><span class="line">   HashCode Dm = prepareDm ( m ), hashP = <span class="number">0</span>, hashT = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++ ) &#123; <span class="comment">//初始化</span></span><br><span class="line">      hashP = ( hashP * R + DIGIT ( P, i ) ) % M; <span class="comment">//计算模式串对应的散列值</span></span><br><span class="line">      hashT = ( hashT * R + DIGIT ( T, i ) ) % M; <span class="comment">//计算文本串（前m位）的初始散列值</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> k = <span class="number">0</span>; ; ) &#123; <span class="comment">//查找</span></span><br><span class="line">      <span class="keyword">if</span> ( hashT == hashP ) </span><br><span class="line">         <span class="keyword">if</span> ( check1by1 ( P, T, k ) ) <span class="keyword">return</span> k;</span><br><span class="line">      <span class="keyword">if</span> ( ++k &gt; n - m ) <span class="keyword">return</span> k; <span class="comment">//assert: k &gt; n - m，表示无匹配</span></span><br><span class="line">      <span class="keyword">else</span> updateHash ( hashT, T, m, k, Dm ); <span class="comment">//否则，更新子串散列码，继续查找</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法除了预先计算模式串指纹hash(P)等预处理，至多包含$|T|-|P|=n-m$次迭代，每轮都需计算当前子串的指纹。</p><p>然而，若字符集规模较大，模式串P较长，其对应的指纹将很大。若指纹的长度无法在常数时间内完成，总体需要$O(nm)$时间。</p><h2 id="散列压缩"><a href="#散列压缩" class="headerlink" title="散列压缩"></a>散列压缩</h2><p>通过对比压缩后的指纹，确定匹配位置，借助散列将指纹压缩至存储器支持的范围。比如，采用模余函数：$hash(key)=key % M$</p><p>经过散列压缩后指纹比对的时间将仅取决于散列表长，而与模式串长m无关。</p><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>hash()值相等，并非匹配的充分条件，压缩散列空间的时候必然引起冲突。文本串中不同子串的指纹可能相同，甚至都恰好与模式串相同。因此，通过hash()筛选之后，还须经过严格比对，方可确定是否匹配。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check1by1</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T, <span class="keyword">size_t</span> i )</span> </span>&#123; <span class="comment">//指纹相同时，逐位比对以确认是否真正匹配</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; j &lt; m; j++, i++ ) <span class="comment">//尽管需要O(m)时间</span></span><br><span class="line">      <span class="keyword">if</span> ( P[j] != T[i] ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//但只要散列得当，调用本例程并返回false的概率将极低</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适当选取散列函数可大大降低冲突的可能。</p><h2 id="指纹更新"><a href="#指纹更新" class="headerlink" title="指纹更新"></a>指纹更新</h2><p>可根据前一子串和后一子串的指纹，在常数时间内得到后一子串的指纹。整个算法过程中，消耗与子串计算的时间，平均每次仅为常数时间。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子串指纹快速更新算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHash</span> <span class="params">( HashCode&amp; hashT, <span class="keyword">char</span>* T, <span class="keyword">size_t</span> m, <span class="keyword">size_t</span> k, HashCode Dm )</span> </span>&#123;</span><br><span class="line">   hashT = ( hashT - DIGIT ( T, k - <span class="number">1</span> ) * Dm ) % M; <span class="comment">//在前一指纹基础上，去除首位T[k - 1]</span></span><br><span class="line">   hashT = ( hashT * R + DIGIT ( T, k + m - <span class="number">1</span> ) ) % M; <span class="comment">//添加末位T[k + m - 1]</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &gt; hashT ) hashT += M; <span class="comment">//确保散列码落在合法区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HashCode <span class="title">prepareDm</span> <span class="params">( <span class="keyword">size_t</span> m )</span> </span>&#123; <span class="comment">//预处理：计算R^(m - 1) % M （仅需调用一次，不必优化）</span></span><br><span class="line">   HashCode  Dm = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; m; i++ ) Dm = ( R * Dm ) % M; <span class="comment">//直接累乘m - 1次，并取模</span></span><br><span class="line">   <span class="keyword">return</span> Dm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;串或字符串属于线性结构，但字符串作为数据结构，结构简单，规模庞大，元素重复率高。所谓结构简单，是指字符表本身的规模不大，甚至可能极小。以生物信息序列为例，参与蛋白质合成的氨基酸只有20种，而构成DNA序列仅有4种。因此，以字符串形式表示的海量文本处理技术，一直都是相关领域的研究重点。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>优先级队列</title>
    <link href="http://twinkle0331.github.io/algorithm/pq/"/>
    <id>http://twinkle0331.github.io/algorithm/pq/</id>
    <published>2019-09-09T07:36:38.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>此前的搜索树和词典结构都支持覆盖全集的访问和操作，其中存储的每一数据对象都可作为查找和访问目标。搜索树结构需要在所有元素之间定义并维护一个显式的全序关系，而词典结构从内部强制地在对象和对应的秩之间建立起某种关联关系，隐式地定义了一个全序关系。优先级队列将操作对象限定于当前的全局极值者。比如，在所有鸟类中，查找种群规模最小者。这一访问方式称为循优先级访问。</p><a id="more"></a><p>在实际应用环境中，不少事件都可用优先级队列描述，比如银行会员排队问题，操作系统的任务调度问题，输入法的词频调整。数据项的某种属性只要可以相互比较大小，则这种大小称为优先级。按照事先约定的优先级，可以始终高效地查找优先级最高的数据项的数据结构统一称为优先级队列。</p><p>考虑之前的数据结构效率</p><table><thead><tr><th></th><th>getmax()</th><th>delmax()</th><th>insert()</th></tr></thead><tbody><tr><td>无序向量</td><td>$\Theta(n)$</td><td>$ \Theta(n)$</td><td>$O( 1 )$</td></tr><tr><td>有序向量</td><td>$O (1)$</td><td>$O (1)$</td><td>$O( n )$</td></tr><tr><td>无序列表</td><td>$\Theta ( n )$</td><td>$\Theta ( n )$</td><td>$O ( 1 )$</td></tr><tr><td>有序列表</td><td>$O (1)$</td><td>$O (1)$</td><td>$O( n )$</td></tr></tbody></table><p>AVL、splay、red-black树三个接口均只需$O(logn)$时间，但是BBST的功能远远超出了优先级队列的要求。若只需查找极值元，则不必维护所有元素的全序关系，偏序足以。</p><h1 id="完全二叉堆"><a href="#完全二叉堆" class="headerlink" title="完全二叉堆"></a>完全二叉堆</h1><p>有限偏序值的极值必定存在，此时借助堆结构维护一个全序即足矣。完全二叉堆即为堆结构的典型代表。</p><h2 id="结构性与堆序性"><a href="#结构性与堆序性" class="headerlink" title="结构性与堆序性"></a>结构性与堆序性</h2><p>首先结构性是在逻辑结构上须等同于完全二叉树，如此一来，堆节点和词条一一对应。其次，堆顶节点之外的每个节点都不大于其父节点，这即为堆序性。</p><p>由堆序性可以看出，堆中优先级最高的词条必然处于堆顶位置。因此，堆结构的<code>getmax()</code> 操作总是在堆顶完成。</p><p>完全二叉堆的拓扑联接结构完全由其规模$n$确定。按照层次遍历的顺序，每个节点都对应唯一的编号。故若将所有节点组织为一个向量，则堆中各节点与向量单元的秩必将一一对应。各节点在物理上连续排列，故仅需$O(n)$时间。通过节点的编号，可便捷地判断父子关系。</p><p>对于完全二叉堆中的任意节点$v$，必然满足：</p><ol><li>若$v$有左孩子，则$i(lchild(v))=2i(v)+1$</li><li>若$v$有右孩子，则$i(rchild(v))=2i(v)+2$</li><li>若$v$有父节点，则$i(parent(v))=\lfloor (i(v)-1)/2 \rfloor=\lceil i(v)/2 \rceil -1$</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  Parent(i)         ( ( i - 1 ) &gt;&gt; 1 ) <span class="comment">//PQ[i]的父节点（floor((i-1)/2)，i无论正负）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LChild(i)         ( 1 + ( ( i ) &lt;&lt; 1 ) ) <span class="comment">//PQ[i]的左孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RChild(i)         ( ( 1 + ( i ) ) &lt;&lt; 1 ) <span class="comment">//PQ[i]的右孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LastInternal(n)   Parent( n - 1 ) <span class="comment">//最后一个内部节点（即末节点的父亲）</span></span></span><br></pre></td></tr></table></figure><p>共$n$个节点时，内部节点的最大秩$=\lfloor (n-2)/2 \rfloor=\lceil (n-3)/2 \rceil$</p><p>令各节点的秩统一地递增一个单位，从秩的二进制表示来看，祖先必是后代的前缀。</p><p>对于秩为$r$的元素，其上溯第$h$代祖先所对应的秩必然为$O((r+1)&gt;&gt;h)-1)$</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>为插入词条$e$,只需将$e$作为末元素接入向量，结构性自然保持，若堆序性亦未破坏，则完成。</p><p>若违反堆序性，则只能是与其父亲违反堆序性，$e$与其父节点交换，不断重复直到$e$与其父亲满足堆序性或者$e$到达堆顶。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::insert ( T e ) &#123; <span class="comment">//将词条插入完全二叉堆中</span></span><br><span class="line">   Vector&lt;T&gt;::insert ( e ); <span class="comment">//首先将新词条接至向量末尾</span></span><br><span class="line">   percolateUp ( _size - <span class="number">1</span> ); <span class="comment">//再对该词条实施上滤调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对向量中的第i个词条实施上滤操作，i &lt; _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank PQ_ComplHeap&lt;T&gt;::percolateUp ( Rank i ) &#123;</span><br><span class="line">   <span class="keyword">while</span> ( ParentValid ( i ) ) &#123; <span class="comment">//只要i有父亲（尚未抵达堆顶），则</span></span><br><span class="line">      Rank j = Parent ( i ); <span class="comment">//将i之父记作j</span></span><br><span class="line">      <span class="keyword">if</span> ( lt ( _elem[i], _elem[j] ) ) <span class="keyword">break</span>; <span class="comment">//一旦当前父子不再逆序，上滤旋即完成</span></span><br><span class="line">      swap ( _elem[i], _elem[j] ); i = j; <span class="comment">//否则，父子交换位置，并继续考查上一层</span></span><br><span class="line">   &#125; <span class="comment">//while</span></span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//返回上滤最终抵达的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效率</strong></p><p>$e$与父亲的交换，每次仅需$O(1)$时间，每经过一次交换,$e$都会上升一层。在插入新节点$e$的过程中，只有$e$的祖先们才有可能需要与之交换。完全二叉堆以完全二叉树实现，必平衡，故$e$的祖先至多$O(logn)$个。</p><p>通过上滤，可在$O(logn)$时间内插入一个新节点，并整体得以调整为堆。</p><p>可在向量中将各节点顺次后移一个单元，并在腾出的元素中置入对应元素类型的最大值作为哨兵(比如，对于整数取作<code>INT_MAX</code>)。但在上滤过程中只需比较父子节点的大小，而无需核对是否越界。</p><p>如此转换后，父子节点各自在物理上所对应的秩需要进行调整</p><p>对于完全二叉堆中的任意节点$v$，必然满足：</p><ol><li>若$v$有左孩子，则$i(lchild(v))=2i(v)$</li><li>若$v$有右孩子，则$i(rchild(v))=2i(v)+1$</li><li>若$v$有父节点，则$i(parent(v))=\lfloor i(v)/2 \rfloor=\lceil (i(v)-1)/2 \rceil $</li></ol><p>在上滤的过程无需核对是否已经越界，因此在一定程度上提高插入操作的效率，但渐进复杂度仍然为$O(logn)$。当然，以上调整对下滤的过程及效率没有影响。</p><p>在堆顶通往任一叶节点的沿途上，各节点对应的关键码必然单调变化。所以可在引入新节点但未上滤调整之前，将该节点对应的查找路径视为一个静态查找表。并使用二分查找算法。</p><p>具体地，每次都可在$O(1)$时间内确定高度居中地祖先的秩，将其作为轴点，只需再做$O(1)$次比较，即可将查找范围缩小一半。如此反复迭代，直到查找范围内只剩下耽搁节点。</p><p>既然完全二叉堆的高度不超过$h=O(logn)$,故整个查找过程的迭代次数将不超过：</p><p>$logh=O(loglogn)$</p><p>以上算法只适用于上滤操作，因为任一节点通向其后代的路径并不唯一，而通往其祖先的路径必然唯一。</p><p>同时，以上方法可以有效地减少词条地比较操作，但是词条交换操作却不可减少。事实上，无论如何，再最坏情况下仍然需要执行$O( h )=O(logn)$次交换操作。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>最大元素始终在堆顶，删除堆顶元素只需要摘除向量首元素，以末元素$e$代替。若新堆顶$e$不满足堆序性，将$e$与其(至多)两个孩子中的大者交换。若与新孩子继续违反堆序性，则继续套用以上方法，不断重复，直到$e$满足堆序性，或已为叶子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_ComplHeap&lt;T&gt;::delMax() &#123; <span class="comment">//删除非空完全二叉堆中优先级最高的词条</span></span><br><span class="line">   T maxElem = _elem[<span class="number">0</span>]; _elem[<span class="number">0</span>] = _elem[ --_size ]; <span class="comment">//摘除堆顶（首词条），代之以末词条</span></span><br><span class="line">   percolateDown ( _size, <span class="number">0</span> ); <span class="comment">//对新堆顶实施下滤</span></span><br><span class="line">   <span class="keyword">return</span> maxElem; <span class="comment">//返回此前备份的最大词条</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对向量前n个词条中的第i个实施下滤，i &lt; n</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank PQ_ComplHeap&lt;T&gt;::percolateDown ( Rank n, Rank i ) &#123;</span><br><span class="line">   Rank j; <span class="comment">//i及其（至多两个）孩子中，堪为父者</span></span><br><span class="line">   <span class="keyword">while</span> ( i != ( j = ProperParent ( _elem, n, i ) ) ) <span class="comment">//只要i非j，则</span></span><br><span class="line">      &#123; swap ( _elem[i], _elem[j] ); i = j; &#125; <span class="comment">//二者换位，并继续考查下降后的i</span></span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//返回下滤抵达的位置（亦i亦j）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效率</strong></p><p>在下滤的过程中，每经过一次交换，$e$的高度都将降低一层。故在每层至多需要一次交换。由于堆是完全二叉树，高度为$O(logn)$。通过下滤，可在$O(logn)$时间内删除堆顶节点并整体重新调整为堆。</p><p>若实际上升$k=O(logn)$层，则$k$次<code>swap()</code>操作共需$3k+1$次，可将此类赋值操作降低至$k+1$次。</p><p>在插入接口的上滤操作中，新元素可暂且不予插入，而只是将其上若干代祖先节点依次下移，待所有祖先均已就位时，才将新元素置入腾空的空节点。删除操作同理。</p><blockquote><p>为何在摘除堆顶元素后，不自上而下地依次以更大孩子节点顶替空缺的父节点</p></blockquote><p>如此可以维持完全二叉堆的堆序性，但是经过如此调整后完全二叉堆的拓扑结构未必仍然是一棵完全二叉树，故其结构性可能遭到破坏，因为该节点到最大孩子的路径和根节点到末节点的路径未必是同一条。</p><blockquote><p>在关键码独立均匀分布时，插入操作平均只需常数时间</p></blockquote><p>根据堆的定义及调整规则，若新节点$p$通过上滤升高了k层，则意味着在$2^{k+1}$个随机节点($p$的父亲、$p$、以及$p$的$2^{k+1}-2$)中，该节点恰好为第二大者。</p><p>于是，若将新节点$p$累计上升的高度记作H,则H恰好为$k$的概率为:</p><p>$Pr(H=k)=1/2^{k+1}=(1/2)^k(1/2),0\leq k$</p><p>这是一个典型的几何分布，其数学期望为：</p><p>$E(h)=1/(1/2)-1=1$</p><p>每个节点经过上滤后平均上升1层，其间需做$1+1=2$次比较操作。</p><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>很多算法中输入词条都是成批给出，故在初始化阶段往往需要解决一个共同问题:给定一组词条，高效地将他们组织为一个堆，这一过程称为建堆。</p><p><strong>蛮力算法</strong></p><p>从空堆开始，反复调用<code>insert()</code> 接口，即可将输入词条逐一插入其中，并最终完成建堆的任务。</p><p>若共有$n$个词条，则累计耗时量为：</p><p>$O(1)+O(2)+O(3)+…+O(n)=O(logn!)=O(nlogn)$</p><p>在$O(nlogn)$时间内可对所有词条全排序，但是在此只能提供一个偏序。</p><p><strong>自上而下的下滤</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify ( Rank n ) &#123; <span class="comment">//Floyd建堆算法，O(n)时间</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i-- ) <span class="comment">//自底而上，依次</span></span><br><span class="line">      percolateUp ( n, i ); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效率</strong></p><p>最坏情况下，每个节点都需要上滤至根，所需成本线性正比于其深度。即便只考虑底层，$n/2$个叶节点，深度均为$O(logn)$,累计耗时$O(nlogn)$，与蛮力算法一致。</p><p>考查高度为$h$，规模为$n=2^{h+1}-1$的满二叉树，其中深度为$i$的节点有$2^i$个，整个算法平均复杂度为：</p><p>$\sum_{i=1}^{n}(i2^i)=(h-1)2^{h+1}+2=(log_2(n+1)-2)(n+1)+2=O(nlogn)$ </p><p><strong>floyd算法</strong></p><p>给定任意堆$H_0$和$H_1$，以及节点$p$，将其转化为一个新堆，相当于以$p$为中介将堆$H_1$,$H_2$ 合并，故称为堆合并操作。</p><p>为满足结构性，可将这两个堆作为p的左、右子树，联接成一棵完整的二叉树。若p与孩子满足堆序性，则该二叉树为一个不折不扣的二叉堆。此时等效于在<code>delMax()</code>中摘除堆顶，再将末位词条转移至堆顶。只需对堆顶p实施下滤操作即可将全树转换为堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify ( Rank n ) &#123; <span class="comment">//Floyd建堆算法，O(n)时间</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = LastInternal ( n ); InHeap ( n, i ); i-- ) <span class="comment">//自底而上，依次</span></span><br><span class="line">      percolateDown ( n, i ); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效率</strong></p><p>每个内部节点所需的调整时间，正比于其高度而非深度。</p><p>不失一般性，考查满树$n=2^{d+1}-1$</p><p>$S(n)=$所有节点的高度总和</p><p>$\sum_{i=0}^{d} (d-i)(2^i)=d \sum_{i=0}^{d}2^i-T(n)$</p><p>$=d(2^{d+1}-1)-[(d-1)2^{d+1}+2]=2^{d+1}-(d+2)=n-log_2(n+1)=O(n)$</p><p>同层内部节点下滤的次序，仅涉及到其各自的后代，它们之间完全相互独立，故改变次序不影响最终的结果。同时，每个节点下滤过程完全不变，所需时间不变，建堆所需的总体时间亦不变。</p><h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>完全二叉堆的另一具体应用：对于向量中的n个词条，如何借助堆的相关算法，实现高效的排序。相应地，这类算法也称作堆排序算法。</p><p>算法总体思路和选择排序相同，将所有词条分为未排序和已排序，不断从前一类中取出最大者，顺序加至后一类中。算法启动之初，所有词条均属于前者，此后，后一类不断增长。当所有词条转入后一类时，即完成排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::heapSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   <span class="function">PQ_ComplHeap&lt;T&gt; <span class="title">H</span> <span class="params">( _elem + lo, hi - lo )</span></span>; <span class="comment">//将待排序区间建成一个完全二叉堆，O(n)</span></span><br><span class="line">   <span class="keyword">while</span> ( ! H.empty() ) <span class="comment">//反复地摘除最大元并归入已排序的后缀，直至堆空</span></span><br><span class="line">      _elem[--hi] = H.delMax(); <span class="comment">//等效于堆顶与末元素对换后下滤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的待排序词条既然组织为向量，不妨将其划分为前缀H和与之互补的后缀S。整个算法过程中始终满足以下不变性：<strong>H中的最大词条不会大于S中的最小词条</strong>。与选择排序不同之处在于，无论S包含多少词条，都将组织为一个堆。</p><p>不需要全排序，查找前$k$个元素所需的时间为$O(klogn)$。</p><p><strong>效率</strong></p><p>就地堆排序易于理解，便于实现，快速高效(尤其对于大规模数据)。</p><p>可就地运转，不需要全排序即可找出前k个词条，但是在采取就地策略的同时，对换操作必须涉及两个完整的词条，所以操作的单位成本增加。</p><blockquote><p>以上堆排序算法是稳定的吗？</p></blockquote><p>不是稳定的，在反复摘除堆顶并将末词条转移至堆顶，然后下滤过程中，雷同词条之间的相对次序不再保持，故它们在最终所得的排序队列中必然是随机排列的。</p><p>以上堆排序是堆排序固有的不足，难以通过算法自身的调整予以改进。可通过合成数方法，使得原来相等的元素，初始位置越靠前，合成数越小。</p><h2 id="半无穷范围查询"><a href="#半无穷范围查询" class="headerlink" title="半无穷范围查询"></a>半无穷范围查询</h2><p>所谓半无穷范围查询简化之前的一般性范围查询，查询区域为某一侧无界的矩形区域，比如$R=[-1,+1] [0,+\infty]$ ，即对称地包含正半$y$坐标轴、宽度为$2$的一个广义矩形区域。同样为从某一固定的点集中找出落在制定区域$R$内的所有点。通过优先级搜索可将保持$O(r+logn)$的时间效率并将空间复杂度从范围树的$O(nlogn)$优化至$O(n)$。</p><p>优先级搜索树除了在拓扑上应是一棵二叉搜索树，还需同时遵守以下三条规则：</p><ul><li><p>首先，各个节点的$y$坐标不小于其左、右孩子(如果存在)</p><p>因此，整体上可视为以$y$为优先级的二叉堆</p></li><li><p>此外，相对于任一父节点，左子树中的节点$x$坐标均不得大于右子树中的节点</p></li><li><p>最后，互为兄弟的每一对左右子树，在规模上相差不得超过1</p><p>若无需遵守最后一条规则，则可保证所有节点以$x$坐标为序组成一棵二叉搜索树，该结构兼具二叉搜索树和堆的特性，故亦称为树堆。</p></li></ul><blockquote><p>试设计一个算法，在$O(nlogn)$时间内将平面上$n$个点组织为一棵优先级搜索树</p></blockquote><p>首先，不妨按照$x$坐标对所有点排序，然后根据以上定义，可以递归地将这些点组织为一棵优先级搜索树。</p><p>具体地，为了构造任一点集对应的子树，只需花费$O(n)$时间从中找到最高者($y$坐标最大者)。以下，借助$x$坐标的排序序列，可在$O(1)$时间内将剩余的$n-1$个点均平衡地划分为在空间上分列于左、右的两个子集–二者对应的子湖是可通过递归构造。</p><p>如此，构造全树的时间不超过:</p><p>$T(n)=2T(n/2)+O(n)=O(nlogn)$</p><blockquote><p>试设计一个算法，利用已经创建的优先级搜索树，在$O(r+logn)$时间内完成每次半无穷范围查询</p></blockquote><p>查询算法的大致过程可描述为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queryPST(PSTNode v,SemInfRange R)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!v||v.y&lt;R.y) <span class="keyword">return</span>;<span class="comment">//y-pruning</span></span><br><span class="line">     <span class="keyword">if</span>(R.x1&lt;v.x&amp;&amp;v.x&lt;R.x2) output(v);<span class="comment">//hit</span></span><br><span class="line">     <span class="keyword">if</span>(R.x1&lt;&gt;v.xm) queryPST(v.lc,R);<span class="comment">//recursion&amp;x-pruning</span></span><br><span class="line">     <span class="keyword">if</span>(v.xm&lt;=R.x2) queryPST(V.RC,R);<span class="comment">//recursion&amp;x-pruning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先,根据$y$坐标，判断当前子树根节点$v$(及其后代)是否已经落在查询范围$R$之外。若是，则可立即在此处返回，不再进行递归—亦即纵向剪枝；否则，才需要继续深入查找。</p><p>以下，检查根节点$v$的$x$坐标，若落在查询范围之外，则需报告该节点。</p><p>最后，若在节点$v$处的横向切分位置为$xm$，则通过将其与$R$的左、右边界相比较，即可确认是否有必要继续沿对应的子树分支继续递归搜索–亦即横向剪枝。</p><p>唯有当$R.x1$不位于$v.xm$左侧时，才有必要对左子树$v.lc$做递归搜索，唯有当$R.x2$不位于$v.xm$左侧时，才有必要对右子树$v.rc$做递归搜索。</p><p>对任一查询区域$R=[R_1,R_2][y,+\infty]$ ,考查被算法<code>queryPST()</code>访问的任一节点，设与之对应的点为$v=(a,b)$，于是，$v$无非三种类型：</p><ol><li>被访问，且报告出来，也就是说，$v$落在$R$之内$(x_1 \leq a \leq x_2)$且$y\leq b$，此类节点恰有$r$个</li><li>虽被访问，但未报告，因其$x$坐标落在$R$之外$(a&lt;x_1)$或$(x_2&lt;a)$而横向剪枝，不再深入递归。此类节点在每一层上至多有两个，总数不超过$2O(logn)$</li><li>虽然被访问，但是未被报告，$x$坐标落在$R$之内$(x_1 \leq a \leq x_2)$,但是因为其$y$坐标却未落在$R$之内$(b&lt;y)$而纵向剪枝，此类节点的父节点必然属于1类或者2类，其总数不超过这两类节点总数的两倍。</li></ol><p>综合以上分析可知，<code>queryPST()</code>算法渐进的时间复杂度不超过$O(r+logn)$。</p><h2 id="锦标赛排序"><a href="#锦标赛排序" class="headerlink" title="锦标赛排序"></a>锦标赛排序</h2><p>堆排序中主要开销为建堆和删除堆顶元素，按照floyd算法，每次下滤可能在每一高度上均需要两次比较来从当前节点、当前节点的左、右孩子确定替换元素，所以在建堆过程中实际比较操作次数可能达到$2n$次，同理，删除堆顶元素并下滤恢复堆序性的过程中，堆的比较次数为$2logn$，以上两点均存在优化空间，所以引入了锦标赛排序，将前者比较操作次数降低至$n-1$次，后者比较操作次数降至$O(logn)$次。</p><p><strong>锦标赛树</strong></p><p>锦标赛树同样为二叉树，叶节点为待排序元素，以小者胜为原则，内部节点为孩子中的胜者，树根为全局冠军。内部节点之间存在重复，但是始终满足：<strong>在任一子树中，从根通往优胜者的沿途，所有节点都是优胜者</strong>。</p><p>由完全二叉树的性质，若存在$n$个叶节点，则内部节点为$n$个或者$n-1$个,取决于最后一个内部节点为一度还是二度。故节点总体空间不超过$2n$，空间复杂度为$O(n)$。</p><p>在每个内部节点处均需要一次比较，选出该节点左、右孩子中的胜者，所以构建锦标赛树所需的比较次数等于内部节点数目。所以构造锦标赛树的时间复杂度为$O(n)$。</p><p>插入/删除操作只需要更新沿着该叶节点到根节点的沿途节点，也即沿途胜者，总体时间复杂度为$O(logn)$。</p><p>由此设计锦标赛排序算法为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create a tournament tree <span class="keyword">for</span> the input <span class="built_in">list</span></span><br><span class="line"><span class="keyword">while</span> there are active leaves</span><br><span class="line">   remove the root</span><br><span class="line">   retrace the root down to its leaf</span><br><span class="line">   deactive the leaf</span><br><span class="line">   replay along the path back to the root</span><br></pre></td></tr></table></figure><p>先花费$O(n)$时间建立锦标赛树，然后删除根节点，并沿原胜利者到根节点的路径找到原胜利者的叶节点，将原胜利者的叶节点优先级置为无穷大。最后从叶节点出发，逐层上溯至树根，重新确定各轮胜者，耗时$O(logn)$。上述删除和重赛迭代n次，故锦标赛排序的总体时间复杂度为$O(nlog n)$。</p><h2 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h2><p>由于在锦标赛树中，原冠军节点失效后，需要从该节点到根节点逐层上溯，重新确定各轮胜者，而重新确定胜者需要当前节点与其兄弟节点比较，但是其兄弟节点未必位于缓存中。除此之外，原来冠军已经失效，上溯过程中必然修改根节点到原来胜者所处叶节点沿途节点的值，均需要访存，所以引入败者树，父节点中不再保存胜者，而是保存败者。按照锦标赛排序算法，从根节点下行找到冠军叶节点，此时只访问该路径上的节点，所以具有时间局部性，可以更充分地利用缓存机制，在败者树更新过程中，各沿途节点未必需要更新，减少了写操作。</p><blockquote><p>锦标赛树可否实现稳定排序？</p></blockquote><p>可以，只需保证在相等元素比较时，位置靠前者胜出即可，得到地排序序列仍然可以保持相等元素之间的相对次序。</p><p>另外，可借助多叉锦标赛树实现多路合并。</p><h1 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a>左式堆</h1><p>除了标准的插入和删除操作，堆结构在实际应用中的另一常见操作即为合并。任给堆A和B，如何将二者所含的词条组织为一个堆H。</p><p><strong>方法一</strong></p><p>反复地取出堆B的最大词条并插入堆A中，当堆B为空时，堆A即为所需的堆H,这一过程可描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!B.empty())</span><br><span class="line">   A.insert(B.delmax());</span><br></pre></td></tr></table></figure><p>将两个堆的规模分别记作$n$和$m$,且$n\geq m$。每一步迭代均需做一次删除和一次插入操作。因共需$m$次迭代，故总体运行时间为：$m[O(logm)+log(n+m)]=O(mlog(n+m))=O(mlogn)$</p><p><strong>方法二</strong></p><p>将两个堆中的词条视为彼此独立的对象，直接借助floyd算法，将它们重新组织为一个新堆H,该方法的运行时间为：$O(n+m)$</p><p>实际上，既然所有词条已分成两组各自成堆，则意味着它们已经具有一定的偏序性，而一组相互独立的词条并不具有偏序性。由前者构建一个更大的偏序集，应该比后者简单。以上算法均未凑效的原因在于，不能保证合并操作涉及的节点足够少。</p><h2 id="单侧倾斜"><a href="#单侧倾斜" class="headerlink" title="单侧倾斜"></a>单侧倾斜</h2><p>左式堆是优先级队列的另一表现形式，可高效地支持合并操作。其基本思路是：在保持堆序性的前提下附加新的条件，使在堆的合并过程中，只需要调整很少量的节点。具体地，调整节点不超过$O(logn)$个，故可达到极高的效率。</p><p>左式堆的整体结构呈单侧倾斜状，其中节点均偏向于左侧，也就是说，左式堆不再如完全二叉堆一样满足结构性。实际上，结构性并非堆结构的本质要求。</p><h2 id="空节点路径长度"><a href="#空节点路径长度" class="headerlink" title="空节点路径长度"></a>空节点路径长度</h2><p>左式堆的倾斜度，应该控制在什么范围？又该如何控制？为此，借鉴红黑树和AVL树，未各节点引入空节点路径长苏，并依次确定相关算法的执行方向。</p><p>节点x的空节点路径长度(null path length)，记为$npl(x)$。若$x$为外部节点，则约定$npl(x)=npl(null)=0$。若x为内部节点，则$npl(x)$可递归地定义为：$npl(x)=1+min(npl(lc(x)),npl(rc(x)))$</p><p>也就是说，节点$x$的$npl$值取决于其左、右孩子$npl$值中的小者。</p><p><img src="https://i.loli.net/2019/09/09/VW6H38udDwe4G2F.png"></p><h2 id="左倾性"><a href="#左倾性" class="headerlink" title="左倾性"></a>左倾性</h2><p>左式堆是处处满足左倾性的二叉堆，即任一内部节点满足：</p><p>$npl(lc(x))\geq npl(rc(x))$</p><p>也就是说，就$npl$的指标而言，任一内部节点的左孩子都不小于其右孩子。</p><p>根据$npl$和左倾性的定义，左式堆中任一节点$x$都应满足：</p><p>$npl(x)=1+npl(rc(x))$</p><p>左式堆中每个节点的$npl$值，仅取决于其右孩子。</p><p>左孩子的$npl$值不小于右孩子并不意味着左孩子的高度必定不低于右孩子，因为一个节点的$npl$值由子树中最浅的叶子决定，高度则由最深的叶子决定。</p><h2 id="右侧链"><a href="#右侧链" class="headerlink" title="右侧链"></a>右侧链</h2><p>从节点$x$出发沿右侧分支一直前行至空节点，经过的通路称作其最右侧通路，记作rPath(x)。在左式堆中，每个节点的npl值恰好等于其最右侧通路的长度。</p><p>根节点r的最右侧通路<code>rPath(r)</code>的终点必然为全堆中深度最小的外部节点。若记：</p><p>$npl(r)=|rPath(x)|=d$</p><p>则该堆应包含一棵以$r$为根、高度为$d$的满二叉树，该二叉树至少应包含$2^{d}-1$个内部节点，$2^{d+1}-1$个外部节点。反之，在包含$n$个节点的左式堆中，最右侧通路$d\leq \lfloor log_2(n+1)-1 \rfloor =O(logn)$</p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>首先判断并处理待合并子堆为空的平凡情况，再通过一次比较，以及在必要时所做的一次交换，以保证堆顶a的优先级总是不低于另一堆顶$b$。</p><p>按照上述原理递归地将$a$的右子堆和堆$b$合并，并作为$a$的右子堆重新接入。递归返回后，还需比较$a$左、右孩子的npl值，如有必要还需令其互换，以保证前者不小于后者。此后只需在右孩子npl的基础上加1即可得到堆顶$a$的新npl值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//根据相对优先级确定适宜的方式，合并以a和b为根节点的两个左式堆</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">merge</span> <span class="params">( BinNodePosi(T) a, BinNodePosi(T) b )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( ! a ) <span class="keyword">return</span> b; <span class="comment">//退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( ! b ) <span class="keyword">return</span> a; <span class="comment">//退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( lt ( a-&gt;data, b-&gt;data ) ) swap ( a, b ); <span class="comment">//一般情况：首先确保b不大</span></span><br><span class="line">   a-&gt;rc = merge ( a-&gt;rc, b ); <span class="comment">//将a的右子堆，与b合并</span></span><br><span class="line">   a-&gt;rc-&gt;parent = a; <span class="comment">//并更新父子关系</span></span><br><span class="line">   <span class="keyword">if</span> ( !a-&gt;lc || a-&gt;lc-&gt;npl &lt; a-&gt;rc-&gt;npl ) <span class="comment">//若有必要</span></span><br><span class="line">      swap ( a-&gt;lc, a-&gt;rc ); <span class="comment">//交换a的左、右子堆，以确保右子堆的npl不大</span></span><br><span class="line">   a-&gt;npl = a-&gt;rc ? a-&gt;rc-&gt;npl + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">//更新a的npl</span></span><br><span class="line">   <span class="keyword">return</span> a; <span class="comment">//返回合并后的堆顶</span></span><br><span class="line">&#125; <span class="comment">//本算法只实现结构上的合并，堆的规模须由上层调用者负责更新</span></span><br></pre></td></tr></table></figure><p><strong>复杂度</strong></p><p>借助递归分析图不难看出，所有递归实例可排成一个线性序列，实质上属于线性递归，其运行时间正比于递归深度。递归只可能发生在两个待合并子树的最右侧通路上。若待合并堆的规模分别为$n$和$m$，则其两条最右侧通路的长度分别不会超过：</p><p>$O(logn)+O(logm)=O(logn+logm)=O(log (max(n,m))$</p><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>基于merge操作实现<code>delMax()</code>算法，考查堆顶$x$及其子堆$H_L$和$H_R$。</p><p>在摘除x之后，$H_L$和$H_R$即可被视作为两个彼此独立待合并的堆。于是，只要通过<code>merge()</code>操作将它们合并起来，效果完全等效于常规的<code>delMax()</code>操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_LeftHeap&lt;T&gt;::delMax() &#123; <span class="comment">//基于合并操作的词条删除算法（当前队列非空）</span></span><br><span class="line">   BinNodePosi(T) lHeap = _root-&gt;lc; <span class="comment">//左子堆</span></span><br><span class="line">   BinNodePosi(T) rHeap = _root-&gt;rc; <span class="comment">//右子堆</span></span><br><span class="line">   T e = _root-&gt;data; <span class="keyword">delete</span> _root; _size--; <span class="comment">//删除根节点</span></span><br><span class="line">   _root = merge ( lHeap, rHeap ); <span class="comment">//原左右子堆合并</span></span><br><span class="line"><span class="comment">//   if ( _root ) _root-&gt;parent = NULL; //若堆非空，还需相应设置父子链接</span></span><br><span class="line">   <span class="keyword">return</span> e; <span class="comment">//返回原根节点的数据项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由合并操作的分析，时间成本总体依然不超过$O(log n)$</p><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>若将词条$x$插入堆H中，只要将$x$视为一个仅含单个节点的堆，则调用<code>merge()</code>操作后，其效果等效于完成了一次词条插入操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::insert ( T e ) &#123; <span class="comment">//基于合并操作的词条插入算法</span></span><br><span class="line">   BinNodePosi(T) v = <span class="keyword">new</span> BinNode&lt;T&gt; ( e ); <span class="comment">//为e创建一个二叉树节点</span></span><br><span class="line">   _root = merge ( _root, v ); <span class="comment">//通过合并完成新节点的插入</span></span><br><span class="line"><span class="comment">//   _root-&gt;parent = NULL; //既然此时堆非空，还需相应设置父子链接</span></span><br><span class="line">   _size++; <span class="comment">//更新规模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由合并操作的分析，时间成本总体依然不超过$O(log n)$</p><h1 id="栈堆-队堆"><a href="#栈堆-队堆" class="headerlink" title="栈堆/队堆"></a>栈堆/队堆</h1><p>为栈/队列提供在$O(1)$时间内访问最大值的接口，集成了栈/队列和堆属性的数据结构，称为栈堆(steap)/队堆(queap)。</p><h2 id="栈堆"><a href="#栈堆" class="headerlink" title="栈堆"></a>栈堆</h2><p>对于任何一个栈，可以引入另一个与之孪生的镜像P，P中的元素与S中的元素始终保持一一对应，前者的取值恰好是后者所有前驱中的最大者。当然P中元素必定按照单调非降的顺序排列。如此，任何时刻栈P的顶元素，都是栈S中的最大元素。为保持二者如上的对应关系，它们的push和pop必须同步进行。</p><p>若执行S.pop()，则只需同步地执行H.pop()，而若执行S.push(e),则需要同步地执行P.push(max(e,P.top()))。</p><p>以上方案还可以进一步优化。</p><p>可将栈P的空间进一步压缩，P中相等的元素必然彼此相邻，并因此可分为若干组。若假想式地令栈P中的每个元素通过指针指向栈S中的每个元素，而不是保留后者的副本，则可以将同组的元素合并起来，共享一个指针。当然，同时还需为合并后的元素增设一个计数器，记录原先同组元素的数目。如此改进之后，每一组元素只需保留以分，附加空间使用量可以大大降低。</p><p>相应地，在栈S每次执行出栈操作时，栈P必须同步地执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(--P.top().counter)) P.pop();</span><br></pre></td></tr></table></figure><p>而在栈S每次入栈时，栈P必须同步地执行</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P.top()&lt;e ? P.push(e),P.top.counter=<span class="number">1</span> :P.top().counter++;</span><br></pre></td></tr></table></figure><p>可见，S的<code>push()</code>和<code>pop()</code>接口，依然保持$O(1)$效率。</p><h2 id="队堆"><a href="#队堆" class="headerlink" title="队堆"></a>队堆</h2><p>上述关于栈的技巧同样可以推广至队列结构，可以引入一个双端队列P，并依然约定，其中每个元素也是始终指向队列Q中所有前驱的最大者。</p><p>为保持二者的对应关系，它们的<code>dequeue()</code>和<code>enqueue()</code>接口必须同步进行，若执行：<code>Q.dequeue()</code>,则需同步地执行<code>P.removeFront()</code>，而若执行<code>Q.enqueue()</code>，则只需同步地执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P.insertRear(e);</span><br><span class="line"><span class="keyword">for</span>(x=P.rear();x&amp;(x.key&lt;=e);x=x.pred)&#123;</span><br><span class="line">  x.key=e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了首先令e加入队列P，还需要将P尾部所有不大于e的元素统一更新为e。在最坏情况下，这需要$\Omega(n)$时间，而这种情况可能持续发生。造成这一困难的原因在于，队列中任一元素的前驱集，不再如栈中那样是固定的，而是可能增加，且新增元素可能非常大。</p><p>同样，可仿照前一技巧，将队列P压缩。然后在队列每次执行出队操作时，队列P必须同步地执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(--P.front().counter)) P.removeFront();</span><br></pre></td></tr></table></figure><p>而在队列Q每次执行入队时，队列P同步地执行：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!P.empty()&amp;&amp;(P.rear().key&lt;=e))</span><br><span class="line">   a+=P.removeRear().counter;<span class="comment">//当当前尾部元素不大于e时，累计计数器后删除该尾部元素</span></span><br><span class="line">P.insertRear(e);</span><br><span class="line">P.rear().counter=a;</span><br></pre></td></tr></table></figure><p>这里的while循环在最坏情况下仍然需要迭代$O(n)$步，但因为参与迭代的元素必然随即被删除，故就分摊意义而言仅为$O(1)$步，时间性能大为改善。</p><p>另外，这里的队列P并不需要双端队列的所有功能，<code>removeFront()</code>,<code>insertRear()</code>,<code>removeRear()</code>接口，无需使用<code>insertFront()</code>接口。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;此前的搜索树和词典结构都支持覆盖全集的访问和操作，其中存储的每一数据对象都可作为查找和访问目标。搜索树结构需要在所有元素之间定义并维护一个显式的全序关系，而词典结构从内部强制地在对象和对应的秩之间建立起某种关联关系，隐式地定义了一个全序关系。优先级队列将操作对象限定于当前的全局极值者。比如，在所有鸟类中，查找种群规模最小者。这一访问方式称为循优先级访问。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>词典</title>
    <link href="http://twinkle0331.github.io/algorithm/hash/"/>
    <id>http://twinkle0331.github.io/algorithm/hash/</id>
    <published>2019-09-07T03:13:39.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>借助数据结构来表示和组织的数据结构，将所有数据视作一个整体统筹处理，进而提高信息访问的规范性及其处理的效率。例如，借助关键码查找和访问数据元素，其中最典型的例子即为词典。逻辑上的词典，为由一组数据构成的集合，其中各元素都是由关键码和数据项合成的词条。</p><a id="more"></a><p>映射和词典一样，也是词条的集合，二者的差异仅在于，映射要求不同词条的关键码互异，而词典则允许多个词条拥有相同的关键码。除了静态查找，映射和词典都支持动态更新，二者均统称为符号表。符号表并不要求词条之间可根据关键码比较大小，也不需要按照大小次序来组织数据项。以散列表为代表的符号表结构，转而根据数据项之间的数值，直接做逻辑查找和物理定位。在此类结构中，关键码和数值的地位等同，这种数据访问方式即为循值访问。为了循值访问，在符号表内部仍需强制地在数据对象的数值与其物理地址之间建立某种关联。</p><h1 id="应用情景"><a href="#应用情景" class="headerlink" title="应用情景"></a>应用情景</h1><p>散列以最基本的向量作为底层支撑结构，通过适当的散列函数在词条的关键码与向量单元的秩之间建立映射关系。只要散列表、散列函数、冲突排解策略安排得当，可在期望的常数时间内实现词典的所有接口操作。</p><p><strong>电话查询系统</strong></p><p>假设某大学拟建立一个电话簿查询系统，由电话号码查询机主信息，</p><p>蛮力：使用数组，按电话号码索引，静态的查找和动态的删除仅需要常数时间。</p><p>在使用8位编号系统时，可能的电话门数可能达到$10^8$次，而该校所有人员涉及的电话门数仅为25000门。上述方案使用的数组长度大致与$10^8$相当,此时的空间有效利用率仅为$25000/10^8=0.025$%，绝大部分空间处于闲置状态。</p><p>此类问题在实际应用中非常常见，共同特点可归纳为：尽管词典实际需要保存的词条数N远远少于可能出现的词条数R，但是R个词条中任何一个均有可能出现在此词典中。</p><p>散列表是散列方法的底层基础，逻辑上由一系列可存放词条的单元组成，故这些单元也被称为桶或桶单元，与之对应地，各桶单元也应按照其逻辑次序在物理上连续排列，往往用向量(数组)实现。此时地散列表亦称作桶数组。</p><p>设桶数组的大小为M，则$N&lt;M&lt;&lt;R$，空间$=O(N+M)=O(N)$。</p><h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p>一组词条在散列表内部的分布取决于散列方案，即事先在词条与桶地址之间定义某种映射关系，可描述为从关键码空间到桶地址空间的函数。</p><p><code>hash():key-&gt;hash(key)</code></p><p>这里的<code>hash()</code>称作散列函数，<code>hash(key)</code>称作key的散列地址，即与关键码key相对应的桶在散列表中的秩。</p><p>例如，某学校学生学号为10160000到10163999,则可直接使用一个长度为4000的散列表A[0~3999]，并取</p><p><code>hash(key)=key-10160000</code></p><p>从而将学号为x的学生学籍词条存放于桶单元A[hash(x)]。</p><p>如此之后，根据任一合法学号，都可在常数时间内确定其散列地址，并完成一次查找、插入或删除。</p><p>同义词，key1不等于key2，<code>hash(key1)=hash(key2)</code>。</p><blockquote><p>是否存在某种定址方法，保证不出现冲突(消除同义词)，即散列函数等效于一个单射。</p></blockquote><p>在关键码满足某些条件时，的确可以实现单射式散列。对于已知且固定的关键码集，可实现完美散列，采用两级散列，仅需$O(n)$空间，关键码之间互不冲突。一般情况下，完美散列无法保证存在。</p><p><strong>设计原则</strong></p><p>作为一个比较好的散列函数，应该具备以下特性：</p><ul><li>确定性，无论所含的数据项如何，词条E在散列表中的映射地址完全取决于关键码</li><li>映射过程不可过于复杂，从而使查询和修改操作可在常数时间内完成</li><li>所有关键码经过映射后应尽量覆盖整个地址空间[0,M),充分利用有效的散列表空间，即hash()最好是满射</li></ul><p>定义域规模R远远大于取值域规模M,hash()不可能是单射。这意味着散列冲突在所难免。最为重要的一条原则就是关键码映射到各桶的概率应尽量接近于1/M，若关键码独立均匀分布，这也是任意一对关键码相互冲突的概率。整体而言，等效于将关键码空间均匀地映射到散列地址空间，从而避免极短低效的情况。总之，随机越强、规律性越弱的散列函数越好。</p><h2 id="除余法"><a href="#除余法" class="headerlink" title="除余法"></a>除余法</h2><p><code>hash(key)=key % M</code></p><p>一般地，散列表长度$M$与词条关键码间隔$T$之间的公约数越大，发生冲突的可能性也越大。在实际应用中，对同一词典的访问往往具有某种周期性，若其周期与$M$有公共的因子，则冲突的概率将急剧攀升。若$M$为素数时，对于严格或大致等间隔的关键码序列，也不会出现冲突激增的情况。同时，数据对散列表的覆盖最充分，分布最均匀。</p><p>若取$M=2^k$，则对任何词条都有：</p><p><code>key%M=key &amp;(M-1)=key &amp; 00...001111..11</code></p><p>此时采用模余法的效果，等同于从key的展开式中截取末尾的$k$个比特。词条key中更高的其余比特位对散列的位置没有任何影响，从而在很大程度上降低了散列的随机性和均匀性。</p><blockquote><p>假定散列表长度为$M$，采用除余法，若从空开始将间隔为$T$的$M$个关键码插入其中，若$g=gcd(M,T)$为$M$和$T$的最大公约数，则每个关键码大约与$g$个关键码冲突</p></blockquote><p>这一组关键码序列依次构成一个等差数列，其公差为$T$。不失一般性，设他们分别是：</p><p>${0,T,2T,3T,…,(M-1)T}$</p><p>按照模余法，任何一对关键码相互冲突，当且仅当它们关于散列表长$M$，属于同一同余类。$g$为$M$和$T$的最大公约数，故相对于$M$而言，这些关键码来自于$M/g$个同余类。每一类各有彼此冲突的$g$个关键码。例如，其中0所属的同余类为：</p><p>${0,TM/g,2TM/g,3TM/g,…,(g-1)TM/g}$</p><p>散列表的$M$个桶与$M$的$M$个同余类一一对应。既然此时的关键码只能来自其中M/g个同余类，故必有M-M/g个桶闲置，空间利用率不超过：$\displaystyle \frac{M/g}{M}=1/g$</p><p><strong>除余法的缺陷</strong></p><ol><li>不动点：无论表长M取值如何，总有<code>hash(0)=0</code></li><li>零阶均匀：$[0,R)$的关键码，平均分配至$M$个桶，但相邻关键码的散列地址也必相邻</li></ol><h2 id="MAD法"><a href="#MAD法" class="headerlink" title="MAD法"></a>MAD法</h2><p>一阶均匀：邻近的关键码，散列地址不再邻近</p><p>取M为素数,$a&gt;0$,$b&gt;0$,$a%M!=0$，</p><p>$hash(key)=(a*key+b)%M$</p><p>当然，某些条件下未必需要更高阶的均匀性。</p><h2 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h2><p>从关键码key特定进制的展开中取特定的若干位，构成一个整形地址。比如，取十进制表示的奇数位，$hash(123456789)=13579$</p><h2 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h2><p>从关键码key的平方的十进制或二进制展开中取居中的若干位，构成一个整形地址。</p><h2 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h2><p>将关键码的十进制或二进制展开分割为等宽的若干段，经异或运算后得到散列地址。</p><h2 id="位异或法"><a href="#位异或法" class="headerlink" title="位异或法"></a>位异或法</h2><p>将特定的二进制展开分割为等宽的若干段，经异或运算得到地址</p><p>总之，越是随机，越是没有规律越好。</p><h2 id="伪随机数法"><a href="#伪随机数法" class="headerlink" title="伪随机数法"></a>伪随机数法</h2><p>散列函数和目标与随机数的目标一致，所以通过随机数法映射地址：</p><p>$hash(key)=rand(key)%M$</p><h1 id="散列码转换"><a href="#散列码转换" class="headerlink" title="散列码转换"></a>散列码转换</h1><p>作为词典的散列表结构，既不能假定词条关键码所属的类型天然地支持大小比较，更不应将关键码仅限定为整数类型。为扩大散列奇数地适用范围，散列函数hash()需要将任一类型的关键码映射为地址空间$[0,M)$内的一个整数hash(key)，通常可分解为两步</p><ul><li>利用某一种散列码转换函数<code>hashcode()</code>将关键码key统一转换为一个整数，称为散列码</li><li>再利用散列函数将散列码映射为散列地址</li></ul><p>那么，这里的散列转换函数<code>hashCode()</code>支持什么条件呢？</p><p>为支持后续尺度不同的散列空间，取值范围应覆盖系统所支持的最大整数范围，其次，各关键码经hashCode()映射后所得的散列码，相互之间的冲突也应尽可能减少，否则，这一阶段出现的冲突后一阶段将无法消除。</p><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>对于<code>byte</code>,<code>short</code>,<code>int</code>和<code>char</code>等本身即可表示为不超过32位整数的数据类型，可直接将它们的这种表示作为散列码。比如，可通过类型强制转换为32位整数。</p><h2 id="多项式法"><a href="#多项式法" class="headerlink" title="多项式法"></a>多项式法</h2><p>与一般的组合对象不同，字符串各字符之间的次序具有特定含义，在散列码转换时务必考虑它们之间的次序。以英文为例，同一组字母往往可组成意义完全不同的多个单词，比如stop和tops等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">hashCode</span> <span class="params">( <span class="keyword">char</span> s[] )</span> </span>&#123; <span class="comment">//生成字符串的循环移位散列码（cyclic shift hash code）</span></span><br><span class="line">   <span class="keyword">int</span> h = <span class="number">0</span>; <span class="comment">//散列码</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( s ), i = <span class="number">0</span>; i &lt; n; i++ ) <span class="comment">//自左向右，逐个处理每一字符</span></span><br><span class="line">      &#123; h = ( h &lt;&lt; <span class="number">5</span> ) | ( h &gt;&gt; <span class="number">27</span> ); h += ( <span class="keyword">int</span> ) s[i]; &#125; <span class="comment">//散列码循环左移5位，再累加当前字符</span></span><br><span class="line">   <span class="keyword">return</span> ( <span class="keyword">size_t</span> ) h; <span class="comment">//如此所得的散列码，实际上可理解为近似的“多项式散列码”</span></span><br><span class="line">&#125; <span class="comment">//对于英语单词，&quot;循环左移5位&quot;是实验统计得出的最佳值</span></span><br></pre></td></tr></table></figure><p>若简单地将各字母分别对应到整数，并将其总和作为散列码，则很多单词将相互冲突。为计入各字符之间出现的相对次序，可取常数$a \geq 2$,并将$x_0x_1…x_{n-1}$的散列码取作：</p><p>$x_0a^{n-1}+x_1a^{n-2}+…+x_{n-2}a^1+x_{n-1}$</p><p>依次将字符串中的每个字符视为一个多项式的各项系数，故亦称为多项式散列码。其中的常数a非常关键，为了尽可能多地保留原字符串的信息以减少冲突，其低比特位不得全为0。针对不同类型的字符串，应通过实验确定a的最佳取值。</p><h1 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h1><p>散列表中很大概率会有冲突，所以必须制定一套有效的对策，以处理和排解时常发生的冲突。</p><h2 id="多槽位法"><a href="#多槽位法" class="headerlink" title="多槽位法"></a>多槽位法</h2><p>将彼此冲突的每一组词条组织为一个小规模的词典，分别存放于它们共同对应的桶单元中。比较简便的一种方法是，统一将各桶细分为更小的称作槽位的单元，每一组槽位可组织为向量或列表。只要槽位数目不多，仍可保证常数复杂度。</p><p>但是绝大多数槽位都处于空闲状态，若每个桶都被细分为$k$个槽位，则当散列表总共存有$n$个词条时，装填因子</p><p>$\lambda’ = N/(kM)=\lambda /k$ 将降低至原来的$1/k$。</p><p>其次，很难在事先确定槽位应细分到何种程度，方可保证在任何情况下都够用，在极端情况下，可能所有(或接近所有)词条都冲突于单个桶单元。尽管几乎其余所有的桶都会处于空闲状态，该桶却会因为冲突过多而溢出。</p><h2 id="独立链法"><a href="#独立链法" class="headerlink" title="独立链法"></a>独立链法</h2><p>每个桶存放一个指针，冲突的词条组织成列表。</p><p>各子词典的规模往往不大，大多数往往只含单个词条或者甚至是空的。无需为每个桶预留多个槽位，任意多次的冲突都可解决。可更为灵活地动态调整各子词典地容量和规模，删除操作实现简单、统一。</p><p>但是指针需要额外空间，节点也需要动态申请。一旦发生冲突，则需要遍历整个列表，导致查找成本的增加。对于列表结构来说，空间未必连续分布，系统缓存几乎失效。</p><h2 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h2><p>单独开辟一块连续空间，发生冲突的词条，顺序存入此区域。</p><p>不冲突则已，一旦发生冲突，处理冲突词条的时间正比于溢出区的规模。</p><h1 id="闭散列"><a href="#闭散列" class="headerlink" title="闭散列"></a>闭散列</h1><p>就逻辑结构而言，独立链等策略便捷紧凑，但因需要引入次级关联结构，不能保证物理上的关联性，在查找过程中需要更多的I/O操作。实际上，仅仅依靠基本的散列表结构，就地排解冲突，反而是更好的选择。在冲突时允许在散列表内部寻找另一空桶存放，如此，各桶并非只能存放特定的一组词条。从理论上来说，每个桶单元可存放任一词条，所以这一策略也称作开放定址，同时，因为可用的散列地址仅限于散列表覆盖的范围内，所以亦称作闭散列。</p><h2 id="线性试探法"><a href="#线性试探法" class="headerlink" title="线性试探法"></a>线性试探法</h2><p>在插入关键码key时，若发现ht[hash(key)]被占用，则转而试探ht[hash(key)+1]，若ht[hash(key)+1]被占用，则进一步试探ht[hash(key)+2],…,如此知道发现一个可用空桶。为了确保桶地址合法，最后还需要对M统一取余，第i次试探的桶单元应为：ht[(hash(key)+i)mod M],i=1,2,3…</p><p>如此，被试探的桶单元在物理空间上依次连贯，地址构成等差数列。</p><p><strong>查找链</strong></p><p>散列表每一组相互冲突的词条将视为一个有序序列，对其中任意一员的查找都需要借助这一序列。对应的查找过程，可能终止于三种情况：</p><ul><li>在当前桶单元命中目标关键码，则成功返回</li><li>当前桶单元为空，但其中关键码与目标关键码不等，则须转入下一桶单元继续试探</li><li>当前桶单元为空，则查找以失败返回</li></ul><p>对于长度为n的查找链，失败查找长度为n+1，在等概率假设下，平均成功查找长度为$\lceil n/2 \rceil$</p><p>相互冲突的关键码必定属于同一查找链，但是同一查找链的关键码却未必相互冲突。究其原因在于，多组各自冲突的关键码，有可能相互交织和重叠。此时，各组关键码的查找长度将进一步增加。</p><p><strong>局部性</strong></p><p>线性查找法组成各查找链的词条，在物理上保证一定的连贯性，具有良好的数据局部性，故系统缓存的作用可以充分发挥，查找过程中几乎无需I/O操作。尽管闭散列策略同时也会在一定程度上增加冲突发生的可能，但只要散列表的规模不是很小，装填因子不是很大，对于I/O负担的降低而言，这些问题都将微不足道。</p><p>在散列表内部解决冲突，无需附加的指针(指针、链表或溢出区等)空间，结构本身保持简洁。只要还有空桶，迟早会找到。但是已发生过(并已排解)的冲突，将会导致本不必发生的冲突。</p><p><strong>懒惰删除</strong></p><p>查找链中任何一环的确是，都会导致后续词条因无法抵达而缺失，表现为有时无法找到实际已存在的词条。所以采用闭散列时，执行删除操作需要特别调整。</p><p>为了保证查找链的完整，可将后继词条悉数取出，再重新插入，但如此将导致删除操作的复杂度增加。简明有效的方法是，为每个桶另设一个标志位，指示该桶尽管目前为空，但此前的确曾存放过词条。该桶虽不存放任何实质的词条，但仍是查找链中的一环。如此标记后，对后继词条的查找仍可照常进行，而不致中断。</p><p>带有删除标记的桶扮演的角色，因具体的操作而异。</p><ul><li>在删除等操作之前对某一目标词条的查找，在查找过程中，只有在当前桶单元为空，且不带懒惰删除标记时方可报告查找失败，否则，无论该桶非空，或带有懒惰删除标记，都将沿着查找链继续试探。</li><li>在插入等操作之前对某一目标词条的查找，无论当前桶为空，还是带有懒惰删除标记，均可报告查找成功，否则都将继续沿着查找链继续试探。</li></ul><p>懒惰标记的操作借助位图实现，具体操作如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Bitmap* lazyRemoval; &#x2F;&#x2F;懒惰删除标记</span><br><span class="line">#define lazilyRemoved(x)  (lazyRemoval-&gt;test(x))</span><br><span class="line">#define markAsRemoved(x)  (lazyRemoval-&gt;set(x))</span><br></pre></td></tr></table></figure><p>考虑如下调整：</p><ul><li>每次查找成功后，将命中词条前移至查找链中第一个带有懒惰删除标记的空桶(若的确命中存在且位于空桶之前)</li><li>每次查找失败后，若查找链的某一后缀完全由带懒惰删除标记的空桶组成，则清除它们的标记</li></ul><p>但是以上调整并不可行，为了删除带有懒惰删除标记的桶，实质上等效于压缩查找链。但是<strong>查找链可能彼此有所重叠，任何一个带有懒惰删除标记的桶，都可能同时属于多个查找链</strong>。所以其中一条查找链的压缩，都将可能导致其他查找链的断裂。因此为了使这些策略可行，还必须做更多的处理，通常都未免弄巧成拙，得不偿失。</p><p><strong>查找</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; V* Hashtable&lt;K, V&gt;::get ( K k ) <span class="comment">//散列表词条查找算法</span></span><br><span class="line">&#123;  <span class="keyword">int</span> r = probe4Hit ( k ); <span class="keyword">return</span> ht[r] ? &amp; ( ht[r]-&gt;value ) : <span class="literal">NULL</span>;  &#125; <span class="comment">//禁止词条的key值雷同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">int</span> Hashtable&lt;K, V&gt;::probe4Free ( <span class="keyword">const</span> K&amp; k ) &#123;</span><br><span class="line">   <span class="keyword">int</span> r = hashCode ( k ) % M; <span class="comment">//从起始桶（按除余法确定）出发</span></span><br><span class="line">   <span class="keyword">while</span> ( ht[r] ) r = ( r + <span class="number">1</span> ) % M; <span class="comment">//沿查找链逐桶试探，直到首个空桶（无论是否带有懒惰删除标记）</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//为保证空桶总能找到，装填因子及散列表长需要合理设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先采用除余法确定首个试探的桶单元，然后按线性试探法沿查找链逐桶试探。统一返回最后查找被试探的桶的秩，上层调用者只需核对该桶是否为空，即可判断是否查找失败。</p><p><strong>删除</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Hashtable&lt;K, V&gt;::remove ( K k ) &#123; <span class="comment">//散列表词条删除算法</span></span><br><span class="line">   <span class="keyword">int</span> r = probe4Hit ( k ); <span class="keyword">if</span> ( !ht[r] ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//对应词条不存在时，无法删除</span></span><br><span class="line">   release ( ht[r] ); ht[r] = <span class="literal">NULL</span>; markAsRemoved ( r ); N--; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">//否则释放桶中词条，设置懒惰删除标记，并更新词条总数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">int</span> Hashtable&lt;K, V&gt;::probe4Hit ( <span class="keyword">const</span> K&amp; k ) &#123;</span><br><span class="line">   <span class="keyword">int</span> r = hashCode ( k ) % M; <span class="comment">//从起始桶（按除余法确定）出发</span></span><br><span class="line">   <span class="keyword">while</span> ( ( ht[r] &amp;&amp; ( k != ht[r]-&gt;key ) ) || ( !ht[r] &amp;&amp; lazilyRemoved ( r ) ) )</span><br><span class="line">      r = ( r + <span class="number">1</span> ) % M; <span class="comment">//沿查找链线性试探：跳过所有冲突的桶，以及带懒惰删除标记的桶</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//调用者根据ht[r]是否为空，即可判断查找是否成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先调用<code>probe4Hit(k)</code>算法，沿关键码k对应的查找链顺序查找。若在某桶单元命中，则释放其中的词条，为该桶单元设置懒惰删除标记，并更新词典的规模。</p><p><strong>插入</strong></p><p>调用<code>probe4Free(k)</code>算法，若沿关键码k所属查找链可找到一空桶，则在其中创建对应的词条，并更新词典的规模。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Hashtable&lt;K, V&gt;::put ( K k, V v ) &#123; <span class="comment">//散列表词条插入</span></span><br><span class="line">   <span class="keyword">if</span> ( ht[probe4Hit ( k ) ] ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//雷同元素不必重复插入</span></span><br><span class="line">   <span class="keyword">int</span> r = probe4Free ( k ); <span class="comment">//为新词条找个空桶（只要装填因子控制得当，必然成功）</span></span><br><span class="line">   ht[r] = <span class="keyword">new</span> Entry&lt;K, V&gt; ( k, v ); ++N; <span class="comment">//插入（注意：懒惰删除标记无需复位）</span></span><br><span class="line">   <span class="keyword">if</span> ( N * <span class="number">2</span> &gt; M ) rehash(); <span class="comment">//装填因子高于50%后重散列</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">int</span> Hashtable&lt;K, V&gt;::probe4Free ( <span class="keyword">const</span> K&amp; k ) &#123;</span><br><span class="line">   <span class="keyword">int</span> r = hashCode ( k ) % M; <span class="comment">//从起始桶（按除余法确定）出发</span></span><br><span class="line">   <span class="keyword">while</span> ( ht[r] ) r = ( r + <span class="number">1</span> ) % M; <span class="comment">//沿查找链逐桶试探，直到首个空桶（无论是否带有懒惰删除标记）</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//为保证空桶总能找到，装填因子及散列表长需要合理设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装填因子$\lambda =N/M$是最为重要的因素。随着$\lambda$上升，词条在散列表中聚集的程度必将持续减少，这也势必加剧查找成本的进一步攀升。若将装填因子控制在适当范围内，闭散列的平均效率通常可保持在较为理想的水平。一般建议是$\lambda &lt;0.5$。</p><p><strong>重散列</strong></p><p>将装填因子控制在一定范围内，重散列即是常用的一种方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">void</span> Hashtable&lt;K, V&gt;::rehash() &#123;</span><br><span class="line">   <span class="keyword">int</span> old_capacity = M; Entry&lt;K, V&gt;** old_ht = ht;</span><br><span class="line">   M = primeNLT ( <span class="number">2</span> * M, <span class="number">1048576</span>, <span class="string">&quot;../../_input/prime-1048576-bitmap.txt&quot;</span> ); <span class="comment">//容量至少加倍</span></span><br><span class="line">   N = <span class="number">0</span>; ht = <span class="keyword">new</span> Entry&lt;K, V&gt;*[M]; <span class="built_in">memset</span> ( ht, <span class="number">0</span>, <span class="keyword">sizeof</span> ( Entry&lt;K, V&gt;* ) * M ); <span class="comment">//新桶数组</span></span><br><span class="line">   release ( lazyRemoval ); lazyRemoval = <span class="keyword">new</span> Bitmap ( M ); <span class="comment">//新开懒惰删除标记比特图</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; old_capacity; i++ ) <span class="comment">//扫描原桶数组</span></span><br><span class="line">      <span class="keyword">if</span> ( old_ht[i] ) <span class="comment">//将非空桶中的词条逐一</span></span><br><span class="line">         put ( old_ht[i]-&gt;key, old_ht[i]-&gt;value ); <span class="comment">//插入至新的桶数组</span></span><br><span class="line">   release ( old_ht ); <span class="comment">//释放原桶数组——由于其中原先存放的词条均已转移，故只需释放桶数组本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重散列算法：装填因子过大时，采取“逐一取出再插入”的朴素策略，对桶数组扩容</p><p>不可简单地（通过memcpy()）将原桶数组复制到新桶数组（比如前端），否则存在两个问题：</p><ul><li>会继承原有冲突</li><li>可能导致查找链在后端断裂，即便为所有扩充桶设置懒惰删除标志也无济于事</li></ul><h2 id="平方试探法"><a href="#平方试探法" class="headerlink" title="平方试探法"></a>平方试探法</h2><p><strong>单向平方试探</strong></p><p>线性试探法各查找链均由物理地址连续的桶单元组成，因而会加剧关键码的聚集趋势，查找操作的效率将有所降低。平凡试探法可有效缓解聚集现象，在试探过程中，按如下规则确定第j次试探的桶地址：</p><p>$(hash(key)+j^2)%M,j=0,1,2,…$</p><p>各次试探的位置到起始位置的距离以平方速率增长。</p><p><strong>局部性</strong></p><p>平凡试探法之所以可以有效地缓解聚集现象，是因为充分利用了平方函数的特点，顺着查找链，试探位置的间距将以线性的速度增长。同时，常规的I/O操作页面规模已足够大，只有在查找链极长时，才有可能引发额外的I/O操作。</p><blockquote><p>设散列表长度取作素数$M&gt;2$,试证明：任一关键码所对应的的查找链中，前$\lceil M/2 \rceil=(M+1)/2$个桶必然互异</p></blockquote><p>反证，假设存在$0 \leq a &lt; \lceil M/2 \rceil$,使查找链上的第$a$个位置与第$b$个位置冲突，于是$a^2$和$b^2$必然同属于关于$M$的同一同余类，亦即：</p><p>$a^2 \equiv b^2(mod M)$</p><p>于是$a^2-b^2=(a+b)(a-b) \equiv 0(mod M)$</p><p>无论是$(a+b)$还是$(a-b)$绝对值都严格小于M,故均不可能被M整除，这与M为素数的条件矛盾。</p><p>查找链的前$\lceil M/2 \rceil$项关于$M$必然属于不同的同余类，因此互不冲突。在装填因子不足50%时，$\lceil M/2 \rceil$ 至少有一个是空余的，因此不可能发生无法抵达空桶的情况。</p><p>M若为合数，$n^2%M$可能的取值必然少于$\lceil M/2 \rceil$种，M若为素数，$n^2%M$可能的取值恰好等于$\lceil M/2 \rceil$种，恰由查找链的前$\lceil M/2 \rceil$项取遍。</p><blockquote><p>在装填因子超过50%时，只要适当调整各桶的位置，下一插入操作必然因无法达到空桶而失败</p></blockquote><p>任取：$\lceil M/2 \rceil \leq c&lt;M-1$,考查查找链上的第$c$项</p><p>总是存在$0 \leq d &lt;\lceil m/2 \rceil $,查找链上第$d$项与该第$c$项冲突</p><p>实际上，只要令$d=M-c \neq c$</p><p>则有：$c^2-d^2=(c+d)(c-d)=M(c-d) \equiv 0(mod M)$</p><p>于是$c^2$和$d^2$同属一个同余类，作为散列地址相互冲突。</p><blockquote><p>散列表长度$M$为合数时，即便装填因子低于50%,平方试探仍有可能无法终止</p></blockquote><p>考查$M=12$的散列表，{$0^2$,$1^2$,$2^2$,$3^2$,$4^2$,…}关于$M$模余只有${0,1,4,9}$四种可能。于是，即便只有这四个位置为空，也会因为查找链的重合循环导致新的关键码0无法插入。但是此时的装填因子仅为$\lambda=4/12&lt;50%$</p><p>此时，对于秩$0 \leq a&lt;b&lt;\lceil M/2\rceil$,即便</p><p>$a+b \equiv 0 (mod M)$</p><p>$a-b \equiv 0(mod M)$</p><p>均不成立，也依然可能有:</p><p>$a^2-b^2=(a+b)(a-b) \equiv 0 (modM)$</p><p>以以上例子为例，$M=12$的散列表，取$a=24$和$b=4$,则</p><p>$2+4=6 \equiv 0(mod 12)$</p><p>$2-4=-2 \equiv 0(mod 12)$</p><p>均不成立，然而依然有$2^2-4^2=-12\equiv 0(mod 12)$</p><p><strong>双向平方试探</strong></p><p>自冲突位置起，将以{$+1^2$,$-1^2$,$+2^2$,$-2^2$,$+3^2$,$-3^2$,…}为间距依次试探。整个试探过程中，跳转的方向前后交替，所以称为双向平方试探。</p><blockquote><p>只要散列表取作$4k+3$($k$为非负整数)，则任一关键码所对应的查找链中，前$M$个桶必然互异</p></blockquote><p>根据跳转的方向，查找链的前$M$项可分为三类：</p><ul><li>O:第1次试探，位于原地的起点</li><li>A:第$2、4、6、…,M-1$次试探，相对于起点向前跳转</li><li>B:第$3、5、7、….M$次试探，相对于起点向后跳转</li></ul><p>根据此前的结论,$O \cup A$和$O \cup B$内部的试探不至相互冲突。因此，只需考虑A类试探和B类试探之间是否会存在冲突。</p><p>假设第$2a$次试探和第$2b+1$次试探相互冲突，于是便有：</p><p>$a^2 \equiv b^2(mod M)$</p><p>亦即$n=a^2+b^2\equiv 0(mod M) $</p><p>对于形如$M=4k+3$的素数表长，这是不可能的</p><p>一个自然数$n$若可表示为一对整数的平方和，则称之为可平方拆分的。</p><p>不妨设n的素因子分解式为：</p><p>$n=p_1^{\alpha1}p_2^{\alpha2}p_3^{\alpha3}…p_d^{\alpha d}$</p><p>以下恒等式：</p><p>$(u^2+v^2)(s^2+t^2)=(us+vt)^2$</p><p>$n$是可平方拆分的当且仅当对每个$1\leq d \leq d$，或$\alpha i$为偶数，或$p_i$是可平方拆分的。</p><p>除了$2=1^2+1^2$,其余素数可以根据关于4的模余值划分为两个同余类。根据费马平方和定理，形如$4k+1$的素因子必可以平方拆分，而形如$4k+3$的素因子必然不可平方拆分。因此，若$n$可平方拆分，则对于其中每一个形如$p_i=4k+3$的素因子，$\alpha i$必然是偶数。</p><p>由以上式子得，$M=4k+3$应是$4k+3$的一个素因子。根据分析可知，n必然可以被$M^2$整除，于是便有：</p><p>$n=a^2+b^2 \geq M^2$</p><p>然而，对于取值在$[1,\lfloor M/2 \rfloor]$ 范围内的$a$和$b$，这是不可能的。</p><h1 id="散列应用"><a href="#散列应用" class="headerlink" title="散列应用"></a>散列应用</h1><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><strong>简单情况</strong></p><p>考查如下问题：给定$[0,M)$内的$n$个互异整数，如何高效地进行排序？</p><p>借助散列表$E[0,M)$</p><ul><li>创建散列表并将散列表初始化为0</li><li>使用最简单的散列函数$hash(key)=key4,将整数视为关键码逐一插入到散列表中</li><li>顺序遍历一趟散列表，依次输出非空桶中存放的关键码</li></ul><p>散列表的创建初始化耗时$O(M)$,将所有关键码插入散列表耗时$O( n )$ ，依次读出非空桶中的关键码$O(M)$，总体运行时间为$O(n+M)$。</p><p><strong>一般情况</strong></p><p>允许关键码重复，又该如何高效排序？</p><p>沿用以上构思，只不过这次需要处理散列冲突。不妨采用独立链法解决冲突，将所有整数作为关键码插入散列表后，只需一趟顺序遍历即可得到完整的排序结果，在串联时留意链表方向，甚至可以确保排序结果的稳定，如此实现的桶排序算法属于稳定算法。</p><p>散列表的创建初始化耗时$O(M)$,将所有关键码插入散列表耗时$O( n )$ ，依次读出非空桶中的关键码$O(M)$，总体运行时间为$O(n+M)$。在n&gt;&gt;M的场合，桶排序的时间将是:</p><p>$O(n+M)=O(max(n,M))=O(n)$</p><p>线性正比于待排序元素的数目，突破了$\Omega(nlogn)$的下界。在关键码均匀分布时，亦是如此。</p><p>基于散列表的排序算法采取的是循秩访问的方式，摒弃了以往基于关键码大小比较式的设计思路，所以不受下界约束。</p><p><strong>最大间隙</strong></p><p>任意$n$个互异点均将实轴分为$n-1$段有界区间，其中哪一段最长？</p><p><strong>平凡算法</strong></p><ul><li><p>将各点按照坐标排序(最坏情况下$\Omega(n logn)$)</p></li><li><p>依次计算相邻点对之间的距离，保留最大者$\Theta (n)$</p></li></ul><p><strong>线性算法</strong></p><ul><li>一趟线性扫描找到最左点、最右点</li><li>将有效范围划分为$n-1$段($n$个桶)</li><li>通过散列将各点归入对应的桶</li><li>在各桶中，动态记录最左点和最右点</li><li>算出相邻(非空桶之间的距离)</li><li>最大距离则为最大间隙</li></ul><p><strong>正确性</strong></p><p>$n-1$个间隙中的最宽者，绝不可能窄于这些间隙的平均宽度，即各个桶单元对应的区间宽度。最大间隙的两个端点绝不可能落在同一桶单元内。必然来自两个非空桶，中间可能有若干非空桶。左端点应在前一桶中应该最靠右，而又端点在后一桶中应该最靠左，因此只需动态记录各桶的最左点和最右点。</p><p><strong>复杂度</strong></p><p>时间复杂度为$O(n)$，空间复杂度为维护散列表所需空间，$O(n)$辅助空间。</p><p>对于最小间隙的问题，则不可使用以上方法，因为上述方法可用基于<strong>最大间隙至少与相邻的两个桶相交</strong>的事实，而最小间隙既有可能与两个相邻的非空桶相交，也有可能只与其中一个桶相交。</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>实际应用场景中词条的关键码，未必都是整数。比如，一种常见情形是，关键码由多个字段组成，并采用所谓的字典序确定大小次序：<strong>任意两个关键码的大小关系取决于它们第一个互异的字段</strong>。</p><p>假定关键码由$t$个字段{$k_t$,$k_{t-1}$,$k_{t-2}$,…,$k_1$}组成，其中$k_t$优先级最高。只需按照优先级递增的顺序对每一字段做一趟桶排序，即可实现按整个关键码字典序的排序。这一算法称作基数排序，采用了低位字段优先的策略，其中所做桶排序的趟数，取决于组成关键码的字段数。</p><p><strong>正确性与稳定性</strong></p><p>以以下命题作为归纳假设：在经过基数排序的前i趟桶排序后，所有词条均已按照关键码最低的i个字段有序排列。</p><p>假定前$i-1$趟均成立，考查第i趟桶排序的情况</p><ul><li>凡第$i$位不同的词条：即便此前为逆序，现在亦必已转为有序</li><li>凡第$i$位相同的词条，得益于桶排序的稳定性，必保持原有次序</li></ul><p>如此实现的基数排序同样稳定。</p><p><strong>复杂度</strong></p><p>根据以上基数排序的流程，总体运行时间等于其中各趟桶排序所需时间的总和。</p><p>设各字段取值范围为$[0,m_i),1 \leq i \leq t $</p><p>$M=max{m_1,m_2,…,m_t}$</p><p>总体运行时间不超过:</p><p>$O(n+m_1)+O(n+m_2)+…O(n+m_t)=O(t(n+M))$</p><p>当$M=O(n)$且$t$为常数时，$O(n)$。</p><p>在一些特定场合，基数排序非常高效。例如，任给来自$[0,n^d)$范围内的$n$个整数，其中常数d&gt;1，可在$O(n)$时间内完成对它们的排序。</p><ul><li>在$O(dn)=O(n)$时间内，将这些整数转换为$n$进制的表示。</li><li>将每一位视作一个域，则这些整数的排序依据等效于按照这些域的字典序，直接套用基数排序即可完成排序</li></ul><p>以上基数排序过程包含$d$趟桶排序，累计耗时：</p><p>$dO(n)=O(dn)=O(n)$</p><p>原因：</p><ol><li>整数的取值范围有限制</li><li>不再是基于比较的计算模式</li></ol><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>若将任一有序序列等效地视作有序向量，则每个元素的秩，应恰好等于序列中不大于该元素的元素总数。例如，其中最小元素的秩为$0$，最大元素的秩为$n-14$，分别有$0$和$n-1$个元素不大于它们。根据这一原理，只需统计出各元素的对应这一指标，也就确定了它们在有序向量中各自对应的秩。</p><p>无需借助冲突的独立链表，由此可得计数排序算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int* countingsort(int A[0,n))</span><br><span class="line">   引入一个可计数的散列表H[<span class="number">0</span>,M),其长度等于输入元素取值范围的宽度M</span><br><span class="line">   将H[]中所有桶的数值初始化为<span class="number">0</span></span><br><span class="line">   遍历序列A[<span class="number">0</span>,n) <span class="comment">//遍历计数，O(n)</span></span><br><span class="line">     对于每一项，令H[A[k]]++</span><br><span class="line">   遍历散列表H[<span class="number">0</span>,M)</span><br><span class="line">     对于每一项H[i],令H[i+<span class="number">1</span>]+=H[i]</span><br><span class="line">   创建序列S[<span class="number">0</span>,n)，记录排序结果</span><br><span class="line">   逆向遍历输入序列A[<span class="number">0</span>,n)</span><br><span class="line">     对于每一项A[k]</span><br><span class="line">     令S[--H[A[k]]]=A[k]</span><br><span class="line">   返回s[<span class="number">0</span>,n)</span><br></pre></td></tr></table></figure><p>注意，最后一步扫描不可从前到后，否则稳定性不再满足。</p><p>其中各个步骤所需的时间，总体而言不超过$O(n+M)$ 。若$n&gt;&gt;m$，则排序时间为$O(n)$。这就是所谓的小集合大数据的情况，在当下已经成为数据和信息处理的主流类型。</p><h1 id="跳转表"><a href="#跳转表" class="headerlink" title="跳转表"></a>跳转表</h1><p>可否综合向量与列表的优势，高效地实现词典接口？具体地，如何使得各接口的效率为$O(logn)$。</p><p><img src="https://i.loli.net/2019/09/08/V9cLzn6BCqXRgGK.png"></p><p>跳转表的宏观逻辑如图所示，其内部由沿纵向分层，横向相互耦合的多个列表{$S_0$,$S_1$,$S_2$,…,$S_h$}组成，$h$称为跳转表的高度。每一水平列表称作一层，其中$S_0$和$S_h$分别称作底层和顶层。同层节点之间可定义前驱和后继关系。为便于查找，同层节点都按关键码排序。层次不同的节点可能沿着纵向组成塔，同一塔内的节点以高度为序定义前驱和后继。塔与词典中的词条一一对应。</p><p>高层列表总是底层列表的子集，其中特别地，$S_0$包含词典中所有词条，而$S_h$除头、尾哨兵外不含任何实质地词条。跳转表的层高$h$必然决定于最大的塔高。</p><p>跳转表各塔高度的随机分布规律对跳转表的整体性能至关重要。控制跳转表的生长过程，在时间和空间上都可实现足够高的效率。此类控制策略必然满足所谓生长概率减半的条件：</p><p>对于任意的$0 \leq k&lt;h$,$S_k$中任一节点在$S_{k+1}$中仍然出现的概率，始终为1/2。</p><p>可见，各塔高度符合集合分布：$Pr(h=k)=p^{k-1}(1-p)$</p><p>于是，期望的塔高为$E(h)=1/(1-p)=2$</p><p>也可以如此解释，$S_0$中任一关键码在$S_k$中依然出现的概率均为$2^{-k}$,第$k$层节点数的期望值$E(|S_k|)=n2^{-k}=n/2^k$。</p><p>于是，所有节点期望的总数(即各层列表所需空间总和)为</p><p>$E(\sum_k|S_k|)=\sum_kE(|S_k|)=n\sum_k2^{-k}&lt;2n=O(n)$</p><p>跳转表所需空间期望值为$ O( n )$</p><h2 id="初始化与构造"><a href="#初始化与构造" class="headerlink" title="初始化与构造"></a>初始化与构造</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Quadlist&lt;T&gt;::init() &#123; <span class="comment">//Quadlist初始化，创建Quadlist对象时统一调用</span></span><br><span class="line">   header = <span class="keyword">new</span> QuadlistNode&lt;T&gt;; <span class="comment">//创建头哨兵节点</span></span><br><span class="line">   trailer = <span class="keyword">new</span> QuadlistNode&lt;T&gt;; <span class="comment">//创建尾哨兵节点</span></span><br><span class="line">   header-&gt;succ = trailer; header-&gt;pred = <span class="literal">NULL</span>; <span class="comment">//沿横向联接哨兵</span></span><br><span class="line">   trailer-&gt;pred = header; trailer-&gt;succ = <span class="literal">NULL</span>; <span class="comment">//沿横向联接哨兵</span></span><br><span class="line">   header-&gt;above = trailer-&gt;above = <span class="literal">NULL</span>; <span class="comment">//纵向的后继置空</span></span><br><span class="line">   header-&gt;below = trailer-&gt;below = <span class="literal">NULL</span>; <span class="comment">//纵向的前驱置空</span></span><br><span class="line">   _size = <span class="number">0</span>; <span class="comment">//记录规模</span></span><br><span class="line">&#125; <span class="comment">//如此构造的四联表，不含任何实质的节点，且暂时与其它四联表相互独立</span></span><br></pre></td></tr></table></figure><p>每个词条都在所属的塔内同时存在多个副本，浪费了大量的空间。只需将所有词条组织为一个独立的横向列表，则各词条所对应的纵向列表即可不必重复保留词条的副本。纵向列表中的每个节点，只需通过引用指向横向列表中对应的词条。如此，一旦查找终止于某纵向列表，即可直接通过引用找到对应的词条。</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; V* Skiplist&lt;K, V&gt;::get ( K k ) &#123; <span class="comment">//跳转表词条查找算法</span></span><br><span class="line">   <span class="keyword">if</span> ( empty() ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   ListNode&lt;Quadlist&lt;Entry&lt;K, V&gt;&gt;*&gt;* qlist = first(); <span class="comment">//从顶层Quadlist的</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* p = qlist-&gt;data-&gt;first(); <span class="comment">//首节点开始</span></span><br><span class="line">   <span class="keyword">return</span> skipSearch ( qlist, p, k ) ? &amp; ( p-&gt;entry.value ) : <span class="literal">NULL</span>; <span class="comment">//查找并报告</span></span><br><span class="line">&#125; <span class="comment">//有多个命中时靠后者优先</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Skiplist&lt;K, V&gt;::skipSearch (</span><br><span class="line">   ListNode&lt;Quadlist&lt;Entry&lt;K, V&gt;&gt;*&gt;* &amp;qlist, <span class="comment">//从指定层qlist的</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* &amp;p, <span class="comment">//首节点p出发</span></span><br><span class="line">   K&amp; k ) &#123; <span class="comment">//向右、向下查找目标关键码k</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123; <span class="comment">//在每一层</span></span><br><span class="line">      <span class="keyword">while</span> ( p-&gt;succ &amp;&amp; ( p-&gt;entry.key &lt;= k ) ) <span class="comment">//从前向后查找</span></span><br><span class="line">         p = p-&gt;succ; <span class="comment">//直到出现更大的key或溢出至trailer</span></span><br><span class="line">      p = p-&gt;pred; <span class="comment">//此时倒回一步，即可判断是否</span></span><br><span class="line">      <span class="keyword">if</span> ( p-&gt;pred &amp;&amp; ( k == p-&gt;entry.key ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//命中</span></span><br><span class="line">      qlist = qlist-&gt;succ; <span class="comment">//否则转入下一层</span></span><br><span class="line">      <span class="keyword">if</span> ( !qlist-&gt;succ ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若已到穿透底层，则意味着失败</span></span><br><span class="line">      p = ( p-&gt;pred ) ? p-&gt;below : qlist-&gt;data-&gt;first(); <span class="comment">//否则转至当前塔的下一节点</span></span><br><span class="line">   &#125;  <span class="comment">//课后：通过实验统计，验证关于平均查找长度的结论</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的参数<code>p</code>和<code>qlist</code>分别指示命中关键码所属塔的顶部节点及其所属的列表。<code>qlist</code>和<code>p</code>的初始值分别为顶层列表及其首节点，返回后将为上层的查找节点提供必要的信息。</p><p><strong>时间复杂度</strong></p><p>考查第$k$层列表$S_k$,</p><p>$S_k$非空，当且仅当$S_0$所含的$n$个节点中,至少有一个会出现在$S_k$中，相应的概率为</p><p>$Pr(|S_k|&gt;0) \leq n2^{-k}=n/2^k$</p><p>反过来，$S_k$ 为空的概率为</p><p>$Pr(|S_k|&gt;0) \geq 1-n2^{-k}$</p><p>这一概率随着高度$k$的增加将迅速上升并接近100%。</p><p>以$k=3logn$层为例，该层列表为空，当且仅当$h&lt;k$,对应的概率为</p><p>$Pr(h&lt;k)=Pr(|S_k|=0)\geq 1-n/2^k=1-n/n^3=1-1/n^2$</p><p>一般地，$k=alogn$层列表为空的概率为$1-1/n^{a-1}$,$a&gt;3$后这一概率将迅速地接近100%。</p><p>$h$的期望值$S(h)=O(logn)$</p><p>查找的过程中，每次跳转只能向右或向下，故活跃节点的高度必单调非增，每个高度上纵向跳转至多一次。因此，整个查找过程中消耗于纵向跳转的时间不超过跳转表高度的期望值$O(logn)$。</p><p>沿同一列表的横向跳转所经过的节点必然依次紧邻，且均为各自所属塔的塔顶。若将同层连续横向跳转的次数记作$Y$,跳转经过$k$个塔顶，一个非塔顶则有几何分布：</p><p>$Pr(Y=k)=(1-p)^kp$</p><p>$E(Y)=(1-p)/p=(1-0.5)/0.5=1$</p><p>同层列表中紧邻的塔顶节点，平均不过$1+1=2$个。沿着每条查找路径，在每一高度上平均只做常数次横向跳转。因此，整个查找过程中所做的横向跳转的期望次数，线性正比于跳转表的期望高度，亦是$O( log n)$。</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>此处通过逻辑表达式<code>rand%2</code> 来模拟投掷硬币，并保证生长概率减半的条件。通过伪随机数的奇偶，近似地模拟一次理想的掷硬币实验。只要伪随机数为奇数，新塔就继续生长，否则停止生长。新塔的期望高度，将取决于此前连续的正面硬币的期望次数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Skiplist&lt;K, V&gt;::put ( K k, V v ) &#123; <span class="comment">//跳转表词条插入算法</span></span><br><span class="line">   Entry&lt;K, V&gt; e = Entry&lt;K, V&gt; ( k, v ); <span class="comment">//待插入的词条（将被随机地插入多个副本）</span></span><br><span class="line">   <span class="keyword">if</span> ( empty() ) insertAsFirst ( <span class="keyword">new</span> Quadlist&lt;Entry&lt;K, V&gt;&gt; ); <span class="comment">//插入首个Entry</span></span><br><span class="line">   ListNode&lt;Quadlist&lt;Entry&lt;K, V&gt;&gt;*&gt;* qlist = first(); <span class="comment">//从顶层四联表的</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* p = qlist-&gt;data-&gt;first(); <span class="comment">//首节点出发</span></span><br><span class="line">   <span class="keyword">if</span> ( skipSearch ( qlist, p, k ) ) <span class="comment">//查找适当的插入位置（不大于关键码k的最后一个节点p）</span></span><br><span class="line">      <span class="keyword">while</span> ( p-&gt;below ) p = p-&gt;below; <span class="comment">//若已有雷同词条，则需强制转到塔底</span></span><br><span class="line">   qlist = last(); <span class="comment">//以下，紧邻于p的右侧，一座新塔将自底而上逐层生长</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* b = qlist-&gt;data-&gt;insertAfterAbove ( e, p ); <span class="comment">//新节点b即新塔基座</span></span><br><span class="line">   <span class="keyword">while</span> ( rand() &amp; <span class="number">1</span> ) &#123; <span class="comment">//经投掷硬币，若确定新塔需要再长高一层，则</span></span><br><span class="line">      <span class="keyword">while</span> ( qlist-&gt;data-&gt;valid ( p ) &amp;&amp; !p-&gt;above ) p = p-&gt;pred; <span class="comment">//找出不低于此高度的最近前驱</span></span><br><span class="line">      <span class="keyword">if</span> ( !qlist-&gt;data-&gt;valid ( p ) ) &#123; <span class="comment">//若该前驱是header</span></span><br><span class="line">         <span class="keyword">if</span> ( qlist == first() ) <span class="comment">//且当前已是最顶层，则意味着必须</span></span><br><span class="line">            insertAsFirst ( <span class="keyword">new</span> Quadlist&lt;Entry&lt;K, V&gt;&gt; ); <span class="comment">//首先创建新的一层，然后</span></span><br><span class="line">         p = qlist-&gt;pred-&gt;data-&gt;first()-&gt;pred; <span class="comment">//将p转至上一层Skiplist的header</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//否则，可径自</span></span><br><span class="line">         p = p-&gt;above; <span class="comment">//将p提升至该高度</span></span><br><span class="line">      qlist = qlist-&gt;pred; <span class="comment">//上升一层，并在该层</span></span><br><span class="line">      b = qlist-&gt;data-&gt;insertAfterAbove ( e, p, b ); <span class="comment">//将新节点插入p之后、b之上</span></span><br><span class="line">   &#125;<span class="comment">//课后：调整随机参数，观察总体层高的相应变化</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//Dictionary允许重复元素，故插入必成功——这与Hashtable等Map略有差异</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>从跳转表中删除关键码为$k$的词条的具体操作过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Skiplist&lt;K, V&gt;::remove ( K k ) &#123; <span class="comment">//跳转表词条删除算法</span></span><br><span class="line">   <span class="keyword">if</span> ( empty() ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//空表情况</span></span><br><span class="line">   ListNode&lt;Quadlist&lt;Entry&lt;K, V&gt;&gt;*&gt;* qlist = first(); <span class="comment">//从顶层Quadlist的</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* p = qlist-&gt;data-&gt;first(); <span class="comment">//首节点开始</span></span><br><span class="line">   <span class="keyword">if</span> ( !skipSearch ( qlist, p, k ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//目标词条不存在，直接返回</span></span><br><span class="line">   <span class="keyword">do</span> &#123; <span class="comment">//若目标词条存在，则逐层拆除与之对应的塔</span></span><br><span class="line">      QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* lower = p-&gt;below; <span class="comment">//记住下一层节点，并</span></span><br><span class="line">      qlist-&gt;data-&gt;remove ( p ); <span class="comment">//删除当前层节点，再</span></span><br><span class="line">      p = lower; qlist = qlist-&gt;succ; <span class="comment">//转入下一层</span></span><br><span class="line">   &#125; <span class="keyword">while</span> ( qlist-&gt;succ ); <span class="comment">//如上不断重复，直到塔基</span></span><br><span class="line">   <span class="keyword">while</span> ( !empty() &amp;&amp; first()-&gt;data-&gt;empty() ) <span class="comment">//逐一地</span></span><br><span class="line">      List::remove ( first() ); <span class="comment">//清除已可能不含词条的顶层Quadlist</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//删除操作成功完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>QuadlistNode</code>节点总是以塔为单位，自顶而下得成批被删除，其中每一节点的删除，都按照如下模式：节点p为当前的塔顶，将它从横向列表中删除，其下邻随后将称为新塔顶，并将在紧随其后的下一次删除操作中被删除。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//删除Quadlist内位置p处的节点，返回其中存放的词条</span></span><br><span class="line">T Quadlist&lt;T&gt;::remove ( QlistNodePosi(T) p ) &#123; <span class="comment">//assert: p为Quadlist中的合法位置</span></span><br><span class="line">   p-&gt;pred-&gt;succ = p-&gt;succ; p-&gt;succ-&gt;pred = p-&gt;pred; _size--;<span class="comment">//摘除节点</span></span><br><span class="line">   T e = p-&gt;entry; <span class="keyword">delete</span> p; <span class="comment">//备份词条，释放节点</span></span><br><span class="line">   <span class="keyword">return</span> e; <span class="comment">//返回词条</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Quadlist&lt;T&gt;::clear() &#123; <span class="comment">//清空Quadlist</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; _size ) remove ( header-&gt;succ ); <span class="comment">//逐个删除所有节点</span></span><br><span class="line">   <span class="keyword">return</span> oldSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>词条的删除算法，不外乎消耗于两个方面：</p><ul><li><strong>查找目标关键码</strong> </li><li><strong>拆除与目标关键码相关的塔</strong></li></ul><p>词条删除操作所需时间不超过$O(h)=O(logn)$</p><h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>集合可视为一种抽象数据类型，考查其中的特例，整数集合，按照散列的思想，所有离散集或者显式地本身就是整数集，或者隐式地可转换为整数集。</p><p>对集合的操作有：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> k)</span></span>;<span class="comment">//将整数加入当前集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> k)</span></span>;<span class="comment">//从当前集合中排除整数k</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> k)</span>P</span>;<span class="comment">//判断整数是否属于当前集合</span></span><br></pre></td></tr></table></figure><p>位图是一种特殊的序列结构，可用于动态地表示由一组无符号整数构成的集合，其长度无限，且每个元素取值为布尔型。</p><p>一种简洁的实现方式如下，使用物理地址连续的一段空间，各元素依次对应于一个比特位:若集合包含整数$k$,则该段空间中的第$k$个比特位为1，否则该比特位为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> <span class="comment">//位图Bitmap类</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">char</span>* M; <span class="keyword">int</span> N; <span class="comment">//比特图所存放的空间M[]，容量为N*sizeof(char)*8比特</span></span><br><span class="line">      <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; M = <span class="keyword">new</span> <span class="keyword">char</span>[N = ( n + <span class="number">7</span> ) / <span class="number">8</span>]; <span class="built_in">memset</span> ( M, <span class="number">0</span>, N ); &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Bitmap ( <span class="keyword">int</span> n = <span class="number">8</span> ) &#123; init ( n ); &#125; <span class="comment">//按指定或默认规模创建比特图（为测试暂时选用较小的默认值）</span></span><br><span class="line">    Bitmap ( <span class="keyword">char</span>* file, <span class="keyword">int</span> n = <span class="number">8</span> ) <span class="comment">//按指定或默认规模，从指定文件中读取比特图</span></span><br><span class="line">    &#123;    </span><br><span class="line">      init ( n ); </span><br><span class="line">      FILE* fp = fopen ( file, <span class="string">&quot;r&quot;</span> ); fread ( M, <span class="keyword">sizeof</span> ( <span class="keyword">char</span> ), N, fp );                     fclose ( fp );  </span><br><span class="line">    &#125;</span><br><span class="line">    ~Bitmap() &#123; <span class="keyword">delete</span> [] M; M = <span class="literal">NULL</span>; &#125; <span class="comment">//析构时释放比特图空间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span>   <span class="params">( <span class="keyword">int</span> k )</span> </span>&#123; expand ( k );  M[k &gt;&gt; <span class="number">3</span>] |=   ( <span class="number">0x80</span> &gt;&gt; ( k &amp; <span class="number">0x07</span> ) ); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span> <span class="params">( <span class="keyword">int</span> k )</span> </span>&#123; expand ( k );  M[k &gt;&gt; <span class="number">3</span>] &amp;= ~ ( <span class="number">0x80</span> &gt;&gt; ( k &amp; <span class="number">0x07</span> ) ); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">test</span>  <span class="params">( <span class="keyword">int</span> k )</span> </span>&#123; expand ( k ); <span class="keyword">return</span> M[k &gt;&gt; <span class="number">3</span>] &amp;( <span class="number">0x80</span> &gt;&gt; ( k &amp; <span class="number">0x07</span> ) );&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump</span> <span class="params">( <span class="keyword">char</span>* file )</span> <span class="comment">//将位图整体导出至指定的文件，以便对此后的新位图批量初始化</span></span></span><br><span class="line"><span class="function">    </span>&#123;  FILE* fp = fopen ( file, <span class="string">&quot;w&quot;</span> ); </span><br><span class="line">       fwrite ( M, <span class="keyword">sizeof</span> ( <span class="keyword">char</span> ), N, fp ); </span><br><span class="line">       fclose ( fp );  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">bits2string</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//将前n位转换为字符串——</span></span><br><span class="line">       expand ( n - <span class="number">1</span> ); <span class="comment">//此时可能被访问的最高位为bitmap[n - 1]</span></span><br><span class="line">       <span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>]; s[n] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//字符串所占空间，由上层调用者负责释放</span></span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) s[i] = test ( i ) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">       <span class="keyword">return</span> s; <span class="comment">//返回字符串位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span> <span class="params">( <span class="keyword">int</span> k )</span> </span>&#123; <span class="comment">//若被访问的Bitmap[k]已出界，则需扩容</span></span><br><span class="line">         <span class="keyword">if</span> ( k &lt; <span class="number">8</span> * N ) <span class="keyword">return</span>; <span class="comment">//仍在界内，无需扩容</span></span><br><span class="line">         <span class="keyword">int</span> oldN = N; <span class="keyword">char</span>* oldM = M;</span><br><span class="line">         init ( <span class="number">2</span> * k ); <span class="comment">//与向量类似，加倍策略</span></span><br><span class="line">         memcpy_s ( M, N, oldM, oldN ); <span class="keyword">delete</span> [] oldM; <span class="comment">//原数据转移至新空间</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>每个字节通常包含8个比特，故通过移位运算：$k&gt;&gt;3$ 即可确定该元素所属字节的秩，通过逻辑与运算$k&amp;0x07$即可确定该比特位在该字节中的位置；通过移位操作(高位顺序在前)：</p><p>$0x80&gt;&gt;(k&amp;0x07)$即可得到该比特位在此字节中的数值掩码。 </p><p><code>dump()</code>接口将位图导出至指定文件，以便于对此后的新位图进行初始化。</p><p><code>set()</code>,<code>clear()</code>,<code>test()</code>仅涉及常数次基本运算，故其时间复杂度为$O(1)$。</p><p>位图向量所占的空间线性正比于集合的取值范围。</p><h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><blockquote><p>int A[n]的元素均取自[0,m)，如何剔除其中的重复者</p></blockquote><p>仿照无序向量的去重方法，先有序化，再扫描一次$O(nlogn+n)$</p><p>但是数据量虽大，但是重复率极高，比如$2^{24}&lt;&lt;n=10^{10}$</p><p>即$10000000000$个无符号整数，若采用内部排序算法需要$4*n=40GB$内存，否则，频繁的I/O操作将导致效率低下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bitmap <span class="title">B</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) B.<span class="built_in">set</span>(A[i]);<span class="comment">//O(n)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;i&lt;m;k++) <span class="keyword">if</span>(B.test(k)) <span class="comment">/*...*/</span>;<span class="comment">//O(m)</span></span><br></pre></td></tr></table></figure><p>可通过位图来利用$m&lt;&lt;n$的条件</p><p>总体运行时间$O(n+m)$</p><p>空间复杂度$O(m)$,搜索引擎的应用类似，词表规模不大，但是重复的概率很高。</p><blockquote><p>如何计算[0,n)内的素数</p></blockquote><p>不计内循环，外循环自身每次仅一次加法、两次判断，累计O(n)</p><p>内循环每趟迭代$O(n/i)$步，由素数定理至多$n/lnn$趟，累计耗时不过</p><p>$n/2 + n/3 + n/5 + n/7 + n/11 + …&lt;  n/2 + n/3 + n/4 + n/6 + n/7 + … + n/(n/ln(n))$</p><p>$=  O(n(ln(n/lnn) - 1))$</p><p>$=  O(nln(n) - nln(ln(n)) - 1)$</p><p>$=  O(nlogn)$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eratosthenes</span> <span class="params">( <span class="keyword">int</span> n, <span class="keyword">char</span>* file )</span> </span>&#123;</span><br><span class="line">   <span class="function">Bitmap <span class="title">B</span> <span class="params">( n )</span></span>; B.<span class="built_in">set</span> ( <span class="number">0</span> ); B.<span class="built_in">set</span> ( <span class="number">1</span> ); <span class="comment">//0和1都不是素数</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++ ) <span class="comment">//反复地，从下一</span></span><br><span class="line">      <span class="keyword">if</span> ( !B.test ( i ) ) <span class="comment">//可认定的素数i起</span></span><br><span class="line">         <span class="keyword">for</span> ( <span class="keyword">int</span> j = __min ( i, <span class="number">46340</span> ) * __min ( i, <span class="number">46340</span> ); j &lt; n; j += i ) <span class="comment">//以i为间隔</span></span><br><span class="line">            B.<span class="built_in">set</span> ( j ); <span class="comment">//将下一个数标记为合数</span></span><br><span class="line">   B.dump ( file ); <span class="comment">//将所有整数的筛选标记统一存入指定文件，以便日后直接导入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内循环从$i * i$而非$i + i$开始，迭代步数由$O(n / i)$降至$O(max(1, n / i - i))$</p><h2 id="快速初始化"><a href="#快速初始化" class="headerlink" title="快速初始化"></a>快速初始化</h2><p>将$B[m]$拆分为一堆等长的rank型向量，总体空间复杂度仍然为$O(m)$。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> <span class="comment">//位图Bitmap类：以空间作为补偿，节省初始化时间（仅允许插入，不支持删除）</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Rank* F; Rank N; <span class="comment">//规模为N的向量F，记录[k]被标记的次序（即其在栈T[]中的秩）</span></span><br><span class="line">   Rank* T; Rank top; <span class="comment">//容量为N的栈T，记录被标记各位秩的栈，以及栈顶指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">valid</span> <span class="params">( Rank r )</span> </span>&#123; <span class="keyword">return</span> ( <span class="number">0</span> &lt;= r ) &amp;&amp; ( r &lt; top ); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Bitmap ( Rank n = <span class="number">8</span> ) <span class="comment">//按指定（或默认）规模创建比特图（为测试暂时选用较小的默认值）</span></span><br><span class="line">   &#123; N = n; F = <span class="keyword">new</span> Rank[N]; T = <span class="keyword">new</span> Rank[N]; top = <span class="number">0</span>; &#125; <span class="comment">//在O(1)时间内隐式地初始化</span></span><br><span class="line">   ~Bitmap() &#123; <span class="keyword">delete</span> [] F; <span class="keyword">delete</span> [] T; &#125; <span class="comment">//析构时释放空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">( Rank k )</span> </span>&#123; <span class="comment">//插入</span></span><br><span class="line">      <span class="keyword">if</span> ( test ( k ) ) <span class="keyword">return</span>; <span class="comment">//忽略已带标记的位</span></span><br><span class="line">      F[k] = top++; T[ F[k] ] = k; <span class="comment">//建立校验环</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">test</span> <span class="params">( Rank k )</span> <span class="comment">//测试</span></span></span><br><span class="line"><span class="function">   </span>&#123;  <span class="keyword">return</span> valid ( F[k] ) &amp;&amp; ( k == T[ F[k] ] );  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每当需要调用<code>set(k)</code>标记新的$B[k]$位时，即可将$k$压入栈$T[]$中，并将当前元素(当前的顶元素)在栈中的秩存入$F[k]$。在$k$与$T[F[k]]$之间建立了一个校验环路，当$F[k]$指向栈$T[]$中某个有效元素(<code>valid(F[k])</code>)恰好等于$k$时，在逻辑上必然等效于<code>B[k]=True</code>,反之亦然。test(k)只需判断以上两个条件是否成立。</p><p>以上方法仅限于标记操作<code>set()</code>，尚且不支持clear()操作。如需兼顾这两个操作，就必须有效地区分两种操作，从未标记过的，以及曾经一度被标记后来又被清除的。否则，每次为无标记的位增加标记时简单套用目前的set()接口为其增加一个校验环，则无法限制在$N$以内，整个结构的空间复杂度也将随着操作的次数严格地单调增加。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> <span class="comment">//位图Bitmap类：以空间作为补偿，节省初始化时间（既允许插入，亦支持删除）</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Rank* F; Rank N; <span class="comment">//规模为N的向量F，记录[k]被标记的次序（即其在栈T[]中的秩）</span></span><br><span class="line">   Rank* T; Rank top; <span class="comment">//容量为N的栈T，记录被标记各位秩的栈，以及栈顶指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">valid</span> <span class="params">( Rank r )</span> </span>&#123; <span class="keyword">return</span> ( <span class="number">0</span> &lt;= r ) &amp;&amp; ( r &lt; top ); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">erased</span> <span class="params">( Rank k )</span> <span class="comment">//判断[k]是否曾被标记过，且后来又被清除</span></span></span><br><span class="line"><span class="function">   </span>&#123; <span class="keyword">return</span> valid ( F[k] ) &amp;&amp; ! ( T[ F[k] ] + <span class="number">1</span> + k ); &#125; <span class="comment">//这里约定：T[ F[k] ] = - 1 - k</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Bitmap ( Rank n = <span class="number">8</span> ) <span class="comment">//按指定（或默认）规模创建比特图（为测试暂时选用较小的默认值）</span></span><br><span class="line">   &#123; N = n; F = <span class="keyword">new</span> Rank[N]; T = <span class="keyword">new</span> Rank[N]; top = <span class="number">0</span>; &#125; <span class="comment">//在O(1)时间内隐式地初始化</span></span><br><span class="line">   ~Bitmap() &#123; <span class="keyword">delete</span> [] F; <span class="keyword">delete</span> [] T; &#125; <span class="comment">//析构时释放空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">( Rank k )</span> </span>&#123; <span class="comment">//插入</span></span><br><span class="line">      <span class="keyword">if</span> ( test ( k ) ) <span class="keyword">return</span>; <span class="comment">//忽略已带标记的位</span></span><br><span class="line">      <span class="keyword">if</span> ( !erased ( k ) ) F[k] = top++; <span class="comment">//若系初次标记，则创建新校验环</span></span><br><span class="line">      T[ F[k] ] = k; <span class="comment">//若系曾经标记后被清除，则恢复原校验环</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span> <span class="params">( Rank k )</span> <span class="comment">//删除</span></span></span><br><span class="line"><span class="function">   </span>&#123;  <span class="keyword">if</span> ( test ( k ) ) T[ F[k] ] = - <span class="number">1</span> - k;  &#125; <span class="comment">//忽略不带标记的位</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">test</span> <span class="params">( Rank k )</span> <span class="comment">//测试</span></span></span><br><span class="line"><span class="function">   </span>&#123;  <span class="keyword">return</span> valid ( F[k] ) &amp;&amp; ( k == T[ F[k] ] );  &#125;</span><br></pre></td></tr></table></figure><p>这里的<code>clear()</code>接口将$T[F[k]]$取负之后再减一，也就是再与正常校验环不冲突的情况下就地保留原校验环的信息。</p><p><code>set(k)</code>只需调用<code>erased(k)</code>即可判断$k$属于哪种类型，若从未标记过，则按之前的方法新建一个校验环，否则直接恢复原先的校验环。</p><p>再考查以上实现的空间复杂度，表面上看$F[]$和$T[]$的规模均不超过$N$,但是两个向量元素类型不再是比特位而是秩。二者的本质区别在于前一类元素自身所占的空间与整体规模无关，而后者有关。这里$rank$类型的取值必须足以覆盖<code>Bitmap</code>的规模，反之，可用Bitmap最大也不能超越$rank$类型的取值范围。比如，$rank$为四个字节类型的整数，则<code>Bitmap</code>的规模无法超过$2^{31}-1=O(10^9)$，否则$rank$的自身字宽必须相应加大。所幸目前多数应用均不超过这个规模，因此可近似认为以上算法具有线性复杂度。</p><p>还用于散列表和桶单元的初始化和图的初始化。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;借助数据结构来表示和组织的数据结构，将所有数据视作一个整体统筹处理，进而提高信息访问的规范性及其处理的效率。例如，借助关键码查找和访问数据元素，其中最典型的例子即为词典。逻辑上的词典，为由一组数据构成的集合，其中各元素都是由关键码和数据项合成的词条。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>二叉搜索树</title>
    <link href="http://twinkle0331.github.io/algorithm/bst/"/>
    <id>http://twinkle0331.github.io/algorithm/bst/</id>
    <published>2019-09-05T01:38:10.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>任何词条之间可相互比较大小是有序向量得以定义，以及二分查找赖以成立的基本前提。通过对二分查找策略的抽象和推广，定义和实现二叉搜索树结构。二叉搜索树有诸多变种，各具特色，各有所长，也有各自适用范围。为有效控制树高，二叉树的性能主要取决于树高，故应在节点数目一定的情况下尽可能地减小树高，相应地，尽可能使兄弟子树地高度彼此接近，即全树尽可能地平衡。平衡二叉搜索树通过对树中每一局部增加某种性质来保证二叉树的适度平衡性。</p><a id="more"></a><p>查找，即按照事先约定的规则，从数据集合中找出符合特定条件的对象，属于基本的静态操作。</p><p>基本的数据结构(列表和向量)并不能高效地兼顾静态查找和动态修改操作。</p><table><thead><tr><th>基本结构</th><th>查找</th><th>插入/删除</th></tr></thead><tbody><tr><td>无序向量</td><td>$O( n )$</td><td>$ O( n )$</td></tr><tr><td>有序向量</td><td>$O(logn)$</td><td>$ O(n)$</td></tr><tr><td>无序列表</td><td>$O( n )$</td><td>$O(1)$</td></tr><tr><td>有序列表</td><td>$O(n)$</td><td>$O(n)$</td></tr></tbody></table><h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h2><p>在所谓的二叉搜索树中，处处都满足顺序性：</p><p><strong>任一节点r的左(右)子树中，所有节点(若存在)，均不大于(不小于)r</strong></p><p>为了回避边界情况，暂且假定所有节点互不相等，于是上述顺序性可简化表述为：</p><p><strong>任一节点r的左(右)子树中，所有节点(若存在)，均小于(大于)r</strong></p><p>当然，在实际应用中，对相等元素的禁止既不自然也不必要，可以对现有结构进行扩展，使二叉搜索树的接口支持相等词条的同时并存。</p><h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><p>在微观上满足顺序性，在宏观上满足单调性，单调性：</p><p><strong>BST的中序遍历序列，必然单调非降</strong></p><p>考查二叉树中的任一节点$r$，按照中序遍历的约定，$r$左(右)子树中的节点(若存在)均应先于(后于)r接受访问。</p><p>按照二叉搜索树的定义，$r$左(右)子树中的节点(若存在)均不大于(不小于)$r$，故中序遍历序列必然在r处单调非降，反之亦然。</p><p>鉴于以上所取$r$的任意性，在二叉搜索树中处处成立。</p><p>二叉搜索树的定义无法更改为<strong>任意节点的左(右)孩子均不大于(不小于)r</strong>，即将原来定义中的左(右)后代替换为左(右)孩子。满足这一定义的树未必中序遍历序列单调非降。</p><h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><p>二叉搜索树的查找算法采取了减而治之的思路和策略，执行过程可描述为：</p><p><strong>从树根出发，逐步地缩小查找范围，直到发现目标(成功)或缩小至空树(失败)</strong></p><p>对照中序遍历来看，整个过程可视为仿效有序向量的二分查找。</p><p><strong>递归版</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search ( const T&amp; e ) &#x2F;&#x2F;在BST中查找关键码e</span><br><span class="line">&#123; return searchIn ( _root, e, _hot &#x3D; NULL ); &#125; &#x2F;&#x2F;返回目标节点位置的引用，以便后续插入、删除操作</span><br><span class="line">template &lt;typename T&gt; &#x2F;&#x2F;在以v为根的（AVL、SPLAY、rbTree等）BST子树中查找关键码e</span><br><span class="line">static BinNodePosi(T) &amp; searchIn ( BinNodePosi(T) &amp; v, const T&amp; e, BinNodePosi(T) &amp; hot ) &#123;</span><br><span class="line">   if ( !v || ( e &#x3D;&#x3D; v-&gt;data ) ) return v; &#x2F;&#x2F;递归基：在节点v（或假想的通配节点）处命中</span><br><span class="line">   hot &#x3D; v; &#x2F;&#x2F;一般情况：先记下当前节点，然后再</span><br><span class="line">   return searchIn ( ( ( e &lt; v-&gt;data ) ? v-&gt;lc : v-&gt;rc ), e, hot ); &#x2F;&#x2F;深入一层，递归查找</span><br><span class="line">&#125; &#x2F;&#x2F;返回时，返回值指向命中节点（或假想的通配哨兵），hot指向其父亲（退化时为初始值NULL）</span><br></pre></td></tr></table></figure><p><strong>迭代版</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search ( <span class="keyword">const</span> T&amp; e ) <span class="comment">//在BST中查找关键码e</span></span><br><span class="line">&#123; <span class="keyword">return</span> searchIn ( _root, e, _hot = <span class="literal">NULL</span> ); &#125; <span class="comment">//返回目标节点位置的引用，以便后续插入、删除操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EQUAL(e, v)  (!(v) || (e) == (v)-&gt;data) <span class="comment">//节点v（或假想的通配哨兵）的关键码等于e</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//在以v为根的（AVL、SPLAY、rbTree等）BST子树中查找关键码e</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> &amp; <span class="title">searchIn</span> <span class="params">( BinNodePosi(T) &amp; v, <span class="keyword">const</span> T&amp; e, BinNodePosi(T) &amp; hot )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( EQUAL ( e, v ) ) <span class="keyword">return</span> v; hot = v; <span class="comment">//退化情况：在子树根节点v处命中</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> ) &#123; <span class="comment">//一般地，反复不断地</span></span><br><span class="line">      BinNodePosi(T) &amp; c = ( e &lt; hot-&gt;data ) ? hot-&gt;lc : hot-&gt;rc; <span class="comment">//确定深入方向</span></span><br><span class="line">      <span class="keyword">if</span> ( EQUAL ( e, c ) ) <span class="keyword">return</span> c; hot = c; <span class="comment">//命中返回，或者深入一层</span></span><br><span class="line">   &#125; <span class="comment">//hot始终指向最后一个失败节点</span></span><br><span class="line">&#125; <span class="comment">//返回时，返回值指向命中节点（或假想的通配哨兵），hot指向其父亲（退化时为初始值NULL）</span></span><br></pre></td></tr></table></figure><p>运行时间正比于返回节点v的深度，不超过树高$O(h)$。最好情况下目标关键码刚好出现在树根节点处(或附近)，此时只需$O(1)$时间。最坏情况下，规模为$n$的二叉搜索树深度可能达到$\Omega(n)$,比如该树退化为一条单链时，此时的查找等效于顺序查找。</p><p>节点的插入和删除操作都需要首先调用查找算法，并根据查找结果确定后续的处理方式，这里以引用的方式传递(子)树根节点。在成功时指向一个关键码为e且真实存在的节点，失败时，指向最后一次试图转向的空节点<code>null</code>。对于后一情况，可假想地将此节点转换为一个数值为e的哨兵节点，如此，无论命中与否，查找的返回值均等效地指向命中节点,而<code>hot</code>总是指向命中节点的父亲。</p><blockquote><p>无论树的具体形态如何，查找必然有n种成功情况和n+1种失败情况</p></blockquote><p>通过对树高数学归纳可以证明。</p><p>假设原有二叉树度数为0、1、2的节点，各有$n_0$,$n_1$,$n_2$个。</p><p>在原有二叉搜索树的基础上，引入$n_1+2n_0$个外部节点，可使原有节点度数统一为2，如此，即可将任一二叉搜索树T转化为一棵真二叉树T’。s设T’度数为0、1、2的节点，分别为$n’_0,n’_1,n’_2$。查找失败的情况必定对应于外部节点。</p><p>由树的性质，有$e’=n’-1=n’_1+2n’_2$</p><p>$n’=n’_0+n_1+n’_2=1+2n_1+n_2$</p><p>此时所有节点均为二度节点，则$n’_1=0$</p><p>$n’_0=n’_2+1$</p><p>注意到此时的零度节点数量即等于引入的外部节点，即$n’_0=n_1+2n_0$</p><p>二度节点即为原来的节点总数$n’_2=n_0+n_1+n_2=n$</p><p>即$n’_0=n+1$,查找失败的情况总数即是外部节点的数目。</p><p>查找成功的情况总数即是二叉搜索树的节点总数$n$,得证。</p><h2 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h2><p>为了在二叉搜索树中插入一个顶点，首先需要利用查找算法<code>search()</code> 确定插入的位置和方式，然后才能将新节点作为叶子插入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入BST树中</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标不存在（留意对_hot的设置）</span></span><br><span class="line">   x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot ); <span class="comment">//创建新节点x：以e为关键码，以_hot为父</span></span><br><span class="line">   _size++; <span class="comment">//更新全树规模</span></span><br><span class="line">   updateHeightAbove ( x ); <span class="comment">//更新x及其历代祖先的高度</span></span><br><span class="line">   <span class="keyword">return</span> x; <span class="comment">//新插入的节点，必为叶子</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span></span><br></pre></td></tr></table></figure><p>这里需要注意，在创建新节点$x$的时候，只是指定了父亲为$hot$，并没有指定$hot$的左孩子还是右孩子为$x$。在前一步的<code>search</code>过程中，返回了命中节点的引用，通过对$x$的赋值来连接父子节点，同时也将$x$接入树中。</p><p>插入操作必定在叶节点处，同样取决于节点的深度，在最坏情况下不超过全树的高度，即最深的叶子的深度。</p><blockquote><p>在二叉树树中插入节点v之后，除v的历代祖先外，其余节点的高度无需更新</p></blockquote><p>节点的高度仅取决于其后代，更确切地，是该节点与其最深后代之间的距离。因此在插入节点$v$之后，节点$a$的高度可能发生变化，当且仅当$v$是$a$的后代，或反过来等价地，a是v的祖先。</p><blockquote><p>祖先高度不会降低，但是至多加一</p></blockquote><p>插入节点$v$之后，所有节点的后代集不至缩小。高度取决于后代深度的最大值，故不至于下降。<br>另外一方面，假定节点$a$的高度由$h$增加至$h’$。若将$v$的父节点记作$p$,则$a$到$p$的距离不大于$a$在此之前的高度，于是必有：</p><p>$h’ \leq |ap|+1 \leq h+1$</p><blockquote><p>一旦某个祖先高度不变，则更高的祖先高度也必然高度不变</p></blockquote><p>对于任意节点$p$，若将其左、右孩子分别记作$l$和$r$(可能为空)，则必有：</p><p>$height(p)=1+max(height(l),height(r))$</p><p>在插入节点$v$之后，在$l$和$r$之间，至多其一可能会(作为$v$的祖先)有所变化。一旦该节点的高度不变，$p$以及更高层祖先(如果存在的话)的高度亦保持不变。</p><h2 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h2><p><strong>单分支情况</strong></p><p>若节点x的某一子树为空，则可将其替换为另一棵子树(可能亦为空)，如此操作后，二叉搜索树的拓扑结构依然完整，顺序性同样满足。</p><p><strong>双分支情况</strong></p><p>l除了更新全树规模和释放被摘除节点外，此时也要更新一系列祖先高度，首个需要更新的祖先恰好为<code>hot</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BST&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从BST树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   removeAt ( x, _hot ); _size--; <span class="comment">//实施删除</span></span><br><span class="line">   updateHeightAbove ( _hot ); <span class="comment">//更新_hot及其历代祖先的高度</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">//删除成功与否，由返回值指示</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">removeAt</span> <span class="params">( BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot )</span> </span>&#123;</span><br><span class="line">   BinNodePosi(T) w = x; <span class="comment">//实际被摘除的节点，初值同x</span></span><br><span class="line">   BinNodePosi(T) succ = <span class="literal">NULL</span>; <span class="comment">//实际被删除节点的接替者</span></span><br><span class="line">   <span class="keyword">if</span> ( !HasLChild ( *x ) ) <span class="comment">//若*x的左子树为空，则可</span></span><br><span class="line">      succ = x = x-&gt;rc; <span class="comment">//直接将*x替换为其右子树</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( !HasRChild ( *x ) ) <span class="comment">//若右子树为空，则可</span></span><br><span class="line">      succ = x = x-&gt;lc; <span class="comment">//对称地处理——注意：此时succ != NULL</span></span><br><span class="line">   <span class="keyword">else</span> &#123; <span class="comment">//若左右子树均存在，则选择x的直接后继作为实际被摘除节点，为此需要</span></span><br><span class="line">      w = w-&gt;succ(); <span class="comment">//（在右子树中）找到*x的直接后继*w</span></span><br><span class="line">      swap ( x-&gt;data, w-&gt;data ); <span class="comment">//交换*x和*w的数据元素</span></span><br><span class="line">      BinNodePosi(T) u = w-&gt;parent;</span><br><span class="line">      ( ( u == x ) ? u-&gt;rc : u-&gt;lc ) = succ = w-&gt;rc; <span class="comment">//隔离节点*w</span></span><br><span class="line">   &#125;</span><br><span class="line">   hot = w-&gt;parent; <span class="comment">//记录实际被删除节点的父亲</span></span><br><span class="line">   <span class="keyword">if</span> ( succ ) succ-&gt;parent = hot; <span class="comment">//并将被删除节点的接替者与hot相联</span></span><br><span class="line">   release ( w-&gt;data ); release ( w ); <span class="keyword">return</span> succ; <span class="comment">//释放被摘除节点，返回接替者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法操作所需的时间主要消耗于对<code>search()</code>，<code>succ()</code>，<code>updateHeightAbove()</code>的调用。在树的任意高度，它们至多消耗$O(1)$时间，故总体的渐进时间复杂度亦不超过全树的高度。</p><blockquote><p>从二叉搜索树中删除节点，若实际被删除的节点为x,则此后除x的历代祖先外，其余节点的高度无需更新</p></blockquote><p>节点的高度仅取决于其后代，更确切地，是该节点与其最深后代之间的距离。因此在插入节点v之后，节点a的高度可能发生变化，当且仅当v是a的后代，或反过来等价地，a是v的祖先。</p><blockquote><p>祖先高度不会降低，但是至多减一</p></blockquote><p>假设在删除节点x之后，祖先节点a的高度由h变化至h’。假想将x重新插回树中，于是自然地，a的高度应该从h恢复至h，由插入的结论，必有：</p><p>$h\leq h’+1$</p><p>亦即$h’ \geq h-1$</p><blockquote><p>一旦某个祖先高度不变，更高的祖先也必然高度不变</p></blockquote><p>反正，假设在删除节点x之后，祖先节点高度会间隔地下降和不变。</p><p>假想将x重新插入树中，所有节点的高度均应复原，而祖先节点的高度则必然间隔地上升和不变，这一结论与之前插入的结论不一致。</p><p>在逐层上行更新祖先高度时，一旦某一祖先的高度不变，便可随即终止。</p><h2 id="期望树高"><a href="#期望树高" class="headerlink" title="期望树高"></a>期望树高</h2><p>BST主要接口<code>search()</code>，<code>insert()</code>，<code>remove()</code>的运行时间在最坏情况下均线性正比于其高度$O(h)$。</p><p>若无法有效控制树高，在最坏情况下，二叉搜索树可能彻底地退化为列表，查找效率降至$O(n)$,线性正比于树(列表)规模。</p><p>以下按照两种常用的随机统计方法对BST的平均性能进行分析</p><p><strong>随机生成</strong></p><p>考察$n$个互异词条${e_1,e_2,..,e_n}$,对任一排列$P=(e_{i1},e_{i2},…,e_{in})$</p><p>从空树开始，反复调用<code>insert()</code>接口将各词条依次插入，得到T</p><p>与随机序列$P$对应的$T$，称由$P$随机生成。</p><p>假定任一排列$P$作为输入的概率均等$1/n!$</p><p>则由$n$个互异词条随机生成的二叉搜索树，平均高度为$\Theta(logn)$</p><p><strong>随机组成</strong></p><p>n个互异节点在遵守顺序性的情况下，可随机确定拓扑联接关系</p><p>如此得到的BST，称由这组节点随机组成。</p><p>由同一节点组成的二叉搜索树不尽相同，但是中序遍历序列必然相同，不妨记作</p><p>$x_0$,$x_1$,$x_2$,…,$x_{k-1}$,$x_k$,$x_{k+1}$,$x_{k+2}$,…,$x_{n-1}$</p><p>根据所选树根节点的不同，所有搜索树分为$n$类，对于其中以$x_{k}$为根者而言，左、右子树必然分别由{$x_0$,$x_1$,$x_2$,…,$x_{k-1}$}和{$x_{k+1}$,$x_{k+2}$,…,$x_{n-1}$}组成。</p><p>如此，可得边界条件和递推式如下：</p><p>$T(0)=T(1)=1$</p><p>由$n$个互异节点组随机组成的BST，若共计$T(n)$棵，则有<br>$$<br>T(n)=\sum_{k=1}^{n-1} T(k-1)T(n-k)=catalan(n)=\frac{(2n)!}{n!(n+1)!}<br>$$<br>假定所有BST等概率出现，则其平均高度为$\Theta(\sqrt n)$</p><p>在随机生成的统计方法中，越低的BST被统计多次，故过于乐观。理想随机在实际中并不常见，关键码往往按单调甚至线性的次序出现，极高的BST频繁出现不足为奇。</p><blockquote><p>在目标节点同时拥有左右子树的时候，总是固定选取直接后继与之交换，从二叉树的整个生命周期来看，左子树将越来越倾向于高于右子树，从而加剧整体的不平衡性</p></blockquote><p>一种简捷的策略为除直接后继外还考虑直接前驱，并在二者之间随机选取。</p><h1 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h1><p>二叉搜索树的性能主要取决于树高，故在节点数目固定时应尽可能地降低高度。</p><p>节点数目固定时，兄弟子树的高度越接近(平衡)，全树也倾向于更低。</p><p>若高度为$h$的二叉树共含$n$个节点，则必有：</p><p>$n\leq 2^{h+1}-1$<br>这里的等号成立，当且仅当是满树。于是有：</p><p>$h \geq log_2(n+1)-1 $</p><p>$h \geq \lceil log_2{n+1} \rceil-1=\lfloor log_2n \rfloor$</p><p>恰好为$\lfloor log_2n \rfloor$时，称作理想平衡。大致相当于完全树甚至满树：叶节点只能出现在最底部的两层。完全二叉树的限制过于苛刻相对二叉树所有可能的形态，此类二叉树所占比例极低，而随着二叉树规模的增大，这一规模还将继续锐减。所以对标准适度放松，依照某种相对宽松的标准，重新定义二叉搜索树的平衡性。</p><p>高度在渐进意义上不超过$O(logn)$，故可称作适度平衡。适度平衡的BST，称作平衡二叉搜索树。</p><h2 id="等价变换"><a href="#等价变换" class="headerlink" title="等价变换"></a>等价变换</h2><p>若两棵二叉树的中序遍历序列相同，则称它们彼此等价。</p><p><strong>上下可变</strong></p><p>联接关系不同，承袭关系可能颠倒</p><p><strong>左右不乱</strong></p><p>中序遍历序列完全一致，全局单调非降</p><p>各种平衡二叉搜索树(BBST)可视为BST的某一子集，相应地满足限制条件。除了适度平衡性，还具有如下局部性：</p><ul><li>单次动态修改操作后，至多$O(logn)$处局部不再满足限制条件</li><li>可在$O(logn)$时间内，使这些局部(以至全树)重新满足</li></ul><p>刚刚失去平衡的二叉搜索树，必然可以迅速转换为一棵等价的平衡二叉搜索树。等价二叉搜索树之间的上述转换过程，也称作等价变换。</p><h2 id="旋转调整"><a href="#旋转调整" class="headerlink" title="旋转调整"></a>旋转调整</h2><p>修复局部失衡的最基本手段，就是通过围绕特定节点的旋转，实现等价前提下的拓扑调整。</p><p>设$c$和$Z$是$v$左孩子、右子树，$X$和$Y$是$c$的左、右子树。以$v$为轴的zig旋转，如图所示，重新调整这两个节点和三棵子树之间的关系，将$X$和$v$作为$c$的左子树、右孩子，$Y$和$Z$分别作为$v$的左、右子树。</p><p>对称地，设$X$和$c$是$v$左子树、右孩子，$Y$和$Z$是$c$的左、右子树。以$v$为轴的zig旋转，如图所示，重新调整这两个节点和三棵子树之间的关系，将$X$和$Y$作为$v$的左子树、右子树，$v$和$Z$分别作为$c$的左孩子、右子树。</p><p>zig和zag均属于局部操作，旋转以后中序遍历序列依然不变，故均为等价变换。旋转操作仅涉及常数顶点及其之间的联接关系，故均可在常数时间内完成。</p><p><img src="https://i.loli.net/2019/09/05/frTd2gO7DXhIPZU.png"></p><p>调整之后，$v/c$深度加/减1，子(全)树高度的变化幅度，上下不超过1。实际上，经过不超过$O(n)$次旋转，等价的BST均可相互转化。</p><blockquote><p>规模为n的任何二叉搜索树，经过不超过n-1次旋转调整，都可等价变换为仅含左分支的二叉搜索树，即最左侧通路</p></blockquote><p><strong>任一节点需要通过一次旋转归入最左侧通路，当且仅当它最初不在最左侧通路上。</strong></p><p>故原最左侧通路的长度为$s$，则上述算法所做的旋转调整，恰好共计$n-s-1$次。</p><p>特别地，$s=0$(根节点的左子树为空),当且仅当需做$n-1$次旋转。</p><p>考查二叉搜索树的最左侧通路，从该通路的末端节点$L_d$开始，逐步迭代地延长该路径，直至不能延长。每次迭代，无非两种情况：</p><ul><li>若$L_k$的右子树为空，则可令$L_k$上移一层，转至其父节点</li><li>若$L_k$的右孩子$R_k$存在，则可以以当前$L_k$为轴，做一次zag旋转调整，如此，$R_k$将作为$L_k$的父亲纳入最左侧通路中。</li></ul><p>整个迭代过程的不变性为：</p><ul><li>当前$L_k$来自最左侧通路</li><li>$L_k$的左子树(由不大于$L_k$的所有节点组成)已不含任何右向分支</li></ul><p>另外，整个迭代过程也满足如下单调性：</p><p><strong>最左侧通路的长度，严格单调增加</strong></p><p>故该算法必然终止，且所得的二叉搜索树已不含任何右向分支。</p><p>以上思路具体实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过zag旋转调整，将BST子树x拉伸成最左侧通路</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">stretchByZag</span> <span class="params">( BinNodePosi(T) &amp; x )</span> </span>&#123;</span><br><span class="line">   BinNodePosi(T) p = x; <span class="keyword">while</span> ( p-&gt;rc ) p = p-&gt;rc; <span class="comment">//最大节点，必是子树最终的根</span></span><br><span class="line">   <span class="keyword">while</span> ( x-&gt;lc ) x = x-&gt;lc; <span class="comment">//转至初始最左侧通路的末端</span></span><br><span class="line">   <span class="keyword">for</span> ( ; x != p; x = x-&gt;parent ) &#123; <span class="comment">//若x右子树已空，则上升一层</span></span><br><span class="line">       <span class="keyword">while</span> ( x-&gt;rc ) <span class="comment">//否则，反复地</span></span><br><span class="line">       x-&gt;zag(); <span class="comment">//以x为轴做zag旋转</span></span><br><span class="line">      &#125; <span class="comment">//直到抵达子树的根</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可见，每做一次zag旋转，总有一个节点归入最左侧通路中，后者的长度也同时加一。最坏情况下，除原根节点外，其余节点均各自对应于一次旋转，累计不过n-1次。</p><p>由以上结论推广可知：</p><p><strong>规模为n的任何两棵等价二叉搜索树，至多经过2n-2次旋转，即可彼此转换。</strong></p><h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>通过合理设定适度平衡的标准，并借助以上等价变换，AVL树可实现近似理想的平衡。在渐进意义上，AVL树可始终将其高度控制在$O(logn)$以内，从而保证每次查找、插入或删除操作均可在$O(logn)$时间内完成。</p><p>任一节点的平衡因子定义为其左、右子树的高度差，即</p><p>$balFac(v)=height(lc(v))=height(rc(v))$</p><p>空树高度取-1，单节点子树(叶节点)高度取0。</p><p>AVL树，即平衡因子受限的二叉搜索树，其中各节点平衡因子的绝对值均不超过1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define Balanced(x) ( stature( (x).lc ) &#x3D;&#x3D; stature( (x).rc ) ) &#x2F;&#x2F;理想平衡条件</span><br><span class="line">#define BalFac(x) ( stature( (x).lc ) - stature( (x).rc ) ) &#x2F;&#x2F;平衡因子</span><br><span class="line">#define AvlBalanced(x) ( ( -2 &lt; BalFac(x) ) &amp;&amp; ( BalFac(x) &lt; 2 ) ) &#x2F;&#x2F;AVL平衡条件</span><br></pre></td></tr></table></figure><blockquote><p>高度为$h$的AVL树至少包含$S(h)=fib(n+3)-1$个节点。</p></blockquote><p>固定高度$h$，考查节点最少的AVL树</p><p>将这一最小规模记作$S(h)$</p><p>$S(h)=1+S(h-1)+S(h-2)$<br>$S(h)+1=[S(h-1)+1]+[S(h-2)+1]$</p><p>当$h$等于0时，T中至少有1个节点，$S(0)+1=fib(3)$</p><p>递推关系为$fib(h+3)=fib(n+2)+fib(n+2)$</p><p>反过来，由$n$个节点构成的AVL树，高度至多为$O(logn)$。</p><p>按照BST规则动态操作之后，AVL的平衡性可能破坏</p><ul><li>插入：从祖父开始，每个祖先都有可能失衡，且可能同时失衡</li><li>删除：从父亲开始，每个祖先都有可能失衡，但至多一个</li></ul><p>通过旋转等价变换恢复平衡，累计操作不过$O(logn)$。</p><h2 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h2><p>插入节点$x$之后，可能有多个失衡节点。插入操作必定位于叶节点处，叶节点的父亲必不失衡，故失衡节点中最低者$g$不低于$x$祖父。</p><p>在$x$和$g(x)$的通路上，设$p$为$g(x)$的孩子，$v$为$p$的孩子。$g(x)$是由于$x$的引入而失衡，则$p$和$v$的高度均不会低于各自的兄弟。因此可通过以下宏定义由$g(x)$找到$p$和$v$。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define tallerChild(x) ( \</span><br><span class="line">   stature( (x)-&gt;lc ) &gt; stature( (x)-&gt;rc ) ? (x)-&gt;lc : ( &#x2F;*左高*&#x2F; \</span><br><span class="line">   stature( (x)-&gt;lc ) &lt; stature( (x)-&gt;rc ) ? (x)-&gt;rc : ( &#x2F;*右高*&#x2F; \</span><br><span class="line">   IsLChild( * (x) ) ? (x)-&gt;lc : (x)-&gt;rc &#x2F;*等高：与父亲x同侧者（zIg-zIg或zAg-zAg）优先*&#x2F; \</span><br><span class="line">   ) \</span><br><span class="line">   ) \</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里通过比较子树的高度直接计算。失衡节点的恢复方案取决于节点$g(x)$、$p$、$v$之间具体的联接方向。</p><p><strong>单旋</strong></p><p>不妨设$p$是$g$的右孩子，$c$是$p$的右孩子。在这种情况下，必定是子树$v$中插入节点$x$，而使$g(x)$不再平衡。逆时针旋转<code>zag(g(x))</code>，$g(x)$必将恢复平衡。对称情况可由<code>zig(g(x))</code>恢复平衡。</p><p><img src="https://i.loli.net/2019/09/05/OgtlCb9r2SEGB3s.png"></p><p><strong>双旋</strong></p><p>不妨设节点$v$是$p$的左孩子，而$p$是$g(x)$的右孩子。在这种情况下，必定是在子树$v$中插入了新节点$x$，而致使$g(x)$不再平衡。先顺时针旋转<code>zig(p)</code>，再<code>zag(g(x))</code>，$g(x)$必将恢复平衡。</p><p><img src="https://i.loli.net/2019/09/05/Er2TLX4YKDyC3hu.png"></p><p>经过局部调整后，局部子树高度也必将复原，$g(x$)以上所有祖先的平衡因子亦将统一地复原。在AVL树中插入新节点后，仅需不超过两次旋转即可使整树恢复平衡。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) AVL&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入AVL树中</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标节点不存在</span></span><br><span class="line">   BinNodePosi(T) xx = x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot ); _size++; <span class="comment">//创建新节点x</span></span><br><span class="line"><span class="comment">// 此时，x的父亲_hot若增高，则其祖父有可能失衡</span></span><br><span class="line">   <span class="keyword">for</span> ( BinNodePosi(T) g = _hot; g; g = g-&gt;parent ) &#123; <span class="comment">//从x之父出发向上，逐层检查各代祖先g</span></span><br><span class="line">      <span class="keyword">if</span> ( !AvlBalanced ( *g ) ) &#123; <span class="comment">//一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将子树</span></span><br><span class="line">         FromParentTo ( *g ) = rotateAt ( tallerChild ( tallerChild ( g ) ) ); <span class="comment">//重新接入原树</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//g复衡后，局部子树高度必然复原；其祖先亦必如此，故调整随即结束</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//否则（g依然平衡），只需简单地</span></span><br><span class="line">         updateHeight ( g ); <span class="comment">//更新其高度（注意：即便g未失衡，高度亦可能增加）</span></span><br><span class="line">   &#125; <span class="comment">//至多只需一次调整；若果真做过调整，则全树高度必然复原</span></span><br><span class="line">   <span class="keyword">return</span> xx; <span class="comment">//返回新节点位置</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，总有AVL::insert(e)-&gt;data == e</span></span><br></pre></td></tr></table></figure><p>在AVL树中引入一个节点后，失衡的节点可能多达$\Omega(logn)$个。</p><h2 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h2><p>同时至多一个失衡节点，首个可能就是$x$的父亲$hot$</p><p>在不包含$x$的一侧，必有一个非空孩子$p$，且$p$的孩子至少为1。于是，可按以下规则从$p$的两个孩子中选出节点$v$</p><ul><li>若两个孩子不等高，则$v$取作其中更高者</li><li>否则，优先取与$v$与$p$同向者</li></ul><p><strong>单旋</strong></p><p>在$T_{3}$中删除了节点而使$g(x)$不再平衡，但$p$的平衡因子非负时，通过以g(x)为轴顺时针旋转一次可恢复局部的平衡。</p><p><img src="https://i.loli.net/2019/09/05/56Jglbcdf1XWQNI.png"></p><p><strong>双旋</strong></p><p>若$g(x)$失衡时$p$的平衡因子为-1，则经过以$p$为轴的一次逆时针旋转和以$g(x)$为轴顺时针旋转时可恢复局部平衡。</p><p><img src="https://i.loli.net/2019/09/05/o7CGOzSfMXla3Ji.png"></p><p><strong>失衡传播</strong></p><p>在删除节点后，通过单旋或双旋调整使局部子树恢复平衡，但是恢复平衡后，子树的高度未必可以复原，可能再次失衡。</p><p>设$g(x)$复衡后，局部子树的高度的确降低。此时，若$g(x)$原本属于某一更高祖先的更短分支，则因为该分支的进一步缩短，从而致使该祖先失衡，称作失衡传播。失衡传播的方向必然为自底而上，而不至于影响到后代节点。在此过程的任一时刻，至多只有一个失衡的节点；高层的某一节点由平衡转为失衡只可能发生在下层失衡节点恢复平衡之后。因此，可沿<code>parent</code>指针遍历所有祖先，每找到一个失衡的祖先节点，即可套用以上算法使之恢复平衡。</p><p>在AVL树中摘除一个节点后，刚刚通过调整使$g(x)$恢复了平衡，此时，若发现$g(x)$原先的父节点依然平衡，在更高层仍可能有失衡的祖先，仅仅通过平衡性不足以确定可否终止自底而上的重平衡过程，转而核对重平衡后节点的高度可判断是否可以立即终止上溯过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> AVL&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从AVL树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   removeAt ( x, _hot ); _size--; <span class="comment">//先按BST规则删除之（此后，原节点之父_hot及其祖先均可能失衡）</span></span><br><span class="line">   <span class="keyword">for</span> ( BinNodePosi(T) g = _hot; g; g = g-&gt;parent ) &#123; <span class="comment">//从_hot出发向上，逐层检查各代祖先g</span></span><br><span class="line">      <span class="keyword">if</span> ( !AvlBalanced ( *g ) ) <span class="comment">//一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将该子树联至</span></span><br><span class="line">         g = FromParentTo ( *g ) = rotateAt ( tallerChild ( tallerChild ( g ) ) ); <span class="comment">//原父亲</span></span><br><span class="line">      updateHeight ( g ); <span class="comment">//并更新其高度（注意：即便g未失衡，高度亦可能降低）</span></span><br><span class="line">   &#125; <span class="comment">//可能需做Omega(logn)次调整——无论是否做过调整，全树高度均可能降低</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//删除成功</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure><blockquote><p>在AVL树中摘除一个节点后，失衡的节点至多一个</p></blockquote><p>节点的平衡与否取决于其左、右子树之差。因此反过来，只要子树的高度不变，则节点不可能失衡。</p><p>在删除节点以后自底而上逐层核对平衡因子的过程中，一旦遇到一个失衡节点$v$，则被删除的节点必然来自$v$原来更低的一棵子树，而$v$的高度必然由其另一更高的子树确定，故$v$的高度必然保持不变。由此可知，其祖先节点必然不可能失衡。</p><blockquote><p>在高度为h的AVL树中，任一叶节点的深度均不小于$\lfloor h/2 \rfloor$</p></blockquote><p>对树高做数学归纳。作为归纳基时，$h=1$的情况显然。假设以上命题对高度小于$h$的AVL树均成立。</p><p>根据AVL树的性质，此时左、右子树的高度至多为$h-1$，至少为$h-2$。</p><p>由归纳假设，在高度为$h-1$的子树内部，叶节点的深度不小于$\lceil (h-1)/2 \rceil \geq \lceil h/2 \rceil -1$ </p><p>而在高度为$h-2$的子树内部，叶节点的深度也不小于$ \lceil h/2 \rceil -1$ </p><p>因此在全树中，任何叶节点深度都不至小于</p><p>$ 1+(\lceil h/2 \rceil -1)=\lceil h/2 \rceil$ </p><p>对于任意大的正整数都存在一棵规模为$n$的AVL树，从中删除某一特定节点后的确需要做$\Omega(logn)$次旋转方能使全树恢复平衡。</p><blockquote><p>knuth指出，remove()操作尽管在最坏情况下需做$\Omega(logn)$次旋转，但平均而言仅需0.21次</p></blockquote><p>设在AVL树中摘除一个节点后，刚刚通过调整使g(x)恢复了平衡。此时若发现g(x)原来的父节点恢复了平衡，仍然需要检查更高层的祖先。</p><p>仅仅通过平衡性，并不足以确定可否及时终止自底而上的重平衡过程。转而核对重平衡后节点的高度，即可及时判断是否可以立即停止上溯过程。</p><p>AVL的插入操作，可以在首次重平衡后随即终止上溯，原因在于此时不仅局部子树的平衡性能够恢复，而且局部子树的高度亦必然同时恢复。</p><h2 id="统一重平衡算法"><a href="#统一重平衡算法" class="headerlink" title="统一重平衡算法"></a>统一重平衡算法</h2><p>从刚发生失衡的节点$x$出发逆行而上，直至遇到最低的失衡节点$g(x)$。于是在$g(x)$的更高一侧的子树内，其孩节点$p$和孙节点$v$必然存在，这一局部可以$g(x)$，$p$，$v$为界，分为四棵子树。按照中序遍历序列再重新排序$g(x)$和$p$,$v$，分别命名为$a$,$b$,$c$。观察之前的例子，可以发现四7棵子树的高度彼此相差不过一层，所以将这四棵树重新组装起来恰好即是一棵AVL树。</p><p><img src="https://i.loli.net/2019/09/05/iwsFpGeAUv6aLVx.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::connect34 (</span><br><span class="line">   BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c,</span><br><span class="line">   BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, BinNodePosi(T) T3</span><br><span class="line">) &#123;</span><br><span class="line">   <span class="comment">//*DSA*/print(a); print(b); print(c); printf(&quot;\n&quot;);</span></span><br><span class="line">   a-&gt;lc = T0; <span class="keyword">if</span> ( T0 ) T0-&gt;parent = a;</span><br><span class="line">   a-&gt;rc = T1; <span class="keyword">if</span> ( T1 ) T1-&gt;parent = a; updateHeight ( a );</span><br><span class="line">   c-&gt;lc = T2; <span class="keyword">if</span> ( T2 ) T2-&gt;parent = c;</span><br><span class="line">   c-&gt;rc = T3; <span class="keyword">if</span> ( T3 ) T3-&gt;parent = c; updateHeight ( c );</span><br><span class="line">   b-&gt;lc = a; a-&gt;parent = b;</span><br><span class="line">   b-&gt;rc = c; c-&gt;parent = b; updateHeight ( b );</span><br><span class="line">   <span class="keyword">return</span> b; <span class="comment">//该子树新的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::rotateAt ( BinNodePosi(T) v ) &#123; <span class="comment">//v为非空孙辈节点</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="keyword">if</span> ( !v ) &#123; <span class="built_in">printf</span> ( <span class="string">&quot;\a\nFail to rotate a null node\n&quot;</span> ); <span class="built_in">exit</span> ( <span class="number">-1</span> ); &#125;</span><br><span class="line">   BinNodePosi(T) p = v-&gt;parent; BinNodePosi(T) g = p-&gt;parent; <span class="comment">//视v、p和g相对位置分四种情况</span></span><br><span class="line">   <span class="keyword">if</span> ( IsLChild ( *p ) ) <span class="comment">/* zig */</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *v ) ) &#123; <span class="comment">/* zig-zig */</span> </span><br><span class="line">         p-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( v, p, g, v-&gt;lc, v-&gt;rc, p-&gt;rc, g-&gt;rc );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">/* zig-zag */</span>  </span><br><span class="line">         v-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( p, v, g, p-&gt;lc, v-&gt;lc, v-&gt;rc, g-&gt;rc );</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span>  <span class="comment">/* zag */</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRChild ( *v ) ) &#123; <span class="comment">/* zag-zag */</span> </span><br><span class="line">         p-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( g, p, v, g-&gt;lc, p-&gt;lc, v-&gt;lc, v-&gt;rc );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">/* zag-zig */</span>  </span><br><span class="line">         v-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( g, v, p, g-&gt;lc, v-&gt;lc, v-&gt;rc, p-&gt;rc );</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;任何词条之间可相互比较大小是有序向量得以定义，以及二分查找赖以成立的基本前提。通过对二分查找策略的抽象和推广，定义和实现二叉搜索树结构。二叉搜索树有诸多变种，各具特色，各有所长，也有各自适用范围。为有效控制树高，二叉树的性能主要取决于树高，故应在节点数目一定的情况下尽可能地减小树高，相应地，尽可能使兄弟子树地高度彼此接近，即全树尽可能地平衡。平衡二叉搜索树通过对树中每一局部增加某种性质来保证二叉树的适度平衡性。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>图</title>
    <link href="http://twinkle0331.github.io/algorithm/graph/"/>
    <id>http://twinkle0331.github.io/algorithm/graph/</id>
    <published>2019-09-03T01:00:25.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>在城市交通图中联接于各公交站之间的街道，或者在互联网中联接于IP之间的二元关系，这类信息往往可表述为定义于一组对象之间的二元关系。相互之间均可能存在二元关系的一组对象，属于非线性结构。图结构是描述这类信息的典型结构，通过遍历将其转化为半线性结构，进而借助树的相关算法解决问题。</p><a id="more"></a><p>所谓的图，可定义为$G=(V;E)$,其中，集合V中的元素称作顶点，集合E中的元素分别对应于$V$中的某一对顶点，表示它们之间存在某种关系，故亦称作边。同一条边的两个顶点彼此邻接，同一顶点自我邻接，构成自环，不含自环即为简单图。</p><p>若邻接顶点$u$和$v$的次序无所谓，则$(u,v)$为无向边。所有边均无方向的图称为无向图。</p><p>有向边$(u,v)$从$u$指向$v$，其中$u$称作该边的起点，而v称作该边的终点。</p><p>图$G(V;E)$的子图$T=(V;F)$若是树，则为其支撑树。同一图的支撑树通常并不唯一。同一网络的支撑树中，总权重最小者为最小支撑树MST。</p><h1 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h1><p>用二维矩阵记录顶点之间的联接关系，一一对应：矩阵元素对应图中可能存在的边。<br>$$<br>A[i,j]=\left{<br>\begin{aligned}<br>1 ,&amp; 若顶点i与j之间存在联边 \<br>0 ,&amp;  若顶点i与j之间不存在联边\<br>\end{aligned}<br>\right.<br>$$<br>由于为简单图，所以对角线统一设置为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span> <span class="comment">//顶点对象（为简化起见，并未严格封装）</span></span><br><span class="line">   Tv data; <span class="keyword">int</span> inDegree, outDegree; VStatus status; <span class="comment">//数据、出入度数、状态</span></span><br><span class="line">   <span class="keyword">int</span> dTime, fTime; <span class="comment">//时间标签</span></span><br><span class="line">   <span class="keyword">int</span> parent; <span class="keyword">int</span> priority; <span class="comment">//在遍历树中的父节点、优先级数</span></span><br><span class="line">   Vertex ( Tv <span class="keyword">const</span>&amp; d = ( Tv ) <span class="number">0</span> ) : <span class="comment">//构造新顶点</span></span><br><span class="line">      data ( d ), inDegree ( <span class="number">0</span> ), outDegree ( <span class="number">0</span> ), status ( UNDISCOVERED ),</span><br><span class="line">      dTime ( <span class="number">-1</span> ), fTime ( <span class="number">-1</span> ), parent ( <span class="number">-1</span> ), priority ( INT_MAX ) &#123;&#125; <span class="comment">//暂不考虑权重溢出</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> UNDISCOVERED, DISCOVERED, VISITED &#125; VStatus; <span class="comment">//顶点状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125; EType; <span class="comment">//边在遍历树中所属的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="comment">//边对象（为简化起见，并未严格封装）</span></span><br><span class="line">   Te data; <span class="keyword">int</span> weight; EType type; <span class="comment">//数据、权重、类型</span></span><br><span class="line">   Edge ( Te <span class="keyword">const</span>&amp; d, <span class="keyword">int</span> w ) : data ( d ), weight ( w ), type ( UNDETERMINED ) &#123;&#125; <span class="comment">//构造</span></span><br><span class="line">&#125;;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//顶点类型、边类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphMatrix</span> :</span> <span class="keyword">public</span> Graph&lt;Tv, Te&gt; &#123; <span class="comment">//基于向量，以邻接矩阵形式实现的图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Vector&lt; Vertex&lt; Tv &gt; &gt; V; <span class="comment">//顶点集（向量）</span></span><br><span class="line">   Vector&lt; Vector&lt; Edge&lt; Te &gt; * &gt; &gt; E; <span class="comment">//边集（邻接矩阵）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   GraphMatrix() &#123; n = e = <span class="number">0</span>; &#125; <span class="comment">//构造</span></span><br><span class="line">   ~GraphMatrix() &#123; <span class="comment">//析构</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有动态创建的</span></span><br><span class="line">         <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++ ) <span class="comment">//边记录</span></span><br><span class="line">            <span class="keyword">delete</span> E[j][k]; <span class="comment">//逐条清除</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>适用范围广泛，尤其适用于稠密图，可处理隐式图。</p><h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><table><thead><tr><th>判断两点之间是否存在联边</th><th>$O(1)$</th></tr></thead><tbody><tr><td>获取顶点的出/入度数</td><td>$O(1)$</td></tr><tr><td>添加、删除边后更新度数</td><td>$O(1)$</td></tr></tbody></table><p>由于向量循秩访问的特点，所有静态操作接口，均只需常数时间。边的静态操作和动态操作也只需常数时间，代价是邻接矩阵的空间冗余。但是顶点的动态操作非常耗时，为了插入新的顶点，顶点集向量需添加一个元素，边集向量也需要添加一行，且每行都需要添加一个元素。</p><blockquote><p>计入向量扩容所需的时间，分摊而言，插入顶点的复杂度不超过$O(n)$</p></blockquote><p>每一向量扩容的单次插入操作，在分摊意义上来说为常数时间，在每一顶点插入过程中，n个向量的操作(包括扩容操作)完全同步，故总体的分摊时间不超过分摊的$O(n)$</p><p>当然，为了插入一个顶点，在最坏情况下需要访问和修改整个邻接矩阵，共需$O(n^2)$时间。</p><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度为$O(n^2)$,与实际边数无关。</p><p>对于无向图，可将二维邻接矩阵映射为一维向量，空间复杂度为之前的一半，渐进意义而言，空间复杂度仍然为$O(n^2)$。</p><p><strong>关联矩阵</strong></p><p>用二维矩阵记录顶点与边之间的联接关系，空间复杂度为$O(ne)=O(n^3)$<br>$$<br>I[i,j]=\left{<br>\begin{aligned}<br>1 ,&amp; 第j条边从第i个节点出发 \<br>-1,&amp; 第j条边进入第i个节点 \<br>0 , &amp; 否则<br>\end{aligned}<br>\right.<br>$$<br>基于关联矩阵，可以将差分约束系统转换为有向带权图，将差分约束变量视作顶点，将差分约束矩阵视为关联矩阵，如此一来，原问题转换为了有向带权图的最短路径问题。</p><h1 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h1><p>类似于关联矩阵的思路，将关联矩阵组织的各行组织为列表，只记录存在的边</p><h2 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>有向图=$O(n+e)$</p><p>无向图=$O(n+2e)=O(n+e)$</p><p>无向弧被重复存储，可通过双向链表的方式解决。</p><p>适用于稀疏图</p><h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><table><thead><tr><th>建立邻接表</th><th>$O(n+ e)$</th></tr></thead><tbody><tr><td>枚举从$v$出发的边</td><td>$O(1+deg(v))$</td></tr><tr><td>枚举顶点$v$的邻居(无向图)</td><td>$O(1 + deg(v))$</td></tr><tr><td>枚举到$v$的边</td><td>$O( n+ e)$</td></tr></tbody></table><blockquote><p>计算顶点v的出度/入度</p></blockquote><p>增加度数记录域：$O(n)$记录空间</p><p>增加/删除边时更新度数:$O(1)$时间</p><p>每次查询$O(1)$时间</p><p>建立逆邻接表可将枚举到$v$的边时间复杂度降低至$O(1+deg(v))$,但是空间复杂度有所上升。</p><blockquote><p>给定$u$,$v$，判断$u$,$v$之间是否存在与$u$,$v$相关的边</p></blockquote><p>遍历顶点$i$对应的边表，方可判定是否存在与顶点$j$相关联者，所以所需时间也由$O(1)$增加至$O(deg(i))$</p><p>有向图：搜索$u$的邻接表，$O(deg(u))=O(e)$</p><p>无向图：搜索$u$或$v$的邻接表，$O(max(deg(u),deg(v)))=O(e)$</p><p>并行搜索：$O(2min(deg(u),deg(v)))=O(e)$</p><p>借助散列，边的判定可降低至$O(1)$，空间与邻接表相同。</p><blockquote><p>为什么有时仍用邻接矩阵，仅仅是处理简单？</p></blockquote><p>可处理欧拉路之类的隐式图</p><h1 id="取舍原则"><a href="#取舍原则" class="headerlink" title="取舍原则"></a>取舍原则</h1><p>用邻接矩阵还是邻接表来表示图，取决于以下原则：</p><ul><li>空间/速度</li><li>顶点类型</li><li>弧类型(方向/权值)</li><li>图类型(稠密图)</li></ul><h2 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h2><table><thead><tr><th>邻接矩阵</th><th>邻接表</th></tr></thead><tbody><tr><td>经常检测边的存在</td><td>经常计算顶点的度数</td></tr><tr><td>经常做边的插入/删除</td><td>顶点数目不确定</td></tr><tr><td>图的规模固定</td><td>经常做遍历</td></tr><tr><td>稠密图</td><td>稀疏图</td></tr></tbody></table><p>图的遍历可理解为将非线性结构转化为半线性结构的过程。经遍历确定的边类型中，最重要的一类边为树边，他们与所有顶点共同构成了图的一棵支撑树，称作遍历树。</p><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>在广度优先算法中，越早被访问到的顶点，其邻居越优先被选用，而同一顶点所有邻居之间的优先级反而并不重要。例如，起始于顶点$s$的BFS搜索，首先访问顶点$s$​，再访问$s$所有未访问的邻居，再按后者的次序逐个访问它们的邻居。在所有已访问到的顶点中，仍有邻居尚未访问者，构成所谓的波峰集，于是BFS搜索过程也可等效理解为</p><p><strong>反复从波峰集找到最早被访问的顶点$v$，若其邻居均已访问到，则将其逐出波峰集，否则，随意选出一个尚未访问到的邻居，并将其加入到波峰集中。</strong></p><p>将图的BFS搜索应用于树结构，则其效果等效于树的层次遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//广度优先搜索BFS算法（全图）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::bfs ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">do</span> <span class="comment">//逐一检查所有顶点</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) <span class="comment">//一旦遇到尚未发现的顶点</span></span><br><span class="line">         BFS ( v, clock ); <span class="comment">//即从该顶点出发启动一次BFS</span></span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="comment">//按序号检查，故不漏不重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//广度优先搜索BFS算法（单个连通域）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::BFS ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   Queue&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">//引入辅助队列</span></span><br><span class="line">   status ( v ) = DISCOVERED; Q.enqueue ( v ); <span class="comment">//初始化起点</span></span><br><span class="line">   <span class="keyword">while</span> ( !Q.empty() ) &#123; <span class="comment">//在Q变空之前，不断</span></span><br><span class="line">      <span class="keyword">int</span> v = Q.dequeue(); dTime ( v ) = ++clock; <span class="comment">//取出队首顶点v</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">         <span class="keyword">if</span> ( UNDISCOVERED == status ( u ) ) &#123; <span class="comment">//若u尚未被发现，则</span></span><br><span class="line">            status ( u ) = DISCOVERED; Q.enqueue ( u ); <span class="comment">//发现该顶点</span></span><br><span class="line">            type ( v, u ) = TREE; parent ( u ) = v; <span class="comment">//引入树边拓展支撑树</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若u已被发现，或者甚至已访问完毕，则</span></span><br><span class="line">            type ( v, u ) = CROSS; <span class="comment">//将(v, u)归类于跨边</span></span><br><span class="line">         &#125;</span><br><span class="line">      status ( v ) = VISITED; <span class="comment">//至此，当前顶点访问完毕</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>波峰集中各顶点始终按其在BFS树中的深度在辅助队列中单调排列，且任何时刻同处于辅助队列中的顶点，深度彼此相差不超过一个单位</p></blockquote><p>利用数学归纳法，证明该不变性在每一顶点入队后成立。</p><p>一般地，考查下一入队节点$u$,在BFS树中的深度在入队的同时确定，而就在$u$入队的那一步迭代之前，必有某一顶点$v$刚刚出队，在BFS树中$u$是$v$的孩子，故有：</p><p>$depth(h)=depth(v)+1$</p><p>因此，该不变性在该步迭代之前成立，则在$v$出队、$u$入队后应该继续成立。</p><blockquote><p>所有顶点按照在BFS树中的深度以非降次序接受访问</p></blockquote><p>BFS树是广度优先搜索的过程中自下而上逐层形成的，各顶点也是以其在树中的深度为序逐个被发现的，反过来，对原图的广度优先搜索过程，完全等同于对BFS树的层次遍历过程。</p><p>由原图各边所联接的每一对顶点，在BFS树中的深度相差至多不超过一个单位，其中特别地，由树边联接的顶点，在BFS树中的深度之差恰好为1。</p><blockquote><p>所有顶点按其到$s$的距离，以非降次序接受访问</p></blockquote><p>每一顶点到$s$的距离均等于在BFS树中的深度，也可以理解为bfs从s到v的路径，即为二者在原图中的最短通路。</p><p>反证法，假设至少有一个顶点不满足这个性质，考查此类顶点中$\pi()$值最小者u</p><p>既然在BFS树(原图的子图)中，已有一条长度为depth(v)的通路联接于顶点s和u之间(树depth的定义)。</p><p>故必然有$\pi(u) \leq depth(u)$</p><p>因此，不妨假定$\pi(u)&lt;depth(u)$</p><p>在原图中，考查$s$到$u$任何一条最短路径，其长度为$\pi(u)$。显然u不等于s，故u在该通路上的直接前驱节点存在。将次前驱节点记作$v$，则$v$应满足：</p><p>$\pi(v)=\pi(u)-1&lt;\pi(u)$</p><p>否则，可选其余顶点作为前驱节点</p><p>之前假定$u$为其中$\pi()$值最小者，$v$的$\pi()$值比$u$小，故必然满足这一性质</p><p>即得$depth(v)+1&lt;depth(u)$</p><p>然而根据之前的结论，在顶点$v$出队时，作为$v$的邻接顶点之一，$u$必然会在同一步迭代中入队，并同时确定其在BFS树中的深度为：</p><p>$depth(u)=depth(v)+1$</p><p>以上分析对有向图同样使用。</p><p>定义$dist(v,u)$为无向图中，任意顶点之间的最近距离。</p><p>由树边联接的顶点，$dist(s)$恰好相差1；</p><p>由跨边联接的顶点，$dist(s)$至多相差1.</p><blockquote><p>针对有向图和无向图讨论跨边的可能情况</p></blockquote><p>无向图任意一对邻接顶点在BFS树中的深度之差最多为1，因此在经过广度优先搜索后，无向图的各边无非分为两类：</p><ul><li>树边，$u$为<code>discovered</code>,$v$为<code>undiscovered</code>,亦是被BFS树采用的边</li><li>跨边，$u$为<code>discovered</code>,$v$为<code>discovered</code>,($u$和$v$之间存在路径，故$u$必然没有访问结束)亦即联接于来自不同分支、深度相同或最多相差一层的两个顶点之间的边</li></ul><p>有向图中每一条边$(v,u)$均必然满足，</p><p>$depth(u)\leq depth(v)+1$</p><p>这一不等式取等号时，$(v,u)$即是由$v$指向$u$的一条树边。</p><p>若满足：</p><p>$depth(u)=depth(v)$,则$v$和$u$在BFS树中分别属于不同的分支，$(v,u)$跨越于二者之间。</p><p>若满足：</p><p>$depth(u)&lt;depth(v)$</p><p>则在BFS树中,$u$既可能和$v$属于不同的分支，也可能就是$v$的祖先。</p><p>在有向边中还可能$u$处于<code>visited</code>,$v$处于<code>discovered</code>。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>$BFS(v)$以$v$为根，生成一棵BFS树，$n$个节点,$c$棵树，则有$n-c$条树边，故生成BFS森林包括$c$棵树，$n-c$条树边，$e-n+c$条跨边。</p><p><strong>联通域分解</strong></p><p>广度优先搜索算法，其算法BFS(v)只有在访遍顶点v所属的极大联通域之后方可返回，此外，若还有其他尚未访问的联通域，则算法主入口bfs()中的循环必然会继续检查其余的所有顶点，而一旦发现尚处于<code>UNDISCOVERED</code>,会在下次调用子算法BFS()并遍历该顶点属于的极大联通域。</p><p>按照BFS()的各次调用顺序，分批次输出所访问的顶点以及边，可实现无向图的极大联通域分解。</p><p><strong>最短路径</strong></p><p>经过广度优先搜索后，各顶点在BFS树中的深度值即是在原图中从起始顶点到他们的最小距离，因此，只需要调用该算法，在每个顶点入队时随即输出其所确定的深度值，而在最终生成的BFS树中，从树根到各顶点的唯一通路，即是对应的最短通路。任意两个顶点之间的最短通路可能不止一条，但是长度必然相同。</p><h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>深度优先搜索选取下一顶点的策略可概括为：优先选取最后一个被访问到的顶点的邻居。</p><p>于是，从顶点$s$出发的DFS搜索，将首先访问顶点$s$，再从顶点$s$所有未访问到的邻居任取其一，并从$s$所有未访问的邻居中任取一个，并从该顶点递归地执行DFS搜索,故各顶点访问的次序类似于树的先序遍历，而各顶点被访问完的次序，则类似于树的后序遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//深度优先搜索DFS算法（全图）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::dfs ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">do</span> <span class="comment">//逐一检查所有顶点</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) <span class="comment">//一旦遇到尚未发现的顶点</span></span><br><span class="line">         DFS ( v, clock ); <span class="comment">//即从该顶点出发启动一次DFS</span></span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="comment">//按序号检查，故不漏不重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//深度优先搜索DFS算法（单个连通域）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::DFS ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   dTime ( v ) = ++clock; status ( v ) = DISCOVERED; <span class="comment">//发现当前顶点v</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">      <span class="keyword">switch</span> ( status ( u ) ) &#123; <span class="comment">//并视其状态分别处理</span></span><br><span class="line">         <span class="keyword">case</span> UNDISCOVERED: <span class="comment">//u尚未发现，意味着支撑树可在此拓展</span></span><br><span class="line">            type ( v, u ) = TREE; parent ( u ) = v; DFS ( u, clock ); <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> DISCOVERED: <span class="comment">//u已被发现但尚未访问完毕，应属被后代指向的祖先</span></span><br><span class="line">            type ( v, u ) = BACKWARD; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>: <span class="comment">//u已访问完毕（VISITED，有向图），则视承袭关系分为前向边或跨边</span></span><br><span class="line">            type ( v, u ) = ( dTime ( v ) &lt; dTime ( u ) ) ? FORWARD : CROSS; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   status ( v ) = VISITED; fTime ( v ) = ++clock; <span class="comment">//至此，当前顶点v方告访问完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过显式地维护一个栈结构，动态记录从起始顶点到当前顶点通路上地各个顶点，其中栈顶对应于当前顶点。每当遇到<code>undiscovered</code>状态顶点，并令其入栈，一旦当前顶点的所有邻居都不再处于<code>undiscovered</code>状态，则将其转为<code>visited</code>状态，并令其出栈。</p><p><strong>边的分类</strong></p><p>每一递归实例中，先将当前节点标记为<code>discovered</code>状态，再递归地对其邻居递归处理，待所有邻居处理完毕之后再将顶点$v$置为<code>visited</code>状态，便可回溯。</p><p>若顶点$u$为<code>undiscovered</code>状态，则将边$(v,u)$归纳为树边。</p><p>若顶点$u$处于<code>discovered</code>状态，则发现一个有向环路，此时，在DFS遍历树中，$u$必为$v$的祖先，应将边$(v,u)$归纳为后向边。</p><p>这里为每个顶点都记录了被发现的顶点和访问完成的时刻，对应的时间$[dTime(v),fTime(v)]$称为$v$的活跃期。</p><p>对于有向图，顶点$v$还可能处于<code>visited</code>状态，此时通过对比$v$和$u$活跃期，即可判定$v$是否为$u$的祖先，若是，则边$(v,u)$应为前向边，否则，二者必定来自不同的分支，边$(v,u)$应归类为跨边。</p><p>此处需特别注意，无向图只有后向边(不区分)，没有跨边和前向边。</p><blockquote><p>顶点$v$是$u$的祖先，当且仅当$[dTime(u),fTime(u)] \subseteq  [dTime(v),fTime(v)]$</p></blockquote><p>先证明仅当，若$v$为$u$的祖先，则遍历过程的次序应该是</p><ol><li>$v$被发现</li><li>$u$被发现</li><li>$u$访问完成</li><li>$v$访问完成</li></ol><p>也就是说，$u$的活跃期包含于$v$的活跃期中，在任一顶点刚被发现的时候，其每个后代顶点$u$都应处于<code>undiscovered</code>状态。</p><p>反之，若$u$包含于$v$的活跃期中，则意味着当$u$被发现(由<code>discovered</code>状态转入<code>discovered</code>状态，$v$应该正处于<code>discovered</code>状态。因此，$v$既不可能与$u$处于不同的分支，又不可能是$u$的后代，故当亦成立。</p><p>由以上分析可进一步看出，此类顶点活跃期之间是严格的包含关系。</p><blockquote><p>$v$和$u$无承袭关系，当且仅当二者的活跃期无交集</p></blockquote><p>当必然成立，只需证明仅当</p><p>考察没有承袭关系的顶点$v$和$u$，不妨设$dTime[u]&lt;dTime[v]$，则$fTime[u]&lt;dTime[v]$</p><p>若不然($dTime(u)&lt;fTime(u)$),则意味着当$u$被发现时，$v$应该仍处于<code>discovered</code>状态。此时必然有一条从$v$到$u$的路径，沿途的节点都处于<code>visited</code>状态，在DFS的函数调用栈中，沿途各节点依次分别存有一帧。在DFS树中，该路径上的每一条边都对应于一对父子节点，故说明$u$是$v$的后代，与假设矛盾。</p><blockquote><p>起始于顶点$s$的DFS搜索过程中的某时刻，设当前节点为$v$，任一顶点$u$处于discovered状态，当且仅当$u$来自s通往$v$的路径沿途，或者等效地，在DFS树中$u$必定为$v$的祖先</p></blockquote><p>由条件可知$dTime(u)&lt;dTime(v)&lt;fTime(u)$</p><p>由以上节点活跃期之间相互包含关系的结论，必有：</p><p>$dTime(u)&lt;dTime(v)&lt;fTime(v)&lt;fTime(u)$</p><p>则$[dTime(v),fTime(v)] \subseteq  [dTime(u),fTime(u)]$,$u$必定为$v$的祖先。</p><p>由以上规律可知，起始顶点$s$既是第一个转入<code>discovered</code>状态的，也是最后一个转入<code>visited</code>状态的，其活跃期贯穿整个DFS算法的始末，在此期间的任何一个时刻，任何顶点处于<code>discovered</code>状态，当且仅当它属于从起始顶点$s$到当前顶点$v$的通路上。</p><h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>从顶点$s$出发的深度优先搜索：</p><ul><li>在无向图中将访问与$s$联通的所有顶点</li><li>在有向图中将访问由$s$可达的所有顶点</li></ul><table><thead><tr><th>联通图的支撑树</th><th>DFS/BFS</th></tr></thead><tbody><tr><td>非联通图的支撑森林</td><td>DFS/BFS</td></tr><tr><td>联通性检测</td><td>DFS/BFS</td></tr><tr><td>无向环路检测</td><td>DFS/BFS</td></tr><tr><td>有向环路检测</td><td>DFS</td></tr><tr><td>顶点之间可达性检测/路径求解</td><td>DFS/BFS</td></tr><tr><td>顶点之间的最短距离</td><td>BFS</td></tr><tr><td>直径</td><td>DFS</td></tr><tr><td>Eulerian tour</td><td>DFS</td></tr><tr><td>拓扑排序</td><td>DFS</td></tr><tr><td>双联通分量、强联通分量分解</td><td>DFS</td></tr></tbody></table><p><strong>欧拉环路问题</strong></p><p>在$O(n+e)$时间内判断任一无向图是否存在欧拉环路，并且在存在时构造出一条欧拉环路</p><p>根据图论的基本结论，只需遍历全图确定其连通性，再核对各顶点的度数。若连通且没有奇度数的顶点，则必然存在欧拉环路。若其中奇度数的顶点存在两个，则恰有两个，则必然存在以这两个顶点为起点和终点的欧拉环路。</p><p>构造欧拉环路的一种算法：从任一顶点出发做一趟DFS，依次记录沿途经过的各边并随即从图中删除，一旦有顶点度数归零，则随即将其删除。每当回到起点，则得到一条欧拉环路。此时若还存在已访问但是还未删除的顶点，则任选其一并从它出发再做一趟DFS,过程相同。每次所新得的子环路，都需要在搜索的起始点处与此前的环路合并为一条更大的子环路。最终不剩任何顶点的时候，算法结束，当前的子环路即为原图的一条欧拉环路。</p><h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>在具体情景中，有如下问题：</p><ul><li>给定项目工程图，是否存在可串行施工的方案？</li><li>email系统中，是否存在自动转发或回复的回路</li></ul><p>在图论中，拓扑排序是一个有向图所有顶点的线性序列，该序列必须满足以下两个条件：</p><ul><li>每个顶点出现且仅出现一次</li><li>若存在一条从顶点A到顶点B的路径，那么在序列中顶点A出现在顶点B的前面</li></ul><p>那么拓扑排序是否必然存在？</p><p>教材中偏序和全序的定义为：</p><ul><li>偏序：集合内只有部分元素在这个关系中是可以比较的</li><li>全序：任何一对元素均是可以比较的</li></ul><p>对于有向无环图，任意两个顶点之间的关系要么是确定的(存在先后关系)，要么是不确定的(不存在先后关系)，绝对不存在互相矛盾的关系(即环路)，以上即有向无环图。抽象而言，有向无环图两个顶点之间不存在环路，至于联通与否无所谓，所以有向无环图必然满足偏序关系。</p><p>所谓全序，就是在偏序的基础上，有向无环图的任一顶点之间均有明确的关系。用图来表示，即单向联通。可见，全序就是偏序的特殊情况。</p><p>拓扑排序并不唯一，交换某些节点后仍然为拓扑排序。若有向图中存在环路，则必然不可能存在拓扑排序。反之，对于有向无环图，即不含环路的有向图必然存在拓扑排序。有向无环图对应偏序关系，而拓扑排序为全序关系。在顶点数目有限时，与某一偏序相容的全序必然存在。</p><h2 id="零入度"><a href="#零入度" class="headerlink" title="零入度"></a>零入度</h2><p>有限偏序集必有极大/极大元素，任何有向无环图都存在一种拓扑排序。</p><p>极大元素即该元素不小于偏序集的任何其他元素，即在偏序集中是极大的。极大元素并不只是大小关系，有向无环图中的极大，其实就是在这个偏序集中不存在第二个元素可以使得它作为被处理的关系，即关系的受者。这样的元素称为该偏序集的极大元素。</p><p><strong>存在性</strong></p><ol><li>任何DAG，必有(至少一个)顶点入度为0，记作m</li><li>若DAG\{M}存在拓扑排序，则$S=&lt;u_{k1}…,u_{k(n-1)}&gt;$,则$S’=&lt;m,u_{k1}…,u_{k(n-1)}&gt;$ 即为DAG的拓扑排序。</li><li>只要$m$不唯一，则拓扑排序也应不唯一</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">将所有零入度的顶点存入栈&#x2F;&#x2F;O(n)</span><br><span class="line">取空队列Q&#x2F;&#x2F;记录拓扑排序序列</span><br><span class="line">while(!S.empty())&#123;&#x2F;&#x2F;O(n)</span><br><span class="line">    Q.enqueue(v&#x3D;S.pop);&#x2F;&#x2F;栈顶顶点转入队列Q</span><br><span class="line">    for each edge(v,u)&#x2F;&#x2F;凡入度为1(经节点删除后入度为0)者，均压入栈中</span><br><span class="line">     if(inDegree(u)&lt;2) S.push(u);</span><br><span class="line">    G&#x3D;G\&#123;v&#125;;&#x2F;&#x2F;删除顶点v和其关联边</span><br><span class="line">&#125;</span><br><span class="line">return |G|:&quot;not DAG&quot;:Q;</span><br></pre></td></tr></table></figure><p>残留的G空，当且仅当原图可拓扑排序。</p><p>栈S和队列Q的初始化共需$O(n)$时间，主体迭代共计迭代$O(n)$步，其中涉及的操作无非以下五类：</p><ul><li>出、入栈，共计$O(n)$次</li><li>入队，共计$O(n)$次</li><li>递减邻接矩阵的入度，共计$O(e)$次</li><li>删除零入度顶点，共计$O(n)$ 个</li><li>删除关联边，累计$O(e)$个</li></ul><p>以上操作均为基本操作，故时间复杂度为$O(n+e)$</p><p>空间方面，除了原图本身，引入了辅助栈和辅助队列，分别用以存放零入度顶点和排序序列，无论是S还是Q，每个顶点在其中最多存放一份，故二者的规模始终不超过$O(n)$。进一步可以发现，二者在任何时刻都不可能有公共顶点，S弹出节点并随即并入Q,故二者总体所占的空间为$O(n)$。</p><h2 id="零出度"><a href="#零出度" class="headerlink" title="零出度"></a>零出度</h2><p>将关注点转至与极大顶点对称的极小顶点，同理，有限偏序集中也必然极小元素(同样，未必唯一)。该元素作为顶点，出度必然为0。在DFS搜索中，首先因访问完成而转至<code>visited</code>状态的顶点m必然具有此性质。根据DFS搜索的特性，顶点m(及其关联边)对此后的搜索过程不起作用。于是下一转至visited状态的节点可等效理解为剔除m后出度为0者。DFS搜索过程中各个顶点被标记为<code>visited</code>的顺序恰好按照逆序给出了原图的一个拓扑排序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//基于DFS的拓扑排序算法</span></span><br><span class="line">Stack&lt;Tv&gt;* Graph&lt;Tv, Te&gt;::tSort ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s;</span><br><span class="line">   Stack&lt;Tv&gt;* S = <span class="keyword">new</span> Stack&lt;Tv&gt;; <span class="comment">//用栈记录排序顶点</span></span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) )</span><br><span class="line">         <span class="keyword">if</span> ( !TSort ( v, clock, S ) ) &#123; <span class="comment">//clock并非必需</span></span><br><span class="line">            <span class="keyword">while</span> ( !S-&gt;empty() ) <span class="comment">//任一连通域（亦即整图）非DAG</span></span><br><span class="line">               S-&gt;pop(); <span class="keyword">break</span>; <span class="comment">//则不必继续计算，故直接返回</span></span><br><span class="line">         &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) );</span><br><span class="line">   <span class="keyword">return</span> S; <span class="comment">//若输入为DAG，则S内各顶点自顶向底排序；否则（不存在拓扑排序），S空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//基于DFS的拓扑排序算法（单趟）</span></span><br><span class="line"><span class="keyword">bool</span> Graph&lt;Tv, Te&gt;::TSort ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock, Stack&lt;Tv&gt;* S ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   dTime ( v ) = ++clock; status ( v ) = DISCOVERED; <span class="comment">//发现顶点v</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">      <span class="keyword">switch</span> ( status ( u ) ) &#123; <span class="comment">//并视u的状态分别处理</span></span><br><span class="line">         <span class="keyword">case</span> UNDISCOVERED:</span><br><span class="line">            parent ( u ) = v; type ( v, u ) = TREE;</span><br><span class="line">            <span class="keyword">if</span> ( !TSort ( u, clock, S ) ) <span class="comment">//从顶点u处出发深入搜索</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若u及其后代不能拓扑排序（则全图亦必如此），故返回并报告</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> DISCOVERED:</span><br><span class="line">            type ( v, u ) = BACKWARD; <span class="comment">//一旦发现后向边（非DAG），则</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//不必深入，故返回并报告</span></span><br><span class="line">         <span class="keyword">default</span>: <span class="comment">//VISITED (digraphs only)</span></span><br><span class="line">            type ( v, u ) = ( dTime ( v ) &lt; dTime ( u ) ) ? FORWARD : CROSS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   status ( v ) = VISITED; S-&gt;push ( vertex ( v ) ); <span class="comment">//顶点被标记为VISITED时，随即入栈</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//v及其后代可以拓扑排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>额外引入的栈复杂度不超过顶点总数$O(n)$ ,总体而言，空间复杂度与基本深度优先算法一致，为$O(n + e)$。</p><p>递归跟踪过程与标准DFS过程一致，为$O(n+e)$。 </p><h1 id="双联通域分解"><a href="#双联通域分解" class="headerlink" title="双联通域分解"></a>双联通域分解</h1><p>若无向图删除顶点$v$以后G包含的联通域增多，则$v$被称为关节点。如何找出图中所有关节点呢？</p><p><strong>蛮力算法</strong></p><ol><li>通过BFS或DFS统计出图G包含的联通域数目</li><li>逐一枚举各个顶点，暂时将其从图中删去</li><li>统计出图G\{v}所含的联通域数目</li></ol><p>于是,$v$为关节点当且仅当图G\{v}的联通域数目大于图G。</p><p>时间复杂度为$O(n(n+e))$</p><p><strong>可行算法</strong></p><p>DFS树的根节点若至少有两个分支，必定为关节点，无向图不存在跨边，所以根节点的两个分支无法通过跨边相连，去除根节点后联通域数目必然增加。若根节点只有一个分支，则不可能为根节点，叶节点绝不可能是关节点。</p><p>考查一般的内部节点$c$，若节点$c$的移除导致某一棵真子树和真祖先无法联通，则$c$必定为关节点。反之，若所有子树均可以与$c$的某一祖先联通，则$c$就不可能是关节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="keyword">void</span> Graph&lt;Tv, Te&gt;::bcc ( <span class="keyword">int</span> s ) &#123; <span class="comment">//基于DFS的BCC分解算法</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; Stack&lt;<span class="keyword">int</span>&gt; S; <span class="comment">//栈S用以记录已访问的顶点</span></span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) &#123; <span class="comment">//一旦发现未发现的顶点（新连通分量）</span></span><br><span class="line">         BCC ( v, clock, S ); <span class="comment">//即从该顶点出发启动一次BCC</span></span><br><span class="line">         S.pop(); <span class="comment">//遍历返回后，弹出栈中最后一个顶点——当前连通域的起点</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hca(x) (fTime(x)) <span class="comment">//利用此处闲置的fTime[]充当hca[]</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//顶点类型、边类型</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::BCC ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock, Stack&lt;<span class="keyword">int</span>&gt;&amp; S ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   hca ( v ) = dTime ( v ) = ++clock; status ( v ) = DISCOVERED; S.push ( v ); <span class="comment">//v被发现并入栈</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">      <span class="keyword">switch</span> ( status ( u ) ) &#123; <span class="comment">//并视u的状态分别处理</span></span><br><span class="line">         <span class="keyword">case</span> UNDISCOVERED:</span><br><span class="line">            parent ( u ) = v; type ( v, u ) = TREE; BCC ( u, clock, S ); <span class="comment">//从顶点u处深入</span></span><br><span class="line">            <span class="keyword">if</span> ( hca ( u ) &lt; dTime ( v ) ) <span class="comment">//遍历返回后，若发现u（通过后向边）可指向v的真祖先</span></span><br><span class="line">               hca ( v ) = min ( hca ( v ), hca ( u ) ); <span class="comment">//则v亦必如此</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//否则，以v为关节点（u以下即是一个BCC，且其中顶点此时正集中于栈S的顶部）</span></span><br><span class="line">               <span class="keyword">do</span> &#123; </span><br><span class="line">                  temp.push ( S.pop() ); print ( vertex ( temp.top() ) ); </span><br><span class="line">               &#125; <span class="keyword">while</span> ( v != temp.top() ); </span><br><span class="line">               <span class="keyword">while</span> ( !temp.empty() ) S.push ( temp.pop() );</span><br><span class="line">               <span class="keyword">while</span> ( v != S.pop() ); <span class="comment">//依次弹出当前BCC中的节点，亦可根据实际需求转存至其它结构</span></span><br><span class="line">               S.push ( v ); <span class="comment">//最后一个顶点（关节点）重新入栈——分摊不足一次</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> DISCOVERED:</span><br><span class="line">            type ( v, u ) = BACKWARD; <span class="comment">//标记(v, u)，并按照“越小越高”的准则</span></span><br><span class="line">            <span class="keyword">if</span> ( u != parent ( v ) ) hca ( v ) = min ( hca ( v ), dTime ( u ) ); <span class="comment">//更新hca[v]</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>: <span class="comment">//VISITED (digraphs only)</span></span><br><span class="line">            type ( v, u ) = ( dTime ( v ) &lt; dTime ( u ) ) ? FORWARD : CROSS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   status ( v ) = VISITED; <span class="comment">//对v的访问结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于处理的是无向图，在顶点$v$的孩子$u$处返回后，通过比较$hca[u]$与$dTime[v]$的大小，即可判断是否为关节点。</p><ul><li>若若$hca[u] \geq dTime[v]$,则说明u的后代无法通过后向边与v的真祖先联通，故v为关节点。</li><li>若$hca[u] &lt; dTime[v]$，则意味着u可经由后向边连通至v的真祖先。</li></ul><p>每次遇到一条后向边，也将$hca[v]$更新为$hca[v]$和$dTime[u]$之间的小者，以保证顶点v可以始终记录顶点v可由后向边向上联通的最小祖先。</p><p>额外引入的栈复杂度不超过顶点总数$O(n)$ ,总体而言，空间复杂度与基本深度优先算法一致，为$O(n + e)$。</p><p>时间方面，尽管同一节点可能多次入栈，但是每次入栈都对应于一个新发现的连通域，与之对应地必有至少另一顶点出栈并不再入栈，此类重复入栈操作不超过n次，入栈操作累计不超过2n次，为$O(n+e)$。 </p><h1 id="优先级搜索"><a href="#优先级搜索" class="headerlink" title="优先级搜索"></a>优先级搜索</h1><p>各图搜索算法的差异，主要体现为每一步迭代对新顶点的选取策略不同，比如，BFS优先考查更早被发现的顶点，而DFS搜索优先考查最后被发现的顶点。每一种选取策略等效于给所有顶点赋予不同的优先级，而且随着算法的运行不断调整，每一步迭代所选取的节点都为当时优先级最高者。所以可以引入统一的框架，鉴于优先级在其中的关键角色，称为优先级搜索。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt; <span class="comment">//优先级搜索（全图）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::pfs ( <span class="keyword">int</span> s, PU prioUpdater ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">do</span> <span class="comment">//逐一检查所有顶点</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) <span class="comment">//一旦遇到尚未发现的顶点</span></span><br><span class="line">         PFS ( v, prioUpdater ); <span class="comment">//即从该顶点出发启动一次PFS</span></span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="comment">//按序号检查，故不漏不重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt; <span class="comment">//顶点类型、边类型、优先级更新器</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::PFS ( <span class="keyword">int</span> s, PU prioUpdater ) &#123; <span class="comment">//优先级搜索（单个连通域）</span></span><br><span class="line">   priority ( s ) = <span class="number">0</span>; status ( s ) = VISITED; parent ( s ) = <span class="number">-1</span>; <span class="comment">//初始化，起点s加至PFS树中</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> ) &#123; <span class="comment">//将下一顶点和边加至PFS树中</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> w = firstNbr ( s ); <span class="number">-1</span> &lt; w; w = nextNbr ( s, w ) ) <span class="comment">//枚举s的所有邻居w</span></span><br><span class="line">         prioUpdater ( <span class="keyword">this</span>, s, w ); <span class="comment">//更新顶点w的优先级及其父顶点</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> shortest = INT_MAX, w = <span class="number">0</span>; w &lt; n; w++ )</span><br><span class="line">         <span class="keyword">if</span> ( UNDISCOVERED == status ( w ) ) <span class="comment">//从尚未加入遍历树的顶点中</span></span><br><span class="line">            <span class="keyword">if</span> ( shortest &gt; priority ( w ) ) <span class="comment">//选出下一个</span></span><br><span class="line">               &#123; shortest = priority ( w ); s = w; &#125; <span class="comment">//优先级最高的顶点s</span></span><br><span class="line">      <span class="keyword">if</span> ( VISITED == status ( s ) ) <span class="keyword">break</span>; <span class="comment">//直至所有顶点均已加入</span></span><br><span class="line">      status ( s ) = VISITED; type ( parent ( s ), s ) = TREE; <span class="comment">//将s及与其父的联边加入遍历树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//通过定义具体的优先级更新策略prioUpdater，即可实现不同的算法功能</span></span><br></pre></td></tr></table></figure><p>PFS搜索由两重循环构成，其中内层循环又由并列的两层循环构成，前一循环的累计时间应取决于所有顶点的出度总和，即$O(e)$,后一循环固定迭代$n$次，累计$O(n^2)$时间，二者合计总体复杂度$O(n^2)$ 。</p><p>PFS中的各顶点可组织为优先级队列的形式，为此需要使用优先级队列接口：</p><ul><li>由$n$个顶点创建初始优先级队列，累计$ O(n)$</li><li>取优先级最高的跨边$(u,w)$，累计$ O(nlogn)$</li><li>更新所有关联节点到U的距离，提高优先级,共计$ O(elogn)$</li></ul><p>总体运行时间=$O((n+e)logn)$</p><p>对于稀疏图，处理效率很高，对于稠密图，反而不如常规实现的版本。</p><p>若将二叉堆改为多叉堆，则堆高降至$O(log_dn)$。</p><p>上滤成本降低至$log_dn$,但是下滤成本$\displaystyle dlog_dn&gt;d\frac{ln2}{lnd}log_2n$</p><p>对于稠密图，两次操作差距悬殊，如此：</p><p>PFS的运行时间为$ndlog_dn+elog_dn=(nd+e)log_dn$</p><p>令$\displaystyle f(x)=(nx+e)\frac{lnn}{lnx}$</p><p>$\displaystyle f’(x)=n \frac{lnn}{lnx}-(nx+e)\frac{lnn}{x{ln^2x}}$</p><p>$h(x)=nlnx(1+lnx)-(nx+e)lnn$</p><p>$h’(x)=nlnn(1+lnx)-nlnn=nlnnlnx&gt;0$</p><p>令$h(x)=0$，即$\displaystyle nlnn(xlnx-x)=elnn$</p><p>即$xlnx-x=e/n$的解，根据matlab求解得，</p><p>$e/(n<em>lambertw(0, (e</em>exp(-1))/n))$</p><p><a href="https://en.wikipedia.org/wiki/Lambert_W_function">lambertw</a>，大致取$d=e/n+2$时，总体性能最优$O(elog_{e/n+2}n)$ </p><p>两相权衡，大致取$d=e/n+2$时，总体性能最优$O(elog_{e/n+2}n)$</p><p>对稀疏图保持高效，$elog_{e/n+2}\approx nlog_{n/n+2}n=O(nlogn)$</p><p>对稠密图改进极大，$elog_{e/n+2}n \approx n^2log_{n^2+n}n \approx n^2=O(e)$</p><p>对于一般的图，可以自适应地实现最优。</p><h1 id="最小支撑树"><a href="#最小支撑树" class="headerlink" title="最小支撑树"></a>最小支撑树</h1><p>连通图G的某一无环联通子图T若覆盖G中的所有顶点，则称作G的一棵支撑树或生成树。</p><p>支撑树<code>/spanning</code>即为覆盖N中所有顶点</p><p>树，则具有以下性质：</p><ul><li>连通且无环，$|V|=|F|+1$</li><li>再添加一条边形成环路，再删除同环的一条边恢复为树</li><li>删除一条边后不再连通，再添加联边恢复为树</li></ul><p>同一网络的最小支撑树并不唯一。</p><p>若图$G$为一带权网络，则每一棵支撑树的成本即为其所采用各边权重的总和。在G的所有支撑树中，成本最低者称作最小支撑树。</p><h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p>聚类分析、网络架构设计、VLSI布线设计等诸多实际应用问题可转化为最小支撑树的构造问题。在这些应用中，边的权重大多对应于某种可量化的成本，可作为对应优化问题的基本模型，同时最小支撑树构造算法也可以为一些NP问题提供足够快速、足够接近的近似解法。</p><p>例如哈密顿环路(经过每个顶点刚好一次)问题，在任意n个城市的所有哈密顿环路中，找出交通成本最低者。</p><p>若已经构造出对应的最小支撑数，可在$O(n)$时间内找出一条哈密尔顿环路，其交通成本不超过最优成本的两倍</p><h2 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h2><p>由最小生成树的定义，蛮力算法大致如下：</p><ul><li>逐一枚举G的所有生成树，从而挑选其中的最低者</li></ul><blockquote><p>n个互异顶点构成的图，可能有多少支撑树？</p></blockquote><p><a href="https://en.wikipedia.org/wiki/Cayley's_formula#Generalizations">Cayley公式</a>：联接n个互异顶点的树有$n^{n-2}$棵，或等价地，完全图$k_n$有$n^{n-2}$棵支撑树。</p><h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><p>图$G=(V;E)$中，顶点集$V$的任一平凡子集$U$及其补集$V/U$都构成$G$的一个割，记作$(U;V/U)$。若边$uv$满足$u \in U$且$v\notin U$,则称作该割的一条跨越边。因此类边联接于V和其补集之间。</p><p>先假定各节边的权重互异，退化情况同样可证</p><p>prim算法的正确性基于以下事实：<strong>最小支撑树总是会采用联接每一割的最短跨越边</strong>。</p><p>反证：假设$(u,v)$未被任何MST采用</p><p>任取一棵MST,不妨命名为$T$,将$(u,v)$​加入其中，于是将出现唯一的回路，该回路必将经过$(u,v)$以及至少另一跨边$(s,t)$(若不存在跨边则二者必然不连通)，再删除边$st$则该环路必将消失。转换后的子树$T’$仍然为连通图，$T$和$T’$二者的差异仅在于边$uv$和边$st$,故二者成本之差即是这两条边的权重之差。不难看出，边$st$的权重必然大于身为最短跨越边的$uv$，故$T’$的总体权重小于$T$，这与$T$总体权重最小的前提矛盾。</p><p>反之，<strong>N的任一MST必然通过极短跨边联接每一割</strong></p><blockquote><p>G的每棵极小支撑树中的每一条边，必然为某一割的极短跨越边</p></blockquote><p>任取$G$的一棵极小支撑树$T$，考查其中的任何一条树边$uv$。将该边删除之后，$T$应恰好被分成两棵子树，它们对应的两个顶点子集也构成G的一个割$(U:V/U)$。</p><p>实际上，$uv$必然是该割的极短跨越边之一，否则将其替换为一条极短跨边，则可得到一棵权重更小的树。</p><p>以下方法可由现有某一图最小支撑树导出该图添加一边后的最小支撑树</p><p>设$T$为$N$的一棵MST，在$N$中添加边$e$后得到$N’$</p><p>若：沿着$e$在$T$中对应的环路，$f$为一极长边，则$T-{f}+{e}$即为$N’$的一棵MST</p><p>此时，$f=e,T-{f}+{e}=T$即为$N’$的MST</p><ul><li>若$e$为环路上的最长边，则e不可能属于$N’$的MST,此时,e不可能属于$N’$的MST,此时，$f=e,T-{f}+{e}=T$依然是$N’$的MST</li><li>否则有$|e|\leq |f|$,移除后$T-{f}$一分为二，对应于$N/N’$的割</li></ul><p>此割在$N$和$N’$中导出的一对互补子图完全一致，在$N/N’$中，$f/e$应是该割的极短跨越边，故这对子图各自的MST经联接后，即是$N’$的一棵MST。</p><blockquote><p>在MST不唯一时，由极短跨边构成的支撑树，未必就是一棵MST</p></blockquote><p>同一割可能同时拥有多条极短跨越边，以下证明可说明prim算法的正确性，即</p><blockquote><p>只要$T_{k}$是某棵最小支撑树的子树，则$T_{k+1}$也必然是(尽管可能与前一棵子树不同)极小支撑树的子树。</p></blockquote><p>假定$T_{k}$是某棵最小支撑树T的子集，</p><ul><li>若$e\in T$,则$E\cup{e}$必然为最小支撑树T的子集</li><li>设$e=(u,v)$，那么在$T$中必然存在从$u$到$v$的路径(树的性质)；$u$,$v$必然存在于$(S,V-S)$的两个点集里，于是这条路径上必有某条边$(x,y)$同样跨越割</li></ul><p>类似之前的操作，令$T’=T-{(x,y)}\cup{(u,v)}$</p><p>那么$T’$仍然是一棵最小支撑树，$w(u,v)\leq w(x,y)$</p><p>因此，$w(T’)=w(T)-w(x,y)+w(u,v)\leq w(T)$</p><p>由于$T$为最小支撑树，所以$w(T)\leq w(T’)$，所以$T$’同样为最小生成树。</p><blockquote><p>对于权值不为正数的网络，prim算法是否仍然可行</p></blockquote><p>依然可行，首先确认带负权边的网络依然拥有最小支撑树，可统一增加某个值使得所有边的权值为正，得到G’,G’的每一支撑树和G的每一支撑树必然一一对应，均相差一个常数。</p><blockquote><p>同一割的跨边可能不止采用一次</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//Prim算法：无向连通图，各边表示为方向互逆、权重相等的一对边</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::prim ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); priority ( s ) = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123; <span class="comment">//共需引入n个顶点和n-1条边</span></span><br><span class="line">      status ( s ) = VISITED;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">-1</span> != parent ( s ) ) type ( parent ( s ), s ) = TREE; <span class="comment">//引入当前的s</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> j = firstNbr ( s ); <span class="number">-1</span> &lt; j; j = nextNbr ( s, j ) ) <span class="comment">//枚举s的所有邻居j</span></span><br><span class="line">         <span class="keyword">if</span> ( ( status ( j ) == UNDISCOVERED ) &amp;&amp; ( priority ( j ) &gt; weight ( s, j ) ) ) <span class="comment">//对邻接顶点j做松弛</span></span><br><span class="line">            &#123; priority ( j ) = weight ( s, j ); parent ( j ) = s; &#125; <span class="comment">//与Dijkstra算法唯一的不同之处</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> shortest = INT_MAX, j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//选出下一极短跨边</span></span><br><span class="line">         <span class="keyword">if</span> ( ( status ( j ) == UNDISCOVERED ) &amp;&amp; ( shortest &gt; priority ( j ) ) )</span><br><span class="line">            &#123; shortest = priority ( j ); s = j; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PrimPU</span> &#123;</span> <span class="comment">//针对Prim算法的顶点优先级更新器</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( Graph&lt;Tv, Te&gt;* g, <span class="keyword">int</span> uk, <span class="keyword">int</span> v )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == g-&gt;status ( v ) ) <span class="comment">//对于uk每一尚未被发现的邻接顶点v</span></span><br><span class="line">         <span class="keyword">if</span> ( g-&gt;priority ( v ) &gt; g-&gt;weight ( uk, v ) ) &#123; <span class="comment">//按Prim策略做松弛</span></span><br><span class="line">            g-&gt;priority ( v ) = g-&gt;weight ( uk, v ); <span class="comment">//更新优先级（数）</span></span><br><span class="line">            g-&gt;parent ( v ) = uk; <span class="comment">//更新父节点</span></span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在带权网络存在多条相等的边(同为某一割的极短跨越边)时，可能存在歧义</p><p>若带权网络均为整数权重，则可通过给每条边的权重增加一个扰动量来消除歧义，如此构造的W’中各边的权重必然互异，其最小支撑树必然唯一。</p><p>设原图共含$v$个顶点、$e$条边，不妨假定$v-1&lt;e$。若各边权重(按照输入次序)依次为</p><p>$W=[w_{1},w_{2},..w_{e}]$</p><p>且不妨设各边权重不至完全相等，则可将其替换为：</p><p>$W=[w_1+1/e^{2},w_2+2/e^2,..,w_e+e/e^2]$</p><p>各边权重均有所增加，且增量为以$1/e^2$为公差的算术级数。</p><p>所有各边的扰动量总和不超过：</p><p>$(1+2+3+…+e)/e^2=(1+e)/2e&lt;1$</p><p>即便在$W$中存在等权的边，在如此构造的$W$’中各边的权重必然互异。于是由prim算法构造的最小支撑树必然唯一确定。于是，$W’$的任一支撑树都应满足都应满足</p><p>$|T_{m}’|\leq |T’|$</p><p>$\lfloor |T_{m}’|\rfloor \leq \lfloor  |T’| \rfloor$</p><p>既然$|W|=|W’|=e$,故二者的支撑树必然存在一一对应的关系。</p><p>考查如此对应的每一对支撑树$T$和$T’$。既然它们各自都恰好包含$v-1$条边，故应有：</p><p>$0&lt;|T’|-|T|&lt;(v-1)(1/e) \leq 1$</p><p>必有：</p><p>$\lfloor  |T’| \rfloor=\lfloor  |T| \rfloor$</p><p>特别地，设与$T_m’$对应的支撑树为$T_m$，则也应有：</p><p>$\lfloor  |T_{m}’| \rfloor=\lfloor  |T_{m}| \rfloor$</p><p>$|T_m|=\lfloor |T_{m}’|\rfloor \leq \lfloor  |T’| \rfloor=|T|$</p><p>由此可见，$T_m$必然是$w$的一棵最小支撑树。</p><p>以上方法之所以行之有效，是因为事先在不等权的边之间确定边权重的最小差值，从而保证W’的各权重互异，同时又能保证通过向下取整运算，从而从$|T’|$确定相应的$|T|$。若权重可以取自任何实数，则这两个性质无法兼顾。</p><p>当然，可推广至浮点数的情况，先将浮点数通过统一的放缩，将各边的权重转换为整数。</p><p>基于优先级队列，我们可以设计如下算法：</p><p>首先花费$O(n)$时间将起点$s$与其余顶点之间的$n-1$条边组织为一个优先级队列H。此后每一步迭代中，只需$O(logn)$时间即可从H中取出优先级数最小的边，并将对应的节点转入最小支撑树中。</p><p>取出每个节点需要$O(logn)$时间，删除操作，下滤，累计需要$O(nlogn)$时间。</p><p>所有顶点的所有邻接顶点的松弛，优先级增加，上滤，在最坏情况下累计需要$O(elogn)$时间。</p><p>如此改进以后，prim算法的效率为$O((n+e)logn)$ 。</p><h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2><p>krusal算法将每个顶点视作一棵树，并将所有边按权重非降排序，依次考查各边，只要其端点分属于不同的树，则引入该边，并将端点所分别归属的树合二为一，如此迭代，累计已引入$n-1$条边时，即得到一棵最小生成树。</p><blockquote><p>算法过程中引入的每一条边，都是某一割的极短跨越边，因此必定属于某棵极小支撑树。</p></blockquote><p>设$e=(u,v)$的引入导致树$T$和$S$的合并，将$(T;V/T)$视作原网络$N$的割，则$e$当属该割的一条跨边。</p><p>在确定应引入$e$时，该割的所有跨边都经kruskal考察，且只可能因为不短于$e$而被淘汰。</p><p>故$e$属于该割的一条极短跨边。</p><p>与prim同理，以上论述同样不充分。以下论述则为充分证明：</p><blockquote><p>kruskal算法过程中不断生长的森林，总是某棵MST的子图</p></blockquote><p><strong>时间复杂度分析</strong></p><p>若全排序，则将耗时$O(eloge)=O(n^2logn)$</p><p>实际上，大多数情况下只需要考虑前$O(n)$条边。</p><p>将所有边组织为优先队列</p><p>建堆，$O(e)$</p><p>删除并复原，共迭代$O(e)$次,实际中远远小于$e$，尤其对于稠密图</p><p>总共=$O(e)+O(elog n)=O(elogn)$</p><blockquote><p>如何高效地检查回路？</p></blockquote><p><strong>并查集</strong></p><p>给定一组互不相交的等价类，由各自的一个成员为代表</p><p>初始时各包含一个元素</p><p><code>find(x)</code> 找到元素x的等价类</p><p><code>union(x,y)</code> 合并x和y所属等价类</p><p><code>kruskal</code>算法迭代过程中所涉及的计算无非两类：</p><ul><li>查询元素x对应的等价类</li><li>将元素y所属的等价类(子树)，并入元素y所属的等价类(子树)</li></ul><p>并查集中的等价类，为某一全集的若干不相交子集。最初状态下，每个元素自成一个子集，并以该元素作为标识，每经过一次<code>union(x,y)</code>操作，都将元素y所属的子集归入元素x所属的子集，并继续沿用元素x此前的标识。</p><p>仿照父子节点表示法，将每个子集组织为一棵多叉树，并令所有多叉树共存于一个向量中。子集合并即对应树的合并，元素所属的子集即是所属的树，也对应该树的根。</p><p><code>find(x)</code>查找问题也就转化为了在多叉树中查找节点的问题，沿着<code>paren</code>t指针依次上行，直到最高祖先。</p><p>为了有效控制树高，可采取低者优先归入高者的策略，也就是比较待合并树的高度，并倾向于将更低者归入更高者。为此需要给每个节点增加一个域，动态记录树的高度。</p><p>有效控制树高的另一策略是路径压缩，在每次查找的过程中将上行通路的沿途节点取出，并作为树根的孩子重新介入树中。</p><h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>若以带权图来表示真实的通讯、交通、物流或社交网络，则各边的权重可代表信道成本、交通运输费用或交往程度。给定有向图G及其中的顶点u和v，找到从u到v的最短路径和长度即为最短路径问题。</p><p>对旅游者来说，最短路径意味着最经济的出行路线，对路由器来说，最短路径意味着最快将数据包传送至指定位置。</p><h2 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h2><p><strong>单源点到各顶点的最短路径</strong></p><p>给定顶点$x$，计算$x$到其余各个顶点的最短路径及其长度</p><p><strong>所有顶点对之间的路径</strong></p><p>找出每个顶点$i$和$j$之间的最短路径及长度</p><h2 id="最短路径树"><a href="#最短路径树" class="headerlink" title="最短路径树"></a>最短路径树</h2><p>在连通图中，$s$到每个顶点都有至少一条最短路径，任何路径的最短前缀也必定为一条最短路径。在任意带权网络中，考查从源点到其余顶点的最短路径(若有多条，选取其一)，就同一起点额如烟，所有最短路径的并不含回路，因此必构成一棵树。</p><h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>按照到$s$的最短距离，对其余的顶点排序</p><p>$dist(s,u_1)\leq dist(s,u_2) \leq …\leq dist(s,u_{n-1})$</p><p>沿着任一最短路径，各顶点到$s$的最短距离单调变化，$u_1$必定直接与$s$相连，为了找到$u_1$，只需在与$s$关联的各顶点之间找到对应权值最小者。</p><p>每一个顶点$u_{k+1}$都是$T_{k}$之外距离s最近者，由此引出贪心迭代算法。与prim算法不同，考虑距离为到s的距离而不是到$T_{k}$的距离。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//最短路径Dijkstra算法：适用于一般的有向图</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::dijkstra ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); priority ( s ) = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123; <span class="comment">//共需引入n个顶点和n-1条边</span></span><br><span class="line">      status ( s ) = VISITED;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">-1</span> != parent ( s ) ) type ( parent ( s ), s ) = TREE; <span class="comment">//引入当前的s</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> j = firstNbr ( s ); <span class="number">-1</span> &lt; j; j = nextNbr ( s, j ) ) <span class="comment">//枚举s的所有邻居j</span></span><br><span class="line">         <span class="keyword">if</span> ( ( status ( j ) == UNDISCOVERED ) &amp;&amp; ( priority ( j ) &gt; priority ( s ) + weight ( s, j ) ) ) <span class="comment">//对邻接顶点j做松弛</span></span><br><span class="line">            &#123; priority ( j ) = priority ( s ) + weight ( s, j ); parent ( j ) = s; &#125; <span class="comment">//与Prim算法唯一的不同之处</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> shortest = INT_MAX, j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//选出下一最近顶点</span></span><br><span class="line">         <span class="keyword">if</span> ( ( status ( j ) == UNDISCOVERED ) &amp;&amp; ( shortest &gt; priority ( j ) ) )</span><br><span class="line">            &#123; shortest = priority ( j ); s = j; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//对于无向连通图，假设每一条边表示为方向互逆、权重相等的一对边</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">DijkstraPU</span> &#123;</span> <span class="comment">//针对Dijkstra算法的顶点优先级更新器</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( Graph&lt;Tv, Te&gt;* g, <span class="keyword">int</span> uk, <span class="keyword">int</span> v )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == g-&gt;status ( v ) ) <span class="comment">//对于uk每一尚未被发现的邻接顶点v，按Dijkstra策略</span></span><br><span class="line">         <span class="keyword">if</span> ( g-&gt;priority ( v ) &gt; g-&gt;priority ( uk ) + g-&gt;weight ( uk, v ) ) &#123; <span class="comment">//做松弛</span></span><br><span class="line">            g-&gt;priority ( v ) = g-&gt;priority ( uk ) + g-&gt;weight ( uk, v ); <span class="comment">//更新优先级（数）</span></span><br><span class="line">            g-&gt;parent ( v ) = uk; <span class="comment">//并同时更新父节点</span></span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>若节点之间存在负权重，则<code>dijkstra</code>不可行。任意两点之间通路数目有限，其中最短者仍然存在，故最短路径树依然存在，但是<code>dijkstra</code>树在此时未必可行。可在pfs优先级更新时，不再忽略非<code>undiscovered</code>节点，一旦优先级有所增加，则随即恢复为<code>undiscovered</code>状态，进而参加下一节点的候选，时间复杂度同样因此提高。</p><p>即便带权网络中不含权重相等的边，其最短路径树依然可能不唯一。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在城市交通图中联接于各公交站之间的街道，或者在互联网中联接于IP之间的二元关系，这类信息往往可表述为定义于一组对象之间的二元关系。相互之间均可能存在二元关系的一组对象，属于非线性结构。图结构是描述这类信息的典型结构，通过遍历将其转化为半线性结构，进而借助树的相关算法解决问题。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://twinkle0331.github.io/algorithm/bin-tree/"/>
    <id>http://twinkle0331.github.io/algorithm/bin-tree/</id>
    <published>2019-09-02T13:40:20.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>树是一种分层结构，而层次化这一结构几乎蕴含于所有事物及其联系中，称为其本质属性之一。从文件系统、互联网域名系统，一直到地球生态系统乃至人类社会系统，层次化特征和层次化结构均无所不在。二叉树不再是简单的线性结构，但确定某种次序后具有线性特征，故树属于半线性结构。</p><p>树等价于无环联通图，因此与一般的图相同，树也由一组顶点和联接于其间的若干条边组成，故任一节点与根节点之间存在着唯一路径。</p><a id="more"></a><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>节点度数不超过2的树称为二叉树，同一节点的孩子和子树，均以左、右区分。</p><p>深度为$k$的节点，至多$2^k$个</p><p>含$n$个节点的二叉树，高度为$h$的二叉树中，$h&lt;n&lt;2^{h+1}$</p><p>1）$n=h+1$时，退化为一条单链</p><p>2）$n=2^{h+1}-1$,即所谓的满二叉树</p><p>设度数为0，1，2的节点，各有$n_0$,$n_1$,$n_2$个</p><p>树为极小联通图，故边数$e=n+1=n_1+2n_2$</p><p>叶节点数$n_0=n_2+1$</p><p>即$n_1$与$n_0$无关</p><p>$h=0$时，$1=0+1$</p><p>此后，$n_0$与$n_2$同步递增</p><p>特别地，当$n_1=0$时，有$e=2n_2$和$n_0=n_2+1=(n+1)/2$</p><p>此时，所有的节点均为偶数，不含单分支节点。</p><p>二叉树本身并不具有天然的次序，需要在各个节点与其孩子间定义某种局部次序，从而间接地定义出全局次序。按惯例，左孩子优先于右孩子，将节点和左右孩子分别称为V,L,R,局部次序有VLR,LVR,LRV三种选择，根据节点V的访问次序分别称为先序遍历、中序遍历、后序遍历。</p><h1 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h1><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_R</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( !x ) <span class="keyword">return</span>;</span><br><span class="line">   visit ( x-&gt;data );</span><br><span class="line">   travPre_R ( x-&gt;lc, visit );</span><br><span class="line">   travPre_R ( x-&gt;rc, visit );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><p>对右子树的递归属于尾递归，左子树的递归接近尾递归，借用尾递归的消除方法，可得到迭代版算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I1</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#1）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">if</span> ( x ) S.push ( x ); <span class="comment">//根节点入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( !S.empty() ) &#123; <span class="comment">//在栈变空之前反复循环</span></span><br><span class="line">      x = S.pop(); visit ( x-&gt;data ); <span class="comment">//弹出并访问当前节点，其非空孩子的入栈次序为先右后左</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *x ) ) S.push ( x-&gt;rc ); <span class="keyword">if</span> ( HasLChild ( *x ) ) S.push ( x-&gt;lc );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先序遍历序列可分为两段：</p><ul><li>沿最左侧通路自顶而下访问的各节点</li><li>自底而上访问遍历的对应右子树</li></ul><p>借助栈逆序记录最左侧通路上的节点的右子树，以确定对应右子树自底而上的遍历次序。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I2</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#2）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">      visitAlongLeftBranch ( x, visit, S ); <span class="comment">//从当前节点出发，逐批访问</span></span><br><span class="line">      <span class="keyword">if</span> ( S.empty() ) <span class="keyword">break</span>; <span class="comment">//直到栈空</span></span><br><span class="line">      x = S.pop(); <span class="comment">//弹出下一批的起点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点；沿途节点遇到后立即访问</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitAlongLeftBranch</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit, Stack&lt;BinNodePosi(T)&gt;&amp; S )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( x ) &#123;</span><br><span class="line">      visit ( x-&gt;data ); <span class="comment">//访问当前节点</span></span><br><span class="line">      S.push ( x-&gt;rc ); <span class="comment">//右孩子入栈暂存（可优化：通过判断，避免空的右孩子入栈）</span></span><br><span class="line">      x = x-&gt;lc;  <span class="comment">//沿左分支深入一层</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><h2 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_R</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( !x ) <span class="keyword">return</span>;</span><br><span class="line">   travIn_R ( x-&gt;lc, visit );</span><br><span class="line">   visit ( x-&gt;data );</span><br><span class="line">   travIn_R ( x-&gt;rc, visit );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代版-1"><a href="#迭代版-1" class="headerlink" title="迭代版"></a>迭代版</h2><p>与之前的先序遍历算法不同，沿最左侧分支下行时只是将对应的节点压栈，并没有执行访问操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goAlongLeftBranch</span> <span class="params">( BinNodePosi(T) x, Stack&lt;BinNodePosi(T)&gt;&amp; S )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( x ) &#123; S.push ( x ); x = x-&gt;lc; &#125; <span class="comment">//当前节点入栈后随即向左侧分支深入，迭代直到无左孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I1</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#1）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">      goAlongLeftBranch ( x, S ); <span class="comment">//从当前节点出发，逐批入栈</span></span><br><span class="line">      <span class="keyword">if</span> ( S.empty() ) <span class="keyword">break</span>; <span class="comment">//直至所有节点处理完毕</span></span><br><span class="line">      x = S.pop(); visit ( x-&gt;data ); <span class="comment">//弹出栈顶节点并访问之</span></span><br><span class="line">      x = x-&gt;rc; <span class="comment">//转向右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将上一版等价地描述以下版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I2</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#2）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( x ) &#123;</span><br><span class="line">         S.push ( x ); <span class="comment">//根节点进栈</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !S.empty() ) &#123;</span><br><span class="line">         x = S.pop(); <span class="comment">//尚未访问的最低祖先节点退栈</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该祖先节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//遍历祖先的右子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//遍历完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上版需借助辅助栈，所需辅助空间正比于二叉树的高度，在最坏情况下与节点数目相当。借助<code>BinNode</code>对象内部的<code>parent</code>指针，以下版本仅需要常数辅助空间，属于就地算法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I3</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#3，无需辅助栈）</span></span><br><span class="line">   <span class="keyword">bool</span> backtrack = <span class="literal">false</span>; <span class="comment">//前一步是否刚从右子树回溯——省去栈，仅O(1)辅助空间</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( !backtrack &amp;&amp; HasLChild ( *x ) ) <span class="comment">//若有左子树且不是刚刚回溯，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则——无左子树或刚刚回溯（相当于无左子树）</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该节点</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) &#123; <span class="comment">//若其右子树非空，则</span></span><br><span class="line">            x = x-&gt;rc; <span class="comment">//深入右子树继续遍历</span></span><br><span class="line">            backtrack = <span class="literal">false</span>; <span class="comment">//并关闭回溯标志</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若右子树空，则</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">break</span>; <span class="comment">//回溯（含抵达末节点时的退出返回）</span></span><br><span class="line">            backtrack = <span class="literal">true</span>; <span class="comment">//并设置回溯标志</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BinNode&lt;T&gt;::succ() &#123; <span class="comment">//定位节点v的直接后继</span></span><br><span class="line">   BinNodePosi(T) s = <span class="keyword">this</span>; <span class="comment">//记录后继的临时变量</span></span><br><span class="line">   <span class="keyword">if</span> ( rc ) &#123; <span class="comment">//若有右孩子，则直接后继必在右子树中，具体地就是</span></span><br><span class="line">      s = rc; <span class="comment">//右子树中</span></span><br><span class="line">      <span class="keyword">while</span> ( HasLChild ( *s ) ) s = s-&gt;lc; <span class="comment">//最靠左（最小）的节点</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则，直接后继应是“将当前节点包含于其左子树中的最低祖先”，具体地就是</span></span><br><span class="line">      <span class="keyword">while</span> ( IsRChild ( *s ) ) s = s-&gt;parent; <span class="comment">//逆向地沿右向分支，不断朝左上方移动</span></span><br><span class="line">      s = s-&gt;parent; <span class="comment">//最后再朝右上方移动一步，即抵达直接后继（如果存在）</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此版相当于将原辅助栈替换为一个标志位<code>backtrack</code>，标志是否有从下而上的回溯。若不是，则按照中序遍历的策略优先遍历左子树，否则，则意味着当前左子树已访问完毕，访问当前节点后深入右子树。</p><p>改进该算法，无需辅助栈，也无需辅助标志位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I4</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历（迭代版#4，无需栈或标志位）</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) <span class="comment">//若有左子树，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问当前节点，并</span></span><br><span class="line">         <span class="keyword">while</span> ( !HasRChild ( *x ) ) <span class="comment">//不断地在无右分支处</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">return</span>; <span class="comment">//回溯至直接后继（在没有后继的末节点处，直接退出）</span></span><br><span class="line">            <span class="keyword">else</span> visit ( x-&gt;data ); <span class="comment">//访问新的当前节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//（直至有右分支处）转向非空的右子树</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论二叉树的规模如何，对succ()接口所有调用所需时间总和不超过O(n)</p></blockquote><p>在这一场合对<code>succ</code>的调用，其中if判断语句必然取else分支，因此，算法所消耗的所有时间应线性正比于其中while循环的部署，即其中对<code>parent</code>引用的访问次数。数学归纳法对树高归纳可证明对<code>parent</code>引用不超过$n$次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I3</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#3，无需辅助栈）</span></span><br><span class="line">   <span class="keyword">bool</span> backtrack = <span class="literal">false</span>; <span class="comment">//前一步是否刚从右子树回溯——省去栈，仅O(1)辅助空间</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( !backtrack &amp;&amp; HasLChild ( *x ) ) <span class="comment">//若有左子树且不是刚刚回溯，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则——无左子树或刚刚回溯（相当于无左子树）</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该节点</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) &#123; <span class="comment">//若其右子树非空，则</span></span><br><span class="line">            x = x-&gt;rc; <span class="comment">//深入右子树继续遍历</span></span><br><span class="line">            backtrack = <span class="literal">false</span>; <span class="comment">//并关闭回溯标志</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若右子树空，则</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">break</span>; <span class="comment">//回溯（含抵达末节点时的退出返回）</span></span><br><span class="line">            backtrack = <span class="literal">true</span>; <span class="comment">//并设置回溯标志</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个节点都仅在左子树被访问完成后接受访问，所以只访问一次。</p><p>另外，此处并未显式地使用复杂的辅助结构，表面上看只需要常数辅助空间，但是相比于其余算法，该算法要求每个算法均有<code>parent</code>指针，仍为$O(n)$空间。</p><h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><h2 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPost_R</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树后序遍历算法（递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( !x ) <span class="keyword">return</span>;</span><br><span class="line">   travPost_R ( x-&gt;lc, visit );</span><br><span class="line">   travPost_R ( x-&gt;rc, visit );</span><br><span class="line">   visit ( x-&gt;data );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代版-2"><a href="#迭代版-2" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//在以S栈顶节点为根的子树中，找到最高左侧可见叶节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gotoHLVFL</span> <span class="params">( Stack&lt;BinNodePosi(T)&gt;&amp; S )</span> </span>&#123; <span class="comment">//沿途所遇节点依次入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( BinNodePosi(T) x = S.top() ) <span class="comment">//自顶而下，反复检查当前节点（即栈顶）</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) &#123; <span class="comment">//尽可能向左</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) S.push ( x-&gt;rc ); <span class="comment">//若有右孩子，优先入栈</span></span><br><span class="line">         S.push ( x-&gt;lc ); <span class="comment">//然后才转至左孩子</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//实不得已</span></span><br><span class="line">         S.push ( x-&gt;rc ); <span class="comment">//才向右</span></span><br><span class="line">   S.pop(); <span class="comment">//返回之前，弹出栈顶的空节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPost_I</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树的后序遍历（迭代版）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">if</span> ( x ) S.push ( x ); <span class="comment">//根节点入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( !S.empty() ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( S.top() != x-&gt;parent ) <span class="comment">//若栈顶非当前节点之父（则必为其右兄），此时需</span></span><br><span class="line">         gotoHLVFL ( S ); <span class="comment">//在以其右兄为根之子树中，找到HLVFL（相当于递归深入其中）</span></span><br><span class="line">      x = S.pop(); visit ( x-&gt;data ); <span class="comment">//弹出栈顶（即前一节点之后继），并访问之</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在后续遍历序列中，栈顶元素应后于栈顶子树访问，所以后序遍历序列并不是访问栈顶元素，而是先判断对应子树是否遍历，若遍历再访问栈顶元素。</p><p>在迭代版后序遍历算法运行中，树中每一层至多有两个节点存在栈中，故栈结构最大规模不超过二叉树深度的两倍，最坏情况下为$O(n)$。</p><h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>递归的形式类似于栈，层次遍历的顺序与栈访问顺序有所不同，所以借助与栈对称的队列结构实现层次遍历。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="keyword">void</span> BinNode&lt;T&gt;::travLevel ( VST&amp; visit ) &#123; <span class="comment">//二叉树层次遍历算法</span></span><br><span class="line">   Queue&lt;BinNodePosi(T)&gt; Q; <span class="comment">//辅助队列</span></span><br><span class="line">   Q.enqueue ( <span class="keyword">this</span> ); <span class="comment">//根节点入队</span></span><br><span class="line">   <span class="keyword">while</span> ( !Q.empty() ) &#123; <span class="comment">//在队列再次变空之前，反复迭代</span></span><br><span class="line">      BinNodePosi(T) x = Q.dequeue(); visit ( x-&gt;data ); <span class="comment">//取出队首节点并访问之</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) Q.enqueue ( x-&gt;lc ); <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *x ) ) Q.enqueue ( x-&gt;rc ); <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列中所存节点的深度不超过1，故最大规模不超过二叉树任一的相邻两层的规模之和。</p><blockquote><p>只要辅助队列Q的容量不低于$\lceil n/2 \rceil$ ,就不会出现中途溢出的问题</p></blockquote><p>在算法的每一步迭代过程中，若当前至少有$n$各个元素入过队，则在队中的至多$\lceil n/2 \rceil$,相应地，至少有$\lfloor n/2 \rfloor$个已经出队。每次迭代都会有一个节点出队，若该节点的度数为$d(0&lt;=d&lt;=2)$，则随即会有$d$个节点入队，通过对已出队的节点做数学归纳可证。</p><p>在算法的任一时刻，辅助队列的规模均不至小于仍在队列中节点的数目。为了使仍在队列中节点数目占当前入过队节点比重尽可能大，此前所有出队节点度数都必须取作最大的2，且中途一旦某个节点只有1度甚至0度，则不可能恢复到这一比重，即当树为规模为n的完全二叉树时需要如此大容量的队列。</p><p>在整个遍历过程中，规模为$n$的完全二叉树为单峰对称的，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,1,2,..(n+1)&#x2F;2,...,2,1,0&#125;</span><br><span class="line">&#123;0,1,2,..n&#x2F;2,n&#x2F;2,...,2,1,0&#125;</span><br></pre></td></tr></table></figure><p>$n$为偶数时，最后一个内部节点度数为1，入一出一，所以队列规模不变。</p><h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>叶节点仅限于最低两层</p><p>底层叶子均居于次底层叶子左侧，除末节点的父亲，内部节点均有叶子。</p><p>叶节点不致少于内部节点，但至多多出一个。</p><p>分为两种情况：</p><ul><li><strong>各节点均为二度节点</strong> $n_0=n_1+n_2+1=n_2+1$</li><li><strong>有一节点为一度</strong> $n_0=n_2+1=n_2+n_1$</li></ul><blockquote><p>这些算法的确会访问每个节点一次且仅一次</p></blockquote><p>只要某个节点可以被访问到，则其孩子节点必然也能</p><p>由此进一步可知：只要某个节点能被访问到，则其每个后代节点必然也能。于是特别地，作为根节点地后代，树中所有节点都能被起始于根节点的遍历访问到。</p><p>另外一方面，任何节点仅被访问一次。</p><p>除了层次遍历算法和中序遍历算法均借助辅助栈进行访问，注意到每个节点都在且仅在刚刚出栈后，随即被访问。每个节点各自仅入栈一次，即可确定每个节点的确至多被访问一次。</p><p>层次遍历算法和中序遍历算法未使用到栈结构，性质类似。</p><blockquote><p>这些算法都具有线性时间复杂度</p></blockquote><p>这些算法的运行时间主要消耗于两个部分：</p><ul><li>栈(队列)操作</li><li>对节点的访问操作</li></ul><p>以上操作对每个节点而言均为常数次，所以总体而言，这些算法具有线性时间复杂度。</p><blockquote><p>递推方程分析</p></blockquote><p>$T(n)=T(n-a-1)+T(a)+O(1)$</p><p>每递归一层，等效于将当前问题分解为两个子问题，递归基只需常数时间，同样可以得出这些算法具有线性复杂度的结论。</p><h1 id="二叉编码树"><a href="#二叉编码树" class="headerlink" title="二叉编码树"></a>二叉编码树</h1><p>通讯理论中一个基本的问题是：如何在尽可能低的成本的情况下，以尽可能高的速度，尽可能忠实地实现信息在空间和时间上的复制和转移。在现代通讯技术中，无论采用电、磁、光、电或其他任何形式，在信道上传递的信息大多以二进制比特的形式表示和存在，而每一个具体的编码方案都对应于一棵二叉编码树。</p><p>在加载到信道上之前，信息被转换为二进制的过程被称为编码，反之，信道抵达目标后再由二进制编码回复原始信息的过程被称为解码。</p><p>任一编码方案都可描述为一棵二叉树：从根节点出发，每次向左(右)对应一个0(1)比特位。各字符分别存放于对应的叶子中。字符x的编码串rps(v(x))=rps(x)由根到v(x)的通路确定。</p><p>字符编码不必等长，所有字符都对应于叶节点，不存在解码歧义现象，为前缀无歧义编码，不同字符的编码互不为前缀，故不致歧义，此为可行的PFC编码方案。</p><blockquote><p>若采用PFC编码，则无论二进制编码串的长度与内容如何，解码过程总能持续进行</p></blockquote><p>整个解码过程就是在PFC编码树上的下行过程，从根节点出发，根据编码串的当前编码相应地向左(比特0)或向右(比特1)深入，一旦抵达叶节点，则输出其对应的字符，并随即复位至根节点。</p><p>可见，算法无法继续的唯一可能情况为，在准备向下深入时没有发现对应的分支，然而根据定义和约束条件，PFC编码树必然是真二叉树，每一内部节点必然拥有左、右分支，因此上述情况不可能发生。</p><p>解码过程不必回溯，若因为信道干扰等因素导致某个比特位翻转错误，尽管解码依然可进行，但是后续所有字符的解码都会出现错误。</p><h2 id="最优编码树"><a href="#最优编码树" class="headerlink" title="最优编码树"></a>最优编码树</h2><p>在实际的通讯系统中，信道的使用效率很大程度上取决于编码本身的效率。比如，高效的算法生成的编码串应尽可能短。</p><p>字符x的编码长度|rps(x)|为其对应叶节点的深度depth(v(x))。于是，各字符的平均编码长度就是编码树T中的叶节点平均深度。</p><p>$ald(T)=\sum_{x\in \sum}|rps(x)|/|\sum|=\sum_{x\in \sum}depth(x)/|\sum|$</p><p>平均编码长度是反应编码效率的重要指标，我们尽可能希望这一指标小。同一字符集的所有编码方案中，平均编码长度最小者被称为最优方案，对应编码树的ald()值达到最小，故称之为最优编码树，简称最优编码树。对于任一字符集，最优编码树必然存在。</p><p><strong>双子性</strong></p><p>最优编码树必然为真二叉树，内部节点的左、右孩子全双，不然，假设其中内部节点p有唯一的孩子x，则将p删除并代之以子树x。除了子树中所有叶节点的编码长度统一缩短一层外，其余叶节点的编码长度不变，相比于之前的编码树平均编码长度必然更短。</p><p><strong>层次性</strong></p><p>叶节点位置深度之差不超过1，类似双子性的证明，替换后可得到的编码树平均编码长度更短，不符合最优编码树的原则。</p><p><strong>不唯一性</strong></p><p>对于任一内部节点而言，左右子树互换之后平均编码长度不变。</p><p><strong>最优编码树的构造</strong></p><p>真完全树为最优编码树，可直接导出构造最优编码树的算法：创建一棵规模为$2|\sum|-1$的完全二叉树T，将$\sum$中的字符任意分配给T的$|\sum|$个节点。</p><blockquote><p>若不同序列作为输出的概率均等，则任何CBA式排序算法平均运行时间仍然为$\Omega(nlogn)$</p></blockquote><p>针对CBA式算法复杂度的下界估计，统一方法为：</p><ul><li>确定算法所对应的比较树</li><li>通过输入规模与可能的输出结果(叶节点)数目推算出最小树高</li></ul><p>在各种输出结果符合某种概率分布的情况下，算法的平均性能，则等效于比较树中各叶节点的加权平均深度。</p><p>最优编码树在各种输出结果均等的情况下，对于任一固定输入规模n，完全二叉树的叶节点平均深度可达到最小。</p><h2 id="huffman编码树"><a href="#huffman编码树" class="headerlink" title="huffman编码树"></a>huffman编码树</h2><p>以上最优编码树算法假定各个字符在文本串中出现的次数相等，而这一条件往往不满足，甚至不确定。</p><p>若考虑字符各自出现频率，则可将带权平均编码长度取作编码树T的叶节点带权平均深度，即是</p><p>$wald(T)=\sum_{x\in \sum}p(x)|rps(x)|$</p><p>此时，完全二叉编码树并不是wald值最短。</p><p><strong>最优带权编码树</strong></p><p>频率高的超字符，应尽可能放在高/低处。</p><p>同样，huffman编码树满足层次性、双子性、不唯一性。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffTree* <span class="title">minHChar</span> <span class="params">( HuffForest* forest )</span> </span>&#123; <span class="comment">//在Huffman森林中找出权重最小的（超）字符</span></span><br><span class="line">   ListNodePosi ( HuffTree* ) p = forest-&gt;first(); <span class="comment">//从首节点出发查找</span></span><br><span class="line">   ListNodePosi ( HuffTree* ) minChar = p; <span class="comment">//最小Huffman树所在的节点位置</span></span><br><span class="line">   <span class="keyword">int</span> minWeight = p-&gt;data-&gt;root()-&gt;data.weight; <span class="comment">//目前的最小权重</span></span><br><span class="line">   <span class="keyword">while</span> ( forest-&gt;valid ( p = p-&gt;succ ) ) <span class="comment">//遍历所有节点</span></span><br><span class="line">      <span class="keyword">if</span> ( minWeight &gt; p-&gt;data-&gt;root()-&gt;data.weight ) <span class="comment">//若当前节点所含树更小，则</span></span><br><span class="line">         &#123;  minWeight = p-&gt;data-&gt;root()-&gt;data.weight; minChar = p;  &#125; <span class="comment">//更新记录</span></span><br><span class="line">   <span class="keyword">return</span> forest-&gt;remove ( minChar ); <span class="comment">//将挑选出的Huffman树从森林中摘除，并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffTree* <span class="title">generateTree</span> <span class="params">( HuffForest* forest )</span> </span>&#123; <span class="comment">//Huffman编码算法</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> &lt; forest-&gt;size() ) &#123;</span><br><span class="line">      HuffTree* T1 = minHChar ( forest ); HuffTree* T2 = minHChar ( forest );</span><br><span class="line">      HuffTree* S = <span class="keyword">new</span> HuffTree(); </span><br><span class="line">      S-&gt;insertAsRoot ( HuffChar ( <span class="string">&#x27;^&#x27;</span>, T1-&gt;root()-&gt;data.weight + T2-&gt;root()-&gt;data.weight ) );</span><br><span class="line">      S-&gt;attachAsLC ( S-&gt;root(), T1 ); S-&gt;attachAsRC ( S-&gt;root(), T2 );</span><br><span class="line">      forest-&gt;insertAsLast ( S ); </span><br><span class="line">   &#125; <span class="comment">//assert: 循环结束时，森林中唯一（列表首节点中）的那棵树即Huffman编码树</span></span><br><span class="line">   <span class="keyword">return</span> forest-&gt;first()-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="comment">//通过遍历获取各字符的编码</span></span><br><span class="line">generateCT ( Bitmap* code, <span class="keyword">int</span> length, HuffTable* table, BinNodePosi ( HuffChar ) v ) &#123;</span><br><span class="line">   <span class="keyword">if</span> ( IsLeaf ( *v ) ) <span class="comment">//若是叶节点（还有多种方法可以判断）</span></span><br><span class="line">      &#123;  table-&gt;put ( v-&gt;data.ch, code-&gt;bits2string ( length ) ); <span class="keyword">return</span>;  &#125;</span><br><span class="line">   <span class="keyword">if</span> ( HasLChild ( *v ) ) <span class="comment">//Left = 0</span></span><br><span class="line">      &#123; code-&gt;clear ( length ); generateCT ( code, length + <span class="number">1</span>, table, v-&gt;lc ); &#125;</span><br><span class="line">   <span class="keyword">if</span> ( HasRChild ( *v ) ) <span class="comment">//Right = 1</span></span><br><span class="line">      &#123; code-&gt;<span class="built_in">set</span> ( length ); generateCT ( code, length + <span class="number">1</span>, table, v-&gt;rc ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffTable* <span class="title">generateTable</span> <span class="params">( HuffTree* tree )</span> </span>&#123; <span class="comment">//将各字符编码统一存入以散列表实现的编码表中</span></span><br><span class="line">   HuffTable* table = <span class="keyword">new</span> HuffTable; Bitmap* code = <span class="keyword">new</span> Bitmap;</span><br><span class="line">   generateCT ( code, <span class="number">0</span>, table, tree-&gt;root() ); release ( code ); <span class="keyword">return</span> table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每迭代一次，森林的规模减1,故共需迭代n-1此，直到只剩一棵树。<code>minHChar()</code> 每次都要遍历森林中所有的超字符，所需时间线性正比于当时森林的规模。因此总体运行时间应为：</p><p>$O(1)+O(n-1)+…+O(2)=O(n^2)$</p><blockquote><p>任何CBA式huffman树构造算法在最坏情况下都需要运行$\Omega(nlog n)$时间</p></blockquote><p>只需建立一个从排序问题到huffman编码树问题的线性归约</p><p>事实上，对于每一个待排序的输入序列，我们都将其视为一组字符的出现频率。不失一般性，假设每个元素非负，否则可在$O(n)$时间内令它们增加同一足够大的正数。</p><p>以这组频率作为输入，可以调用任何CBA式算法构造出huffman编码树，一旦得到这样一棵编码树，只需一趟层次遍历，即可在$O(n)$时间内得到所有叶节点的遍历序列。</p><p>根据huffman编码树的定义，该树必然是单调的。因此，整个过程也等效于同时完成了对原输入序列的排序。</p><p>若待编码字符集已按出现频率排序，则huffman编码可以更快完成。始终将森林中的树分为两类：单节点(尚未参与合并)和多节点(已合并过)。每经过一次迭代，后者虽不见得增多，但必然有一个新成员。</p><p>根据huffman编码树的原理，每次迭代都是在当前森林中选取权重最小的两棵树合并，因此，被选出的树权重必然单调非降，故在当前所有(经合成生成后)多节点树中，最新者的权重必然最大。</p><p>将以上两类节点组织为两个队列，初始状态下，所有字符按照权重非降的次序存入单节点的队列，而多节点的队列，直接置空。此后的过程与常规的huffman编码树类似，反复取出权重最小的两棵树，将其合并后插回森林，直至最后只剩下一棵树</p><h1 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h1><p><strong>关联数组</strong>（<strong>Associative Array</strong>），又称<strong>映射</strong>（<strong>Map</strong>）、<strong>字典</strong>（<strong>Dictionary</strong>）是一个抽象的数据结构、，它包含着类似于（键，值）的有序对。一个关联数组中的有序对可以重复（如C++中的multimap）也可以不重复（如C++中的map)。</p><p>Trie在计算机科学中又称前缀树和键树，是一种保存关联数组的有序树，其中的键通常是字符串。与<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的<a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80">前缀</a>，也就是这个节点对应的字符串，而根节点对应<a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">空字符串</a>。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p><p>Trie这个术语来自于re<strong>trie</strong>val，trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p><p>任一字符串集s都可表示为一棵键树。键树是有根有序树，其中每个节点均有r个分支，深度为d的节点对应于长度为d的字符串，祖先对应的字符串必定为后代所对应字符串的前缀。键树只保留与S中字符串相对应的节点，其余分支均标记为null。</p><p>因为并不确保字符串相互不为前缀，所以对应于完整字符串的节点未必是叶子，每个非空指针通过标志位来表明是否表示s中某个完整的字符串。</p><p>基于键树实现词典的<code>get()</code>,<code>put()</code>,<code>remove()</code>接口时间复杂度分别为$O(h)$,$O(hr)$,$O(hr)$。</p><blockquote><p>若以向量实现键树，则put(),remove()复杂度中的因子r不可消除</p></blockquote><p>在最坏情况下，在创建每个节点后，都需要花费$O(r)$时间，将对应向量中的每个指针都初始化为NULL。</p><p>同样，在最坏情况下，在删除每个节点后，都需要花费$O(r)$时间确认对应向量是否都是NULL。</p><p>以上方式在最坏情况下需要$\Omega(nr)$空间，其中$n=|s|$为字符串的规模。若s中的字符串均互不为前缀，则每个字符串都将对应于一个叶节点。于是，即便只计入这$n$个叶节点，累计空间总量为$\Omega(nr)$。</p><p>若用链表来实现各节点，每个节点的规模与实际的分支数成正比，每个字符串的每个字符至多占用$O(1)$空间，故所需空间总量线性正比于S中所有字符串的长度总和，同时，在每个节点需要$O( r )$时间顺序查找以确定深入的分支方向。get()接口的效率将降至$O(hr)$,其中h为树高，同时也是S中字符串的最大长度。</p><h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p>键树中往往包含大量的单分支节点，通过折叠合并相邻的单分支节点，进一步提高键树的效率。</p><p><strong>基数树</strong>，或称Patricia trie/tree，或crit bit tree，<strong>压缩前缀树</strong>，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。一棵Patricia Trie的任何内部结点有2个或以上的孩子结点。</p><p>将向量地单分支节点合成一个大节点，尽管一定程度上可以提高时、空效率，但是在渐进意义上并无实质改进。</p><p>应用：</p><ul><li>构建<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组</a></li><li>用于<a href="https://zh.wikipedia.org/wiki/IP">IP</a> <a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1">路由</a></li><li> <a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2">信息检索</a>中用于文本文档的<a href="https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">倒排索引</a>。</li></ul><h2 id="三叉树"><a href="#三叉树" class="headerlink" title="三叉树"></a>三叉树</h2><p>Trie树结构，它的实现简单但空间效率低。如果要支持26个英文字母，每个节点就要保存26个指针，假若我们还要支持国际字符、标点符号、区分大小写，内存用量就会急剧上升，以至于不可行。</p><p>类似于二叉查找树，三叉查找树(ternarry tree)可以用于实现带前缀搜索功能的关联数组。比标准的前缀树更省空间，但是查找速度有所下降。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;树是一种分层结构，而层次化这一结构几乎蕴含于所有事物及其联系中，称为其本质属性之一。从文件系统、互联网域名系统，一直到地球生态系统乃至人类社会系统，层次化特征和层次化结构均无所不在。二叉树不再是简单的线性结构，但确定某种次序后具有线性特征，故树属于半线性结构。&lt;/p&gt;
&lt;p&gt;树等价于无环联通图，因此与一般的图相同，树也由一组顶点和联接于其间的若干条边组成，故任一节点与根节点之间存在着唯一路径。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>栈和队列</title>
    <link href="http://twinkle0331.github.io/algorithm/stack/"/>
    <id>http://twinkle0331.github.io/algorithm/stack/</id>
    <published>2019-08-31T06:14:34.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>相对于一般序列结构，栈和队列的操作仅限于逻辑上特定的某端，二者元素接受操作的次序不同，简而言之，栈是先进后出，而队列为先进先出。在信息处理领域，栈和队列的身影随处可见，不少程序设计语言即建立在栈结构之上，我们日常生活中对自然资源和社会资源分配、调度银行和医院服务窗口可借助队列实现合理和优化的分配。</p><a id="more"></a><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是存放数据对象的一种特殊容器，其中的数据元素按线性的逻辑次序排列，但是插入操作仅限于栈的某一特定端，只能在栈顶插入和删除。栈中元素接受操作的次序必然遵循所谓的后进先出规律：从栈的整个生命周期来看，更晚出栈的元素应为更早入栈者。</p><p><strong>栈和递归</strong></p><p>调用栈的基本单位是帧，每次函数调用时都会相应地创建一帧，记录该函数在二进制程序中的返回地址，以及局部变量、传入参数等，并将该帧压入调用栈。在任一时刻，调用栈中的各帧依次对应于那些尚未返回的调用的实例，即当时的活跃函数实例</p><h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="逆序输出"><a href="#逆序输出" class="headerlink" title="逆序输出"></a>逆序输出</h2><p>输出次序和处理过程颠倒，递归深度和输出长度不易预知</p><p><strong>进制转换</strong></p><blockquote><p>给定任意10进制非负整数，将其转换为d进制表示形式</p></blockquote><p>迭代模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span> <span class="params">( Stack&lt;<span class="keyword">char</span>&gt;&amp; S, __int64 n, <span class="keyword">int</span> base )</span> </span>&#123; <span class="comment">//十进制数n到base进制的转换（迭代版）</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> digit[] <span class="comment">//0 &lt; n, 1 &lt; base &lt;= 16，新进制下的数位符号，可视base取值范围适当扩充</span></span><br><span class="line">   = &#123; <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span> &#125;;</span><br><span class="line">   <span class="keyword">while</span> ( n &gt; <span class="number">0</span> ) &#123; <span class="comment">//由低到高，逐一计算出新进制下的各数位</span></span><br><span class="line">      <span class="keyword">int</span> remainder = ( <span class="keyword">int</span> ) ( n % base ); S.push ( digit[remainder] ); <span class="comment">//余数（当前位）入栈</span></span><br><span class="line">      n /= base; <span class="comment">//n更新为其对base的除商</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//新进制下由高到低的各数位，自顶而下保存于栈S中</span></span><br></pre></td></tr></table></figure><p>递归模式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span> <span class="params">( Stack&lt;<span class="keyword">char</span>&gt;&amp; S, __int64 n, <span class="keyword">int</span> base )</span> </span>&#123; <span class="comment">//十进制正整数n到base进制的转换（递归版）</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> digit[] <span class="comment">//0 &lt; n, 1 &lt; base &lt;= 16，新进制下的数位符号，可视base取值范围适当扩充</span></span><br><span class="line">   = &#123; <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span> &#125;;</span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt; n ) &#123; <span class="comment">//在尚有余数之前，反复地</span></span><br><span class="line">      S.push ( digit[n % base] ); <span class="comment">//逆向记录当前最低位，再</span></span><br><span class="line">      convert ( S, n / base, base ); <span class="comment">//通过递归得到所有更高位</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//新进制下由高到低的各数位，自顶而下保存于栈S中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span> </span>&#123;</span><br><span class="line">      Stack&lt;<span class="keyword">char</span>&gt; S; <span class="comment">//用栈记录转换得到的各数位</span></span><br><span class="line">      convert ( S, n, base ); <span class="comment">//进制转换</span></span><br><span class="line">      <span class="keyword">while</span> ( !S.empty() ) <span class="built_in">printf</span> ( <span class="string">&quot;%c&quot;</span>, ( S.pop() ) ); <span class="comment">//逆序输出栈内数位，即正确结果</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归嵌套"><a href="#递归嵌套" class="headerlink" title="递归嵌套"></a>递归嵌套</h2><p>具有自相似性的问题可递归描述，但分支位置和嵌套深度不固定</p><p><strong>括号匹配</strong></p><blockquote><p>检查表达式括号是否匹配</p></blockquote><p>递归实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trim</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span>&amp; lo, <span class="keyword">int</span>&amp; hi )</span> </span>&#123; <span class="comment">//删除exp[lo, hi]不含括号的最长前缀、后缀</span></span><br><span class="line">   <span class="keyword">while</span> ( ( lo &lt;= hi ) &amp;&amp; ( <span class="built_in">exp</span>[lo] != <span class="string">&#x27;(&#x27;</span> ) &amp;&amp; ( <span class="built_in">exp</span>[lo] != <span class="string">&#x27;)&#x27;</span> ) ) lo++; <span class="comment">//查找第一个和</span></span><br><span class="line">   <span class="keyword">while</span> ( ( lo &lt;= hi ) &amp;&amp; ( <span class="built_in">exp</span>[hi] != <span class="string">&#x27;(&#x27;</span> ) &amp;&amp; ( <span class="built_in">exp</span>[hi] != <span class="string">&#x27;)&#x27;</span> ) ) hi--; <span class="comment">//最后一个括号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi )</span> </span>&#123; <span class="comment">//切分exp[lo, hi]，使exp匹配仅当子表达式匹配</span></span><br><span class="line">   <span class="keyword">int</span> mi = lo; <span class="keyword">int</span> crc = <span class="number">1</span>; <span class="comment">//crc为[lo, mi]范围内左、右括号数目之差</span></span><br><span class="line">   <span class="keyword">while</span> ( ( <span class="number">0</span> &lt; crc ) &amp;&amp; ( ++mi &lt; hi ) ) <span class="comment">//逐个检查各字符，直到左、右括号数目相等，或者越界</span></span><br><span class="line">      &#123;  <span class="keyword">if</span> ( <span class="built_in">exp</span>[mi] == <span class="string">&#x27;)&#x27;</span> )  crc--; <span class="keyword">if</span> ( <span class="built_in">exp</span>[mi] == <span class="string">&#x27;(&#x27;</span> )  crc++;  &#125; <span class="comment">//左、右括号分别计数</span></span><br><span class="line">   <span class="keyword">return</span> mi; <span class="comment">//若mi &lt;= hi，则为合法切分点；否则，意味着局部不可能匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">paren</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi )</span> </span>&#123; <span class="comment">//检查表达式exp[lo, hi]是否括号匹配（递归版）</span></span><br><span class="line">   trim ( <span class="built_in">exp</span>, lo, hi ); <span class="keyword">if</span> ( lo &gt; hi ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//清除不含括号的前缀、后缀</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="built_in">exp</span>[lo] != <span class="string">&#x27;(&#x27;</span> ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//首字符非左括号，则必不匹配</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="built_in">exp</span>[hi] != <span class="string">&#x27;)&#x27;</span> ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//末字符非右括号，则必不匹配</span></span><br><span class="line">   <span class="keyword">int</span> mi = divide ( <span class="built_in">exp</span>, lo, hi ); <span class="comment">//确定适当的切分点</span></span><br><span class="line">   <span class="keyword">if</span> ( mi &gt; hi ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//切分点不合法，意味着局部以至整体不匹配</span></span><br><span class="line">   <span class="keyword">return</span> paren ( <span class="built_in">exp</span>, lo + <span class="number">1</span>, mi - <span class="number">1</span> ) &amp;&amp; paren ( <span class="built_in">exp</span>, mi + <span class="number">1</span>, hi ); <span class="comment">//分别检查左、右子表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">paren</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi )</span> </span>&#123; <span class="comment">//表达式括号匹配检查，可兼顾三种括号</span></span><br><span class="line">   Stack&lt;<span class="keyword">char</span>&gt; S; <span class="comment">//使用栈记录已发现但尚未匹配的左括号</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = lo; i &lt;= hi; i++ ) <span class="comment">/* 逐一检查当前字符 */</span> <span class="comment">/*DSA*/</span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> ( <span class="built_in">exp</span>[i] ) &#123; <span class="comment">//左括号直接进栈；右括号若与栈顶失配，则表达式必不匹配</span></span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: S.push ( <span class="built_in">exp</span>[i] ); <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: <span class="keyword">if</span> ( ( S.empty() ) || ( <span class="string">&#x27;(&#x27;</span> != S.pop() ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>: <span class="keyword">if</span> ( ( S.empty() ) || ( <span class="string">&#x27;[&#x27;</span> != S.pop() ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>: <span class="keyword">if</span> ( ( S.empty() ) || ( <span class="string">&#x27;&#123;&#x27;</span> != S.pop() ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>: <span class="keyword">break</span>; <span class="comment">//非括号字符一律忽略</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> S.empty(); <span class="comment">//整个表达式扫描过后，栈中若仍残留（左）括号，则不匹配；否则（栈空）匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈混洗</strong></p><p>考察栈$A=&lt;a_1,a_2,…,a_n]$,$B$为空栈,A左端为栈顶</p><p>只允许将A的顶元素弹出并压入S,或将S的顶元素弹出并压入B</p><p>经过上述一系列操作后，A中元素全部转入B中，</p><p>$B=[a_{k1},a_{k2},…,a_{kn} &gt;$，B右端为栈顶</p><p>同一输入序列，可有多种栈混洗</p><p>$[1,2,3,4&gt;,[4,3,2,1&gt;,[3,2,4,1&gt;$</p><p>长度为$n$的栈混洗，可能的栈混洗个数<br>$$<br>SP(n)=\frac{(2n)!}{n!(n+1)!}<br>$$<br>设s在$k$次pop之后首次重新变空，则$k$无非$n$种情况</p><p>$SP(n)=\sum_{k=1}^{n}SP(k-1)SP(n-k)=catalan(n)$</p><blockquote><p>设B为A的任意排列，则B为A的一个栈混洗，当且仅当对于任意的1&lt;=i&lt;j&lt;k&lt;=n,不存在{…,k,…,i,…,j…} </p></blockquote><p>先证明仅当，首先，对于输入序列中的任意三个元素，其在输出序列中是否存在一个可行的相对排列次序与其它元素无关。不妨只关注这三个元素${i,j,k}$</p><p>无论如何,元素$i,j$必然先于$k$(弹出A并随即压入B中)压入中转栈S,若输出序列${k,i,j}$存在，则意味着这三个元素中，k必然首先从栈S中弹出，并且根据先进后出的规律，此时$i,j$存在于栈S中，且顺序只能为$j,i$，三者的次序必然是${k,j,i}$则$k$率先从栈S弹出，则三者压入输出栈B的次序必然是${k,j,i}$,而不是${k,i,j}$。</p><p>再证明当，对于任何不含禁形的输出序列，都可给出对应的栈混洗过程。</p><blockquote><p>对任意1&lt;=i&lt;j&lt;=n,B中都不含模式{…,j+1,…,i,…,j…},则B必定为A的一个栈混洗</p></blockquote><p>将${j+1,i,j}$视作新一类的禁形，称为615禁形，${k,i,j}$称为915禁形。</p><p>接下来证明，只要B中含有915禁形，必然也含有615禁形，当然，两者中的$i,j$未必一致</p><p>假定对于任何的$k-i&lt;d$,以上命题均成立，接下来考虑$k-i=d$的情况</p><p>不妨设$i&lt;j&lt;k-1$,于是元素$k-1$在B中的相对于$i$的位置无非两种可能</p><ol><li><strong>k-1位于i的左方(前方)</strong>  此时${k-1,i,j}$即915禁形，$k-1-i&lt;d$，所以必然含有615禁形</li><li><strong>k-1位于i的右侧</strong> ${k,i,k-1}$即构成一个615禁形</li></ol><blockquote><p>若对任意1&lt;j&lt;k&lt;=n，B中都不含模式{…,k,…,j-1,…,j…},则B未必为A的栈混洗</p></blockquote><p>945特征${k,j-1,j}$不称作禁形，915禁形未必含有945模式。</p><p>例如，B={2,4,1,3}</p><p>其中{3,1,2},{4,1,2},{4,2,3}，不含有任何945模式，但是却含有915模式{4,2,3},同时也是615模式。</p><h2 id="延迟缓冲"><a href="#延迟缓冲" class="headerlink" title="延迟缓冲"></a>延迟缓冲</h2><p>在一些应用问题中，输入可分解为多个单元并通过迭代依次扫描处理，但过程中的各步计算往往滞后于扫描的进度，需要待到必要信息已完整到一定程度时才能做出判断。在这类场合，栈结构可以扮演缓冲区的角色。</p><p><strong>表达式求值</strong></p><p>自左向右扫描表达式，用栈记录已经扫描的部分(含执行计算的结果)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_OPTR 9 <span class="comment">//运算符总数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE &#125; Operator; <span class="comment">//运算符集合</span></span><br><span class="line"><span class="comment">//加、减、乘、除、乘方、阶乘、左括号、右括号、起始符与终止符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> pri[N_OPTR][N_OPTR] = &#123; <span class="comment">//运算符优先等级 [栈顶] [当前]</span></span><br><span class="line">   <span class="comment">/*              |-------------------- 当 前 运 算 符 --------------------| */</span></span><br><span class="line">   <span class="comment">/*              +      -      *      /      ^      !      (      )      \0 */</span></span><br><span class="line">   <span class="comment">/* --  + */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* |   - */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 栈  * */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 顶  / */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 运  ^ */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 算  ! */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 符  ( */</span>    <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;=&#x27;</span>,   <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">   <span class="comment">/* |   ) */</span>    <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">   <span class="comment">/* -- \0 */</span>    <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27;=&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">evaluate</span> <span class="params">( <span class="keyword">char</span>* S, <span class="keyword">char</span>*&amp; RPN )</span> </span>&#123; <span class="comment">//对（已剔除白空格的）表达式S求值，并转换为逆波兰式RPN</span></span><br><span class="line">   Stack&lt;<span class="keyword">float</span>&gt; opnd; Stack&lt;<span class="keyword">char</span>&gt; optr; <span class="comment">//运算数栈、运算符栈 任何时刻，其中每对相邻元素之间均大小一致</span></span><br><span class="line">   <span class="keyword">char</span>* expr = S;</span><br><span class="line">   optr.push ( <span class="string">&#x27;\0&#x27;</span> ); <span class="comment">//尾哨兵&#x27;\0&#x27;也作为头哨兵首先入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( !optr.empty() ) &#123; <span class="comment">//在运算符栈非空之前，逐个处理表达式中各字符</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">isdigit</span> ( *S ) ) &#123; <span class="comment">//若当前字符为操作数，则</span></span><br><span class="line">         readNumber ( S, opnd ); append ( RPN, opnd.top() ); <span class="comment">//读入操作数，并将其接至RPN末尾</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//若当前字符为运算符，则</span></span><br><span class="line">         <span class="keyword">switch</span> ( orderBetween ( optr.top(), *S ) ) &#123; <span class="comment">//视其与栈顶运算符之间优先级高低分别处理</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>: <span class="comment">//栈顶运算符优先级更低时</span></span><br><span class="line">               optr.push ( *S ); S++; <span class="comment">//计算推迟，当前运算符进栈</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>: <span class="comment">//优先级相等（当前运算符为右括号或者尾部哨兵&#x27;\0&#x27;）时</span></span><br><span class="line">               optr.pop(); S++; <span class="comment">//脱括号并接收下一个字符</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>: &#123; <span class="comment">//栈顶运算符优先级更高时，可实施相应的计算，并将结果重新入栈</span></span><br><span class="line">               <span class="keyword">char</span> op = optr.pop(); append ( RPN, op ); <span class="comment">//栈顶运算符出栈并续接至RPN末尾</span></span><br><span class="line">               <span class="keyword">if</span> ( <span class="string">&#x27;!&#x27;</span> == op ) &#123; <span class="comment">//若属于一元运算符</span></span><br><span class="line">                  <span class="keyword">float</span> pOpnd = opnd.pop(); <span class="comment">//只需取出一个操作数，并</span></span><br><span class="line">                  opnd.push ( calcu ( op, pOpnd ) ); <span class="comment">//实施一元计算，结果入栈</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123; <span class="comment">//对于其它（二元）运算符</span></span><br><span class="line">                  <span class="keyword">float</span> pOpnd2 = opnd.pop(), pOpnd1 = opnd.pop(); <span class="comment">//取出后、前操作数</span></span><br><span class="line">                  opnd.push ( calcu ( pOpnd1, op, pOpnd2 ) ); <span class="comment">//实施二元计算，结果入栈</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> : <span class="built_in">exit</span> ( <span class="number">-1</span> ); <span class="comment">//逢语法错误，不做处理直接退出</span></span><br><span class="line">         &#125;<span class="comment">//switch</span></span><br><span class="line">   &#125;<span class="comment">//while</span></span><br><span class="line">   <span class="keyword">return</span> opnd.pop(); <span class="comment">//弹出并返回最后的计算结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>试改进evaluate()算法，检查表达式的语法是否正确</p></blockquote><p>确认每个操作符与其所对应操作数之间的相对位置符合中缀表达式的语法，在每个操作数入栈时，操作数的规模应该刚好比操作符栈的规模大一。注意，这里的操作符不包括括号和头尾标识符。</p><p><strong>逆波兰表达式</strong></p><p>逆波兰表达式在由运算符和操作数组成的表达式中，不使用括号即可表达带优先级的运算关系。</p><p>RPN转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">( <span class="keyword">char</span>*&amp; rpn, <span class="keyword">float</span> opnd )</span> </span>&#123; <span class="comment">//将操作数接至RPN末尾</span></span><br><span class="line">   <span class="keyword">int</span> n = <span class="built_in">strlen</span> ( rpn ); <span class="comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span></span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">   <span class="keyword">if</span> ( opnd != ( <span class="keyword">float</span> ) ( <span class="keyword">int</span> ) opnd ) <span class="built_in">sprintf</span> ( buf, <span class="string">&quot;%.2f \0&quot;</span>, opnd ); <span class="comment">//浮点格式，或</span></span><br><span class="line">   <span class="keyword">else</span>                          <span class="built_in">sprintf</span> ( buf, <span class="string">&quot;%d \0&quot;</span>, ( <span class="keyword">int</span> ) opnd ); <span class="comment">//整数格式</span></span><br><span class="line">   rpn = ( <span class="keyword">char</span>* ) <span class="built_in">realloc</span> ( rpn, <span class="keyword">sizeof</span> ( <span class="keyword">char</span> ) * ( n + <span class="built_in">strlen</span> ( buf ) + <span class="number">1</span> ) ); <span class="comment">//扩展空间</span></span><br><span class="line">   <span class="built_in">strcat</span> ( rpn, buf ); <span class="comment">//RPN加长</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">( <span class="keyword">char</span>*&amp; rpn, <span class="keyword">char</span> optr )</span> </span>&#123; <span class="comment">//将运算符接至RPN末尾</span></span><br><span class="line">   <span class="keyword">int</span> n = <span class="built_in">strlen</span> ( rpn ); <span class="comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span></span><br><span class="line">   rpn = ( <span class="keyword">char</span>* ) <span class="built_in">realloc</span> ( rpn, <span class="keyword">sizeof</span> ( <span class="keyword">char</span> ) * ( n + <span class="number">3</span> ) ); <span class="comment">//扩展空间</span></span><br><span class="line">   <span class="built_in">sprintf</span> ( rpn + n, <span class="string">&quot;%c &quot;</span>, optr ); rpn[n + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//接入指定的运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>RPN表达式无需括号即可确定运算优先级，是否意味着所占空间必少于常规表达式</p></blockquote><p>未必，尽管RPN表达式可省去括号，但是必须在相邻的操作数、操作符之间插入特定的分隔符(通常为空格)。这种分隔符必须事先约定，且不能用以表示操作符和操作数，故称为元字符。引入元字符的数目与操作数和操作符的数目相当，故所占空间未必少于原表达式。</p><blockquote><p>既然evaluate()算法已经可以求值，同时完成RPN转换有何意义</p></blockquote><p>同样长度（指同样多操作数）的 RPN 比中缀表达式算得快。</p><p>若每个操作数都是一个具体的数，把中缀表达式转成 RPN 的过程已经足以得到中缀表达式的值，这种情况下转成 RPN 再计算得不偿失。</p><p>但是，操作数可能是一个未知数。例如中缀表达式 <code>(a + b) * c</code> 分别代入 n 组具体数字计算表达式值，例如代入 <code>(a=1,b=2,c=3)</code> 、 <code>(a=4,b=5,c=6)</code> 、 <code>(a=10,b=11,c=12)</code> 求值。不转就要算 n 次中缀表达式，转就只要转 1 次 + 算 n 次 RPN 。</p><blockquote><p>逆波兰表达式的优点</p></blockquote><ul><li>当有操作符时就计算，因此，表达式并不是从右至左整体计算而是每次由中心向外计算一部分，这样在复杂运算中就很少导致操作符错误。</li><li>堆栈自动记录中间结果，这就是为什么逆波兰计算器能容易对任意复杂的表达式求值。与普通科学计算器不同，它对表达式的复杂性没有限制。</li><li>逆波兰表达式中不需要括号，用户只需按照表达式顺序求值，让堆栈自动记录中间结果；同样的，也不需要指定操作符的优先级。</li><li>机器状态永远是一个堆栈状态，堆栈里是需要运算的操作数，栈内不会有操作符。</li></ul><h2 id="试探回溯法"><a href="#试探回溯法" class="headerlink" title="试探回溯法"></a>试探回溯法</h2><p>根据候选解的某些局部特征，即可判断其是否合理，以候选解的子集为单位批量地删除称为剪枝。</p><p><strong>试探回溯模式</strong></p><p>从0开始，逐渐增加候选解长度，一旦发现注定要失败，则收缩至前以长度，并继续试探。</p><p><strong>N皇后问题</strong></p><blockquote><p>在n*n的棋盘上放置n个皇后，使得她们互不攻击</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">placeQueens</span> <span class="params">( <span class="keyword">int</span> N )</span> </span>&#123; <span class="comment">//N皇后算法（迭代版）：采用试探/回溯的策略，借助栈记录查找的结果</span></span><br><span class="line">   Stack&lt;Queen&gt; solu; <span class="comment">//存放（部分）解的栈</span></span><br><span class="line">   <span class="function">Queen <span class="title">q</span> <span class="params">( <span class="number">0</span>, <span class="number">0</span> )</span></span>; <span class="comment">//从原点位置出发</span></span><br><span class="line">   <span class="keyword">do</span> &#123; <span class="comment">//反复试探、回溯</span></span><br><span class="line">      <span class="keyword">if</span> ( N &lt;= solu.size() || N &lt;= q.y ) &#123; <span class="comment">//若已出界，则</span></span><br><span class="line">         q = solu.pop(); q.y++; <span class="comment">//回溯一行，并继续试探下一列</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则，试探下一行</span></span><br><span class="line">         <span class="keyword">while</span> ( ( q.y &lt; N ) &amp;&amp; ( <span class="number">0</span> &lt;= solu.find ( q ) ) ) <span class="comment">//通过与已有皇后的比对</span></span><br><span class="line">            <span class="comment">/*DSA*/</span><span class="comment">//while ((q.y &lt; N) &amp;&amp; (solu.find(q))) //（若基于List实现Stack，则find()返回值的语义有所不同）</span></span><br><span class="line">            &#123; q.y++; nCheck++; &#125; <span class="comment">//尝试找到可摆放下一皇后的列</span></span><br><span class="line">         <span class="keyword">if</span> ( N &gt; q.y ) &#123; <span class="comment">//若存在可摆放的列，则</span></span><br><span class="line">            solu.push ( q ); <span class="comment">//摆上当前皇后，并</span></span><br><span class="line">            <span class="keyword">if</span> ( N &lt;= solu.size() ) nSolu++; <span class="comment">//若部分解已成为全局解，则通过全局变量nSolu计数</span></span><br><span class="line">            q.x++; q.y = <span class="number">0</span>; <span class="comment">//转入下一行，从第0列开始，试探下一皇后</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> ( ( <span class="number">0</span> &lt; q.x ) || ( q.y &lt; N ) ); <span class="comment">//所有分支均已或穷举或剪枝之后，算法结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迷宫寻径</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">labyrinth</span> <span class="params">( Cell Laby[LABY_MAX][LABY_MAX], Cell* s, Cell* t )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( ( AVAILABLE != s-&gt;status ) || ( AVAILABLE != t-&gt;status ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//退化情况</span></span><br><span class="line">   Stack&lt;Cell*&gt; path; <span class="comment">//用栈记录通路（Theseus的线绳）</span></span><br><span class="line">   s-&gt;incoming = UNKNOWN; s-&gt;status = ROUTE; path.push ( s ); <span class="comment">//起点</span></span><br><span class="line">   <span class="keyword">do</span> &#123; <span class="comment">//从起点出发不断试探、回溯，直到抵达终点，或者穷尽所有可能</span></span><br><span class="line">      <span class="comment">/*DSA*/</span>displayLaby(); <span class="comment">/*path.traverse(printLabyCell); printLabyCell(path.top());*/</span> getchar();</span><br><span class="line">      Cell* c = path.top(); <span class="comment">//检查当前位置（栈顶）</span></span><br><span class="line">      <span class="keyword">if</span> ( c == t ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//若已抵达终点，则找到了一条通路；否则，沿尚未试探的方向继续试探</span></span><br><span class="line">      <span class="keyword">while</span> ( NO_WAY &gt; ( c-&gt;outgoing = nextESWN ( c-&gt;outgoing ) ) ) <span class="comment">//逐一检查所有方向</span></span><br><span class="line">         <span class="keyword">if</span> ( AVAILABLE == neighbor ( c )-&gt;status ) <span class="keyword">break</span>; <span class="comment">//试图找到尚未试探的方向</span></span><br><span class="line">      <span class="keyword">if</span> ( NO_WAY &lt;= c-&gt;outgoing ) <span class="comment">//若所有方向都已尝试过</span></span><br><span class="line">         &#123; c-&gt;status = BACKTRACKED; c = path.pop(); &#125;<span class="comment">//则向后回溯一步</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则，向前试探一步</span></span><br><span class="line">         &#123; path.push ( c = advance ( c ) ); c-&gt;outgoing = UNKNOWN; c-&gt;status = ROUTE; &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> ( !path.empty() );</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>与栈一样，队列也是存放数据对象的一种容器，其中的数据对象也按线性逻辑次序排列。同样只允许在队列两端进行操作，若插入对象只能从其中某一端，而删除只能从另外一端，将允许取出元素的一头称为队首，另外一端称为队尾。队列中各对象的操作次序遵循先进先出的规律：更早出队的元素应为更早入队者。</p><h1 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h1><h2 id="循环分配器"><a href="#循环分配器" class="headerlink" title="循环分配器"></a>循环分配器</h2><p>一群客户共享同一资源时，按照先来后到的顺序分配资源，例如多个应用程序共享cpu，实验室成员共享打印机</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RoundRobin&#123;</span><br><span class="line">     <span class="function">Queue <span class="title">Q</span><span class="params">(clients)</span></span>;</span><br><span class="line">     <span class="keyword">while</span>(!ServiceClosed())&#123;</span><br><span class="line">         e=Q.enqueue();</span><br><span class="line">         serve(e);</span><br><span class="line">         Q.enqueue(e);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="银行服务模拟"><a href="#银行服务模拟" class="headerlink" title="银行服务模拟"></a>银行服务模拟</h2><p>以银行这一典型场景为例，利用队列结构实现队顾客服务的调度和优化。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate</span> <span class="params">( <span class="keyword">int</span> nWin, <span class="keyword">int</span> servTime )</span> </span>&#123; <span class="comment">//按指定窗口数、服务总时间模拟银行业务</span></span><br><span class="line">   Queue&lt;Customer&gt;* windows = <span class="keyword">new</span> Queue&lt;Customer&gt;[nWin]; <span class="comment">//为每一窗口创建一个队列</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> now = <span class="number">0</span>; now &lt; servTime; now++ ) &#123; <span class="comment">//在下班之前，每隔一个单位时间</span></span><br><span class="line">      <span class="keyword">if</span> ( rand() % ( <span class="number">1</span> + nWin ) ) &#123; <span class="comment">//新顾客以nWin/(nWin + 1)的概率到达</span></span><br><span class="line">         Customer c ; c.time = <span class="number">1</span> + rand() % <span class="number">98</span>; <span class="comment">//新顾客到达，服务时长随机确定</span></span><br><span class="line">         c.window = bestWindow ( windows, nWin ); <span class="comment">//找出最佳（最短）的服务窗口/*DSA*/ToDo: 更精细的策略</span></span><br><span class="line">         windows[c.window].enqueue ( c ); <span class="comment">//新顾客加入对应的队列</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nWin; i++ ) <span class="comment">//分别检查</span></span><br><span class="line">         <span class="keyword">if</span> ( !windows[i].empty() ) <span class="comment">//各非空队列</span></span><br><span class="line">            <span class="keyword">if</span> ( -- windows[i].front().time &lt;= <span class="number">0</span> ) <span class="comment">//队首顾客的服务时长减少一个单位</span></span><br><span class="line">               windows[i].dequeue(); <span class="comment">//服务完毕的顾客出列，由后继顾客接替</span></span><br><span class="line">   &#125; <span class="comment">//for</span></span><br><span class="line">   <span class="keyword">delete</span> [] windows; <span class="comment">//释放所有队列（此前，~List()会自动清空队列）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bestWindow</span> <span class="params">( Queue&lt;Customer&gt; windows[], <span class="keyword">int</span> nWin )</span> </span>&#123; <span class="comment">//为新到顾客确定最佳队列</span></span><br><span class="line">   <span class="keyword">int</span> minSize = windows[<span class="number">0</span>].size(), optiWin = <span class="number">0</span>; <span class="comment">//最优队列（窗口）</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nWin; i++ ) <span class="comment">//在所有窗口中</span></span><br><span class="line">      <span class="keyword">if</span> ( minSize &gt; windows[i].size() ) <span class="comment">//挑选出</span></span><br><span class="line">         &#123; minSize = windows[i].size(); optiWin = i; &#125; <span class="comment">//队列最短者</span></span><br><span class="line">   <span class="keyword">return</span> optiWin; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;相对于一般序列结构，栈和队列的操作仅限于逻辑上特定的某端，二者元素接受操作的次序不同，简而言之，栈是先进后出，而队列为先进先出。在信息处理领域，栈和队列的身影随处可见，不少程序设计语言即建立在栈结构之上，我们日常生活中对自然资源和社会资源分配、调度银行和医院服务窗口可借助队列实现合理和优化的分配。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
  <entry>
    <title>列表</title>
    <link href="http://twinkle0331.github.io/algorithm/list/"/>
    <id>http://twinkle0331.github.io/algorithm/list/</id>
    <published>2019-08-30T11:55:17.000Z</published>
    <updated>2021-03-27T13:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据是否修改数据结构，所有操作分为两类方式</p><ul><li>静态：仅读取，数据结构的内容和组成不变</li><li>动态：需写入，数据结构的局部或整体将改变</li></ul><p>与操作方式相对应的，数据元素的存储和组织形式也分为两种</p><ul><li>静态：数据空间整体创建和销毁</li><li>动态：为各个数据元素动态地分配和回收的物理空间，相邻元素记录彼此的物理地址，在逻辑上形成一个整体，可支持高效的动态操作。</li></ul><p>列表是采用动态存储的典型结构，循位置访问，通过节点之间的相互引用找到特定的节点。借助列表设计算法时，应更多地借助逻辑上相邻元素之间的位置索引。</p><a id="more"></a><h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><h2 id="循秩访问"><a href="#循秩访问" class="headerlink" title="循秩访问"></a>循秩访问</h2><p>模仿向量的循秩访问方式，重载下标操作符，时间复杂度$O(r)$，线性正比于待访问的秩</p><p>以均匀分布为例，单次访问的期望复杂度为$\displaystyle\frac {1+2+3+4+…+n} n = (n+1)/2= o(n)$</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>在节点p(可能为尾节点)的n个真前驱中找到等于e的最后者</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListNodePosi(T) List&lt;T&gt;::find ( T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, ListNodePosi(T) p ) <span class="keyword">const</span> &#123;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; n-- ) <span class="comment">//（0 &lt;= n &lt;= rank(p) &lt; _size）对于p的最近的n个前驱，从右向左</span></span><br><span class="line">      <span class="keyword">if</span> ( e == ( p = p-&gt;pred )-&gt;data ) <span class="keyword">return</span> p; <span class="comment">//逐个比对，直至命中或范围越界</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//p越出左边界意味着区间内不含e，查找失败</span></span><br><span class="line">&#125; <span class="comment">//失败时，返回NULL</span></span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入时间复杂度为$ O(1)$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ListNodePosi(T) ListNode&lt;T&gt;::insertAsPred ( T <span class="keyword">const</span>&amp; e ) &#123;</span><br><span class="line">   ListNodePosi(T) x = <span class="keyword">new</span> ListNode ( e, pred, <span class="keyword">this</span> ); <span class="comment">//创建新节点</span></span><br><span class="line">   pred-&gt;succ = x; pred = x; <span class="comment">//设置正向链接</span></span><br><span class="line">   <span class="keyword">return</span> x; <span class="comment">//返回新节点的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除时间复杂度同样为$ O(1)$</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T List&lt;T&gt;::remove ( ListNodePosi(T) p ) &#123; <span class="comment">//删除合法节点p，返回其数值</span></span><br><span class="line">   T e = p-&gt;data; <span class="comment">//备份待删除节点的数值（假定T类型可直接赋值）</span></span><br><span class="line">   p-&gt;pred-&gt;succ = p-&gt;succ; p-&gt;succ-&gt;pred = p-&gt;pred; <span class="comment">//后继、前驱</span></span><br><span class="line">   <span class="keyword">delete</span> p; _size--; <span class="comment">//释放节点，更新规模</span></span><br><span class="line">   <span class="keyword">return</span> e; <span class="comment">//返回备份的数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> List&lt;T&gt;::deduplicate() &#123; <span class="comment">//剔除无序列表中的重复节点</span></span><br><span class="line">   <span class="keyword">if</span> ( _size &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//平凡列表自然无重复</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   ListNodePosi(T) p = header; Rank r = <span class="number">0</span>; <span class="comment">//p从首节点开始</span></span><br><span class="line">   <span class="keyword">while</span> ( trailer != ( p = p-&gt;succ ) ) &#123; <span class="comment">//依次直到末节点</span></span><br><span class="line">      ListNodePosi(T) q = find ( p-&gt;data, r, p ); <span class="comment">//在p的r个（真）前驱中查找雷同者</span></span><br><span class="line">      q ? remove ( q ) : r++; <span class="comment">//若的确存在，则删除之；否则秩加一</span></span><br><span class="line">   &#125; <span class="comment">//assert: 循环过程中的任意时刻，p的所有前驱互不相同</span></span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//列表规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在最好情况下仅需$O(n)$时间,当所有元素均雷同时，仍然需要执行$O(n)$次迭代，每一步只需要$O(1)$时间。当前节点p始终只有一个前驱，因此<code>find()</code>只需常数时间。</p><p>算法最坏情况即为所有元素均彼此互异，当前节点p的前驱数目将随着迭代的推进线性地递增，平均为$O(n)$,算法总体复杂度为$O(n^2)$。</p><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><h2 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> List&lt;T&gt;::uniquify() &#123; <span class="comment">//成批剔除重复元素，效率更高</span></span><br><span class="line">   <span class="keyword">if</span> ( _size &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//平凡列表自然无重复</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   ListNodePosi(T) p = first(); ListNodePosi(T) q; <span class="comment">//p为各区段起点，q为其后继</span></span><br><span class="line">   <span class="keyword">while</span> ( trailer != ( q = p-&gt;succ ) ) <span class="comment">//反复考查紧邻的节点对(p, q)</span></span><br><span class="line">      <span class="keyword">if</span> ( p-&gt;data != q-&gt;data ) p = q; <span class="comment">//若互异，则转向下一区段</span></span><br><span class="line">      <span class="keyword">else</span> remove ( q ); <span class="comment">//否则（雷同），删除后者</span></span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//列表规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需遍历整个列表一趟，整体运行时间为$ O(n)$，线性正比于列表原先的规模。</p><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ListNodePosi(T) List&lt;T&gt;::search ( T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, ListNodePosi(T) p ) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="comment">// assert: 0 &lt;= n &lt;= rank(p) &lt; _size</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt;= n-- ) <span class="comment">//对于p的最近的n个前驱，从右向左逐个比较</span></span><br><span class="line">      <span class="keyword">if</span> ( ( ( p = p-&gt;pred )-&gt;data ) &lt;= e ) <span class="keyword">break</span>; <span class="comment">//直至命中、数值越界或范围越界</span></span><br><span class="line"><span class="comment">// assert: 至此位置p必符合输出语义约定——尽管此前最后一次关键码比较可能没有意义（等效于与-inf比较）</span></span><br><span class="line">   <span class="keyword">return</span> p; <span class="comment">//返回查找终止的位置</span></span><br><span class="line">&#125; <span class="comment">//失败时，返回区间左边界的前驱（可能是header）——调用者可通过valid()判断成功与否</span></span><br></pre></td></tr></table></figure><p>与无序列表的<code>find()</code>不同，有序列表返回的是不大于e的最后者，而无序列表返回的是等于e的最后者。<code>search</code>多了一次与头哨兵的比较，与查找失败返回NULL语义吻合。两者最好情况下运行时间$O(1)$，最坏情况下为$O(n)$ ；等概率时平均$O(n)$，正比于区间宽度。</p><blockquote><p>为何未能借助有序性提高查找效率，实现不当，还是根本不可能？</p></blockquote><p>按照列表的循位置访问特性，物理存储位置与逻辑次序无关，依据秩的随机访问无法高效实现，而只能根据元素间的引用顺序访问。循位置访问效率较低，故查找效率同样不高。</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>在起泡排序中，每趟扫描交换均需要$O(n)$时间，$O(n)$次比较和$O(n)$次交换，$O(n)$次交换中存在大量无谓的逆向移动，所以整体效率低下。选择排序将序列划分为无序前缀和有序前缀两部分；此外，还要求前缀不大于后缀。每次从前缀中选择最大者，并作为最小元素转移至后缀中。</p><p>选择排序适用于向量与列表在内的任何序列结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//列表的选择排序算法：对起始于位置p的n个元素排序</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::selectionSort ( ListNodePosi(T) p, <span class="keyword">int</span> n ) &#123; <span class="comment">//valid(p) &amp;&amp; rank(p) + n &lt;= size</span></span><br><span class="line">   ListNodePosi(T) head = p-&gt;pred; ListNodePosi(T) tail = p;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) tail = tail-&gt;succ; <span class="comment">//待排序区间为(head, tail)</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> &lt; n ) &#123; <span class="comment">//在至少还剩两个节点之前，在待排序区间内</span></span><br><span class="line">      ListNodePosi(T) max = selectMax ( head-&gt;succ, n ); <span class="comment">//找出最大者（歧义时后者优先）</span></span><br><span class="line">      insertB ( tail, remove ( max ) ); <span class="comment">//将其移至无序区间末尾（作为有序区间新的首元素）</span></span><br><span class="line">      tail = tail-&gt;pred; n--;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">ListNodePosi(T) List&lt;T&gt;::selectMax ( ListNodePosi(T) p, <span class="keyword">int</span> n ) &#123;</span><br><span class="line">   ListNodePosi(T) max = p; <span class="comment">//最大者暂定为首节点p</span></span><br><span class="line">   <span class="keyword">for</span> ( ListNodePosi(T) cur = p; <span class="number">1</span> &lt; n; n-- ) <span class="comment">//从首节点p出发，将后续节点逐一与max比较</span></span><br><span class="line">      <span class="keyword">if</span> ( !lt ( ( cur = cur-&gt;succ )-&gt;data, max-&gt;data ) ) <span class="comment">//若当前元素不小于max，则</span></span><br><span class="line">         max = cur; <span class="comment">//更新最大元素位置记录</span></span><br><span class="line">   <span class="keyword">return</span> max; <span class="comment">//返回最大节点位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>insertB ( tail, remove ( max ) );</code>  涉及节点存储空间的动态释放与申请，所需时间操作比一般操作高出一个数量级，故可改为<code>swap(tail-&gt;pres-&gt;data,max-&gt;data)</code>。</p><blockquote><p>若将!lt ( ( cur = cur-&gt;succ )-&gt;data, max-&gt;data ) 改为lt ( max-&gt;data， ( cur = cur-&gt;succ )-&gt;data ))</p></blockquote><p>采用比较器<code>!lt()</code>或<code>ge()</code>等效于后者优先，如此即可保证重复元素在列表中的次序与其插入次序一致。若改为<code>lt()</code>雷同元素的次序将会完全颠倒，稳定性得不到保证。</p><p><strong>性能分析</strong></p><p>选择排序由$n$步迭代构成，其运行时间取决于各步迭代中查找及插入操作的效率。<code>insertB()</code>和<code>remove()</code>均只需$O(1)$时间。<code>selectMax()</code>每次必须遍历整个无序前缀，时间线性正比于前缀长度，总计为$O(n^2)$。</p><p>但是无论输入序列中各元素相对大小如何，以上$n$次<code>selectMax()</code>调用累计耗时总是$\Theta(n^2)$，最好情况下和最坏情况下复杂度相同。其中元素移动操作远远少于起泡排序，$ \Theta (n^2)$主要来自于元素比较操作。</p><p><strong>循环节</strong></p><p>任何一个序列A[0,n)都可以分解为若干循环节</p><p>任何一个序列A[0,n),都对应于一个有序队列S[0,n)</p><p>元素A[k]所属的循环节是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[k],A[r(k)],A[r(r(k))],...,A[r(...r(k)...)]&#x3D;A[k]</span><br></pre></td></tr></table></figure><p>每个循环节，长度不超过n,循环节之间没有重复元素</p><p>选择排序每迭一步，M所属循环节恰好减少一个单位，M脱离原来的循环节，自成一个长度为1的循环节，其余循环节保持不变。</p><blockquote><p>M已经就位，无需交换，这样的情况会出现几次</p></blockquote><p>有多少个循环节就出现多少次，最大值为$O(n)$，期望值为$O(logn)$</p><h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序算法可简要描述为：</p><p>始终将序列视为两个部分，有序的前缀S和无序的后缀U，反复地对将后缀中的首元素取出并转移至前缀中。</p><p>插入排序适用于向量与列表在内的任何序列结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//列表的插入排序算法：对起始于位置p的n个元素排序</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::insertionSort ( ListNodePosi(T) p, <span class="keyword">int</span> n ) &#123; <span class="comment">//valid(p) &amp;&amp; rank(p) + n &lt;= size</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++ ) &#123; <span class="comment">//逐一为各节点</span></span><br><span class="line">      insertA ( search ( p-&gt;data, r, p ), p-&gt;data ); <span class="comment">//查找适当的位置并插入</span></span><br><span class="line">      p = p-&gt;succ; remove ( p-&gt;pred ); <span class="comment">//转向下一节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>$n$次迭代，每次$O(r+1)$</p><p><strong>性能分析</strong></p><p>仅使用$O(1)$辅助空间，属于就地算法</p><p>不要求所有数据在算法运行时就完备，属于在线算法</p><p>具有输入敏感性</p><ul><li>最好情况：完全(或几乎)有序</li></ul><p>每次迭代只需$1$次比较，$0$次交换，只需$O(n)$时间</p><ul><li>最坏情况：完全或几乎逆序</li></ul><p>第k次迭代，需$O(k)$次比较，1次交换，累计$O(n^2)$时间</p><p><strong>优化的可能</strong></p><p>在有序前缀中的查找定位可以考虑用向量的二分查找，而不是顺序查找。</p><p>假定序列中的n个元素的数值为独立均匀的随机分布，则</p><blockquote><p>列表的插入排序算法平均需要$n^2/4=O(n^2)$次元素比较操作</p></blockquote><p>平均意义下的比较操作次数，也就是概率意义下的比较操作期望次数。</p><p>比较操作期望次数，应等于各步迭代中比较操作的次数。</p><p><code>search()</code>过程涉及的比较操作次数，应从$0$到$n-1$按照算术级数线性递增，故其总和应为<br>$$<br>\sum _{i=1} ^{n-1} (k/2)=\frac {n(n-1)} {4} =O(N^2)<br>$$</p><blockquote><p>向量的插入排序算法平均需要$n^2/4=O(n^2)$次元素移动操作</p></blockquote><p>向量中插入排序的<code>search()</code>接口可通过二分查找从线性优化至$O(log n)$,但是确定位置后将元素插入已排序的子序列却不得不移动个$O(n)$节点，平均需要$n^2/4=O(n^2)$次元素移动操作。</p><blockquote><p>在$n$次迭代中，平均有多少次无需交换呢？</p></blockquote><p>无需移动的元素期望数目，等于各步迭代中待插入元素无需移动的概率之和。</p><p>对于任意$k\in[0,n)$,当前A[k]的$k$个前驱应该也已构成一个有序的子序列A[0,k)。若A[k]无需移动即使得A[0,k]仍为有序子序列，则其充要条件是A[k]在A[0,k]中为最大元素。<br>$$<br>\sum _{i=0} ^{n-1} 1/(k+1)=\sum _{i=1} ^{n} (1/k)= \Theta(logn)<br>$$</p><blockquote><p>序列中元素A[i]和A[j]若满足i&lt;j,且A[i]&gt;A[j]，则称为一个逆序对，若所有逆序对的间距均不超过$k$,则运行时间为$O(kn)$</p></blockquote><p>算法进入到A[k]那步迭代时，该元素在输入序列中的所有前驱都应该业已构成一个有序序列A[0,j)。既然至多$k$个位置与A[j]构成逆序对，故查找过程<code>search()</code> 至多扫描其中k个元素，即可确定合适的插入位置，对应的时间不超过$O(k)$。实际上，每一步都具有以上性质，所以累计运行时间不超过$O(kn)$。<br>当$k$为常数时，插入排序可在线性时间内完成。</p><blockquote><p>若共有$I$个逆序对，则关键码比较次数不超过$O(I)$</p></blockquote><p>这里定义的每一逆序对，均涉及两个元素，为了便于分析，统一归入后者。因此，所有元素逆序前驱的数目总和应恰好等于$I$。每个元素涉及到的比较操作的数目，应恰好等于逆序前驱的数目。整个算法执行过程中所执行的比较操作总数应恰好等于所有元素的逆序前驱的数目总和。</p><blockquote><p>若共有$I$个逆序对，则运行时间$O(n+I)$</p></blockquote><p>由以上分析，算法过程中消耗于比较操作的时间可由$O(I)$界定，而消耗于移动操作的时间则由$O(n)$界定,二者累计即为$O(n+I)$。既然此处实际的运行时间更多地取决于逆序对的数目，而不仅仅是输入序列的长度，故插入排序亦属于所谓的输入敏感的算法。若将失败比较操作同样归入比较操作的范畴，则还有一个$O(n)$项，在渐进意义下这一因素可忽略。</p><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//列表的归并排序算法：对起始于位置p的n个元素排序</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::mergeSort ( ListNodePosi(T) &amp; p, <span class="keyword">int</span> n ) &#123; <span class="comment">//valid(p) &amp;&amp; rank(p) + n &lt;= size</span></span><br><span class="line">   <span class="keyword">if</span> ( n &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//若待排序范围已足够小，则直接返回；否则...</span></span><br><span class="line">   <span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>; <span class="comment">//以中点为界</span></span><br><span class="line">   ListNodePosi(T) q = p; <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ ) q = q-&gt;succ; <span class="comment">//均分列表</span></span><br><span class="line">   mergeSort ( p, m ); mergeSort ( q, n - m ); <span class="comment">//对前、后子列表分别排序</span></span><br><span class="line">   merge ( p, m, *<span class="keyword">this</span>, q, n - m ); <span class="comment">//归并</span></span><br><span class="line">&#125; <span class="comment">//注意：排序后，p依然指向归并后区间的（新）起点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//有序列表的归并：当前列表中自p起的n个元素，与列表L中自q起的m个元素归并</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::merge ( ListNodePosi(T) &amp; p, <span class="keyword">int</span> n, List&lt;T&gt;&amp; L, ListNodePosi(T) q, <span class="keyword">int</span> m ) &#123;</span><br><span class="line"><span class="comment">// assert:  this.valid(p) &amp;&amp; rank(p) + n &lt;= size &amp;&amp; this.sorted(p, n)</span></span><br><span class="line"><span class="comment">//          L.valid(q) &amp;&amp; rank(q) + m &lt;= L._size &amp;&amp; L.sorted(q, m)</span></span><br><span class="line"><span class="comment">// 注意：在归并排序之类的场合，有可能 this == L &amp;&amp; rank(p) + n = rank(q)</span></span><br><span class="line">   ListNodePosi(T) pp = p-&gt;pred; <span class="comment">//借助前驱（可能是header），以便返回前 ...</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; m ) <span class="comment">//在q尚未移出区间之前</span></span><br><span class="line">      <span class="keyword">if</span> ( ( <span class="number">0</span> &lt; n ) &amp;&amp; ( p-&gt;data &lt;= q-&gt;data ) ) <span class="comment">//若p仍在区间内且v(p) &lt;= v(q)，则</span></span><br><span class="line">         &#123; <span class="keyword">if</span> ( q == ( p = p-&gt;succ ) ) <span class="keyword">break</span>; n--; &#125; <span class="comment">//p归入合并的列表，并替换为其直接后继</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//若p已超出右界或v(q) &lt; v(p)，则</span></span><br><span class="line">         &#123; insertB ( p, L.remove ( ( q = q-&gt;succ )-&gt;pred ) ); m--; &#125; <span class="comment">//将q转移至p之前</span></span><br><span class="line">   p = pp-&gt;succ; <span class="comment">//确定归并后区间的（新）起点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为节省每次子列表的划分时间，令$m=min(c,n/2)$，则总体复杂度反而会上升至$O(n^2)$</p><p>$T(n)=T(c)+T(n-c)+O(n)$<br>$T(n)=O(n^2)$ </p><h1 id="游标实现"><a href="#游标实现" class="headerlink" title="游标实现"></a>游标实现</h1><p>在某些特定的语言环境中不支持指针或不支持动态空间分配，此时用线性数组，以游标的形式模拟列表</p><p><code>elem[]</code>:对外可见的数据项</p><p><code>link[]</code>:数据项之间的引用</p><p>维护逻辑上互补的列表data和free</p><p><code>data</code>即为数据链表的首元素的秩，通过link索引至下一元素</p><p><code>free</code>即为空闲链表首元素的秩，通过link索引至下一元素</p><blockquote><p>具体实现</p></blockquote><p>初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CursorList ( <span class="keyword">int</span> c = DEFAULT_CAPACITY ) &#123; <span class="comment">//容量为c</span></span><br><span class="line">      _link = <span class="keyword">new</span> Rank[_capacity = c]; <span class="comment">//游标指针向量</span></span><br><span class="line">      _elem = <span class="keyword">new</span> T[_capacity = c]; <span class="built_in">memset</span> ( _elem, <span class="number">0</span>, c * <span class="keyword">sizeof</span> ( T ) ); <span class="comment">//数据向量</span></span><br><span class="line">      _data = <span class="number">-1</span>; _size = <span class="number">0</span>; <span class="comment">//数据链表初始为空</span></span><br><span class="line">      _free = <span class="number">0</span>; <span class="comment">//空闲链表由所有单元依次串接而成</span></span><br><span class="line">      <span class="keyword">for</span> ( Rank i = <span class="number">0</span>; i &lt; c - <span class="number">1</span>; i++ ) _link[i] = i + <span class="number">1</span>;</span><br><span class="line">      _link[c - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>插入元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rank <span class="title">insert</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> </span>&#123; <span class="comment">//插入元素</span></span><br><span class="line">      assert ( <span class="number">0</span> &lt;= _free );</span><br><span class="line">      Rank k = _free; _free = _link[k]; _elem[k] = e;</span><br><span class="line">      _link[k] = _data; _data = k;</span><br><span class="line">      _size++; <span class="keyword">return</span> k;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>删除元素</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Rank <span class="title">find</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> <span class="keyword">const</span> </span>&#123; <span class="comment">//查找</span></span><br><span class="line">     Rank i = _data; <span class="comment">//从数据链表起点出发</span></span><br><span class="line">     <span class="keyword">while</span> ( ( <span class="number">0</span> &lt;= i ) &amp;&amp; ( e != _elem[i] ) ) i = _link[i]; <span class="comment">//依次比对</span></span><br><span class="line">     <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function">Rank <span class="title">remove</span> <span class="params">( Rank k )</span> </span>&#123; <span class="comment">//删除秩为k的元素</span></span><br><span class="line">     assert ( <span class="number">0</span> &lt;= k ); <span class="comment">//此前经查找并确认k合法</span></span><br><span class="line">     <span class="keyword">if</span> ( _data == k ) <span class="comment">//若[k]为首节点</span></span><br><span class="line">        _data = _link[k];</span><br><span class="line">     <span class="keyword">else</span> &#123; <span class="comment">//否则</span></span><br><span class="line">        Rank i = _data; <span class="keyword">while</span> ( k != _link[i] ) i = _link[i];</span><br><span class="line">        _link[i] = _link[k];</span><br><span class="line">     &#125;</span><br><span class="line">     _link[k] = _free; _free = k; _elem[k] = <span class="number">0</span>;</span><br><span class="line">     _size--; <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>先调用<code>find</code>查找删除元素的秩，再调用<code>remove</code>删秩为k的元素。约定初始化或删除后元素均置为0。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据是否修改数据结构，所有操作分为两类方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态：仅读取，数据结构的内容和组成不变&lt;/li&gt;
&lt;li&gt;动态：需写入，数据结构的局部或整体将改变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与操作方式相对应的，数据元素的存储和组织形式也分为两种&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态：数据空间整体创建和销毁&lt;/li&gt;
&lt;li&gt;动态：为各个数据元素动态地分配和回收的物理空间，相邻元素记录彼此的物理地址，在逻辑上形成一个整体，可支持高效的动态操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;列表是采用动态存储的典型结构，循位置访问，通过节点之间的相互引用找到特定的节点。借助列表设计算法时，应更多地借助逻辑上相邻元素之间的位置索引。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="http://twinkle0331.github.io/categories/Algorithm/"/>
    
    
    <category term="Data structure" scheme="http://twinkle0331.github.io/tags/Data-structure/"/>
    
  </entry>
  
</feed>
