<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"twinkle0331.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="此前的搜索树和词典结构都支持覆盖全集的访问和操作，其中存储的每一数据对象都可作为查找和访问目标。搜索树结构需要在所有元素之间定义并维护一个显式的全序关系，而词典结构从内部强制地在对象和对应的秩之间建立起某种关联关系，隐式地定义了一个全序关系。优先级队列将操作对象限定于当前的全局极值者。比如，在所有鸟类中，查找种群规模最小者。这一访问方式称为循优先级访问。">
<meta property="og:type" content="article">
<meta property="og:title" content="优先级队列">
<meta property="og:url" content="http://twinkle0331.github.io/algorithm/pq/index.html">
<meta property="og:site_name" content="trinkle">
<meta property="og:description" content="此前的搜索树和词典结构都支持覆盖全集的访问和操作，其中存储的每一数据对象都可作为查找和访问目标。搜索树结构需要在所有元素之间定义并维护一个显式的全序关系，而词典结构从内部强制地在对象和对应的秩之间建立起某种关联关系，隐式地定义了一个全序关系。优先级队列将操作对象限定于当前的全局极值者。比如，在所有鸟类中，查找种群规模最小者。这一访问方式称为循优先级访问。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/09/09/VW6H38udDwe4G2F.png">
<meta property="article:published_time" content="2019-09-09T07:36:38.000Z">
<meta property="article:modified_time" content="2021-03-27T13:17:35.000Z">
<meta property="article:author" content="trinkle">
<meta property="article:tag" content="Data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2019/09/09/VW6H38udDwe4G2F.png">


<link rel="canonical" href="http://twinkle0331.github.io/algorithm/pq/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>优先级队列 | trinkle</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="trinkle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">trinkle</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://twinkle0331.github.io/algorithm/pq/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trinkle">
      <meta itemprop="description" content="Stay foolish,stay hungry.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="trinkle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          优先级队列
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-09 15:36:38" itemprop="dateCreated datePublished" datetime="2019-09-09T15:36:38+08:00">2019-09-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>此前的搜索树和词典结构都支持覆盖全集的访问和操作，其中存储的每一数据对象都可作为查找和访问目标。搜索树结构需要在所有元素之间定义并维护一个显式的全序关系，而词典结构从内部强制地在对象和对应的秩之间建立起某种关联关系，隐式地定义了一个全序关系。优先级队列将操作对象限定于当前的全局极值者。比如，在所有鸟类中，查找种群规模最小者。这一访问方式称为循优先级访问。</p>
<a id="more"></a>

<p>在实际应用环境中，不少事件都可用优先级队列描述，比如银行会员排队问题，操作系统的任务调度问题，输入法的词频调整。数据项的某种属性只要可以相互比较大小，则这种大小称为优先级。按照事先约定的优先级，可以始终高效地查找优先级最高的数据项的数据结构统一称为优先级队列。</p>
<p>考虑之前的数据结构效率</p>
<table>
<thead>
<tr>
<th></th>
<th>getmax()</th>
<th>delmax()</th>
<th>insert()</th>
</tr>
</thead>
<tbody><tr>
<td>无序向量</td>
<td>$\Theta(n)$</td>
<td>$ \Theta(n)$</td>
<td>$O( 1 )$</td>
</tr>
<tr>
<td>有序向量</td>
<td>$O (1)$</td>
<td>$O (1)$</td>
<td>$O( n )$</td>
</tr>
<tr>
<td>无序列表</td>
<td>$\Theta ( n )$</td>
<td>$\Theta ( n )$</td>
<td>$O ( 1 )$</td>
</tr>
<tr>
<td>有序列表</td>
<td>$O (1)$</td>
<td>$O (1)$</td>
<td>$O( n )$</td>
</tr>
</tbody></table>
<p>AVL、splay、red-black树三个接口均只需$O(logn)$时间，但是BBST的功能远远超出了优先级队列的要求。若只需查找极值元，则不必维护所有元素的全序关系，偏序足以。</p>
<h1 id="完全二叉堆"><a href="#完全二叉堆" class="headerlink" title="完全二叉堆"></a>完全二叉堆</h1><p>有限偏序值的极值必定存在，此时借助堆结构维护一个全序即足矣。完全二叉堆即为堆结构的典型代表。</p>
<h2 id="结构性与堆序性"><a href="#结构性与堆序性" class="headerlink" title="结构性与堆序性"></a>结构性与堆序性</h2><p>首先结构性是在逻辑结构上须等同于完全二叉树，如此一来，堆节点和词条一一对应。其次，堆顶节点之外的每个节点都不大于其父节点，这即为堆序性。</p>
<p>由堆序性可以看出，堆中优先级最高的词条必然处于堆顶位置。因此，堆结构的<code>getmax()</code> 操作总是在堆顶完成。</p>
<p>完全二叉堆的拓扑联接结构完全由其规模$n$确定。按照层次遍历的顺序，每个节点都对应唯一的编号。故若将所有节点组织为一个向量，则堆中各节点与向量单元的秩必将一一对应。各节点在物理上连续排列，故仅需$O(n)$时间。通过节点的编号，可便捷地判断父子关系。</p>
<p>对于完全二叉堆中的任意节点$v$，必然满足：</p>
<ol>
<li>若$v$有左孩子，则$i(lchild(v))=2i(v)+1$</li>
<li>若$v$有右孩子，则$i(rchild(v))=2i(v)+2$</li>
<li>若$v$有父节点，则$i(parent(v))=\lfloor (i(v)-1)/2 \rfloor=\lceil i(v)/2 \rceil -1$</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  Parent(i)         ( ( i - 1 ) &gt;&gt; 1 ) <span class="comment">//PQ[i]的父节点（floor((i-1)/2)，i无论正负）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LChild(i)         ( 1 + ( ( i ) &lt;&lt; 1 ) ) <span class="comment">//PQ[i]的左孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RChild(i)         ( ( 1 + ( i ) ) &lt;&lt; 1 ) <span class="comment">//PQ[i]的右孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LastInternal(n)   Parent( n - 1 ) <span class="comment">//最后一个内部节点（即末节点的父亲）</span></span></span><br></pre></td></tr></table></figure>
<p>共$n$个节点时，内部节点的最大秩$=\lfloor (n-2)/2 \rfloor=\lceil (n-3)/2 \rceil$</p>
<p>令各节点的秩统一地递增一个单位，从秩的二进制表示来看，祖先必是后代的前缀。</p>
<p>对于秩为$r$的元素，其上溯第$h$代祖先所对应的秩必然为$O((r+1)&gt;&gt;h)-1)$</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>为插入词条$e$,只需将$e$作为末元素接入向量，结构性自然保持，若堆序性亦未破坏，则完成。</p>
<p>若违反堆序性，则只能是与其父亲违反堆序性，$e$与其父节点交换，不断重复直到$e$与其父亲满足堆序性或者$e$到达堆顶。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::insert ( T e ) &#123; <span class="comment">//将词条插入完全二叉堆中</span></span><br><span class="line">   Vector&lt;T&gt;::insert ( e ); <span class="comment">//首先将新词条接至向量末尾</span></span><br><span class="line">   percolateUp ( _size - <span class="number">1</span> ); <span class="comment">//再对该词条实施上滤调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对向量中的第i个词条实施上滤操作，i &lt; _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank PQ_ComplHeap&lt;T&gt;::percolateUp ( Rank i ) &#123;</span><br><span class="line">   <span class="keyword">while</span> ( ParentValid ( i ) ) &#123; <span class="comment">//只要i有父亲（尚未抵达堆顶），则</span></span><br><span class="line">      Rank j = Parent ( i ); <span class="comment">//将i之父记作j</span></span><br><span class="line">      <span class="keyword">if</span> ( lt ( _elem[i], _elem[j] ) ) <span class="keyword">break</span>; <span class="comment">//一旦当前父子不再逆序，上滤旋即完成</span></span><br><span class="line">      swap ( _elem[i], _elem[j] ); i = j; <span class="comment">//否则，父子交换位置，并继续考查上一层</span></span><br><span class="line">   &#125; <span class="comment">//while</span></span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//返回上滤最终抵达的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效率</strong></p>
<p>$e$与父亲的交换，每次仅需$O(1)$时间，每经过一次交换,$e$都会上升一层。在插入新节点$e$的过程中，只有$e$的祖先们才有可能需要与之交换。完全二叉堆以完全二叉树实现，必平衡，故$e$的祖先至多$O(logn)$个。</p>
<p>通过上滤，可在$O(logn)$时间内插入一个新节点，并整体得以调整为堆。</p>
<p>可在向量中将各节点顺次后移一个单元，并在腾出的元素中置入对应元素类型的最大值作为哨兵(比如，对于整数取作<code>INT_MAX</code>)。但在上滤过程中只需比较父子节点的大小，而无需核对是否越界。</p>
<p>如此转换后，父子节点各自在物理上所对应的秩需要进行调整</p>
<p>对于完全二叉堆中的任意节点$v$，必然满足：</p>
<ol>
<li>若$v$有左孩子，则$i(lchild(v))=2i(v)$</li>
<li>若$v$有右孩子，则$i(rchild(v))=2i(v)+1$</li>
<li>若$v$有父节点，则$i(parent(v))=\lfloor i(v)/2 \rfloor=\lceil (i(v)-1)/2 \rceil $</li>
</ol>
<p>在上滤的过程无需核对是否已经越界，因此在一定程度上提高插入操作的效率，但渐进复杂度仍然为$O(logn)$。当然，以上调整对下滤的过程及效率没有影响。</p>
<p>在堆顶通往任一叶节点的沿途上，各节点对应的关键码必然单调变化。所以可在引入新节点但未上滤调整之前，将该节点对应的查找路径视为一个静态查找表。并使用二分查找算法。</p>
<p>具体地，每次都可在$O(1)$时间内确定高度居中地祖先的秩，将其作为轴点，只需再做$O(1)$次比较，即可将查找范围缩小一半。如此反复迭代，直到查找范围内只剩下耽搁节点。</p>
<p>既然完全二叉堆的高度不超过$h=O(logn)$,故整个查找过程的迭代次数将不超过：</p>
<p>$logh=O(loglogn)$</p>
<p>以上算法只适用于上滤操作，因为任一节点通向其后代的路径并不唯一，而通往其祖先的路径必然唯一。</p>
<p>同时，以上方法可以有效地减少词条地比较操作，但是词条交换操作却不可减少。事实上，无论如何，再最坏情况下仍然需要执行$O( h )=O(logn)$次交换操作。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>最大元素始终在堆顶，删除堆顶元素只需要摘除向量首元素，以末元素$e$代替。若新堆顶$e$不满足堆序性，将$e$与其(至多)两个孩子中的大者交换。若与新孩子继续违反堆序性，则继续套用以上方法，不断重复，直到$e$满足堆序性，或已为叶子。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_ComplHeap&lt;T&gt;::delMax() &#123; <span class="comment">//删除非空完全二叉堆中优先级最高的词条</span></span><br><span class="line">   T maxElem = _elem[<span class="number">0</span>]; _elem[<span class="number">0</span>] = _elem[ --_size ]; <span class="comment">//摘除堆顶（首词条），代之以末词条</span></span><br><span class="line">   percolateDown ( _size, <span class="number">0</span> ); <span class="comment">//对新堆顶实施下滤</span></span><br><span class="line">   <span class="keyword">return</span> maxElem; <span class="comment">//返回此前备份的最大词条</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对向量前n个词条中的第i个实施下滤，i &lt; n</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank PQ_ComplHeap&lt;T&gt;::percolateDown ( Rank n, Rank i ) &#123;</span><br><span class="line">   Rank j; <span class="comment">//i及其（至多两个）孩子中，堪为父者</span></span><br><span class="line">   <span class="keyword">while</span> ( i != ( j = ProperParent ( _elem, n, i ) ) ) <span class="comment">//只要i非j，则</span></span><br><span class="line">      &#123; swap ( _elem[i], _elem[j] ); i = j; &#125; <span class="comment">//二者换位，并继续考查下降后的i</span></span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//返回下滤抵达的位置（亦i亦j）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效率</strong></p>
<p>在下滤的过程中，每经过一次交换，$e$的高度都将降低一层。故在每层至多需要一次交换。由于堆是完全二叉树，高度为$O(logn)$。通过下滤，可在$O(logn)$时间内删除堆顶节点并整体重新调整为堆。</p>
<p>若实际上升$k=O(logn)$层，则$k$次<code>swap()</code>操作共需$3k+1$次，可将此类赋值操作降低至$k+1$次。</p>
<p>在插入接口的上滤操作中，新元素可暂且不予插入，而只是将其上若干代祖先节点依次下移，待所有祖先均已就位时，才将新元素置入腾空的空节点。删除操作同理。</p>
<blockquote>
<p>为何在摘除堆顶元素后，不自上而下地依次以更大孩子节点顶替空缺的父节点</p>
</blockquote>
<p>如此可以维持完全二叉堆的堆序性，但是经过如此调整后完全二叉堆的拓扑结构未必仍然是一棵完全二叉树，故其结构性可能遭到破坏，因为该节点到最大孩子的路径和根节点到末节点的路径未必是同一条。</p>
<blockquote>
<p>在关键码独立均匀分布时，插入操作平均只需常数时间</p>
</blockquote>
<p>根据堆的定义及调整规则，若新节点$p$通过上滤升高了k层，则意味着在$2^{k+1}$个随机节点($p$的父亲、$p$、以及$p$的$2^{k+1}-2$)中，该节点恰好为第二大者。</p>
<p>于是，若将新节点$p$累计上升的高度记作H,则H恰好为$k$的概率为:</p>
<p>$Pr(H=k)=1/2^{k+1}=(1/2)^k(1/2),0\leq k$</p>
<p>这是一个典型的几何分布，其数学期望为：</p>
<p>$E(h)=1/(1/2)-1=1$</p>
<p>每个节点经过上滤后平均上升1层，其间需做$1+1=2$次比较操作。</p>
<h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>很多算法中输入词条都是成批给出，故在初始化阶段往往需要解决一个共同问题:给定一组词条，高效地将他们组织为一个堆，这一过程称为建堆。</p>
<p><strong>蛮力算法</strong></p>
<p>从空堆开始，反复调用<code>insert()</code> 接口，即可将输入词条逐一插入其中，并最终完成建堆的任务。</p>
<p>若共有$n$个词条，则累计耗时量为：</p>
<p>$O(1)+O(2)+O(3)+…+O(n)=O(logn!)=O(nlogn)$</p>
<p>在$O(nlogn)$时间内可对所有词条全排序，但是在此只能提供一个偏序。</p>
<p><strong>自上而下的下滤</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify ( Rank n ) &#123; <span class="comment">//Floyd建堆算法，O(n)时间</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i-- ) <span class="comment">//自底而上，依次</span></span><br><span class="line">      percolateUp ( n, i ); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效率</strong></p>
<p>最坏情况下，每个节点都需要上滤至根，所需成本线性正比于其深度。即便只考虑底层，$n/2$个叶节点，深度均为$O(logn)$,累计耗时$O(nlogn)$，与蛮力算法一致。</p>
<p>考查高度为$h$，规模为$n=2^{h+1}-1$的满二叉树，其中深度为$i$的节点有$2^i$个，整个算法平均复杂度为：</p>
<p>$\sum_{i=1}^{n}(i2^i)=(h-1)2^{h+1}+2=(log_2(n+1)-2)(n+1)+2=O(nlogn)$ </p>
<p><strong>floyd算法</strong></p>
<p>给定任意堆$H_0$和$H_1$，以及节点$p$，将其转化为一个新堆，相当于以$p$为中介将堆$H_1$,$H_2$ 合并，故称为堆合并操作。</p>
<p>为满足结构性，可将这两个堆作为p的左、右子树，联接成一棵完整的二叉树。若p与孩子满足堆序性，则该二叉树为一个不折不扣的二叉堆。此时等效于在<code>delMax()</code>中摘除堆顶，再将末位词条转移至堆顶。只需对堆顶p实施下滤操作即可将全树转换为堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify ( Rank n ) &#123; <span class="comment">//Floyd建堆算法，O(n)时间</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = LastInternal ( n ); InHeap ( n, i ); i-- ) <span class="comment">//自底而上，依次</span></span><br><span class="line">      percolateDown ( n, i ); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效率</strong></p>
<p>每个内部节点所需的调整时间，正比于其高度而非深度。</p>
<p>不失一般性，考查满树$n=2^{d+1}-1$</p>
<p>$S(n)=$所有节点的高度总和</p>
<p>$\sum_{i=0}^{d} (d-i)(2^i)=d \sum_{i=0}^{d}2^i-T(n)$</p>
<p>$=d(2^{d+1}-1)-[(d-1)2^{d+1}+2]=2^{d+1}-(d+2)=n-log_2(n+1)=O(n)$</p>
<p>同层内部节点下滤的次序，仅涉及到其各自的后代，它们之间完全相互独立，故改变次序不影响最终的结果。同时，每个节点下滤过程完全不变，所需时间不变，建堆所需的总体时间亦不变。</p>
<h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>完全二叉堆的另一具体应用：对于向量中的n个词条，如何借助堆的相关算法，实现高效的排序。相应地，这类算法也称作堆排序算法。</p>
<p>算法总体思路和选择排序相同，将所有词条分为未排序和已排序，不断从前一类中取出最大者，顺序加至后一类中。算法启动之初，所有词条均属于前者，此后，后一类不断增长。当所有词条转入后一类时，即完成排序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::heapSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   <span class="function">PQ_ComplHeap&lt;T&gt; <span class="title">H</span> <span class="params">( _elem + lo, hi - lo )</span></span>; <span class="comment">//将待排序区间建成一个完全二叉堆，O(n)</span></span><br><span class="line">   <span class="keyword">while</span> ( ! H.empty() ) <span class="comment">//反复地摘除最大元并归入已排序的后缀，直至堆空</span></span><br><span class="line">      _elem[--hi] = H.delMax(); <span class="comment">//等效于堆顶与末元素对换后下滤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的待排序词条既然组织为向量，不妨将其划分为前缀H和与之互补的后缀S。整个算法过程中始终满足以下不变性：<strong>H中的最大词条不会大于S中的最小词条</strong>。与选择排序不同之处在于，无论S包含多少词条，都将组织为一个堆。</p>
<p>不需要全排序，查找前$k$个元素所需的时间为$O(klogn)$。</p>
<p><strong>效率</strong></p>
<p>就地堆排序易于理解，便于实现，快速高效(尤其对于大规模数据)。</p>
<p>可就地运转，不需要全排序即可找出前k个词条，但是在采取就地策略的同时，对换操作必须涉及两个完整的词条，所以操作的单位成本增加。</p>
<blockquote>
<p>以上堆排序算法是稳定的吗？</p>
</blockquote>
<p>不是稳定的，在反复摘除堆顶并将末词条转移至堆顶，然后下滤过程中，雷同词条之间的相对次序不再保持，故它们在最终所得的排序队列中必然是随机排列的。</p>
<p>以上堆排序是堆排序固有的不足，难以通过算法自身的调整予以改进。可通过合成数方法，使得原来相等的元素，初始位置越靠前，合成数越小。</p>
<h2 id="半无穷范围查询"><a href="#半无穷范围查询" class="headerlink" title="半无穷范围查询"></a>半无穷范围查询</h2><p>所谓半无穷范围查询简化之前的一般性范围查询，查询区域为某一侧无界的矩形区域，比如$R=[-1,+1] [0,+\infty]$ ，即对称地包含正半$y$坐标轴、宽度为$2$的一个广义矩形区域。同样为从某一固定的点集中找出落在制定区域$R$内的所有点。通过优先级搜索可将保持$O(r+logn)$的时间效率并将空间复杂度从范围树的$O(nlogn)$优化至$O(n)$。</p>
<p>优先级搜索树除了在拓扑上应是一棵二叉搜索树，还需同时遵守以下三条规则：</p>
<ul>
<li><p>首先，各个节点的$y$坐标不小于其左、右孩子(如果存在)</p>
<p>因此，整体上可视为以$y$为优先级的二叉堆</p>
</li>
<li><p>此外，相对于任一父节点，左子树中的节点$x$坐标均不得大于右子树中的节点</p>
</li>
<li><p>最后，互为兄弟的每一对左右子树，在规模上相差不得超过1</p>
<p>若无需遵守最后一条规则，则可保证所有节点以$x$坐标为序组成一棵二叉搜索树，该结构兼具二叉搜索树和堆的特性，故亦称为树堆。</p>
</li>
</ul>
<blockquote>
<p>试设计一个算法，在$O(nlogn)$时间内将平面上$n$个点组织为一棵优先级搜索树</p>
</blockquote>
<p>首先，不妨按照$x$坐标对所有点排序，然后根据以上定义，可以递归地将这些点组织为一棵优先级搜索树。</p>
<p>具体地，为了构造任一点集对应的子树，只需花费$O(n)$时间从中找到最高者($y$坐标最大者)。以下，借助$x$坐标的排序序列，可在$O(1)$时间内将剩余的$n-1$个点均平衡地划分为在空间上分列于左、右的两个子集–二者对应的子湖是可通过递归构造。</p>
<p>如此，构造全树的时间不超过:</p>
<p>$T(n)=2T(n/2)+O(n)=O(nlogn)$</p>
<blockquote>
<p>试设计一个算法，利用已经创建的优先级搜索树，在$O(r+logn)$时间内完成每次半无穷范围查询</p>
</blockquote>
<p>查询算法的大致过程可描述为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">queryPST(PSTNode v,SemInfRange R)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!v||v.y&lt;R.y) <span class="keyword">return</span>;<span class="comment">//y-pruning</span></span><br><span class="line">     <span class="keyword">if</span>(R.x1&lt;v.x&amp;&amp;v.x&lt;R.x2) output(v);<span class="comment">//hit</span></span><br><span class="line">     <span class="keyword">if</span>(R.x1&lt;&gt;v.xm) queryPST(v.lc,R);<span class="comment">//recursion&amp;x-pruning</span></span><br><span class="line">     <span class="keyword">if</span>(v.xm&lt;=R.x2) queryPST(V.RC,R);<span class="comment">//recursion&amp;x-pruning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先,根据$y$坐标，判断当前子树根节点$v$(及其后代)是否已经落在查询范围$R$之外。若是，则可立即在此处返回，不再进行递归—亦即纵向剪枝；否则，才需要继续深入查找。</p>
<p>以下，检查根节点$v$的$x$坐标，若落在查询范围之外，则需报告该节点。</p>
<p>最后，若在节点$v$处的横向切分位置为$xm$，则通过将其与$R$的左、右边界相比较，即可确认是否有必要继续沿对应的子树分支继续递归搜索–亦即横向剪枝。</p>
<p>唯有当$R.x1$不位于$v.xm$左侧时，才有必要对左子树$v.lc$做递归搜索，唯有当$R.x2$不位于$v.xm$左侧时，才有必要对右子树$v.rc$做递归搜索。</p>
<p>对任一查询区域$R=[R_1,R_2][y,+\infty]$ ,考查被算法<code>queryPST()</code>访问的任一节点，设与之对应的点为$v=(a,b)$，于是，$v$无非三种类型：</p>
<ol>
<li>被访问，且报告出来，也就是说，$v$落在$R$之内$(x_1 \leq a \leq x_2)$且$y\leq b$，此类节点恰有$r$个</li>
<li>虽被访问，但未报告，因其$x$坐标落在$R$之外$(a&lt;x_1)$或$(x_2&lt;a)$而横向剪枝，不再深入递归。此类节点在每一层上至多有两个，总数不超过$2O(logn)$</li>
<li>虽然被访问，但是未被报告，$x$坐标落在$R$之内$(x_1 \leq a \leq x_2)$,但是因为其$y$坐标却未落在$R$之内$(b&lt;y)$而纵向剪枝，此类节点的父节点必然属于1类或者2类，其总数不超过这两类节点总数的两倍。</li>
</ol>
<p>综合以上分析可知，<code>queryPST()</code>算法渐进的时间复杂度不超过$O(r+logn)$。</p>
<h2 id="锦标赛排序"><a href="#锦标赛排序" class="headerlink" title="锦标赛排序"></a>锦标赛排序</h2><p>堆排序中主要开销为建堆和删除堆顶元素，按照floyd算法，每次下滤可能在每一高度上均需要两次比较来从当前节点、当前节点的左、右孩子确定替换元素，所以在建堆过程中实际比较操作次数可能达到$2n$次，同理，删除堆顶元素并下滤恢复堆序性的过程中，堆的比较次数为$2logn$，以上两点均存在优化空间，所以引入了锦标赛排序，将前者比较操作次数降低至$n-1$次，后者比较操作次数降至$O(logn)$次。</p>
<p><strong>锦标赛树</strong></p>
<p>锦标赛树同样为二叉树，叶节点为待排序元素，以小者胜为原则，内部节点为孩子中的胜者，树根为全局冠军。内部节点之间存在重复，但是始终满足：<strong>在任一子树中，从根通往优胜者的沿途，所有节点都是优胜者</strong>。</p>
<p>由完全二叉树的性质，若存在$n$个叶节点，则内部节点为$n$个或者$n-1$个,取决于最后一个内部节点为一度还是二度。故节点总体空间不超过$2n$，空间复杂度为$O(n)$。</p>
<p>在每个内部节点处均需要一次比较，选出该节点左、右孩子中的胜者，所以构建锦标赛树所需的比较次数等于内部节点数目。所以构造锦标赛树的时间复杂度为$O(n)$。</p>
<p>插入/删除操作只需要更新沿着该叶节点到根节点的沿途节点，也即沿途胜者，总体时间复杂度为$O(logn)$。</p>
<p>由此设计锦标赛排序算法为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create a tournament tree <span class="keyword">for</span> the input <span class="built_in">list</span></span><br><span class="line"><span class="keyword">while</span> there are active leaves</span><br><span class="line">   remove the root</span><br><span class="line">   retrace the root down to its leaf</span><br><span class="line">   deactive the leaf</span><br><span class="line">   replay along the path back to the root</span><br></pre></td></tr></table></figure>
<p>先花费$O(n)$时间建立锦标赛树，然后删除根节点，并沿原胜利者到根节点的路径找到原胜利者的叶节点，将原胜利者的叶节点优先级置为无穷大。最后从叶节点出发，逐层上溯至树根，重新确定各轮胜者，耗时$O(logn)$。上述删除和重赛迭代n次，故锦标赛排序的总体时间复杂度为$O(nlog n)$。</p>
<h2 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h2><p>由于在锦标赛树中，原冠军节点失效后，需要从该节点到根节点逐层上溯，重新确定各轮胜者，而重新确定胜者需要当前节点与其兄弟节点比较，但是其兄弟节点未必位于缓存中。除此之外，原来冠军已经失效，上溯过程中必然修改根节点到原来胜者所处叶节点沿途节点的值，均需要访存，所以引入败者树，父节点中不再保存胜者，而是保存败者。按照锦标赛排序算法，从根节点下行找到冠军叶节点，此时只访问该路径上的节点，所以具有时间局部性，可以更充分地利用缓存机制，在败者树更新过程中，各沿途节点未必需要更新，减少了写操作。</p>
<blockquote>
<p>锦标赛树可否实现稳定排序？</p>
</blockquote>
<p>可以，只需保证在相等元素比较时，位置靠前者胜出即可，得到地排序序列仍然可以保持相等元素之间的相对次序。</p>
<p>另外，可借助多叉锦标赛树实现多路合并。</p>
<h1 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a>左式堆</h1><p>除了标准的插入和删除操作，堆结构在实际应用中的另一常见操作即为合并。任给堆A和B，如何将二者所含的词条组织为一个堆H。</p>
<p><strong>方法一</strong></p>
<p>反复地取出堆B的最大词条并插入堆A中，当堆B为空时，堆A即为所需的堆H,这一过程可描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!B.empty())</span><br><span class="line">   A.insert(B.delmax());</span><br></pre></td></tr></table></figure>
<p>将两个堆的规模分别记作$n$和$m$,且$n\geq m$。每一步迭代均需做一次删除和一次插入操作。因共需$m$次迭代，故总体运行时间为：$m[O(logm)+log(n+m)]=O(mlog(n+m))=O(mlogn)$</p>
<p><strong>方法二</strong></p>
<p>将两个堆中的词条视为彼此独立的对象，直接借助floyd算法，将它们重新组织为一个新堆H,该方法的运行时间为：$O(n+m)$</p>
<p>实际上，既然所有词条已分成两组各自成堆，则意味着它们已经具有一定的偏序性，而一组相互独立的词条并不具有偏序性。由前者构建一个更大的偏序集，应该比后者简单。以上算法均未凑效的原因在于，不能保证合并操作涉及的节点足够少。</p>
<h2 id="单侧倾斜"><a href="#单侧倾斜" class="headerlink" title="单侧倾斜"></a>单侧倾斜</h2><p>左式堆是优先级队列的另一表现形式，可高效地支持合并操作。其基本思路是：在保持堆序性的前提下附加新的条件，使在堆的合并过程中，只需要调整很少量的节点。具体地，调整节点不超过$O(logn)$个，故可达到极高的效率。</p>
<p>左式堆的整体结构呈单侧倾斜状，其中节点均偏向于左侧，也就是说，左式堆不再如完全二叉堆一样满足结构性。实际上，结构性并非堆结构的本质要求。</p>
<h2 id="空节点路径长度"><a href="#空节点路径长度" class="headerlink" title="空节点路径长度"></a>空节点路径长度</h2><p>左式堆的倾斜度，应该控制在什么范围？又该如何控制？为此，借鉴红黑树和AVL树，未各节点引入空节点路径长苏，并依次确定相关算法的执行方向。</p>
<p>节点x的空节点路径长度(null path length)，记为$npl(x)$。若$x$为外部节点，则约定$npl(x)=npl(null)=0$。若x为内部节点，则$npl(x)$可递归地定义为：$npl(x)=1+min(npl(lc(x)),npl(rc(x)))$</p>
<p>也就是说，节点$x$的$npl$值取决于其左、右孩子$npl$值中的小者。</p>
<p><img src="https://i.loli.net/2019/09/09/VW6H38udDwe4G2F.png"></p>
<h2 id="左倾性"><a href="#左倾性" class="headerlink" title="左倾性"></a>左倾性</h2><p>左式堆是处处满足左倾性的二叉堆，即任一内部节点满足：</p>
<p>$npl(lc(x))\geq npl(rc(x))$</p>
<p>也就是说，就$npl$的指标而言，任一内部节点的左孩子都不小于其右孩子。</p>
<p>根据$npl$和左倾性的定义，左式堆中任一节点$x$都应满足：</p>
<p>$npl(x)=1+npl(rc(x))$</p>
<p>左式堆中每个节点的$npl$值，仅取决于其右孩子。</p>
<p>左孩子的$npl$值不小于右孩子并不意味着左孩子的高度必定不低于右孩子，因为一个节点的$npl$值由子树中最浅的叶子决定，高度则由最深的叶子决定。</p>
<h2 id="右侧链"><a href="#右侧链" class="headerlink" title="右侧链"></a>右侧链</h2><p>从节点$x$出发沿右侧分支一直前行至空节点，经过的通路称作其最右侧通路，记作rPath(x)。在左式堆中，每个节点的npl值恰好等于其最右侧通路的长度。</p>
<p>根节点r的最右侧通路<code>rPath(r)</code>的终点必然为全堆中深度最小的外部节点。若记：</p>
<p>$npl(r)=|rPath(x)|=d$</p>
<p>则该堆应包含一棵以$r$为根、高度为$d$的满二叉树，该二叉树至少应包含$2^{d}-1$个内部节点，$2^{d+1}-1$个外部节点。反之，在包含$n$个节点的左式堆中，最右侧通路$d\leq \lfloor log_2(n+1)-1 \rfloor =O(logn)$</p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>首先判断并处理待合并子堆为空的平凡情况，再通过一次比较，以及在必要时所做的一次交换，以保证堆顶a的优先级总是不低于另一堆顶$b$。</p>
<p>按照上述原理递归地将$a$的右子堆和堆$b$合并，并作为$a$的右子堆重新接入。递归返回后，还需比较$a$左、右孩子的npl值，如有必要还需令其互换，以保证前者不小于后者。此后只需在右孩子npl的基础上加1即可得到堆顶$a$的新npl值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//根据相对优先级确定适宜的方式，合并以a和b为根节点的两个左式堆</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">merge</span> <span class="params">( BinNodePosi(T) a, BinNodePosi(T) b )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( ! a ) <span class="keyword">return</span> b; <span class="comment">//退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( ! b ) <span class="keyword">return</span> a; <span class="comment">//退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( lt ( a-&gt;data, b-&gt;data ) ) swap ( a, b ); <span class="comment">//一般情况：首先确保b不大</span></span><br><span class="line">   a-&gt;rc = merge ( a-&gt;rc, b ); <span class="comment">//将a的右子堆，与b合并</span></span><br><span class="line">   a-&gt;rc-&gt;parent = a; <span class="comment">//并更新父子关系</span></span><br><span class="line">   <span class="keyword">if</span> ( !a-&gt;lc || a-&gt;lc-&gt;npl &lt; a-&gt;rc-&gt;npl ) <span class="comment">//若有必要</span></span><br><span class="line">      swap ( a-&gt;lc, a-&gt;rc ); <span class="comment">//交换a的左、右子堆，以确保右子堆的npl不大</span></span><br><span class="line">   a-&gt;npl = a-&gt;rc ? a-&gt;rc-&gt;npl + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">//更新a的npl</span></span><br><span class="line">   <span class="keyword">return</span> a; <span class="comment">//返回合并后的堆顶</span></span><br><span class="line">&#125; <span class="comment">//本算法只实现结构上的合并，堆的规模须由上层调用者负责更新</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong></p>
<p>借助递归分析图不难看出，所有递归实例可排成一个线性序列，实质上属于线性递归，其运行时间正比于递归深度。递归只可能发生在两个待合并子树的最右侧通路上。若待合并堆的规模分别为$n$和$m$，则其两条最右侧通路的长度分别不会超过：</p>
<p>$O(logn)+O(logm)=O(logn+logm)=O(log (max(n,m))$</p>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>基于merge操作实现<code>delMax()</code>算法，考查堆顶$x$及其子堆$H_L$和$H_R$。</p>
<p>在摘除x之后，$H_L$和$H_R$即可被视作为两个彼此独立待合并的堆。于是，只要通过<code>merge()</code>操作将它们合并起来，效果完全等效于常规的<code>delMax()</code>操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_LeftHeap&lt;T&gt;::delMax() &#123; <span class="comment">//基于合并操作的词条删除算法（当前队列非空）</span></span><br><span class="line">   BinNodePosi(T) lHeap = _root-&gt;lc; <span class="comment">//左子堆</span></span><br><span class="line">   BinNodePosi(T) rHeap = _root-&gt;rc; <span class="comment">//右子堆</span></span><br><span class="line">   T e = _root-&gt;data; <span class="keyword">delete</span> _root; _size--; <span class="comment">//删除根节点</span></span><br><span class="line">   _root = merge ( lHeap, rHeap ); <span class="comment">//原左右子堆合并</span></span><br><span class="line"><span class="comment">//   if ( _root ) _root-&gt;parent = NULL; //若堆非空，还需相应设置父子链接</span></span><br><span class="line">   <span class="keyword">return</span> e; <span class="comment">//返回原根节点的数据项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由合并操作的分析，时间成本总体依然不超过$O(log n)$</p>
<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>若将词条$x$插入堆H中，只要将$x$视为一个仅含单个节点的堆，则调用<code>merge()</code>操作后，其效果等效于完成了一次词条插入操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::insert ( T e ) &#123; <span class="comment">//基于合并操作的词条插入算法</span></span><br><span class="line">   BinNodePosi(T) v = <span class="keyword">new</span> BinNode&lt;T&gt; ( e ); <span class="comment">//为e创建一个二叉树节点</span></span><br><span class="line">   _root = merge ( _root, v ); <span class="comment">//通过合并完成新节点的插入</span></span><br><span class="line"><span class="comment">//   _root-&gt;parent = NULL; //既然此时堆非空，还需相应设置父子链接</span></span><br><span class="line">   _size++; <span class="comment">//更新规模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由合并操作的分析，时间成本总体依然不超过$O(log n)$</p>
<h1 id="栈堆-队堆"><a href="#栈堆-队堆" class="headerlink" title="栈堆/队堆"></a>栈堆/队堆</h1><p>为栈/队列提供在$O(1)$时间内访问最大值的接口，集成了栈/队列和堆属性的数据结构，称为栈堆(steap)/队堆(queap)。</p>
<h2 id="栈堆"><a href="#栈堆" class="headerlink" title="栈堆"></a>栈堆</h2><p>对于任何一个栈，可以引入另一个与之孪生的镜像P，P中的元素与S中的元素始终保持一一对应，前者的取值恰好是后者所有前驱中的最大者。当然P中元素必定按照单调非降的顺序排列。如此，任何时刻栈P的顶元素，都是栈S中的最大元素。为保持二者如上的对应关系，它们的push和pop必须同步进行。</p>
<p>若执行S.pop()，则只需同步地执行H.pop()，而若执行S.push(e),则需要同步地执行P.push(max(e,P.top()))。</p>
<p>以上方案还可以进一步优化。</p>
<p>可将栈P的空间进一步压缩，P中相等的元素必然彼此相邻，并因此可分为若干组。若假想式地令栈P中的每个元素通过指针指向栈S中的每个元素，而不是保留后者的副本，则可以将同组的元素合并起来，共享一个指针。当然，同时还需为合并后的元素增设一个计数器，记录原先同组元素的数目。如此改进之后，每一组元素只需保留以分，附加空间使用量可以大大降低。</p>
<p>相应地，在栈S每次执行出栈操作时，栈P必须同步地执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(--P.top().counter)) P.pop();</span><br></pre></td></tr></table></figure>
<p>而在栈S每次入栈时，栈P必须同步地执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">P.top()&lt;e ? P.push(e),P.top.counter=<span class="number">1</span> :P.top().counter++;</span><br></pre></td></tr></table></figure>
<p>可见，S的<code>push()</code>和<code>pop()</code>接口，依然保持$O(1)$效率。</p>
<h2 id="队堆"><a href="#队堆" class="headerlink" title="队堆"></a>队堆</h2><p>上述关于栈的技巧同样可以推广至队列结构，可以引入一个双端队列P，并依然约定，其中每个元素也是始终指向队列Q中所有前驱的最大者。</p>
<p>为保持二者的对应关系，它们的<code>dequeue()</code>和<code>enqueue()</code>接口必须同步进行，若执行：<code>Q.dequeue()</code>,则需同步地执行<code>P.removeFront()</code>，而若执行<code>Q.enqueue()</code>，则只需同步地执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">P.insertRear(e);</span><br><span class="line"><span class="keyword">for</span>(x=P.rear();x&amp;(x.key&lt;=e);x=x.pred)&#123;</span><br><span class="line">  x.key=e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了首先令e加入队列P，还需要将P尾部所有不大于e的元素统一更新为e。在最坏情况下，这需要$\Omega(n)$时间，而这种情况可能持续发生。造成这一困难的原因在于，队列中任一元素的前驱集，不再如栈中那样是固定的，而是可能增加，且新增元素可能非常大。</p>
<p>同样，可仿照前一技巧，将队列P压缩。然后在队列每次执行出队操作时，队列P必须同步地执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(--P.front().counter)) P.removeFront();</span><br></pre></td></tr></table></figure>
<p>而在队列Q每次执行入队时，队列P同步地执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!P.empty()&amp;&amp;(P.rear().key&lt;=e))</span><br><span class="line">   a+=P.removeRear().counter;<span class="comment">//当当前尾部元素不大于e时，累计计数器后删除该尾部元素</span></span><br><span class="line">P.insertRear(e);</span><br><span class="line">P.rear().counter=a;</span><br></pre></td></tr></table></figure>
<p>这里的while循环在最坏情况下仍然需要迭代$O(n)$步，但因为参与迭代的元素必然随即被删除，故就分摊意义而言仅为$O(1)$步，时间性能大为改善。</p>
<p>另外，这里的队列P并不需要双端队列的所有功能，<code>removeFront()</code>,<code>insertRear()</code>,<code>removeRear()</code>接口，无需使用<code>insertFront()</code>接口。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>trinkle
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://twinkle0331.github.io/algorithm/pq/" title="优先级队列">http://twinkle0331.github.io/algorithm/pq/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Data-structure/" rel="tag"><i class="fa fa-tag"></i> Data structure</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/algorithm/hash/" rel="prev" title="词典">
                  <i class="fa fa-chevron-left"></i> 词典
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/algorithm/string/" rel="next" title="串">
                  串 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">trinkle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
