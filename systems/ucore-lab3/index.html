<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"twinkle0331.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="ucore lab2通过段页式机制将虚拟内存映射到物理内存，并具体实现了物理内存管理空间中的连续内存分配算法。ucore lab3将实现非连续内存分配中的虚拟内存，借助之前的页表机制和中断异常机制，通过缺页异常的处理来衔接虚拟内存和物理内存之间的差异。与前者差异主要区别在于如何在磁盘交换区缓存页，从而提供比实际物理内存更大的虚拟内存空间。">
<meta property="og:type" content="article">
<meta property="og:title" content="ucore lab3">
<meta property="og:url" content="http://twinkle0331.github.io/systems/ucore-lab3/index.html">
<meta property="og:site_name" content="trinkle">
<meta property="og:description" content="ucore lab2通过段页式机制将虚拟内存映射到物理内存，并具体实现了物理内存管理空间中的连续内存分配算法。ucore lab3将实现非连续内存分配中的虚拟内存，借助之前的页表机制和中断异常机制，通过缺页异常的处理来衔接虚拟内存和物理内存之间的差异。与前者差异主要区别在于如何在磁盘交换区缓存页，从而提供比实际物理内存更大的虚拟内存空间。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/07/03/5d1cab4b16bfb33714.png">
<meta property="article:published_time" content="2019-07-03T12:07:36.000Z">
<meta property="article:modified_time" content="2021-03-27T13:17:35.000Z">
<meta property="article:author" content="trinkle">
<meta property="article:tag" content="ucore">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2019/07/03/5d1cab4b16bfb33714.png">


<link rel="canonical" href="http://twinkle0331.github.io/systems/ucore-lab3/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>ucore lab3 | trinkle</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="trinkle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">trinkle</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://twinkle0331.github.io/systems/ucore-lab3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trinkle">
      <meta itemprop="description" content="Stay foolish,stay hungry.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="trinkle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ucore lab3
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-03 20:07:36" itemprop="dateCreated datePublished" datetime="2019-07-03T20:07:36+08:00">2019-07-03</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Systems/" itemprop="url" rel="index"><span itemprop="name">Systems</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>ucore lab2通过段页式机制将虚拟内存映射到物理内存，并具体实现了物理内存管理空间中的连续内存分配算法。ucore lab3将实现非连续内存分配中的虚拟内存，借助之前的页表机制和中断异常机制，通过缺页异常的处理来衔接虚拟内存和物理内存之间的差异。与前者差异主要区别在于如何在磁盘交换区缓存页，从而提供比实际物理内存更大的虚拟内存空间。</p>
<a id="more"></a>

<p>lab2没有从一般应用程序对内存需求考虑，缺少相关的数据结构和操作来体现一般应用程序对虚拟内存的需求。ucore通过page fault异常处理来简洁完成虚拟内存和物理内存二者之间的衔接。故引入以下两个数据结构，描述ucore模拟应用程序所需的合法内存空间。当访问内存产生page fault异常时，根据访问内存的读写方式和具体的虚拟内存地址，判断是否在<code>vma_struct</code>所描述的合法地址空间范围内，如果在，则可根据具体情况请求调页/页换入换出处理，如果不在则报错。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mm结构体描述一个进程的虚拟地址空间，为进程pcb的成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;        <span class="comment">// 链接到同一页目录表的虚拟内存空间的双向链表 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">// 虚拟内存块缓冲区</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                  <span class="comment">//进程对应页目录表</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                 <span class="comment">//虚拟内存块的数目</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                 <span class="comment">//记录页访问情况的链表头</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//vma结构体描述其中一小部分虚拟地址空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">//vma对应虚拟内存空间属于的进程 </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start;      <span class="comment">//连续虚拟空间的起始位置    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;        <span class="comment">//连续虚拟空间的起始位置</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags;       <span class="comment">//属性 (可读/可写/可执行)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;  <span class="comment">//从小到大将虚拟内存地址空间链接到一起</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/07/03/5d1cab4b16bfb33714.png"></p>
<p>涉及<code>vma_struct</code>的操作主要为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct vma_struct * vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags)</span><br></pre></td></tr></table></figure>
<p>根据输入参数<code>vm_start</code>，<code>vm_end</code>,<code>vm_flags</code>来创建并描述一个虚拟内存空间的<code>vma_struct</code>结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma)</span><br></pre></td></tr></table></figure>
<p>把一个vma变量按照从小到大的顺序插入到所属的mm结构体的<code>mmap_list</code>链表中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct vma_struct * find_vma(struct mm_struct *mm, uintptr_t addr)</span><br></pre></td></tr></table></figure>
<p>根据输入参数addr和mm，查找在mm变量中包含该addr的vma,即满足<code>vma-&gt;vm_start&lt;=addr&lt;=vma-&gt;vm_end</code>。</p>
<p>涉及<code>mm_struct</code>的操作主要为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct mm_struct * mm_create(void)</span><br><span class="line">void mm_destroy(struct mm_struct *mm)</span><br></pre></td></tr></table></figure>
<p>在<code>mm_create</code>中用kmalloc分配一块用于<code>mm_struct</code>的空间并初始化，而<code>mm_destroy</code>是<code>mm_create</code>的逆过程，释放对应的空间。</p>
<h1 id="page-fault异常处理"><a href="#page-fault异常处理" class="headerlink" title="page fault异常处理"></a>page fault异常处理</h1><blockquote>
<p>完成do_pgfault（kern/mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限的时候需要参考页面所在VMA 的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">  ptep = get_pte(mm-&gt;pgdir,addr,<span class="number">1</span>);<span class="comment">//根据缺页地址查找对应pte,若对应页表不存在，则创建一个           //若pte对应的物理页不存在，则分配一物理页并建立物理地址与逻辑地址的映射关系 </span></span><br><span class="line">  <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pgdir_alloc_page(mm-&gt;pgdir,addr,perm)==<span class="literal">NULL</span>)&#123;</span><br><span class="line">           <span class="keyword">goto</span> failed;</span><br><span class="line">&#125;			 </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果PTE存在，则此时P位为0，该页被换出到swap分区中，需要换入内存中</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">          struct Page *page=<span class="literal">NULL</span>;                      </span><br><span class="line">          <span class="keyword">if</span>(ret=swap_in(mm,addr,&amp;page)!=<span class="number">0</span>)&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;swap_in in do_pgfault failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">//根据页目录表找到对应地址所在页在硬盘中的位置并读入				</span></span><br><span class="line">          page_insert(mm-&gt;pgdir,page,addr,perm);<span class="comment">//更改页表中对应项                  </span></span><br><span class="line">          swap_map_swappable(mm,addr,page,<span class="number">0</span>);	<span class="comment">//将该页加入到置换队列中</span></span><br><span class="line">	page-&gt;pra_vaddr=addr;<span class="comment">//设置该物理页对应的虚拟页的起始位置 </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">          <span class="keyword">goto</span> failed;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>do_pgfault</code>函数在缺页的时候被触发，表明用户访问的虚拟地址在物理内存中没有对应的映射，这种情况可能是非法访存，也有可能是合理访存。该函数先检查非法情况，即通过vma中的标志位判断。<br>页访问异常错误码有32位，位0为1表示对应物理页不存在;位1为1表示写异常(比如写了只读页);位2为1表示访问状态异常(比如用户程序访问了内核空间的数据)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">switch (error_code &amp; 3) &#123;</span><br><span class="line">    default:</span><br><span class="line">            &#x2F;* error code flag : default is 3 ( W&#x2F;R&#x3D;1, P&#x3D;1): write, present *&#x2F;</span><br><span class="line">    case 2: &#x2F;* error code flag : (W&#x2F;R&#x3D;1, P&#x3D;0): write, not present *&#x2F;</span><br><span class="line">        if (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(&quot;do_pgfault failed: error code flag &#x3D; write AND not present, but the addr&#39;s vma cannot write\n&quot;);</span><br><span class="line">            goto failed;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case 1: &#x2F;* error code flag : (W&#x2F;R&#x3D;0, P&#x3D;1): read, present *&#x2F;</span><br><span class="line">        cprintf(&quot;do_pgfault failed: error code flag &#x3D; read AND present\n&quot;);</span><br><span class="line">        goto failed;</span><br><span class="line">    case 0: &#x2F;* error code flag : (W&#x2F;R&#x3D;0, P&#x3D;0): read, not present *&#x2F;</span><br><span class="line">        if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(&quot;do_pgfault failed: error code flag &#x3D; read AND not present, but the addr&#39;s vma cannot read or exec\n&quot;);</span><br><span class="line">            goto failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上为异常情况。以上情况之一出现时，那么就会产生缺页异常。CPU会把产生异常的线性地址存储在CR2中，并把表示页访问异常类型的值(页访问异常错误码)保存在中断栈中。</p>
<p>CR2是页故障地址寄存器，保存最后一次出现页故障的全32位线性地址。CR2用于页异常时报告出错信息。当发生页访问异常时，处理器把引起页异常的地址保存在CR2中。操作系统中对应的中断服务例程可以检查CR2的内容，从而查出线性地址空间哪个页引起本次异常。</p>
<p>我们需要完成的部分是对合理访问内存的处理。合理访问内存又分为以下两种情况：</p>
<ul>
<li>该页存在于swap分区中</li>
<li>第一次访问该页，仅在<code>vma_struct</code>中存在对应区域，而没有写入页表，分配物理页</li>
</ul>
<p>此外，我们再关注一下<code>check_pgfault</code>的实现，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pde_t *pgdir &#x3D; mm-&gt;pgdir &#x3D; boot_pgdir;</span><br></pre></td></tr></table></figure>
<p>在启动阶段建立好了启动页目录表，并且建立了如下映射关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt addr &#x3D; linear addr &#x3D; phy addr + 0xC0000000</span><br></pre></td></tr></table></figure>
<p>程序在声明变量时会分配对应的内存并建立映射关系，若直接访问或读取之前声明过的变量则不会引发page fault。这里将初始指针指向<code>0x100</code> ，<code>0x100</code>存在于第1个虚拟页中，在初始的映射关系中并没有相关的条目，所以在第一次访问时触发缺页异常，此后访问地址都在一页的范围内，不会再引发异常。另外，虚拟地址从 <code>0xC0000000</code>开始是启动阶段的映射，之后的访问会动态改变其中页表项，映射也将不再是单一的连续映射，访问虚拟内存地址空间的地址均可以，并不是只有<code>0xC0000000</code>以后的虚拟地址才为合法的地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">struct vma_struct *vma &#x3D; vma_create(0, PTSIZE, VM_WRITE);</span><br><span class="line">insert_vma_struct(mm, vma);</span><br></pre></td></tr></table></figure>
<p>设置从0开始的1024个虚拟页为合法地址空间，并插入到对应的<code>mm_struct</code>中。</p>
<blockquote>
<p>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。</p>
</blockquote>
<p>通过设置PTE中的标志位来查看缺页中断的原因，在扩展时钟算法中，则需要使用PTE中的Access位和Dirty位进行记录该页的历史访问情况。</p>
<ul>
<li>页表项中的访问位用于页面置换算法，页面置换算法可能需要根据不同页面是否被访问，访问时间和访问频率等进行淘汰页面的选择。</li>
<li>页表项中修改位供换出页面使用，页面换出的时候，需要判断外存上的相应页面是否需要重写。如果内存中该页面在使用期间发生了修改，则相应的修改位被设置，用于换出的时候通知操作系统进行外存相应页面的修改。</li>
<li>页表项的状态位用于指示该页是否已经调入内存，供程序访问时使用，如果发现该页未调入内存，则产生缺页中断，由操作系统进行相应处理。</li>
</ul>
<blockquote>
<p>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p>
</blockquote>
<p>这种情况一般不会发生，除非操作系统内核出现故障。对于x86的CPU，会保存现场，并进入double_fault异常而非缺页异常供操作系统开发人员捕捉错误并处理。对于Qemu来说，三次出现嵌套缺页异常的情况下模拟器就会出错退出。</p>
<blockquote>
<p>页目录项和页表项的dirty bit是何时，由谁置1的？</p>
</blockquote>
<p>在页面被修改时由硬件置1的。</p>
<blockquote>
<p>页目录项和页表项的access bit是何时，由谁置1的？</p>
</blockquote>
<p>在页面被访问时由硬件置1的。</p>
<h1 id="页面置换机制"><a href="#页面置换机制" class="headerlink" title="页面置换机制"></a>页面置换机制</h1><h2 id="可以换出的页"><a href="#可以换出的页" class="headerlink" title="可以换出的页"></a>可以换出的页</h2><p>一个基本的原则是：并非所有的物理页都可以交换出去的，只有映射到用户空间且被用户程序直接访问的页面才能被交换，而被内核直接使用的内核空间的页面不能被换出。操作系统是执行的关键代码，需要保证运行的高效性和实时性，如果在操作系统执行过程中，发生了缺页现象，则操作系统不得不等很长时间（硬盘的访问速度比内存的访问速度慢2~3个数量级），这将导致整个系统运行低效。不难想象，处理缺页过程所用到的内核代码或者数据如果被换出，整个内核都面临崩溃的危险。</p>
<h2 id="虚存中的页与硬盘上扇区的关系"><a href="#虚存中的页与硬盘上扇区的关系" class="headerlink" title="虚存中的页与硬盘上扇区的关系"></a>虚存中的页与硬盘上扇区的关系</h2><p>如果一个页被置换到了硬盘上，那操作系统如何简洁地来表示这种情况呢？在ucore的设计上，在PTE中描述这种情况：当一个PTE用来描述一般意义上的物理页时，显然它应该维护各种权限和映射关系，同时有PTE_P标记；但当它用来描述一个被置换出去的物理页时，它被用来维护该物理页与 swap 磁盘上扇区的映射关系，并且该 PTE 不应该由 MMU 将它解释成物理页映射(即没有 PTE_P 标记)，与此同时对应的权限则交由 <code>mm_struct</code> 来维护，当访问位于该页的内存地址时，必然导致 page fault，然后ucore能够根据 PTE 描述的 swap 项将相应的物理页重新建立起来，并根据虚存所描述的权限重新设置好 PTE 使得内存访问能够继续正常进行。</p>
<p><code>swap_out</code>中设置pte的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">v=page-&gt;pra_vaddr; </span><br><span class="line"><span class="keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, v, <span class="number">0</span>);</span><br><span class="line">assert((*ptep &amp; PTE_P) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (swapfs_write( (page-&gt;pra_vaddr/PGSIZE+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>, page) != <span class="number">0</span>) &#123;</span><br><span class="line">	cprintf(<span class="string">&quot;SWAP: failed to save\n&quot;</span>);</span><br><span class="line">	sm-&gt;map_swappable(mm, v, page, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	cprintf(<span class="string">&quot;swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n&quot;</span>, i, v, page-&gt;pra_vaddr/PGSIZE+<span class="number">1</span>);</span><br><span class="line">	*ptep = (page-&gt;pra_vaddr/PGSIZE+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">	free_page(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swap_in</code>中访问pte的操作如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// cprintf(&quot;SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n&quot;, ptep, (*ptep)&gt;&gt;8, addr, result, (result-pages));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">if</span> ((r = swapfs_read((*ptep), result)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">assert(r!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapfs_read</code>的定义为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int swapfs_read(swap_entry_t entry, struct Page *page)</span><br></pre></td></tr></table></figure>
<p>此时<code>ptep</code>指向的内容为<code>swap_entry_t</code>类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">swap_entry_t</span><br><span class="line">  --------------------------------------------</span><br><span class="line"> |         offset        |   reserved   | 0 |</span><br><span class="line">  --------------------------------------------</span><br><span class="line">           24 bits            7 bits    1 bit</span><br></pre></td></tr></table></figure>
<p>如果一个页（4KB/页）被置换到了硬盘某8个扇区（0.5KB/扇区），该PTE的最低位(present位)应该为0 （即 PTE_P 标记为空，表示虚实地址映射关系不存在，接下来的7位暂时保留，可以用作各种扩展；而原来用来表示页帧号的高24位地址，恰好可以用来表示此页在硬盘上的起始扇区的位置（其从第几个扇区开始）。为了在页表项中区别 0 和 swap 分区的映射，将 swap 分区的一个 page 空出来不用，也就是说一个高24位不为0，而最低位为0的PTE表示了一个放在硬盘上的页的起始扇区号。通过这种方式来映射磁盘扇区。</p>
<p>ucore用了第二个IDE硬盘作为交换区来保存被换出的扇区，262144/8=32768个页，即128MB的内存空间。</p>
<h2 id="执行换入换出的时间"><a href="#执行换入换出的时间" class="headerlink" title="执行换入换出的时间"></a>执行换入换出的时间</h2><p><strong>换入的时机</strong></p>
<p>当ucore或应用程序访问地址所在的页不在内存时，就会产生page fault异常，之后调用<strong>do_pgfault</strong>函数，判断产生访问异常的地址属于<code>check_mm_struct</code>的合法虚拟地址空间，若保存在硬盘swap文件中（即对应的PTE的高24位不为0，而最低位为0），则是执行页换入的时机，将调用swap_in函数完成页面换入。</p>
<p><strong>换出的时机</strong></p>
<p>换出针对不同的策略有不同的时机。ucore目前大致有两种策略，即积极换出策略和消极换出策略。</p>
<ul>
<li>积极换出策略是指操作系统周期性地（或在系统不忙的时候）主动把某些认为“不常用”的页换出到硬盘上，从而确保系统中总有一定数量的空闲页存在，这样当需要空闲页时，基本上能够及时满足需求</li>
<li>消极换出策略是指，只是当试图得到空闲页时，发现当前没有空闲的物理页可供分配，这时才开始查找“不常用”页面，并把一个或多个这样的页换出到硬盘上。</li>
</ul>
<h1 id="基于FIFO的页面替换算法"><a href="#基于FIFO的页面替换算法" class="headerlink" title="基于FIFO的页面替换算法"></a>基于FIFO的页面替换算法</h1><p>完成vmm.c中的<code>do_pgfault</code>函数，并且在实现FIFO算法的<code>swap_fifo.c</code>中完成<code>map_swappable</code>和<code>swap_out_victim</code>函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"> </span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">	list_add(head,entry);<span class="comment">//将这一页插入到head之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">         assert(head != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_tick==<span class="number">0</span>); </span><br><span class="line">	 <span class="keyword">list_entry_t</span> *le=head-&gt;prev;<span class="comment">//设为最先进入的页</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span>=</span>le2page(le,pra_page_link);</span><br><span class="line">	 list_del(le);<span class="comment">//从置换队列中移出</span></span><br><span class="line">	 *ptr_page=page;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lab3内容较少，将后面部分的trapframe context挪至此处。</p>
</blockquote>
<h1 id="trapframe和context的原理和区别"><a href="#trapframe和context的原理和区别" class="headerlink" title="trapframe和context的原理和区别"></a>trapframe和context的原理和区别</h1><p>在ucore中，<code>trapframe</code>和<code>context</code>均出现在了线程的调度中。实际上，结构体<code>trapframe</code>用于切换优先级、页表目录等，而<code>context</code>则是用于轻量级的上下文切换。两者的区别在于<code>context</code>仅仅能够切换普通寄存器，而<code>trapframe</code>可以切换包括普通寄存器、段寄存器以及少量的控制寄存器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">struct trapframe &#123;</span><br><span class="line">    struct pushregs tf_regs;</span><br><span class="line">    uint16_t tf_gs;</span><br><span class="line">    uint16_t tf_padding0;</span><br><span class="line">    uint16_t tf_fs;</span><br><span class="line">    uint16_t tf_padding1;</span><br><span class="line">    uint16_t tf_es;</span><br><span class="line">    uint16_t tf_padding2;</span><br><span class="line">    uint16_t tf_ds;</span><br><span class="line">    uint16_t tf_padding3;</span><br><span class="line">    uint32_t tf_trapno;</span><br><span class="line">    &#x2F;* below here defined by x86 hardware *&#x2F;</span><br><span class="line">    uint32_t tf_err;</span><br><span class="line">    uintptr_t tf_eip;</span><br><span class="line">    uint16_t tf_cs;</span><br><span class="line">    uint16_t tf_padding4;</span><br><span class="line">    uint32_t tf_eflags;</span><br><span class="line">    &#x2F;* below here only when crossing rings, such as from user to kernel *&#x2F;</span><br><span class="line">    uintptr_t tf_esp;</span><br><span class="line">    uint16_t tf_ss;</span><br><span class="line">    uint16_t tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p><code>trapframe</code>中依次存储了：</p>
<ul>
<li>目标寄存器</li>
<li><code>gs</code>, <code>fs</code>, <code>es</code>, <code>ds</code> 段寄存器</li>
<li><code>tf_trapno</code>, <code>err</code> 用于储存中断信息</li>
<li><code>eip</code>, <code>cs</code>, <code>eflags</code> 用于存储陷阱(trap)返回后的目的地址</li>
<li><code>esp</code>, <code>ss</code> 在权限发生变化时，用于指示新的栈的位置</li>
</ul>
<p>ucore有两处用到了<code>trapframe</code>，一是中断调用，而是进程切换，接下来分别分析二者的情况</p>
<h2 id="中断调用中使用trapframe"><a href="#中断调用中使用trapframe" class="headerlink" title="中断调用中使用trapframe"></a>中断调用中使用trapframe</h2><p><code>trapframe</code>在中断中，在前期负责中断信息的储存，后期负责中断的恢复。同时，<code>trapframe</code>结构体是位于栈中的，其生成和使用都是通过栈的<code>push</code>、<code>pop</code>命令实现的。</p>
<p>中断发生时，以下代码将信息压入栈中，与tf结构体中成员变量一一对应，之后调用<code>trap(struct trapframe *tf)</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.globl __alltraps</span><br><span class="line">__alltraps:</span><br><span class="line">    # push registers to build a trap frame</span><br><span class="line">    # therefore make the stack look like a struct trapframe</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # load GD_KDATA into %ds and %es to set up data segments for kernel</span><br><span class="line">    movl $GD_KDATA, %eax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    # push %esp to pass a pointer to the trapframe as an argument to trap()</span><br><span class="line">    pushl %esp</span><br><span class="line"></span><br><span class="line">    # call trap(tf), where tf&#x3D;%esp</span><br><span class="line">    call trap</span><br></pre></td></tr></table></figure>
<p>中断处理结束后，将原来信息一一pop，从而恢复之前的执行状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># pop the pushed stack pointer</span><br><span class="line">    popl %esp</span><br><span class="line"></span><br><span class="line">    # return falls through to trapret...</span><br><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>
<p>在调用<code>call trap</code>之后，有一句<code>popl %esp</code>，而后续恢复的信息完全是基于该<code>%esp</code>进行定位的，那么在中断处理内存中，如果我们强行修改<code>%esp</code>成为我们希望接下来运行的代码段的trap描述，那么经过<code>__trapret</code>代码恢复<code>trapframe</code>后，你就可以让程序跳转到任何你希望的地方。</p>
<p>在lab1的challenge中，我们通过以下设置<code>trapframe</code>来完成用户态到内核态的切换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">        tf-&gt;tf_cs = KERNEL_CS;<span class="comment">//直接修改内核堆栈</span></span><br><span class="line">        tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">        tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">        switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (<span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>));</span><br><span class="line">        <span class="comment">//tf结构体开始的位置</span></span><br><span class="line">        memmove(switchu2k, tf, <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>);</span><br><span class="line">        <span class="comment">//由于进入中断时，是用户态进入内核态，而退出中断时，是内核态返回内核态</span></span><br><span class="line">        <span class="comment">//所以去掉最后的esp与ss</span></span><br><span class="line">        *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)switchu2k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>((uint32_t *)tf - 1)</code> 地址后存放了我们修改后的<code>trapframe</code>，即<code>popl %esp</code>恢复的<code>%esp</code>的值。</p>
<h2 id="进程切换中使用context"><a href="#进程切换中使用context" class="headerlink" title="进程切换中使用context"></a>进程切换中使用context</h2><p><code>context</code>结构体定义如下，其中存储了所有用户寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct context &#123;</span><br><span class="line">    uint32_t eip;</span><br><span class="line">    uint32_t esp;</span><br><span class="line">    uint32_t ebx;</span><br><span class="line">    uint32_t ecx;</span><br><span class="line">    uint32_t edx;</span><br><span class="line">    uint32_t esi;</span><br><span class="line">    uint32_t edi;</span><br><span class="line">    uint32_t ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>context</code>结构体主要在<code>switch_to</code> 函数中用到，<code>switch_to</code>传入前后两个<code>context</code>的地址， <code>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context))</code> ，具体实现如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">switch_to:                      # switch_to(from, to)</span><br><span class="line"></span><br><span class="line">    # save from&#39;s registers</span><br><span class="line">    movl 4(%esp), %eax          # eax points to from</span><br><span class="line">    popl 0(%eax)                # save eip !popl</span><br><span class="line">    movl %esp, 4(%eax)          # save esp::context of from</span><br><span class="line">    movl %ebx, 8(%eax)          # save ebx::context of from</span><br><span class="line">    movl %ecx, 12(%eax)         # save ecx::context of from</span><br><span class="line">    movl %edx, 16(%eax)         # save edx::context of from</span><br><span class="line">    movl %esi, 20(%eax)         # save esi::context of from</span><br><span class="line">    movl %edi, 24(%eax)         # save edi::context of from</span><br><span class="line">    movl %ebp, 28(%eax)         # save ebp::context of from</span><br><span class="line"></span><br><span class="line">    # restore to&#39;s registers</span><br><span class="line">    movl 4(%esp), %eax          # not 8(%esp): popped return address already</span><br><span class="line">                                # eax now points to to</span><br><span class="line">    movl 28(%eax), %ebp         # restore ebp::context of to</span><br><span class="line">    movl 24(%eax), %edi         # restore edi::context of to</span><br><span class="line">    movl 20(%eax), %esi         # restore esi::context of to</span><br><span class="line">    movl 16(%eax), %edx         # restore edx::context of to</span><br><span class="line">    movl 12(%eax), %ecx         # restore ecx::context of to</span><br><span class="line">    movl 8(%eax), %ebx          # restore ebx::context of to</span><br><span class="line">    movl 4(%eax), %esp          # restore esp::context of to</span><br><span class="line"></span><br><span class="line">    pushl 0(%eax)               # push eip</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h2 id="进程切换中使用trapframe"><a href="#进程切换中使用trapframe" class="headerlink" title="进程切换中使用trapframe"></a>进程切换中使用trapframe</h2><p>进程切换仅仅通过<code>switch_to</code>函数是不够的，<code>switch_to</code>仅仅保存、恢复了普通寄存器，无法实现优先级跳转、段寄存器修改等等。接下来的工作就需要借助<code>trapframe</code>了。</p>
<p>由于<code>switch_to</code>函数跳转后，将调到<code>context.eip</code>位置。而这个跳转我们没法完全实现进程切换，所以我们可以将其设置为一个触发二级跳转的函数的地址，即<code>forkret</code>的地址入口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;context.eip &#x3D; (uintptr_t)forkret;</span><br><span class="line">proc-&gt;context.esp &#x3D; (uintptr_t)(proc-&gt;tf);</span><br></pre></td></tr></table></figure>
<p><code>forkret</code>函数定义如下，将当前进程的<code>trapframe</code>作为参数传入来切换进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">forkret(<span class="keyword">void</span>) &#123;</span><br><span class="line">    forkrets(current-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forkrets</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # set stack to this new process&#39;s trapframe</span><br><span class="line">    movl 4(%esp), %esp</span><br><span class="line">    jmp __trapret</span><br></pre></td></tr></table></figure>
<p>然后再次回到中断恢复部分的代码，而其中的逻辑也完全相同。最终，进程跳转到目标进程的入口，而该入口的地址，被存放在<code>proc-&gt;tf</code>中。切换后进程对应的<code>trapframe</code>在<code>kernel_thread</code>函数中设置，将调用函数入口<code>fn</code>被储存在了<code>eip</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">kernel_thread(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>trinkle
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://twinkle0331.github.io/systems/ucore-lab3/" title="ucore lab3">http://twinkle0331.github.io/systems/ucore-lab3/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/ucore/" rel="tag"><i class="fa fa-tag"></i> ucore</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/systems/paging/" rel="prev" title="页面置换算法">
                  <i class="fa fa-chevron-left"></i> 页面置换算法
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/systems/process-thread/" rel="next" title="进程 线程">
                  进程 线程 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">trinkle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  


</body>
</html>
