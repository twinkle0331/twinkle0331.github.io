<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"twinkle0331.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="在之前的lab5中，进程通过读ELF定义全局变量来标识程序的起始位置和信息，从而将程序加载到内存中，从而执行存储在磁盘上的文件读写功能。每次读入数据均从ELF文件中读入显然不现实，所以由操作系统中的文件系统来负责管理和存储可长期保存数据。alb8主要侧重于文件系统的实现，从而实现对文件和目录的一系列操作。 文件系统涉及到的内容比较多，这也是我们称之为文件系统而不是文件子系统的原因吧。">
<meta property="og:type" content="article">
<meta property="og:title" content="ucore lab8">
<meta property="og:url" content="http://twinkle0331.github.io/systems/ucore-lab8/index.html">
<meta property="og:site_name" content="trinkle">
<meta property="og:description" content="在之前的lab5中，进程通过读ELF定义全局变量来标识程序的起始位置和信息，从而将程序加载到内存中，从而执行存储在磁盘上的文件读写功能。每次读入数据均从ELF文件中读入显然不现实，所以由操作系统中的文件系统来负责管理和存储可长期保存数据。alb8主要侧重于文件系统的实现，从而实现对文件和目录的一系列操作。 文件系统涉及到的内容比较多，这也是我们称之为文件系统而不是文件子系统的原因吧。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/08/31/QjVlPZ1EbFWmSfG.png">
<meta property="og:image" content="https://i.loli.net/2019/08/31/67vZJ9m4efHEFDl.png">
<meta property="og:image" content="https://i.loli.net/2019/08/31/ERG6KYA4jIqJmWo.png">
<meta property="og:image" content="https://i.loli.net/2019/08/31/tEDeMYzCdaR7wZB.png">
<meta property="og:image" content="https://i.loli.net/2019/08/31/4ZKmSfohRpVT7Fz.png">
<meta property="og:image" content="https://i.loli.net/2019/08/31/uDwSmTabAkN8dZJ.png">
<meta property="og:image" content="https://i.loli.net/2019/08/31/BAlS6qjfxodVGZY.png">
<meta property="og:image" content="https://i.loli.net/2019/09/01/xmzKW4QO2vntuwa.png">
<meta property="article:published_time" content="2019-07-08T00:08:03.000Z">
<meta property="article:modified_time" content="2021-03-27T13:17:35.000Z">
<meta property="article:author" content="trinkle">
<meta property="article:tag" content="ucore">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2019/08/31/QjVlPZ1EbFWmSfG.png">


<link rel="canonical" href="http://twinkle0331.github.io/systems/ucore-lab8/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>ucore lab8 | trinkle</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="trinkle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">trinkle</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://twinkle0331.github.io/systems/ucore-lab8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trinkle">
      <meta itemprop="description" content="Stay foolish,stay hungry.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="trinkle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ucore lab8
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-08 08:08:03" itemprop="dateCreated datePublished" datetime="2019-07-08T08:08:03+08:00">2019-07-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Systems/" itemprop="url" rel="index"><span itemprop="name">Systems</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在之前的lab5中，进程通过读ELF定义全局变量来标识程序的起始位置和信息，从而将程序加载到内存中，从而执行存储在磁盘上的文件读写功能。每次读入数据均从ELF文件中读入显然不现实，所以由操作系统中的文件系统来负责管理和存储可长期保存数据。alb8主要侧重于文件系统的实现，从而实现对文件和目录的一系列操作。</p>
<p>文件系统涉及到的内容比较多，这也是我们称之为文件系统而不是文件子系统的原因吧。</p>
<a id="more"></a>

<blockquote>
<p>填写已有实验</p>
</blockquote>
<p>本实验依赖实验1/2/3/4/5/6/7。请把你做的实验1/2/3/4/5/6/7的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6” /“LAB7”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab8的测试应用程序，可能需对已完成的实验1/2/3/4/5/6/7的代码进行进一步改进。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *<span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    proc-&gt;filesp = <span class="literal">NULL</span>;<span class="comment">//初始化进程控制块中文件信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以拷贝文件的方式来完成父子进程之间的拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (copy_files(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unix提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)、安装点(mount point)</p>
<ul>
<li><p>文件：unix文件中的内容可以理解为有序字节buffer，文件都有一个方便应用程序识别的文件名称。</p>
</li>
<li><p>目录项：目录项不是目录，而是目录的组成部分。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：根目录“/”，目录“test”和文件“testfile”，这三个都是目录项。一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点位置。</p>
</li>
<li><p>索引节点：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</p>
</li>
<li><p>安装点：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为根文件系统树中的叶子出现在系统中。</p>
</li>
</ul>
<p>上述抽象概念形成了UNIX文件系统的逻辑数据结构，并需要通过一个具体文件系统的架构设计与实现把上述信息映射并储存到磁盘介质上。一个具体的文件系统需要在磁盘布局也实现上述抽象概念。比如文件元数据信息存储在磁盘块中的索引节点上。当文件被载如内存时，内核需要使用磁盘块中的索引点来构造内存中的索引节点。</p>
<p><img src="https://i.loli.net/2019/08/31/QjVlPZ1EbFWmSfG.png"></p>
<p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p>
<ul>
<li>通用文件系统访问接口层：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li>
<li>文件系统抽象层：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li>
<li>Simple FS文件系统层：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li>
<li>外设接口层：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li>
</ul>
<p>以用户态写文件函数write的整个执行过程为例，我们可以比较清晰地看到ucore文件系统架构的层次和依赖关系</p>
<p><img src="https://i.loli.net/2019/08/31/67vZJ9m4efHEFDl.png"></p>
<p><img src="https://i.loli.net/2019/08/31/ERG6KYA4jIqJmWo.png"></p>
<p><img src="https://i.loli.net/2019/08/31/tEDeMYzCdaR7wZB.png"></p>
<p><img src="https://i.loli.net/2019/08/31/4ZKmSfohRpVT7Fz.png"></p>
<p>从ucore操作系统来看，ucore文件系统架构主要包含四类主要的数据结构，分别为：</p>
<ul>
<li>超级块（SuperBlock）：它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li>索引节点（inode）：它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的特定目录。它的作用范围是整个OS空间。</li>
<li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
<p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构和关系如下所示</p>
<p>在<code>kern/process/proc.h</code>中定义的<code>proc_struct</code>中定义了进程访问当前文件的数据接口<code>files_struct</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">filesp</span>;</span>                <span class="comment">// the file related info(pwd, files_count, files_array, fs_semaphore) of process</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>files_struct</code>数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// inode of present working directory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// opened files array</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// the number of opened files</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// lock protect sem</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/08/31/uDwSmTabAkN8dZJ.png"></p>
<p><code>inode</code>数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;</span><br><span class="line">    <span class="keyword">int</span> ref_count;</span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sfs_inode</code>数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sfs_disk_inode</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* inode (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                  <span class="comment">/* size of the file (in bytes) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                  <span class="comment">/* one of SYS_TYPE_* above */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                                <span class="comment">/* # of hard links to this file */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* # of blocks */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="comment">/* direct blocks */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                              <span class="comment">/* indirect blocks */</span></span><br><span class="line"><span class="comment">//    uint32_t db_indirect;                           /* double indirect blocks */</span></span><br><span class="line"><span class="comment">//   unused</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/08/31/BAlS6qjfxodVGZY.png"></p>
<h1 id="通用文件系统访问接口"><a href="#通用文件系统访问接口" class="headerlink" title="通用文件系统访问接口"></a>通用文件系统访问接口</h1><p>lab8中定义了一系列与文件系统有关的用户函数，首先讨论对单个文件进行操作的系统调用。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">return</span> sys_open(path, open_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">close(<span class="keyword">int</span> fd) &#123;</span><br><span class="line">    <span class="keyword">return</span> sys_close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">return</span> sys_read(fd, base, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">write(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">return</span> sys_write(fd, base, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在文件操作方面，最基本的相关函数为<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>。在读写一个文件之前，首先调用open系统调用将文件打开。open的第一个参数指定文件的路径名，可使用绝对路径名，第二个参数指定打开的方式，可设置为<code>O_RDONLY</code>，<code>O_WRONLY</code>，<code>O_RDWR</code>，分别表示只读，只写，可读可写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* VFS flags */</span></span><br><span class="line"><span class="comment">// flags for open: choose one of these</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDONLY            0           <span class="comment">// open for reading only</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_WRONLY            1           <span class="comment">// open for writing only</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDWR              2           <span class="comment">// open for reading and writing</span></span></span><br><span class="line"><span class="comment">// then or in any of these:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_CREAT             0x00000004  <span class="comment">// create file if it does not exist</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_EXCL              0x00000008  <span class="comment">// error if O_CREAT and the file exists</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_TRUNC             0x00000010  <span class="comment">// truncate file upon open</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_APPEND            0x00000020  <span class="comment">// append on each write</span></span></span><br><span class="line"><span class="comment">// additonal related definition</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_ACCMODE           3           <span class="comment">// mask for O_RDONLY / O_WRONLY / O_RDWR</span></span></span><br></pre></td></tr></table></figure>
<p>读写文件内容的系统调用是<code>read</code>和<code>write</code>。<code>read</code>调用有三个参数：一个指定所操作的文件描述符，一个指定读取数据的存放地址，最后一个指定读多少字节。</p>
<p>在c语言中对应的系统调用为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count &#x3D; read(filehandle, buffer, nbytes);</span><br></pre></td></tr></table></figure>
<p>该系统调用将实际读到的字节数返回给<code>count</code>变量。在正常情况下与<code>nbytes</code>相等，但有时可能会小一些。例如，读文件直到文件结束符的位置，从而提前结束此次读操作。若由于参数无效或者磁盘访问错误等原因此次系统调用失败，则<code>count</code>置为-1,<code>write</code>函数的参数与<code>read</code>函数一样。</p>
<p>接下来是对目录的操作。</p>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>对于目录而言，最常用的操作是跳转到某个目录，对应的用户库函数为<code>chdir</code>，然后读目录的内容，即列出目录中的文件或目录名，在操作上与读文件类似，首先通过<code>opendir</code>打开目录，通过<code>readdir</code>来读取目录中的文件信息，读完后再调用<code>closedir</code>来关闭目录。由于在ucore中，目录为特殊的文件，所以<code>opendir</code>和<code>closedir</code>实际上是调用文件相关的<code>open</code>和<code>close</code>函数。只有<code>readdir</code>需要调用获取目录内容的特殊系统调用<code>sys_getdirentry</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DIR dir, *dirp=&amp;dir;</span><br><span class="line">DIR *</span><br><span class="line">opendir(<span class="keyword">const</span> <span class="keyword">char</span> *path) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dirp-&gt;fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">stat</span>, *<span class="title">stat</span> =</span> &amp;__stat;</span><br><span class="line">    <span class="keyword">if</span> (fstat(dirp-&gt;fd, stat) != <span class="number">0</span> || !S_ISDIR(stat-&gt;st_mode)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    dirp-&gt;dirent.offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dirp;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *</span></span><br><span class="line"><span class="class"><span class="title">readdir</span>(<span class="title">DIR</span> *<span class="title">dirp</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (sys_getdirentry(dirp-&gt;fd, &amp;(dirp-&gt;dirent)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(dirp-&gt;dirent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">closedir(DIR *dirp) &#123;</span><br><span class="line">    close(dirp-&gt;fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与文件相关的<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>用户库函数对应的是<code>sys_open</code>、<code>sys_close</code>、<code>sys_read</code>、<code>sys_write</code>四个系统调用接口。与目录相关的<code>readdir</code>用户库函数对应的是<code>sys_getdirentry</code>系统调用。这些系统调用函数接口将通过<code>syscall</code>函数来获得ucore的内核服务。在内核态时调用文件系统抽象层的文件和目录接口。</p>
<h1 id="文件系统抽象层"><a href="#文件系统抽象层" class="headerlink" title="文件系统抽象层"></a>文件系统抽象层</h1><p>文件系统抽象层将不同文件系统对外共性接口提取出来，与之前类似，以函数指针的形式封装，从而是通用文件系统访问层只需访问文件系统抽象层而不用关注具体实现。</p>
<h2 id="文件和目录接口"><a href="#文件和目录接口" class="headerlink" title="文件和目录接口"></a>文件和目录接口</h2><p>文件、目录接口层定义了进程在内核中直接访问的文件相关信息，在<code>file</code>数据结构中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;</span><br><span class="line">    <span class="keyword">bool</span> readable;</span><br><span class="line">    <span class="keyword">bool</span> writable;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">off_t</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当创建一个进程后，该进程的<code>files_struct</code> 会被初始化或复制当前父进程的<code>files_struct</code>。当用户进程打开一个文件时，将从<code>fd_array</code>数组中取出一个空闲的file项，将此成员变量node指针指向一个代表此文件的inode起始地址。</p>
<h2 id="inode接口"><a href="#inode接口" class="headerlink" title="inode接口"></a>inode接口</h2><p>inode(index node)是位于内存的节点，是文件的抽象表示，负责把不同文件系统的特定索引节点信息统一封装起来，避免了进程直接访问具体文件系统。</p>
<p>在inode中的成员变量<code>inode_ops</code>定义了一系列对<code>inode</code>的操作函数，具体描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="comment">//返回文件的状态信息，返回指针指向stat数据结构</span></span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>inode_ops</code>是对常规文件、目录、设备文件所有操作的一个抽象函数表示。</p>
<h1 id="SFS文件系统"><a href="#SFS文件系统" class="headerlink" title="SFS文件系统"></a>SFS文件系统</h1><p>ucore将所有文件视为字节流，任何内部逻辑都是专用的，由应用程序负责解释，但是ucore在物理结构上对文件加以区分。ucore目前支持以下几种类型的文件：</p>
<ul>
<li>常规文件：文件中包括的内容信息是由应用程序输入。SFS文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节。</li>
<li>目录：包含一系列的entry，每个entry包含文件名和指向与之相关联的索引节点（index node）的指针。目录是按层次结构组织的。</li>
<li>链接文件：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名。</li>
<li>设备文件：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制。可通过设备文件访问外围设备。</li>
<li>管道：管道是进程间通讯的一个基础设施。管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据。</li>
</ul>
<h2 id="文件系统的布局"><a href="#文件系统的布局" class="headerlink" title="文件系统的布局"></a>文件系统的布局</h2><p>文件系统通常保存在硬盘上，前两个磁盘分别是<code>ucore.img</code>和<code>swap.img</code>，第三个磁盘(disk 0)用于存放一个SFS文件系统。通常文件系统中磁盘的使用是以扇区为单位的，为了便于实现,SFS中以block(4K，与一页的大小相等)为基本单位。</p>
<p>SFS文件系统布局如下所示：</p>
<p><img src="https://i.loli.net/2019/09/01/xmzKW4QO2vntuwa.png"></p>
<p>第0块(4K)是超级块，包含了关于文件系统的所有关键参数。当计算机被启动或首次接触时，超级块的内容就会被装入内存。具体描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                                 <span class="comment">/* magic number, should be SFS_MAGIC */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* # of blocks in fs */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused_blocks;                         <span class="comment">/* # of unused blocks in fs */</span></span><br><span class="line">    <span class="keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">/* infomation for sfs  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中magic的值在宏定义时给出，内核通过magic值来检查镜像是否为合法的SFS.img</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SFS_MAGIC                                   0x2f8dbe2a   </span><br></pre></td></tr></table></figure>
<p>第1块放了root-dir的inode，用来记录根目录的相关信息。通过root-dir是sfs文件系统的根节点，通过root-dir的inode可以定位并查找到根目录下的所有文件信息。</p>
<p>从第2个块开始，用位图的形式来标记所有块的使用情况，每个块用1bit来标明，这个区域被称为是freemap区域。在<code>bitmap.h</code>中位图数据结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nbits;</span><br><span class="line">    <span class="keyword">uint32_t</span> nwords;</span><br><span class="line">    WORD_TYPE *<span class="built_in">map</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>剩余的磁盘空间存放了所有其他目录和文件的inode信息和内容数据信息。这里每个inode都用一个完整的block来存储。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_do_mount(struct device *dev, struct fs **fs_store) &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(struct sfs_super));</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(struct sfs_disk_inode));</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(struct sfs_disk_entry));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;d_blocksize != SFS_BLKSIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NA_DEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate fs structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((fs = alloc_fs(sfs)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(fs, sfs);</span><br><span class="line">    sfs-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;sfs_buffer = sfs_buffer = kmalloc(SFS_BLKSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_fs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load and check superblock */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_init_read(dev, SFS_BLKN_SUPER, sfs_buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> *<span class="title">super</span> =</span> sfs_buffer;</span><br><span class="line">    <span class="keyword">if</span> (super-&gt;magic != SFS_MAGIC) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;sfs: wrong magic in superblock. (%08x should be %08x).\n&quot;</span>,</span><br><span class="line">                super-&gt;magic, SFS_MAGIC);</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (super-&gt;blocks &gt; dev-&gt;d_blocks) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;sfs: fs has %u blocks, device has %u blocks.\n&quot;</span>,</span><br><span class="line">                super-&gt;blocks, dev-&gt;d_blocks);</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    super-&gt;info[SFS_MAX_INFO_LEN] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sfs-&gt;super = *super;</span><br><span class="line"></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alloc and initialize hash list */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;hash_list = hash_list = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">list_entry_t</span>) * SFS_HLIST_SIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SFS_HLIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load and check freemap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> freemap_size_nbits = sfs_freemap_bits(super);</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;freemap = freemap = bitmap_create(freemap_size_nbits)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_hash_list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> freemap_size_nblks = sfs_freemap_blocks(super);</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_init_freemap(dev, freemap, SFS_BLKN_FREEMAP, freemap_size_nblks, sfs_buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_freemap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks = sfs-&gt;super.blocks, unused_blocks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; freemap_size_nbits; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap_test(freemap, i)) &#123;</span><br><span class="line">            unused_blocks ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(unused_blocks == sfs-&gt;super.unused_blocks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* and other fields */</span></span><br><span class="line">    sfs-&gt;super_dirty = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;(sfs-&gt;fs_sem), <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;(sfs-&gt;io_sem), <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;(sfs-&gt;mutex_sem), <span class="number">1</span>);</span><br><span class="line">    list_init(&amp;(sfs-&gt;inode_list));</span><br><span class="line">    cprintf(<span class="string">&quot;sfs: mount: &#x27;%s&#x27; (%d/%d/%d)\n&quot;</span>, sfs-&gt;super.info,</span><br><span class="line">            blocks - unused_blocks, unused_blocks, blocks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link addr of sync/get_root/unmount/cleanup funciton  fs&#x27;s function pointers*/</span></span><br><span class="line">    fs-&gt;fs_sync = sfs_sync;</span><br><span class="line">    fs-&gt;fs_get_root = sfs_get_root;</span><br><span class="line">    fs-&gt;fs_unmount = sfs_unmount;</span><br><span class="line">    fs-&gt;fs_cleanup = sfs_cleanup;</span><br><span class="line">    *fs_store = fs;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">failed_cleanup_freemap:</span><br><span class="line">    bitmap_destroy(freemap);</span><br><span class="line">failed_cleanup_hash_list:</span><br><span class="line">    kfree(hash_list);</span><br><span class="line">failed_cleanup_sfs_buffer:</span><br><span class="line">    kfree(sfs_buffer);</span><br><span class="line">failed_cleanup_fs:</span><br><span class="line">    kfree(fs);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>sfs_fs.c</code> 文件的<code>sfs_do_mount</code> 函数中，加载了位于硬盘上的SFS的<code>superblock</code>和<code>freemap</code>信息，这样一来，在内存中就有了sfs文件系统的全局信息。</p>
<h2 id="索引节点接口"><a href="#索引节点接口" class="headerlink" title="索引节点接口"></a>索引节点接口</h2><p>在sfs文件系统中，需要记录文件内容的存储位置和文件名与文件内容的对应关系。<code>sfs_disk_inode</code> 记录了文件或目录的内容存储的索引信息。</p>
<p><strong>磁盘索引节点</strong></p>
<p><code>sfs_disk_inode</code> 代表了一个实际位于磁盘上的文件，如果inode表示的是文件，则成员变量direct直接指向了保存文件内容数据块的索引值，<code>indirect</code>指向间接数据块，此数据块存放数据块索引，数据块索引才被用于存放文件内容数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* inode (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                 <span class="comment">//文件大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                 <span class="comment">//文件类型</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                               <span class="comment">//硬链接数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                               <span class="comment">//数据块数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                  <span class="comment">//直接数据块索引值</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                             <span class="comment">//一级间接数据块索引值</span></span><br><span class="line"><span class="comment">//    uint32_t db_indirect;                        //二级数据块索引值</span></span><br><span class="line"><span class="comment">//   unused</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认的，ucore 里 <code>SFS_NDIRECT</code> 是 12，即直接索引的数据页大小为 <code>12 * 4k = 48k</code>；当使用一级间接数据块索引时，ucore 支持最大的文件大小为 <code>12 * 4k + 1024 * 4k = 48k + 4m</code>。数据索引表内，0 表示一个无效的索引，inode 里 blocks 表示该文件或者目录占用的磁盘的 block 的个数。indiret 为 0 时，表示不使用一级索引块。（因为 block 0 用来保存 super block，不可能被其他任何文件或目录使用）。</p>
<p><code>sfs_disk_entry</code>表示一个目录中的文件或目录，与<code>sfs_inode</code>一样存储在硬盘，需要时读入内存。</p>
<p>对于普通文件，索引值指向的数据块中保存的是文件中的数据。而对于目录，索引值指向的数据块保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                               <span class="comment">//索引节点所占数据块索引值</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];           <span class="comment">//文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>操作系统中，每个文件系统下的 inode 都应该分配唯一的 inode 编号。SFS 下，为了<del>偷懒</del>实现的简便，每个 inode 直接用所在的磁盘 block 的编号作为 inode 编号。比如，root block 的 inode 编号为 1；每个 <code>sfs_disk_entry</code> 数据结构中，name 表示目录下文件或文件夹的名称，ino 表示磁盘 block 编号，通过读取该 block 的数据，能够得到相应的文件或文件夹的 inode。ino 为0时，表示一个无效的 entry。</p>
<p><strong>内存索引节点</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内存inode包含了SFS的硬盘inode信息，而且还增加了其他一些信息，这属于是便于进行是判断否改写、互斥操作、回收和快速地定位等作用。需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。而硬盘inode的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* filesystem for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>                         <span class="comment">/* on-disk superblock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                             <span class="comment">/* device mounted on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>                         <span class="comment">/* blocks in use are mared 0 */</span></span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                               <span class="comment">/* true if super/freemap modified */</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                               <span class="comment">/* buffer for non-block aligned io */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                             <span class="comment">/* semaphore for fs */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             <span class="comment">/* semaphore for io */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          <span class="comment">/* semaphore for link/unlink and rename */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;                        <span class="comment">/* inode linked-list */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;                        <span class="comment">/* inode hash linked-list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对inode操作的辅助函数如下：</p>
<p><code>sfs_bmap_load_nolock</code> 将 <code>sfs_inode</code> 的第 index 个索引指向的 block 的索引值取出存到相应的指针指向的单元(<code>ino_store</code>)，该函数只接受 <code>index &lt;= inode-&gt;blocks</code> 的参数。当<code>index == inode-&gt;blocks</code>时,为 inode 增长一个 block。并标记 inode 为 dirty,这样可保证sfs在inode不再使用时将数据写回磁盘。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_bmap_load_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">uint32_t</span> index, <span class="keyword">uint32_t</span> *ino_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(index &lt;= din-&gt;blocks);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">bool</span> create = (index == din-&gt;blocks);</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_get_nolock(sfs, <span class="built_in">sin</span>, index, create, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(sfs_block_inuse(sfs, ino));</span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">        din-&gt;blocks ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ino_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *ino_store = ino;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_bmap_get_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">uint32_t</span> index, <span class="keyword">bool</span> create, <span class="keyword">uint32_t</span> *ino_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ent, ino;</span><br><span class="line">	<span class="comment">// the index of disk block is in the first SFS_NDIRECT  direct blocks</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; SFS_NDIRECT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ino = din-&gt;direct[index]) == <span class="number">0</span> &amp;&amp; create) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = sfs_block_alloc(sfs, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            din-&gt;direct[index] = ino;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the index of disk block is in the indirect blocks.</span></span><br><span class="line">    index -= SFS_NDIRECT;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; SFS_BLK_NENTRY) &#123;</span><br><span class="line">        ent = din-&gt;indirect;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_get_sub_nolock(sfs, &amp;ent, index, create, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ent != din-&gt;indirect) &#123;</span><br><span class="line">            assert(din-&gt;indirect == <span class="number">0</span>);</span><br><span class="line">            din-&gt;indirect = ent;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		panic (<span class="string">&quot;sfs_bmap_get_nolock - index out of range&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">    assert(ino == <span class="number">0</span> || sfs_block_inuse(sfs, ino));</span><br><span class="line">    *ino_store = ino;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_bmap_get_nolock</code> 根据sfs_inode 的第 index 找到对应的磁盘数据块号。数据块索引采取多级索引方式，前12个指针直接指向数据块，此后的指针为间接数据块索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define SFS_BLK_NENTRY                              (SFS_BLKSIZE &#x2F; sizeof(uint32_t))</span><br></pre></td></tr></table></figure>
<p><code>sfs_bmap_truncate_nolock</code>释放多级数据索引表的最后一个 entry ，是 <code>sfs_bmap_load_nolock</code> 中，index == inode-&gt;blocks 的逆操作。当一个文件或目录被删除时，sfs 会循环调用该函数直到 inode-&gt;blocks 减为 0，释放所有的数据页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_bmap_truncate_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;blocks != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_free_nolock(sfs, <span class="built_in">sin</span>, din-&gt;blocks - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    din-&gt;blocks --;</span><br><span class="line">    <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_dirent_read_nolock</code>:将目录的第 slot 个 entry 读取到指定的内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_dirent_read_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">int</span> slot, struct sfs_disk_entry *entry) &#123;</span><br><span class="line">    assert(<span class="built_in">sin</span>-&gt;din-&gt;type == SFS_TYPE_DIR &amp;&amp; (slot &gt;= <span class="number">0</span> &amp;&amp; slot &lt; <span class="built_in">sin</span>-&gt;din-&gt;blocks));</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">	<span class="comment">// according to the DIR&#x27;s inode and the slot of file entry, find the index of disk block which contains this file entry</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, slot, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(sfs_block_inuse(sfs, ino));</span><br><span class="line">	<span class="comment">// read the content of file entry in the disk block </span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_rbuf(sfs, entry, <span class="keyword">sizeof</span>(struct sfs_disk_entry), ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;name[SFS_MAX_FNAME_LEN] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_dirent_search_nolock</code>是常用的查找函数。在目录下根据name进行查找，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号(在ucore中与磁盘块编号一致)，和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。文件的数据页是连续的；而对于目录，数据页不是连续的，当某个 entry 删除的时候，SFS 通过设置 entry-&gt;ino 为0将该 entry 所在的 block 标记为 free，在需要添加新 entry 的时候，SFS 优先使用这些 free 的 entry，其次才会去在数据页尾追加新的 entry。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_dirent_search_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> *ino_store, <span class="keyword">int</span> *slot, <span class="keyword">int</span> *empty_slot) &#123;</span><br><span class="line">    assert(<span class="built_in">strlen</span>(name) &lt;= SFS_MAX_FNAME_LEN);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = kmalloc(<span class="keyword">sizeof</span>(struct sfs_disk_entry))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_pvalue(x, v)            do &#123; <span class="meta-keyword">if</span> ((x) != NULL) &#123; *(x) = (v); &#125; &#125; while (0)</span></span><br><span class="line">    <span class="keyword">int</span> ret, i, nslots = <span class="built_in">sin</span>-&gt;din-&gt;blocks;</span><br><span class="line">    set_pvalue(empty_slot, nslots);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nslots; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_dirent_read_nolock(sfs, <span class="built_in">sin</span>, i, entry)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;ino == <span class="number">0</span>) &#123;</span><br><span class="line">            set_pvalue(empty_slot, i);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, entry-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">            set_pvalue(slot, i);</span><br><span class="line">            set_pvalue(ino_store, entry-&gt;ino);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> set_pvalue</span></span><br><span class="line">    ret = -E_NOENT;</span><br><span class="line">out:</span><br><span class="line">    kfree(entry);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_dirent_read_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">int</span> slot, struct sfs_disk_entry *entry) &#123;</span><br><span class="line">    assert(<span class="built_in">sin</span>-&gt;din-&gt;type == SFS_TYPE_DIR &amp;&amp; (slot &gt;= <span class="number">0</span> &amp;&amp; slot &lt; <span class="built_in">sin</span>-&gt;din-&gt;blocks));</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">	<span class="comment">// according to the DIR&#x27;s inode and the slot of file entry, find the index of disk block which contains this file entry</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, slot, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(sfs_block_inuse(sfs, ino));</span><br><span class="line">	<span class="comment">// read the content of file entry in the disk block </span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_rbuf(sfs, entry, <span class="keyword">sizeof</span>(struct sfs_disk_entry), ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;name[SFS_MAX_FNAME_LEN] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_tryseek                    = sfs_tryseek,</span><br><span class="line">    .vop_truncate                   = sfs_truncfile,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sfs_openfile</code>、<code>sfs_close</code>、<code>sfs_read</code>和<code>sfs_write</code>分别对应用户进程发出的open、close、read、write操作。其中<code>sfs_openfile</code>直接返回；<code>sfs_close</code>需要把对文件的修改内容写回到硬盘上，这样确保硬盘上的文件内容数据是最新的；<code>sfs_read</code>和<code>sfs_write</code>函数都调用了一个函数<code>sfs_io</code>，并最终通过访问硬盘驱动来完成对文件内容数据的读写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *io_base;     <span class="comment">// the base addr of buffer (used for Rd/Wr)</span></span><br><span class="line">    <span class="keyword">off_t</span> io_offset;   <span class="comment">// current Rd/Wr position in buffer, will have been incremented by the amount transferred</span></span><br><span class="line">    <span class="keyword">size_t</span> io_len;     <span class="comment">// the length of buffer  (used for Rd/Wr)</span></span><br><span class="line">    <span class="keyword">size_t</span> io_resid;   <span class="comment">// current resident length need to Rd/Wr, will have been decremented by the amount transferred.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">sfs_io(struct inode *node, struct iobuf *iob, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(vop_fs(node), sfs);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> =</span> vop_info(node, sfs_inode);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> alen = iob-&gt;io_resid;</span><br><span class="line">        ret = sfs_io_nolock(sfs, <span class="built_in">sin</span>, iob-&gt;io_base, iob-&gt;io_offset, &amp;alen, write);</span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            iobuf_skip(iob, alen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_namefile                   = sfs_namefile,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于目录也是一种文件，所以<code>sfs_opendir</code>、<code>sys_close</code>对应用户进程发出的open、close函数。相对于<code>sfs_open</code>，<code>sfs_opendir</code>只是完成一些open函数传递的参数判断后返回。目录的close操作与文件的close操作完全一致。由于目录的内容数据与文件的内容数据不同，所以读出目录的内容数据的函数为<code>sfs_getdirentry</code>，其主要工作是获取目录下的文件<code>inode</code>信息。</p>
<blockquote>
<p>首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolock读文件中数据的实现代码。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_io_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE; <span class="comment">//读写开始的扇区号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;<span class="comment">//扇区数目</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断第一块的情况，是否对齐 </span></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断 endpos 和 offset 是否在同一块中</span></span><br><span class="line">        <span class="comment">//若在同一块，读取字节数为endpos - offset</span></span><br><span class="line">        <span class="comment">//若不为同一块 则读取字节数为SFS_BLKSIZE - blkoff</span></span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总的需要读取的字节数</span></span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对中间扇区的处理，中间扇区必然是对齐的</span></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处和前后部分不一样，可直接对整个扇区进行操作</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size, buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对最后一块对齐情况的处理</span></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_io_nolock</code>的代码，是给定一个文件的<code>inode</code>以及需要读写的偏移量和大小，转换成数据块级别的读写操作。主要调用的是两个函数：</p>
<p><code>sfs_io_nolock</code>实现的功能是根据给定的inode,文件偏移量，读写字节数从磁盘中以数据块为单位将数据从磁盘中加载到内存(buffer)中。调用的关键函数有：</p>
<ul>
<li><code>sfs_bmap_load_nolock</code> 将sfs_inode的第index个索引指向的block的索引值取出存到对应的指针单元，执行错误时返回值不为0。</li>
<li><code>sfs_buf_op</code>/<code>sfs_block_op</code>  传入参数为数据块对应的扇区编号，进行读写操作。</li>
</ul>
<p>数据块的读入和读出均以块为单位进行，所以需要对边界情况进行处理。此外，用户希望的读写字节数和实际读写成功的字节数不一致，所以在每次读写操作时均会修改字节数。</p>
<blockquote>
<p>实现“UNIX的PIPE机制”的概要设计方案</p>
</blockquote>
<p>管道本质上就是一个操作系统内核管理的环形缓冲区，所以需要一块内存作为缓冲区，然后需要记录环形缓冲区的头部和尾部。当一个进程尝试从空管道读取数据或者向满管道写入数据的时候，操作系统内核需要将进程阻塞，所以还需要一个读取等待队列和一个写入等待队列。 缓冲区大小通常设为一页的大小4KB。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct pipe &#123;</span><br><span class="line">    size_t head; &#x2F;&#x2F; 缓冲区头部</span><br><span class="line">    size_t tail; &#x2F;&#x2F; 缓冲区尾部</span><br><span class="line">    wait_queue_t read_queue; &#x2F;&#x2F; 管道读取等待队列</span><br><span class="line">    wait_queue_t write_queue; &#x2F;&#x2F; 管道写入等待队列</span><br><span class="line">    char* buffer; &#x2F;&#x2F; 环形缓冲区</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在inode中添加管道数据结构和对应的函数接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">dev_node_ops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = dev_open,</span><br><span class="line">    .vop_close                      = dev_close,</span><br><span class="line">    .vop_read                       = dev_read,</span><br><span class="line">    .vop_write                      = dev_write,</span><br><span class="line">    .vop_fstat                      = dev_fstat,</span><br><span class="line">    .vop_ioctl                      = dev_ioctl,</span><br><span class="line">    .vop_gettype                    = dev_gettype,</span><br><span class="line">    .vop_tryseek                    = dev_tryseek,</span><br><span class="line">    .vop_lookup                     = dev_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="设备层文件IO层"><a href="#设备层文件IO层" class="headerlink" title="设备层文件IO层"></a>设备层文件IO层</h1><p>为了统一访问设备，我们将设备同样视作文件，通过访问文件的接口来访问设备。ucore实现了stdin设备文件、stdout设备文件、disk0设备文件。stdin设备就是键盘，stdout设备就是CONSOLE（串口、并口和文本显示器），而disk0设备是承载SFS文件系统的磁盘设备。</p>
<h2 id="设备接口"><a href="#设备接口" class="headerlink" title="设备接口"></a>设备接口</h2><p><code>device</code>数据结构具体描述如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;</span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;</span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>device数据结构用于表示块设备(比如磁盘)、字符设备(比如键盘、串口)的表示，以及对设备的基本操作。</p>
<p>为了将设备链接在一起，ucore定义了一个双向设备链表，通过链表可以访问所有设备文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static list_entry_t vdev_list;     &#x2F;&#x2F; device info list in vfs layer</span><br></pre></td></tr></table></figure>
<p>接下来通过<code>vfs_dev_t</code>数据结构建立文件系统与表示一个设备文件的inode数据结构的关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;</span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br></pre></td></tr></table></figure>
<p>文件系统通过<code>vfs_dev_t</code>结构的双向链表找到device对应的inode数据结构。一个inode节点在表示设备时成员变量<code>in_type</code>的值是0x1234，则此 inode的成员变量<code>in_info</code>将成为一个device结构，这个inode就是一个设备文件。</p>
<h2 id="stdout设备文件"><a href="#stdout设备文件" class="headerlink" title="stdout设备文件"></a>stdout设备文件</h2><p><strong>初始化</strong></p>
<p>stdout设备初始化如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kern_init--&gt;fs_init--&gt;dev_init--&gt;dev_init_stdout --&gt; dev_create_inode</span><br><span class="line">                                                 --&gt; stdout_device_init</span><br><span class="line">                                                 --&gt; vfs_add_dev</span><br></pre></td></tr></table></figure>
<p>在<code>dev_init_stdout</code>中初始化stdout设备文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dev_init_stdout(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdout: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stdout_device_init(vop_info(node, device));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;stdout&quot;</span>, node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdout: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *</span></span><br><span class="line"><span class="class"><span class="title">dev_create_inode</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = alloc_inode(device)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        vop_init(node, &amp;dev_node_ops, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stdout_device_init(struct device *dev) &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdout_open;</span><br><span class="line">    dev-&gt;d_close = stdout_close;</span><br><span class="line">    dev-&gt;d_io = stdout_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdout_ioctl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问操作</strong></p>
<p>与一般文件基本操作函数类似，stdout设备文件同样有<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdout_open(struct device *dev, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">if</span> (open_flags != O_WRONLY) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdout_close(struct device *dev) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdout_ioctl(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>stdout_open</code>函数在设备打开参数不为只写时报错</p>
<p><code>stdout_io</code>负责完成设备的写操作，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdout_io(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        <span class="keyword">char</span> *data = iob-&gt;io_base;</span><br><span class="line">        <span class="keyword">for</span> (; iob-&gt;io_resid != <span class="number">0</span>; iob-&gt;io_resid --) &#123;</span><br><span class="line">            cputchar(*data ++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入数据放在<code>iob-&gt;io_base</code>所指的内存区域，写入<code>iob-&gt;io_resid</code>次。每次写操作都是通过<code>cputchar</code>来完成的，通过console外设驱动来完成把数据输出到串口、并口和CGA显示器上。此外，若用户想执行读操作，则<code>stdout_io</code>函数直接返回错误值<code>-E_INVAL</code>。</p>
<h2 id="stdin设备文件"><a href="#stdin设备文件" class="headerlink" title="stdin设备文件"></a>stdin设备文件</h2><p>stdin设备文件实际上就是键盘，为只读设备。</p>
<p><strong>初始化</strong></p>
<p>与stdout设备文件类似，stdin设备文件的初始化主要由<code>stdin_device_init</code> 完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stdin_device_init(struct device *dev) &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdin_open;</span><br><span class="line">    dev-&gt;d_close = stdin_close;</span><br><span class="line">    dev-&gt;d_io = stdin_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdin_ioctl;</span><br><span class="line"></span><br><span class="line">    p_rpos = p_wpos = <span class="number">0</span>;</span><br><span class="line">    wait_queue_init(wait_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对于stdout的初始化过程，stdin的初始化相对复杂一些，多了一个stdin_buffer缓冲区，描述缓冲区读写位置的变量p_rpos、p_wpos以及用于等待缓冲区的等待队列wait_queue。在stdin_device_init函数的初始化中，也完成了对p_rpos、p_wpos和wait_queue的初始化。</p>
<p><strong>访问操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdin_io(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">if</span> ((ret = dev_stdin_read(iob-&gt;io_base, iob-&gt;io_resid)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            iob-&gt;io_resid -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若对该设备文件进行写操作则直接报错返回，若为读操作，则进一步调用<code>dev_stdin_read</code>完成对键盘的读入操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">dev_stdin_read(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ret &lt; len; ret ++, p_rpos ++) &#123;</span><br><span class="line">        try_again:</span><br><span class="line">            <span class="keyword">if</span> (p_rpos &lt; p_wpos) &#123;</span><br><span class="line">                *buf ++ = stdin_buffer[p_rpos % STDIN_BUFSIZE];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">                wait_current_set(wait_queue, wait, WT_KBD);</span><br><span class="line">                local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">                schedule();</span><br><span class="line"></span><br><span class="line">                local_intr_save(intr_flag);</span><br><span class="line">                wait_current_del(wait_queue, wait);</span><br><span class="line">                <span class="keyword">if</span> (wait-&gt;wakeup_flags == WT_KBD) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> try_again;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若<code>p_rpos &lt; p_wpos</code>，则表示有键盘输入的新字符在<code>stdin_buffer</code>中，于是就从<code>stdin_buffer</code>中取出新字符放到iobuf指向的缓冲区中；如果<code>p_rpos &gt;=p_wpos</code>，则表明没有新字符，这样调用read用户态库函数的用户进程就需要采用等待队列的睡眠操作进入睡眠状态，等待键盘输入字符的产生。</p>
<p>键盘输入字符后，如何唤醒等待键盘输入的用户进程呢当用户敲击键盘时，会产生键盘中断，在<code>trap_dispatch</code>函数中，当识别出中断是键盘中断（中断号为IRQ_OFFSET + IRQ_KBD）时，会调用<code>dev_stdin_write</code>函数，来把字符写入到<code>stdin_buffer</code>中，且会通过等待队列的唤醒操作唤醒正在等待键盘输入的用户进程。</p>
<h1 id="文件系统的执行程序机制"><a href="#文件系统的执行程序机制" class="headerlink" title="文件系统的执行程序机制"></a>文件系统的执行程序机制</h1><blockquote>
<p>改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。执行：make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可以执行”ls”,”hello”等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。</p>
</blockquote>
<p><code>load_icode</code>分为以下几个步骤：</p>
<ol>
<li>为当前进程建立内存空间</li>
<li>建立页目录表</li>
<li>将文件中各个段加载到内存中，同时设置虚实地址映射</li>
<li>设置用户堆栈并将参数放入到用户堆栈</li>
<li>设置当前进程的cr3,mm</li>
<li>为用户态设置trapframe</li>
</ol>
<p>相比于lab7，lab8中<code>load_icode</code>主要变化如下：</p>
<ul>
<li>ELF文件不再从内存读取，从文件中读入。通过调用<code>load_icode_read</code>函数依次将<code>ELF header</code>，<code>program header</code>以及真正的各个代码段数据段读入内存。</li>
<li>传入参数<code>argc</code>和<code>argv</code>，同时在用户态栈构建命令行参数，使应用程序可以接受命令行参数输入</li>
</ul>
<p>栈空间安排如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  </span><br><span class="line">|   high address   |</span><br><span class="line">+------------------+  </span><br><span class="line">|   argument n     |</span><br><span class="line">+------------------+</span><br><span class="line">|   argument n-<span class="number">1</span>   |</span><br><span class="line">+------------------+</span><br><span class="line">|   argument ...   |</span><br><span class="line">+------------------+  </span><br><span class="line">|   argument <span class="number">1</span>     |</span><br><span class="line">+------------------+  </span><br><span class="line">|   <span class="keyword">null</span> pointer   |</span><br><span class="line">+------------------+ </span><br><span class="line">| pointer to arg n |</span><br><span class="line">+------------------+  </span><br><span class="line">| pointer to arg ..|</span><br><span class="line">+------------------+ </span><br><span class="line">| argument count   |</span><br><span class="line">+------------------+ &lt;- esp(stacktop)</span><br><span class="line">|   low address    |</span><br><span class="line">+------------------+ </span><br></pre></td></tr></table></figure>
<p>将命令行参数放入到栈空间中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">uint32_t</span> len=<span class="number">0</span>,i;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">   len+=strnlen(kargv[i],EXEC_MAX_ARG_LEN+<span class="number">1</span>+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//计算参数内容总长度</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="number">4</span>+<span class="number">1</span>)*<span class="number">4</span>;<span class="comment">//4字节对齐</span></span><br><span class="line">   <span class="comment">//分配参数内容空间的同时分配了空地址所对应的栈空间</span></span><br><span class="line"><span class="keyword">char</span>** uargv=(<span class="keyword">char</span> **)(stacktop  - argc * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">   <span class="comment">//存放指向字符串每行首地址的指针</span></span><br><span class="line">   argv_size = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">       uargv[i] = <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">       argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//存放参数个数</span></span><br><span class="line">   stacktop = (<span class="keyword">uintptr_t</span>)uargv - <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">   *(<span class="keyword">int</span> *)stacktop = argc;</span><br></pre></td></tr></table></figure>
<p>二维数组压栈的时候，最后一个指针后面应该是一个空指针，表示结束，所以在栈空间内分配了4字节空间存储空指针。</p>
<blockquote>
<p>实现基于UNIX硬链接和软链接机制概要设计方案</p>
</blockquote>
<p><strong>硬链接</strong> 在SFS文件系统中已经实现了<code>nlinks</code>数据结构，代表了指向这个<code>inode</code>的硬链接个数，因此只需要添加一个系统调用（例如<code>SYS_link</code>），该系统调用首先找到被链接文件对应的<code>inode</code>，然后在目标文件夹的控制块中增加一个描述符即可，二者的<code>inode</code>指针应该相同，同时<code>nlinks</code>数据结构应该相应增加</p>
<p>创建：</p>
<ol>
<li>将目录项的名字设定为传入参数，目录项的inode号设置为目标文件的inode号。</li>
<li>目标inode的引用计数增加。</li>
</ol>
<p>删除：</p>
<ol>
<li>减少目标inode的引用计数。若减为0，清除目标inode及其数据块。</li>
</ol>
<p><strong>软链接</strong> 软链接的实现稍微复杂些，需要在<code>inode</code>上增加标记位确认这个文件是普通文件还是软链接文件，在进行打开文件或是保存文件的时候，操作系统需要根据软链接指向的地址再次在文件目录中进行查询，寻找或创建相应的<code>inode</code>，注意与硬链接不同，创建软链接的时候不涉及对<code>nlinks</code>的修改。如果需要创建软链接这个特殊的文件，也需要增加一个系统调用（例如<code>SYS_symlink</code>）在完成相应的功能。</p>
<p>创建：将inode的类型设置为符号链接，文件内容（数据）设置为目标路径字符串。</p>
<p>删除：不需要额外的操作。</p>
<h1 id="打开文件流程"><a href="#打开文件流程" class="headerlink" title="打开文件流程"></a>打开文件流程</h1><p>我们接下来分析一个用户进程在打开文件时会做哪些事情？首先假定用户进程需要打开的文件已经存在硬盘上。以<code>user/sfs_filetest1.c</code>为例，首先用户进程会调用在main函数中的如下语句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> fd1 = safe_open(<span class="string">&quot;/test/testfile&quot;</span>, O_RDWR | O_TRUNC);</span><br></pre></td></tr></table></figure>
<p>若ucore可正常查找到这个文件，那么就会返回一个代表文件的文件描述符。</p>
<p><strong>通用文件访问接口层</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sysfile_open(<span class="keyword">const</span> <span class="keyword">char</span> *__path, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;path, __path)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = file_open(path, open_flags);</span><br><span class="line">    kfree(path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先进入通用文件访问接口层，进一步调用如下用户态函数：<code>open-&gt;sys_open-&gt;syscall</code>，通过系统调用进入到内核态。在内核态，通过中断处理例程跳转到<code>sys_open</code>内核函数，并进一步调用sysfile_open内核函数。到了这里，需要把位于用户空间的字符串<code>/test/testfile</code>拷贝到内核空间中的字符串path中，并进入到文件系统抽象层。</p>
<p><strong>文件系统抽象层</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">file_open(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">bool</span> readable = <span class="number">0</span>, writable = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY: readable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY: writable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        readable = writable = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = fd_array_alloc(NO_FD, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_open(path, open_flags, &amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">        fd_array_free(file);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_APPEND) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">stat</span>, *<span class="title">stat</span> =</span> &amp;__stat;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_fstat(node, stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vfs_close(node);</span><br><span class="line">            fd_array_free(file);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        file-&gt;pos = stat-&gt;st_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;node = node;</span><br><span class="line">    file-&gt;readable = readable;</span><br><span class="line">    file-&gt;writable = writable;</span><br><span class="line">    fd_array_open(file);</span><br><span class="line">    <span class="keyword">return</span> file-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分配一个空闲的file数据结构变量file</strong></p>
<p>在文件系统抽象层的处理中，首先调用的是<code>file_open</code>函数，为即将打开的文件分配一个file数据结构的变量。从打开文件表中依次找到状态为<code>FD_NONE</code>的file，将file状态改为<code>FD_INIT</code>,最后返回该file对应的文件描述符。此时仅仅是给当前用户进程分配了一个file数据结构的变量，还没有找到对应的文件索引节点。</p>
<p><strong>找到对应索引节点</strong></p>
<p><code>vfs_open</code>函数先通过<code>vfs_lookup</code>找到path对应文件的inode；之后调用<code>vop_open</code>函数打开文件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">vfs_open(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">bool</span> can_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        can_write = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!can_write) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> excl = (open_flags &amp; O_EXCL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> create = (open_flags &amp; O_CREAT) != <span class="number">0</span>;</span><br><span class="line">    ret = vfs_lookup(path, &amp;node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-16</span> &amp;&amp; (create)) &#123;</span><br><span class="line">            <span class="keyword">char</span> *name;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = vfs_lookup_parent(path, &amp;dir, &amp;name)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = vop_create(dir, name, excl, &amp;node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (excl &amp;&amp; create) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(node != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = vop_open(node, open_flags)) != <span class="number">0</span>) &#123;</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vop_open_inc(node);</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC || create) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_truncate(node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vop_open_dec(node);</span><br><span class="line">            vop_ref_dec(node);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vfs_lookup</code>为针对目录的操作函数。首先调用<code>get_device</code>函数查找文件设备的根目录，并选择开始查找的相对inode。例如，确定<code>C:\Users\abc</code>的文件设备为c盘。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">vfs_lookup(<span class="keyword">char</span> *path, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_device(path, &amp;path, &amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        ret = vop_lookup(node, path, node_store);</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据冒号和反斜杠出现的首位置判断，分为以下几种情况</p>
<ul>
<li>冒号不在反斜杠之前，同时反斜杠不在首部或不存在，为相对路径或仅仅只是一个文件名。 以路径为子路径，从当前目录开始查找。</li>
<li>冒号存在于反斜杠之前，为<code>device:path</code>形式，从路径名称中取得根目录。</li>
<li><code>/path</code> 为相对于<code>bootfs</code>的路径，调用<code>vfs_get_bootfs</code> 取得<code>bootfs_node</code>。<code>bootfs_node</code>在<code>init_main</code>函数中设置为disk0。</li>
<li><code>:path</code> 为相对于当前文件系统的路径</li>
</ul>
<p>通过调用<code>vop_lookup</code>函数来查找到根目录下/对应文件<code>sfs_filetest1</code>的索引节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_device(<span class="keyword">char</span> *path, <span class="keyword">char</span> **subpath, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">int</span> i, slash = <span class="number">-1</span>, colon = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; path[i] != <span class="string">&#x27;\0&#x27;</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;:&#x27;</span>) &#123; colon = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;/&#x27;</span>) &#123; slash = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (colon &lt; <span class="number">0</span> &amp;&amp; slash != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* *</span></span><br><span class="line"><span class="comment">         * No colon before a slash, so no device name specified, and the slash isn&#x27;t leading</span></span><br><span class="line"><span class="comment">         * or is also absent, so this is a relative path or just a bare filename. Start from</span></span><br><span class="line"><span class="comment">         * the current directory, and use the whole thing as the subpath.</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        *subpath = path;</span><br><span class="line">        <span class="keyword">return</span> vfs_get_curdir(node_store);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (colon &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* device:path - get root of device&#x27;s filesystem */</span></span><br><span class="line">        path[colon] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* device:/path - skip slash, treat as device:path */</span></span><br><span class="line">        <span class="keyword">while</span> (path[++ colon] == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        *subpath = path + colon;</span><br><span class="line">        <span class="keyword">return</span> vfs_get_root(path, node_store);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * we have either /path or :path</span></span><br><span class="line"><span class="comment">     * /path is a path relative to the root of the &quot;boot filesystem&quot;</span></span><br><span class="line"><span class="comment">     * :path is a path relative to the root of the current filesystem</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (*path == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vfs_get_bootfs(node_store)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(*path == <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = vfs_get_curdir(&amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* The current directory may not be a device, so it must have a fs. */</span></span><br><span class="line">        assert(node-&gt;in_fs != <span class="literal">NULL</span>);</span><br><span class="line">        *node_store = fsop_get_root(node-&gt;in_fs);</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ///... or :/... */</span></span><br><span class="line">    <span class="keyword">while</span> (*(++ path) == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    *subpath = path;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此后将返回到<code>file_open</code>函数中，通过执行语句<code>file-&gt;node=node</code>，将查找到的inode赋值给文件对应的inode然后返回fd。经过重重回退，通过系统调用返回，用户态的<code>syscall-&gt;sys_open-&gt;open-&gt;safe_open</code>等用户函数的层层函数返回，最终把把fd赋值给fd1。</p>
<p><strong>SFS层文件系统层</strong></p>
<p><code>sfs_inode.c</code>中的<code>sfs_node_dirops</code>变量定义了<code>.vop_lookup = sfs_lookup</code>，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_lookup(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(vop_fs(node), sfs);</span><br><span class="line">    assert(*path != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    vop_ref_inc(node);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> =</span> vop_info(node, sfs_inode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sin</span>-&gt;din-&gt;type != SFS_TYPE_DIR) &#123;</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> -E_NOTDIR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">subnode</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = sfs_lookup_once(sfs, <span class="built_in">sin</span>, path, &amp;subnode, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    vop_ref_dec(node);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = subnode;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_lookup_once(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name, struct inode **node_store, <span class="keyword">int</span> *slot) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;   <span class="comment">// find the NO. of disk block and logical index of file entry</span></span><br><span class="line">        ret = sfs_dirent_search_nolock(sfs, <span class="built_in">sin</span>, name, &amp;ino, slot, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// load the content of inode with the the NO. of disk block</span></span><br><span class="line">        ret = sfs_load_inode(sfs, node_store, ino);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_lookup</code>有三个参数：node，path，node_store。其中node是根目录/所对应的inode节点；path是文件<code>testfile</code>的绝对路径<code>/test/testfile</code>，而node_store是经过查找获得的<code>testfile</code>所对应的inode节点。</p>
<p><code>sfs_lookup</code>函数以/为分割符，从左至右逐一分解path获得各个子目录和最终文件对应的inode节点。在本例中是分解出<code>test</code>子目录，并调用<code>sfs_lookup_once</code>函数获得<code>test</code>子目录对应的inode节点subnode，然后循环进一步调用sfs_lookup_once查找以test子目录下的文件<code>testfile1</code>所对应的inode节点。当无法分解path后，就意味着顺利找到了testfile1对应的inode节点。</p>
<p><code>sfs_lookup_once</code>将调用<code>sfs_dirent_search_nolock</code>函数来查找与路径名匹配的目录项，如果找到目录项，则根据目录项中记录的inode所处的数据块索引值找到路径名对应的SFS磁盘inode，并读入SFS磁盘inode对应的内容，创建SFS内存inode。</p>
<h1 id="读文件流程"><a href="#读文件流程" class="headerlink" title="读文件流程"></a>读文件流程</h1><p>读文件其实就是读出目录中的目录项，首先假定文件在磁盘上且已经打开。用户进程有如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read(fd, data, len);</span><br></pre></td></tr></table></figure>
<p>即读取fd对应文件，读取长度为len，存入data中。</p>
<p><strong>通用文件访问接口层</strong></p>
<p>首先进入通用文件访问接口层，进一步调用如下用户态函数：<code>open-&gt;sys_open-&gt;syscall</code>，通过系统调用进入到内核态。在内核态，通过中断处理例程跳转到<code>sys_read</code>内核函数，并进一步调用sysfile_read内核函数,进入到文件系统抽象层完成进一步读文件的操作。</p>
<p><strong>文件系统抽象层的处理流程</strong></p>
<ol>
<li><p>检查错误，即检查读取长度是否为0和文件是否可读。</p>
</li>
<li><p>分配buffer空间，即调用kmalloc函数分配4096字节的buffer空间。</p>
</li>
<li><p>读文件过程</p>
</li>
</ol>
<p>[1] 实际读文件</p>
<p>循环读取文件，每次读取buffer大小。每次循环中，先检查剩余部分大小，若其小于4096字节，则只读取剩余部分的大小。然后调用file_read函数（详细分析见后）将文件内容读取到buffer中，alen为实际大小。调用copy_to_user函数将读到的内容拷贝到用户的内存空间中，调整各变量以进行下一次循环读取，直至指定长度读取完成。最后函数调用层层返回至用户程序，用户程序收到了读到的文件内容。</p>
<p>[2] file_read函数</p>
<p>这个函数是读文件的核心函数。函数有4个参数，fd是文件描述符，base是缓存的基地址，len是要读取的长度，copied_store存放实际读取的长度。函数首先调用fd2file函数找到对应的file结构，并检查是否可读。调用filemap_acquire函数使打开这个文件的计数加1。调用vop_read函数将文件内容读到iob中（详细分析见后）。调整文件指针偏移量pos的值，使其向后移动实际读到的字节数iobuf_used(iob)。最后调用filemap_release函数使打开这个文件的计数减1，若打开计数为0，则释放file。</p>
<p><strong>SFS文件系统层</strong></p>
<p>在<code>sfs_inode.c</code>中<code>sfs_node_fileops</code>变量定义了<code>.vop_read = sfs_read</code>。</p>
<p><code>sfs_read</code>函数调用<code>sfs_io</code>函数。它有三个参数，node是对应文件的inode，iob是缓存，write表示是读还是写的布尔值(0表示读，1表示写)。函数先找到inode对应sfs和sin，然后调用<code>sfs_io_nolock</code>函数进行读取文件操作，最后调用<code>iobuf_skip</code>函数调整<code>iobuf</code>的指针。</p>
<p>在sfs_io_nolock函数中，先计算一些辅助变量，并处理一些特殊情况（比如越界），然后有sfs_buf_op = sfs_rbuf,sfs_block_op = sfs_rblock，设置读取的函数操作。接着进行实际操作，先处理起始的没有对齐到块的部分，再以块为单位循环处理中间的部分，最后处理末尾剩余的部分。每部分中都调用sfs_bmap_load_nolock函数得到blkno对应的inode编号，并调用sfs_rbuf或sfs_rblock函数读取数据（中间部分调用sfs_rblock，起始和末尾部分调用sfs_rbuf），调整相关变量。完成后如果offset + alen &gt; din-&gt;fileinfo.size（写文件时会出现这种情况，读文件时不会出现这种情况，alen为实际读写的长度），则调整文件大小为offset + alen并设置dirty变量。</p>
<p><code>sfs_bmap_load_nolock</code>函数将对应sfs_inode的第index个索引指向的block的索引值取出存到相应的指针指向的单元（ino_store）。它调用sfs_bmap_get_nolock来完成相应的操作。sfs_rbuf和sfs_rblock函数最终都调用<code>sfs_rwblock_nolock</code>函数完成操作，而sfs_rwblock_nolock函数调用dop_io-&gt;disk0_io-&gt;disk0_read_blks_nolock-&gt;ide_read_secs完成对磁盘的操作。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>trinkle
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://twinkle0331.github.io/systems/ucore-lab8/" title="ucore lab8">http://twinkle0331.github.io/systems/ucore-lab8/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/ucore/" rel="tag"><i class="fa fa-tag"></i> ucore</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/systems/ucore-lab7/" rel="prev" title="ucore lab7">
                  <i class="fa fa-chevron-left"></i> ucore lab7
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/systems/deadlock-ipc/" rel="next" title="死锁与进程通信">
                  死锁与进程通信 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">trinkle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  


</body>
</html>
