<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"twinkle0331.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="树是一种分层结构，而层次化这一结构几乎蕴含于所有事物及其联系中，称为其本质属性之一。从文件系统、互联网域名系统，一直到地球生态系统乃至人类社会系统，层次化特征和层次化结构均无所不在。二叉树不再是简单的线性结构，但确定某种次序后具有线性特征，故树属于半线性结构。 树等价于无环联通图，因此与一般的图相同，树也由一组顶点和联接于其间的若干条边组成，故任一节点与根节点之间存在着唯一路径。">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树">
<meta property="og:url" content="http://twinkle0331.github.io/algorithm/bin-tree/index.html">
<meta property="og:site_name" content="trinkle">
<meta property="og:description" content="树是一种分层结构，而层次化这一结构几乎蕴含于所有事物及其联系中，称为其本质属性之一。从文件系统、互联网域名系统，一直到地球生态系统乃至人类社会系统，层次化特征和层次化结构均无所不在。二叉树不再是简单的线性结构，但确定某种次序后具有线性特征，故树属于半线性结构。 树等价于无环联通图，因此与一般的图相同，树也由一组顶点和联接于其间的若干条边组成，故任一节点与根节点之间存在着唯一路径。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-09-02T13:40:20.000Z">
<meta property="article:modified_time" content="2021-03-27T13:17:35.000Z">
<meta property="article:author" content="trinkle">
<meta property="article:tag" content="Data structure">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://twinkle0331.github.io/algorithm/bin-tree/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>二叉树 | trinkle</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="trinkle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">trinkle</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://twinkle0331.github.io/algorithm/bin-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trinkle">
      <meta itemprop="description" content="Stay foolish,stay hungry.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="trinkle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          二叉树
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-02 21:40:20" itemprop="dateCreated datePublished" datetime="2019-09-02T21:40:20+08:00">2019-09-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>树是一种分层结构，而层次化这一结构几乎蕴含于所有事物及其联系中，称为其本质属性之一。从文件系统、互联网域名系统，一直到地球生态系统乃至人类社会系统，层次化特征和层次化结构均无所不在。二叉树不再是简单的线性结构，但确定某种次序后具有线性特征，故树属于半线性结构。</p>
<p>树等价于无环联通图，因此与一般的图相同，树也由一组顶点和联接于其间的若干条边组成，故任一节点与根节点之间存在着唯一路径。</p>
<a id="more"></a>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>节点度数不超过2的树称为二叉树，同一节点的孩子和子树，均以左、右区分。</p>
<p>深度为$k$的节点，至多$2^k$个</p>
<p>含$n$个节点的二叉树，高度为$h$的二叉树中，$h&lt;n&lt;2^{h+1}$</p>
<p>1）$n=h+1$时，退化为一条单链</p>
<p>2）$n=2^{h+1}-1$,即所谓的满二叉树</p>
<p>设度数为0，1，2的节点，各有$n_0$,$n_1$,$n_2$个</p>
<p>树为极小联通图，故边数$e=n+1=n_1+2n_2$</p>
<p>叶节点数$n_0=n_2+1$</p>
<p>即$n_1$与$n_0$无关</p>
<p>$h=0$时，$1=0+1$</p>
<p>此后，$n_0$与$n_2$同步递增</p>
<p>特别地，当$n_1=0$时，有$e=2n_2$和$n_0=n_2+1=(n+1)/2$</p>
<p>此时，所有的节点均为偶数，不含单分支节点。</p>
<p>二叉树本身并不具有天然的次序，需要在各个节点与其孩子间定义某种局部次序，从而间接地定义出全局次序。按惯例，左孩子优先于右孩子，将节点和左右孩子分别称为V,L,R,局部次序有VLR,LVR,LRV三种选择，根据节点V的访问次序分别称为先序遍历、中序遍历、后序遍历。</p>
<h1 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h1><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_R</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( !x ) <span class="keyword">return</span>;</span><br><span class="line">   visit ( x-&gt;data );</span><br><span class="line">   travPre_R ( x-&gt;lc, visit );</span><br><span class="line">   travPre_R ( x-&gt;rc, visit );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><p>对右子树的递归属于尾递归，左子树的递归接近尾递归，借用尾递归的消除方法，可得到迭代版算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I1</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#1）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">if</span> ( x ) S.push ( x ); <span class="comment">//根节点入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( !S.empty() ) &#123; <span class="comment">//在栈变空之前反复循环</span></span><br><span class="line">      x = S.pop(); visit ( x-&gt;data ); <span class="comment">//弹出并访问当前节点，其非空孩子的入栈次序为先右后左</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *x ) ) S.push ( x-&gt;rc ); <span class="keyword">if</span> ( HasLChild ( *x ) ) S.push ( x-&gt;lc );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先序遍历序列可分为两段：</p>
<ul>
<li>沿最左侧通路自顶而下访问的各节点</li>
<li>自底而上访问遍历的对应右子树</li>
</ul>
<p>借助栈逆序记录最左侧通路上的节点的右子树，以确定对应右子树自底而上的遍历次序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I2</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#2）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">      visitAlongLeftBranch ( x, visit, S ); <span class="comment">//从当前节点出发，逐批访问</span></span><br><span class="line">      <span class="keyword">if</span> ( S.empty() ) <span class="keyword">break</span>; <span class="comment">//直到栈空</span></span><br><span class="line">      x = S.pop(); <span class="comment">//弹出下一批的起点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点；沿途节点遇到后立即访问</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitAlongLeftBranch</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit, Stack&lt;BinNodePosi(T)&gt;&amp; S )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( x ) &#123;</span><br><span class="line">      visit ( x-&gt;data ); <span class="comment">//访问当前节点</span></span><br><span class="line">      S.push ( x-&gt;rc ); <span class="comment">//右孩子入栈暂存（可优化：通过判断，避免空的右孩子入栈）</span></span><br><span class="line">      x = x-&gt;lc;  <span class="comment">//沿左分支深入一层</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><h2 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_R</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( !x ) <span class="keyword">return</span>;</span><br><span class="line">   travIn_R ( x-&gt;lc, visit );</span><br><span class="line">   visit ( x-&gt;data );</span><br><span class="line">   travIn_R ( x-&gt;rc, visit );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代版-1"><a href="#迭代版-1" class="headerlink" title="迭代版"></a>迭代版</h2><p>与之前的先序遍历算法不同，沿最左侧分支下行时只是将对应的节点压栈，并没有执行访问操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goAlongLeftBranch</span> <span class="params">( BinNodePosi(T) x, Stack&lt;BinNodePosi(T)&gt;&amp; S )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( x ) &#123; S.push ( x ); x = x-&gt;lc; &#125; <span class="comment">//当前节点入栈后随即向左侧分支深入，迭代直到无左孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I1</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#1）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">      goAlongLeftBranch ( x, S ); <span class="comment">//从当前节点出发，逐批入栈</span></span><br><span class="line">      <span class="keyword">if</span> ( S.empty() ) <span class="keyword">break</span>; <span class="comment">//直至所有节点处理完毕</span></span><br><span class="line">      x = S.pop(); visit ( x-&gt;data ); <span class="comment">//弹出栈顶节点并访问之</span></span><br><span class="line">      x = x-&gt;rc; <span class="comment">//转向右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上一版等价地描述以下版本：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I2</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#2）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( x ) &#123;</span><br><span class="line">         S.push ( x ); <span class="comment">//根节点进栈</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !S.empty() ) &#123;</span><br><span class="line">         x = S.pop(); <span class="comment">//尚未访问的最低祖先节点退栈</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该祖先节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//遍历祖先的右子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//遍历完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上版需借助辅助栈，所需辅助空间正比于二叉树的高度，在最坏情况下与节点数目相当。借助<code>BinNode</code>对象内部的<code>parent</code>指针，以下版本仅需要常数辅助空间，属于就地算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I3</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#3，无需辅助栈）</span></span><br><span class="line">   <span class="keyword">bool</span> backtrack = <span class="literal">false</span>; <span class="comment">//前一步是否刚从右子树回溯——省去栈，仅O(1)辅助空间</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( !backtrack &amp;&amp; HasLChild ( *x ) ) <span class="comment">//若有左子树且不是刚刚回溯，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则——无左子树或刚刚回溯（相当于无左子树）</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该节点</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) &#123; <span class="comment">//若其右子树非空，则</span></span><br><span class="line">            x = x-&gt;rc; <span class="comment">//深入右子树继续遍历</span></span><br><span class="line">            backtrack = <span class="literal">false</span>; <span class="comment">//并关闭回溯标志</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若右子树空，则</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">break</span>; <span class="comment">//回溯（含抵达末节点时的退出返回）</span></span><br><span class="line">            backtrack = <span class="literal">true</span>; <span class="comment">//并设置回溯标志</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BinNode&lt;T&gt;::succ() &#123; <span class="comment">//定位节点v的直接后继</span></span><br><span class="line">   BinNodePosi(T) s = <span class="keyword">this</span>; <span class="comment">//记录后继的临时变量</span></span><br><span class="line">   <span class="keyword">if</span> ( rc ) &#123; <span class="comment">//若有右孩子，则直接后继必在右子树中，具体地就是</span></span><br><span class="line">      s = rc; <span class="comment">//右子树中</span></span><br><span class="line">      <span class="keyword">while</span> ( HasLChild ( *s ) ) s = s-&gt;lc; <span class="comment">//最靠左（最小）的节点</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则，直接后继应是“将当前节点包含于其左子树中的最低祖先”，具体地就是</span></span><br><span class="line">      <span class="keyword">while</span> ( IsRChild ( *s ) ) s = s-&gt;parent; <span class="comment">//逆向地沿右向分支，不断朝左上方移动</span></span><br><span class="line">      s = s-&gt;parent; <span class="comment">//最后再朝右上方移动一步，即抵达直接后继（如果存在）</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此版相当于将原辅助栈替换为一个标志位<code>backtrack</code>，标志是否有从下而上的回溯。若不是，则按照中序遍历的策略优先遍历左子树，否则，则意味着当前左子树已访问完毕，访问当前节点后深入右子树。</p>
<p>改进该算法，无需辅助栈，也无需辅助标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I4</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历（迭代版#4，无需栈或标志位）</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) <span class="comment">//若有左子树，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问当前节点，并</span></span><br><span class="line">         <span class="keyword">while</span> ( !HasRChild ( *x ) ) <span class="comment">//不断地在无右分支处</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">return</span>; <span class="comment">//回溯至直接后继（在没有后继的末节点处，直接退出）</span></span><br><span class="line">            <span class="keyword">else</span> visit ( x-&gt;data ); <span class="comment">//访问新的当前节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//（直至有右分支处）转向非空的右子树</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论二叉树的规模如何，对succ()接口所有调用所需时间总和不超过O(n)</p>
</blockquote>
<p>在这一场合对<code>succ</code>的调用，其中if判断语句必然取else分支，因此，算法所消耗的所有时间应线性正比于其中while循环的部署，即其中对<code>parent</code>引用的访问次数。数学归纳法对树高归纳可证明对<code>parent</code>引用不超过$n$次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I3</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#3，无需辅助栈）</span></span><br><span class="line">   <span class="keyword">bool</span> backtrack = <span class="literal">false</span>; <span class="comment">//前一步是否刚从右子树回溯——省去栈，仅O(1)辅助空间</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( !backtrack &amp;&amp; HasLChild ( *x ) ) <span class="comment">//若有左子树且不是刚刚回溯，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则——无左子树或刚刚回溯（相当于无左子树）</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该节点</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) &#123; <span class="comment">//若其右子树非空，则</span></span><br><span class="line">            x = x-&gt;rc; <span class="comment">//深入右子树继续遍历</span></span><br><span class="line">            backtrack = <span class="literal">false</span>; <span class="comment">//并关闭回溯标志</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若右子树空，则</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">break</span>; <span class="comment">//回溯（含抵达末节点时的退出返回）</span></span><br><span class="line">            backtrack = <span class="literal">true</span>; <span class="comment">//并设置回溯标志</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个节点都仅在左子树被访问完成后接受访问，所以只访问一次。</p>
<p>另外，此处并未显式地使用复杂的辅助结构，表面上看只需要常数辅助空间，但是相比于其余算法，该算法要求每个算法均有<code>parent</code>指针，仍为$O(n)$空间。</p>
<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><h2 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPost_R</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树后序遍历算法（递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( !x ) <span class="keyword">return</span>;</span><br><span class="line">   travPost_R ( x-&gt;lc, visit );</span><br><span class="line">   travPost_R ( x-&gt;rc, visit );</span><br><span class="line">   visit ( x-&gt;data );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代版-2"><a href="#迭代版-2" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//在以S栈顶节点为根的子树中，找到最高左侧可见叶节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gotoHLVFL</span> <span class="params">( Stack&lt;BinNodePosi(T)&gt;&amp; S )</span> </span>&#123; <span class="comment">//沿途所遇节点依次入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( BinNodePosi(T) x = S.top() ) <span class="comment">//自顶而下，反复检查当前节点（即栈顶）</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) &#123; <span class="comment">//尽可能向左</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) S.push ( x-&gt;rc ); <span class="comment">//若有右孩子，优先入栈</span></span><br><span class="line">         S.push ( x-&gt;lc ); <span class="comment">//然后才转至左孩子</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//实不得已</span></span><br><span class="line">         S.push ( x-&gt;rc ); <span class="comment">//才向右</span></span><br><span class="line">   S.pop(); <span class="comment">//返回之前，弹出栈顶的空节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPost_I</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树的后序遍历（迭代版）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">if</span> ( x ) S.push ( x ); <span class="comment">//根节点入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( !S.empty() ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( S.top() != x-&gt;parent ) <span class="comment">//若栈顶非当前节点之父（则必为其右兄），此时需</span></span><br><span class="line">         gotoHLVFL ( S ); <span class="comment">//在以其右兄为根之子树中，找到HLVFL（相当于递归深入其中）</span></span><br><span class="line">      x = S.pop(); visit ( x-&gt;data ); <span class="comment">//弹出栈顶（即前一节点之后继），并访问之</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在后续遍历序列中，栈顶元素应后于栈顶子树访问，所以后序遍历序列并不是访问栈顶元素，而是先判断对应子树是否遍历，若遍历再访问栈顶元素。</p>
<p>在迭代版后序遍历算法运行中，树中每一层至多有两个节点存在栈中，故栈结构最大规模不超过二叉树深度的两倍，最坏情况下为$O(n)$。</p>
<h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>递归的形式类似于栈，层次遍历的顺序与栈访问顺序有所不同，所以借助与栈对称的队列结构实现层次遍历。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="keyword">void</span> BinNode&lt;T&gt;::travLevel ( VST&amp; visit ) &#123; <span class="comment">//二叉树层次遍历算法</span></span><br><span class="line">   Queue&lt;BinNodePosi(T)&gt; Q; <span class="comment">//辅助队列</span></span><br><span class="line">   Q.enqueue ( <span class="keyword">this</span> ); <span class="comment">//根节点入队</span></span><br><span class="line">   <span class="keyword">while</span> ( !Q.empty() ) &#123; <span class="comment">//在队列再次变空之前，反复迭代</span></span><br><span class="line">      BinNodePosi(T) x = Q.dequeue(); visit ( x-&gt;data ); <span class="comment">//取出队首节点并访问之</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) Q.enqueue ( x-&gt;lc ); <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *x ) ) Q.enqueue ( x-&gt;rc ); <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列中所存节点的深度不超过1，故最大规模不超过二叉树任一的相邻两层的规模之和。</p>
<blockquote>
<p>只要辅助队列Q的容量不低于$\lceil n/2 \rceil$ ,就不会出现中途溢出的问题</p>
</blockquote>
<p>在算法的每一步迭代过程中，若当前至少有$n$各个元素入过队，则在队中的至多$\lceil n/2 \rceil$,相应地，至少有$\lfloor n/2 \rfloor$个已经出队。每次迭代都会有一个节点出队，若该节点的度数为$d(0&lt;=d&lt;=2)$，则随即会有$d$个节点入队，通过对已出队的节点做数学归纳可证。</p>
<p>在算法的任一时刻，辅助队列的规模均不至小于仍在队列中节点的数目。为了使仍在队列中节点数目占当前入过队节点比重尽可能大，此前所有出队节点度数都必须取作最大的2，且中途一旦某个节点只有1度甚至0度，则不可能恢复到这一比重，即当树为规模为n的完全二叉树时需要如此大容量的队列。</p>
<p>在整个遍历过程中，规模为$n$的完全二叉树为单峰对称的，即</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;0,1,2,..(n+1)&#x2F;2,...,2,1,0&#125;</span><br><span class="line">&#123;0,1,2,..n&#x2F;2,n&#x2F;2,...,2,1,0&#125;</span><br></pre></td></tr></table></figure>
<p>$n$为偶数时，最后一个内部节点度数为1，入一出一，所以队列规模不变。</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>叶节点仅限于最低两层</p>
<p>底层叶子均居于次底层叶子左侧，除末节点的父亲，内部节点均有叶子。</p>
<p>叶节点不致少于内部节点，但至多多出一个。</p>
<p>分为两种情况：</p>
<ul>
<li><strong>各节点均为二度节点</strong> $n_0=n_1+n_2+1=n_2+1$</li>
<li><strong>有一节点为一度</strong> $n_0=n_2+1=n_2+n_1$</li>
</ul>
<blockquote>
<p>这些算法的确会访问每个节点一次且仅一次</p>
</blockquote>
<p>只要某个节点可以被访问到，则其孩子节点必然也能</p>
<p>由此进一步可知：只要某个节点能被访问到，则其每个后代节点必然也能。于是特别地，作为根节点地后代，树中所有节点都能被起始于根节点的遍历访问到。</p>
<p>另外一方面，任何节点仅被访问一次。</p>
<p>除了层次遍历算法和中序遍历算法均借助辅助栈进行访问，注意到每个节点都在且仅在刚刚出栈后，随即被访问。每个节点各自仅入栈一次，即可确定每个节点的确至多被访问一次。</p>
<p>层次遍历算法和中序遍历算法未使用到栈结构，性质类似。</p>
<blockquote>
<p>这些算法都具有线性时间复杂度</p>
</blockquote>
<p>这些算法的运行时间主要消耗于两个部分：</p>
<ul>
<li>栈(队列)操作</li>
<li>对节点的访问操作</li>
</ul>
<p>以上操作对每个节点而言均为常数次，所以总体而言，这些算法具有线性时间复杂度。</p>
<blockquote>
<p>递推方程分析</p>
</blockquote>
<p>$T(n)=T(n-a-1)+T(a)+O(1)$</p>
<p>每递归一层，等效于将当前问题分解为两个子问题，递归基只需常数时间，同样可以得出这些算法具有线性复杂度的结论。</p>
<h1 id="二叉编码树"><a href="#二叉编码树" class="headerlink" title="二叉编码树"></a>二叉编码树</h1><p>通讯理论中一个基本的问题是：如何在尽可能低的成本的情况下，以尽可能高的速度，尽可能忠实地实现信息在空间和时间上的复制和转移。在现代通讯技术中，无论采用电、磁、光、电或其他任何形式，在信道上传递的信息大多以二进制比特的形式表示和存在，而每一个具体的编码方案都对应于一棵二叉编码树。</p>
<p>在加载到信道上之前，信息被转换为二进制的过程被称为编码，反之，信道抵达目标后再由二进制编码回复原始信息的过程被称为解码。</p>
<p>任一编码方案都可描述为一棵二叉树：从根节点出发，每次向左(右)对应一个0(1)比特位。各字符分别存放于对应的叶子中。字符x的编码串rps(v(x))=rps(x)由根到v(x)的通路确定。</p>
<p>字符编码不必等长，所有字符都对应于叶节点，不存在解码歧义现象，为前缀无歧义编码，不同字符的编码互不为前缀，故不致歧义，此为可行的PFC编码方案。</p>
<blockquote>
<p>若采用PFC编码，则无论二进制编码串的长度与内容如何，解码过程总能持续进行</p>
</blockquote>
<p>整个解码过程就是在PFC编码树上的下行过程，从根节点出发，根据编码串的当前编码相应地向左(比特0)或向右(比特1)深入，一旦抵达叶节点，则输出其对应的字符，并随即复位至根节点。</p>
<p>可见，算法无法继续的唯一可能情况为，在准备向下深入时没有发现对应的分支，然而根据定义和约束条件，PFC编码树必然是真二叉树，每一内部节点必然拥有左、右分支，因此上述情况不可能发生。</p>
<p>解码过程不必回溯，若因为信道干扰等因素导致某个比特位翻转错误，尽管解码依然可进行，但是后续所有字符的解码都会出现错误。</p>
<h2 id="最优编码树"><a href="#最优编码树" class="headerlink" title="最优编码树"></a>最优编码树</h2><p>在实际的通讯系统中，信道的使用效率很大程度上取决于编码本身的效率。比如，高效的算法生成的编码串应尽可能短。</p>
<p>字符x的编码长度|rps(x)|为其对应叶节点的深度depth(v(x))。于是，各字符的平均编码长度就是编码树T中的叶节点平均深度。</p>
<p>$ald(T)=\sum_{x\in \sum}|rps(x)|/|\sum|=\sum_{x\in \sum}depth(x)/|\sum|$</p>
<p>平均编码长度是反应编码效率的重要指标，我们尽可能希望这一指标小。同一字符集的所有编码方案中，平均编码长度最小者被称为最优方案，对应编码树的ald()值达到最小，故称之为最优编码树，简称最优编码树。对于任一字符集，最优编码树必然存在。</p>
<p><strong>双子性</strong></p>
<p>最优编码树必然为真二叉树，内部节点的左、右孩子全双，不然，假设其中内部节点p有唯一的孩子x，则将p删除并代之以子树x。除了子树中所有叶节点的编码长度统一缩短一层外，其余叶节点的编码长度不变，相比于之前的编码树平均编码长度必然更短。</p>
<p><strong>层次性</strong></p>
<p>叶节点位置深度之差不超过1，类似双子性的证明，替换后可得到的编码树平均编码长度更短，不符合最优编码树的原则。</p>
<p><strong>不唯一性</strong></p>
<p>对于任一内部节点而言，左右子树互换之后平均编码长度不变。</p>
<p><strong>最优编码树的构造</strong></p>
<p>真完全树为最优编码树，可直接导出构造最优编码树的算法：创建一棵规模为$2|\sum|-1$的完全二叉树T，将$\sum$中的字符任意分配给T的$|\sum|$个节点。</p>
<blockquote>
<p>若不同序列作为输出的概率均等，则任何CBA式排序算法平均运行时间仍然为$\Omega(nlogn)$</p>
</blockquote>
<p>针对CBA式算法复杂度的下界估计，统一方法为：</p>
<ul>
<li>确定算法所对应的比较树</li>
<li>通过输入规模与可能的输出结果(叶节点)数目推算出最小树高</li>
</ul>
<p>在各种输出结果符合某种概率分布的情况下，算法的平均性能，则等效于比较树中各叶节点的加权平均深度。</p>
<p>最优编码树在各种输出结果均等的情况下，对于任一固定输入规模n，完全二叉树的叶节点平均深度可达到最小。</p>
<h2 id="huffman编码树"><a href="#huffman编码树" class="headerlink" title="huffman编码树"></a>huffman编码树</h2><p>以上最优编码树算法假定各个字符在文本串中出现的次数相等，而这一条件往往不满足，甚至不确定。</p>
<p>若考虑字符各自出现频率，则可将带权平均编码长度取作编码树T的叶节点带权平均深度，即是</p>
<p>$wald(T)=\sum_{x\in \sum}p(x)|rps(x)|$</p>
<p>此时，完全二叉编码树并不是wald值最短。</p>
<p><strong>最优带权编码树</strong></p>
<p>频率高的超字符，应尽可能放在高/低处。</p>
<p>同样，huffman编码树满足层次性、双子性、不唯一性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffTree* <span class="title">minHChar</span> <span class="params">( HuffForest* forest )</span> </span>&#123; <span class="comment">//在Huffman森林中找出权重最小的（超）字符</span></span><br><span class="line">   ListNodePosi ( HuffTree* ) p = forest-&gt;first(); <span class="comment">//从首节点出发查找</span></span><br><span class="line">   ListNodePosi ( HuffTree* ) minChar = p; <span class="comment">//最小Huffman树所在的节点位置</span></span><br><span class="line">   <span class="keyword">int</span> minWeight = p-&gt;data-&gt;root()-&gt;data.weight; <span class="comment">//目前的最小权重</span></span><br><span class="line">   <span class="keyword">while</span> ( forest-&gt;valid ( p = p-&gt;succ ) ) <span class="comment">//遍历所有节点</span></span><br><span class="line">      <span class="keyword">if</span> ( minWeight &gt; p-&gt;data-&gt;root()-&gt;data.weight ) <span class="comment">//若当前节点所含树更小，则</span></span><br><span class="line">         &#123;  minWeight = p-&gt;data-&gt;root()-&gt;data.weight; minChar = p;  &#125; <span class="comment">//更新记录</span></span><br><span class="line">   <span class="keyword">return</span> forest-&gt;remove ( minChar ); <span class="comment">//将挑选出的Huffman树从森林中摘除，并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffTree* <span class="title">generateTree</span> <span class="params">( HuffForest* forest )</span> </span>&#123; <span class="comment">//Huffman编码算法</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> &lt; forest-&gt;size() ) &#123;</span><br><span class="line">      HuffTree* T1 = minHChar ( forest ); HuffTree* T2 = minHChar ( forest );</span><br><span class="line">      HuffTree* S = <span class="keyword">new</span> HuffTree(); </span><br><span class="line">      S-&gt;insertAsRoot ( HuffChar ( <span class="string">&#x27;^&#x27;</span>, T1-&gt;root()-&gt;data.weight + T2-&gt;root()-&gt;data.weight ) );</span><br><span class="line">      S-&gt;attachAsLC ( S-&gt;root(), T1 ); S-&gt;attachAsRC ( S-&gt;root(), T2 );</span><br><span class="line">      forest-&gt;insertAsLast ( S ); </span><br><span class="line">   &#125; <span class="comment">//assert: 循环结束时，森林中唯一（列表首节点中）的那棵树即Huffman编码树</span></span><br><span class="line">   <span class="keyword">return</span> forest-&gt;first()-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="comment">//通过遍历获取各字符的编码</span></span><br><span class="line">generateCT ( Bitmap* code, <span class="keyword">int</span> length, HuffTable* table, BinNodePosi ( HuffChar ) v ) &#123;</span><br><span class="line">   <span class="keyword">if</span> ( IsLeaf ( *v ) ) <span class="comment">//若是叶节点（还有多种方法可以判断）</span></span><br><span class="line">      &#123;  table-&gt;put ( v-&gt;data.ch, code-&gt;bits2string ( length ) ); <span class="keyword">return</span>;  &#125;</span><br><span class="line">   <span class="keyword">if</span> ( HasLChild ( *v ) ) <span class="comment">//Left = 0</span></span><br><span class="line">      &#123; code-&gt;clear ( length ); generateCT ( code, length + <span class="number">1</span>, table, v-&gt;lc ); &#125;</span><br><span class="line">   <span class="keyword">if</span> ( HasRChild ( *v ) ) <span class="comment">//Right = 1</span></span><br><span class="line">      &#123; code-&gt;<span class="built_in">set</span> ( length ); generateCT ( code, length + <span class="number">1</span>, table, v-&gt;rc ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffTable* <span class="title">generateTable</span> <span class="params">( HuffTree* tree )</span> </span>&#123; <span class="comment">//将各字符编码统一存入以散列表实现的编码表中</span></span><br><span class="line">   HuffTable* table = <span class="keyword">new</span> HuffTable; Bitmap* code = <span class="keyword">new</span> Bitmap;</span><br><span class="line">   generateCT ( code, <span class="number">0</span>, table, tree-&gt;root() ); release ( code ); <span class="keyword">return</span> table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每迭代一次，森林的规模减1,故共需迭代n-1此，直到只剩一棵树。<code>minHChar()</code> 每次都要遍历森林中所有的超字符，所需时间线性正比于当时森林的规模。因此总体运行时间应为：</p>
<p>$O(1)+O(n-1)+…+O(2)=O(n^2)$</p>
<blockquote>
<p>任何CBA式huffman树构造算法在最坏情况下都需要运行$\Omega(nlog n)$时间</p>
</blockquote>
<p>只需建立一个从排序问题到huffman编码树问题的线性归约</p>
<p>事实上，对于每一个待排序的输入序列，我们都将其视为一组字符的出现频率。不失一般性，假设每个元素非负，否则可在$O(n)$时间内令它们增加同一足够大的正数。</p>
<p>以这组频率作为输入，可以调用任何CBA式算法构造出huffman编码树，一旦得到这样一棵编码树，只需一趟层次遍历，即可在$O(n)$时间内得到所有叶节点的遍历序列。</p>
<p>根据huffman编码树的定义，该树必然是单调的。因此，整个过程也等效于同时完成了对原输入序列的排序。</p>
<p>若待编码字符集已按出现频率排序，则huffman编码可以更快完成。始终将森林中的树分为两类：单节点(尚未参与合并)和多节点(已合并过)。每经过一次迭代，后者虽不见得增多，但必然有一个新成员。</p>
<p>根据huffman编码树的原理，每次迭代都是在当前森林中选取权重最小的两棵树合并，因此，被选出的树权重必然单调非降，故在当前所有(经合成生成后)多节点树中，最新者的权重必然最大。</p>
<p>将以上两类节点组织为两个队列，初始状态下，所有字符按照权重非降的次序存入单节点的队列，而多节点的队列，直接置空。此后的过程与常规的huffman编码树类似，反复取出权重最小的两棵树，将其合并后插回森林，直至最后只剩下一棵树</p>
<h1 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h1><p><strong>关联数组</strong>（<strong>Associative Array</strong>），又称<strong>映射</strong>（<strong>Map</strong>）、<strong>字典</strong>（<strong>Dictionary</strong>）是一个抽象的数据结构、，它包含着类似于（键，值）的有序对。一个关联数组中的有序对可以重复（如C++中的multimap）也可以不重复（如C++中的map)。</p>
<p>Trie在计算机科学中又称前缀树和键树，是一种保存关联数组的有序树，其中的键通常是字符串。与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80">前缀</a>，也就是这个节点对应的字符串，而根节点对应<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">空字符串</a>。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>Trie这个术语来自于re<strong>trie</strong>val，trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<p>任一字符串集s都可表示为一棵键树。键树是有根有序树，其中每个节点均有r个分支，深度为d的节点对应于长度为d的字符串，祖先对应的字符串必定为后代所对应字符串的前缀。键树只保留与S中字符串相对应的节点，其余分支均标记为null。</p>
<p>因为并不确保字符串相互不为前缀，所以对应于完整字符串的节点未必是叶子，每个非空指针通过标志位来表明是否表示s中某个完整的字符串。</p>
<p>基于键树实现词典的<code>get()</code>,<code>put()</code>,<code>remove()</code>接口时间复杂度分别为$O(h)$,$O(hr)$,$O(hr)$。</p>
<blockquote>
<p>若以向量实现键树，则put(),remove()复杂度中的因子r不可消除</p>
</blockquote>
<p>在最坏情况下，在创建每个节点后，都需要花费$O(r)$时间，将对应向量中的每个指针都初始化为NULL。</p>
<p>同样，在最坏情况下，在删除每个节点后，都需要花费$O(r)$时间确认对应向量是否都是NULL。</p>
<p>以上方式在最坏情况下需要$\Omega(nr)$空间，其中$n=|s|$为字符串的规模。若s中的字符串均互不为前缀，则每个字符串都将对应于一个叶节点。于是，即便只计入这$n$个叶节点，累计空间总量为$\Omega(nr)$。</p>
<p>若用链表来实现各节点，每个节点的规模与实际的分支数成正比，每个字符串的每个字符至多占用$O(1)$空间，故所需空间总量线性正比于S中所有字符串的长度总和，同时，在每个节点需要$O( r )$时间顺序查找以确定深入的分支方向。get()接口的效率将降至$O(hr)$,其中h为树高，同时也是S中字符串的最大长度。</p>
<h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p>键树中往往包含大量的单分支节点，通过折叠合并相邻的单分支节点，进一步提高键树的效率。</p>
<p><strong>基数树</strong>，或称Patricia trie/tree，或crit bit tree，<strong>压缩前缀树</strong>，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。一棵Patricia Trie的任何内部结点有2个或以上的孩子结点。</p>
<p>将向量地单分支节点合成一个大节点，尽管一定程度上可以提高时、空效率，但是在渐进意义上并无实质改进。</p>
<p>应用：</p>
<ul>
<li>构建<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组</a></li>
<li>用于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/IP">IP</a> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1">路由</a></li>
<li> <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2">信息检索</a>中用于文本文档的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">倒排索引</a>。</li>
</ul>
<h2 id="三叉树"><a href="#三叉树" class="headerlink" title="三叉树"></a>三叉树</h2><p>Trie树结构，它的实现简单但空间效率低。如果要支持26个英文字母，每个节点就要保存26个指针，假若我们还要支持国际字符、标点符号、区分大小写，内存用量就会急剧上升，以至于不可行。</p>
<p>类似于二叉查找树，三叉查找树(ternarry tree)可以用于实现带前缀搜索功能的关联数组。比标准的前缀树更省空间，但是查找速度有所下降。</p>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>trinkle
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://twinkle0331.github.io/algorithm/bin-tree/" title="二叉树">http://twinkle0331.github.io/algorithm/bin-tree/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Data-structure/" rel="tag"><i class="fa fa-tag"></i> Data structure</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/algorithm/stack/" rel="prev" title="栈和队列">
                  <i class="fa fa-chevron-left"></i> 栈和队列
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/algorithm/graph/" rel="next" title="图">
                  图 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">trinkle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
