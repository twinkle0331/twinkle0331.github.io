<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"twinkle0331.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="串或字符串属于线性结构，但字符串作为数据结构，结构简单，规模庞大，元素重复率高。所谓结构简单，是指字符表本身的规模不大，甚至可能极小。以生物信息序列为例，参与蛋白质合成的氨基酸只有20种，而构成DNA序列仅有4种。因此，以字符串形式表示的海量文本处理技术，一直都是相关领域的研究重点。">
<meta property="og:type" content="article">
<meta property="og:title" content="串">
<meta property="og:url" content="http://twinkle0331.github.io/algorithm/string/index.html">
<meta property="og:site_name" content="trinkle">
<meta property="og:description" content="串或字符串属于线性结构，但字符串作为数据结构，结构简单，规模庞大，元素重复率高。所谓结构简单，是指字符表本身的规模不大，甚至可能极小。以生物信息序列为例，参与蛋白质合成的氨基酸只有20种，而构成DNA序列仅有4种。因此，以字符串形式表示的海量文本处理技术，一直都是相关领域的研究重点。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/09/10/6BhE1GOXm3dAULb.png">
<meta property="og:image" content="https://i.loli.net/2019/09/11/JhYefNSm7dsBGEM.png">
<meta property="article:published_time" content="2019-09-10T07:49:33.000Z">
<meta property="article:modified_time" content="2021-03-27T13:17:35.000Z">
<meta property="article:author" content="trinkle">
<meta property="article:tag" content="Data structure">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2019/09/10/6BhE1GOXm3dAULb.png">


<link rel="canonical" href="http://twinkle0331.github.io/algorithm/string/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>串 | trinkle</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="trinkle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">trinkle</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://twinkle0331.github.io/algorithm/string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trinkle">
      <meta itemprop="description" content="Stay foolish,stay hungry.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="trinkle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          串
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-09-10 15:49:33" itemprop="dateCreated datePublished" datetime="2019-09-10T15:49:33+08:00">2019-09-10</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Algorithm/" itemprop="url" rel="index"><span itemprop="name">Algorithm</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>串或字符串属于线性结构，但字符串作为数据结构，结构简单，规模庞大，元素重复率高。所谓结构简单，是指字符表本身的规模不大，甚至可能极小。以生物信息序列为例，参与蛋白质合成的氨基酸只有20种，而构成DNA序列仅有4种。因此，以字符串形式表示的海量文本处理技术，一直都是相关领域的研究重点。</p>
<a id="more"></a>

<p>一般地，由$n$个字符组成构成的串记作：</p>
<p>$S=a_0a_1a_2…a_{n-1}$,其中$a_i \in \sum,0\leq i &lt;n$</p>
<p>这里的$\sum$是所有可用字符的集合，称作字符表，例如二进制比特集，ASCII字符集。字符串S中所含字符的总数$n$，称作S的长度，记作$|S|=n$。这里只考虑长度有限的串，特别地，长度为零的串称作空串。</p>
<p>字符串中任一连续的片段，称作其子串。具体地，对于任意$0\leq i&lt;i+k&lt;n$,由字符串S中起始于位置i的长度为k的子串称作后缀，分别记作：</p>
<p>$S.substr(i,k)=a_ia_{i+1}…a_{ i+k}=S[i,i+k)$</p>
<p>特殊地，起始于位置0、长度为k的子串称作前缀，而终止于位置n-1、长度为k的子串称为后缀，分别记作：</p>
<p>$prefix(S,k)=S.substr(0,k)=S[0,k)$</p>
<p>$Suffix(S,k)=S.substr(n-k,k)=S[n-k,n)$</p>
<p>由以上定义可知：空串是任何字符串的子串，也是任何字符串的前缀和后缀。任何字符串都是自己的子串，也是自己的前缀和后缀。</p>
<p>最后，字符串$S[0,n)$和$T[0,m)$相等，当且仅当二者长度相等$(n=m)$,且对应的字符相同(对任意$0\leq i&lt;n$都有$S[i]=T[i]$)。</p>
<h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><p>在涉及字符串的众多实际应用中，模式匹配是最常使用的一项基本操作。比如UNIX Shell的grep工具和DOS的find命令基本功能都是在指定的字符串中查找特定模式的字符串。生物信息处理领域，也经常需要在蛋白质序列中寻找特定的氨基酸模式。</p>
<p>以上所有应用问题，本质上都可描述为如下形式：</p>
<p><strong>如何在字符串数据中，检测和提取以字符串为形式给出的某一局部特征</strong>。</p>
<p>这类操作都属于串模式匹配范畴，简称串匹配。一般地，即</p>
<p>对于基于同一字符表的任何文本串$T(|T|=n)$和模式串$(|P|=m)$：</p>
<ul>
<li>判定$T$中是否存在某一子串与$T$相同</li>
<li>若存在(匹配)，则报告该子串在$T$中的起始位置</li>
</ul>
<p>串的长度$n$和$m$都很大，但相对而言$m$更大，即满足$2&lt;&lt;m&lt;&lt;n$ 。</p>
<p>根据具体应用需求的不同，串匹配模式可以多种形式呈现。</p>
<p>有些场合属于模式检测问题：只关心是否存在匹配而不关心具体的匹配位置，比如垃圾邮件的检测。有些场合属于模式定位问题，若经判断的确存在匹配，则还需确定具体的匹配位置，比如带病毒程序的鉴别和修复。有些场合属于模式计数问题：若存在多处匹配，则统计出匹配的子串总数，比如网络热门词汇榜的更新。有些场合则属于模式枚举问题，若存在多处匹配时，报告出所有匹配的具体位置。</p>
<p>如何对任一串匹配算法进行评估呢？</p>
<p>假设文本串T和模式串P都是随即生成的，然后综合其各种组合从数学和统计等角度得出结论。</p>
<p>以二进制编码为例，长度为$m$的P有$2^m$ 种，长度为$m$同时在$T$中出现的P为$n-m+1&lt;n$种。</p>
<p>匹配成功的概率极其低，所以并不适合作为衡量的方法。</p>
<p>另外一种简便策略为，随机选取文本串$T$，并从$T$中随机取出长度为$m$的子串作为模式串$P$，此为成功情况。失败情况则采用随机的模式串$P$，由此统计平均复杂度。</p>
<h1 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h1><p>不妨按自左向右的顺序考查各子串。在初始状态下，$T$的前$m$个字符将与$P$的$m$个字符两两对齐。接下来，自左向右检查相互对齐的这$m$对字符，若当前字符对相互匹配，则转向下一字符，反之，一旦失配，则说明在此位置文本串与模式串不可能完全匹配，于是可将$P$整体向右移动一个字符，并从其首字符开始与T中对应的新子串重新对比。</p>
<h2 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************************</span></span><br><span class="line"><span class="comment"> * Text     :  0   1   2   .   .   .   i-j .   .   .   .   i   .   .   n-1</span></span><br><span class="line"><span class="comment"> *             ------------------------|-------------------|------------</span></span><br><span class="line"><span class="comment"> * Pattern  :                          0   .   .   .   .   j   .   .</span></span><br><span class="line"><span class="comment"> *                                     |-------------------|</span></span><br><span class="line"><span class="comment"> ******************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Brute-force-1）</span></span><br><span class="line">   <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//模式串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m &amp;&amp; i &lt; n ) <span class="comment">//自左向右逐个比对字符</span></span><br><span class="line">      <span class="keyword">if</span> ( T[i] == P[j] ) <span class="comment">//若匹配</span></span><br><span class="line">         &#123; i ++;  j ++; &#125; <span class="comment">//则转到下一对字符</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         &#123; i -= j - <span class="number">1</span>; j = <span class="number">0</span>; &#125; <span class="comment">//文本串回退、模式串复位</span></span><br><span class="line">   <span class="keyword">return</span> i - j; <span class="comment">//如何通过返回值，判断匹配结果？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本一借助整数$i$和$j$，分别指示T和P中当前接受比对的字符T[i]和P[i]。若当前字符对匹配，则i和j同时递增以指向下一对字符。一旦$j$增长到$m$则意味着发现了匹配，即可返回P相对于T的对齐位置$i-j$。一旦当前字符失配，则i回退并指向T中当前对齐位置的下一字符，同时j复位至P的首字符处，然后开始下一轮比对。</p>
<p>退出情况对应于整体匹配成功与否</p>
<ul>
<li>若失败，则$j&lt;m,i=n$,$i-j$必然大于$n-m$</li>
<li>若成功，则$j=m,i&lt;=n$,$i-j$必然小于等于$n-m$</li>
</ul>
<h2 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************************</span></span><br><span class="line"><span class="comment"> * Text     :  0   1   2   .   .   .   i   i+1 .   .   .   i+j .   .   n-1</span></span><br><span class="line"><span class="comment"> *             ------------------------|-------------------|------------</span></span><br><span class="line"><span class="comment"> * Pattern  :                          0   1   .   .   .   j   .   .</span></span><br><span class="line"><span class="comment"> *                                     |-------------------|</span></span><br><span class="line"><span class="comment"> ******************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Brute-force-2）</span></span><br><span class="line">   <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串长度、与模式串首字符的对齐位置</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j; <span class="comment">//模式串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n - m + <span class="number">1</span>; i++ ) &#123; <span class="comment">//文本串从第i个字符起，与</span></span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; m; j++ ) <span class="comment">//模式串中对应的字符逐个比对</span></span><br><span class="line">         <span class="keyword">if</span> ( T[i + j] != P[j] ) <span class="keyword">break</span>; <span class="comment">//若失配，模式串整体右移一个字符，再做一轮比对</span></span><br><span class="line">      <span class="keyword">if</span> ( j &gt;= m ) <span class="keyword">break</span>; <span class="comment">//找到匹配子串</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//如何通过返回值，判断匹配结果？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本二借助整体$i$指示$P$相对于$T$的对齐位置，并随着$i$不断递增,对齐位置逐步右移。在每一对齐位置$i$处，另一整数从$0$递增至$m-1$，依次指示当前接受比对的字符为$T[i+j]$与$P[j]$。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>蛮力算法在最好情况下，只需经过一轮比对，比对次数=$m=O(m)$</p>
<p>然而在最坏情况下，整个算法共需做$m(n-m+1)$次比对，其中$(n-m+1)(m-1)+1$次成功比对和$n-m$次失败比对。因为$m&lt;&lt;n$，渐进的时间复杂度为$O(nm)$。</p>
<p>$|\sum|$越小，最坏情况出现的概率越高，$m$越大，最坏情况的后果越严重。</p>
<p>实际上，在通常情况下，蛮力算法效率并不算低</p>
<p>任意字符比对成功的概率与失败概率分别为1/s和(s-1)/s，其中$s=|\sum|$ 为字符表的规模。每个字符各有1/s的概率出现，故任一字符串相同、不同的概率分别为1/s和(s-1)/s。</p>
<p>在$P$与$T$的每一对齐位置，恰好执行$k$次字符对比，当且仅当前$k-1$次成功，第$k$次失败，所以需连续执行恰好$k$次字符比对操作的概率为$(s-1)/s^k$ 。</p>
<p>每一次字符比对可视为一次伯努利实验，成功与失败的概率分别为$1/s$和$(s-1)/s$，而每趟的比对次数X则符合几何分布，X的期望值不超过$s/(s-1)$。在$P$和$T$的每一对齐位置，需连续比对的次数不超过$s/s-1 \leq 2=O(1)$。</p>
<p>直接从期望值的定义出发同样可得出相应结论，具体地，连续执行字符比对操作地次数等于所有可能的次数关于对应概率的加权平均，亦即：</p>
<p>$\sum_{k=1}^{m}k(s-1)/s^k=(s-1)\sum_{k=1}^{m} k/s^k=s/(s-1)$</p>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>蛮力算法在最坏情况下所需时间，为文本串长度与模式串长度的乘积，故无法应用于稍大的场合，很有必要改进。分析以上最坏情况，可知问题在于存在大量的局部匹配：每一轮的m次比对中，仅最后一次失配。一旦发现失配，文本串、模式串的长度都将回退，并重新开始下一轮的尝试。</p>
<p>实际上，这类重复的字符匹配没有必要，因为这些字符在前一轮迭代中已经接受过比对并且成功。那么，如何利用这些信息提高匹配的算法效率呢？</p>
<h2 id="next表"><a href="#next表" class="headerlink" title="next表"></a>next表</h2><p>在每轮比较进行到最后一对字符并发现失配后，蛮力算法会使两个字符指针同步后退，事实上，指针i完全不必后退。经过此前一轮的比较，已确定匹配的范围应为$P[0,j)=T[i-j,i)$</p>
<p>于是，若模式串经过适当右移后，可与$T$的某一子串(包含$T[i]$)完全匹配，则一项必要条件就是：</p>
<p>$P[0,t)=T[i-t,i)=P[j-t,j)$</p>
<p>亦即，在$P[0,j)$中长度为$t$的真前缀，应该与长度为$t$的真后缀完全匹配，故$t$必定来自集合:</p>
<p>$N(P,j)=\left{ 0\leq t&lt;j|P[0,t)=P[j-t,j) \right}$</p>
<p>一般地，该集合可能包含多个这样的$t$,但是需要特别注意的是，其中具体由哪些$t$值构成仅取决于模式串P和首个比对失败的$P[j]$而与文本串无关。</p>
<p>若下一轮比对从$T[i]$和$P[t]$的对比开始，等效于将$P$右移$j-t$个单元。因此，为保证P和T的对齐位置，即$i$绝不倒退，同时不错过任何可能的匹配，应从集合中挑选最大的$t$。当有多个值得试探的右移方案时，应选择其中移动距离最短者。于是，若令</p>
<p>$next[j]=max(N(p,j))$</p>
<p>则一旦发现$P[j]$与$T[i]$失配，即可转而将$P[next[j]]$与$T[i]$彼此对准，并从这一位置开始继续下一轮匹配。</p>
<p>既然集合$N[P,j)$只取决于模式串和失配位置，而与文本串无关，作为其中的最大元素$t$必然具有这一性质。对于任一字符串，均可通过预处理将所有位置$j$所对应的$next[j]$值整理为表格以便于此后查询。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123;  <span class="comment">//KMP算法</span></span><br><span class="line">   <span class="keyword">int</span>* next = buildNext ( P ); <span class="comment">//构造next表</span></span><br><span class="line">   <span class="keyword">int</span> n = ( <span class="keyword">int</span> ) <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串指针</span></span><br><span class="line">   <span class="keyword">int</span> m = ( <span class="keyword">int</span> ) <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m  &amp;&amp; i &lt; n ) <span class="comment">//自左向右逐个比对字符</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; j || T[i] == P[j] ) <span class="comment">//若匹配，或P已移出最左侧（两个判断的次序不可交换）</span></span><br><span class="line">         &#123; i ++;  j ++; &#125; <span class="comment">//则转到下一字符</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         j = next[j]; <span class="comment">//模式串右移（注意：文本串不用回退）</span></span><br><span class="line">   <span class="keyword">delete</span> [] next; <span class="comment">//释放next表</span></span><br><span class="line">   <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>next[0]</strong></p>
<p>只要$j&gt;0$，必有$0\in N[P,j)$，因为空串是任何非空串的子串</p>
<p>但若$j=0$,则有$N(P，0)= \emptyset$</p>
<p>不妨取$next[0]=-1$,向右移动一个字符</p>
<p><strong>next[j+1]</strong></p>
<p>根据已知的$next[0,j]$,如何高效地计算$next[j+1]$?</p>
<p>$next[j]=t$，则意味着在$P[0,j)$中，自匹配的真前缀和真后缀的最大长度为t，故必有$next[j+1] \leq next[j]+1 $,特别地，当且仅当$P[j]=P[t]$时取等号。</p>
<p>那么，更一般地，若$P[j]$不等于$p[t]$，又该如何得到$next[j+1]$?</p>
<p>由next表的功能定义，$next[j+1]$的下一候选者应该依次是</p>
<p>$next[next[j]]+1,next[next[next[j]]]+1,…$</p>
<p>因此，只需反复用$next[t]$替换$t$，即可按优先次序遍历以上候选者：一旦发现$P[j]$与$P[i]$匹配，可令$next[j+1]=next[t]+1$。既然总有$next[t]&lt;t$,故在此过程中$t$必然严格递减，同时，即便$t$降低至$0$，亦必然会终止于通配的next[0]=-1。</p>
<p>next表构造算法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildNext</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造模式串P的next表</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//“主”串指针</span></span><br><span class="line">   <span class="keyword">int</span>* N = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//next表</span></span><br><span class="line">   <span class="keyword">int</span> t = N[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m - <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; t || P[j] == P[t] ) &#123; <span class="comment">//匹配</span></span><br><span class="line">         j ++; t ++;</span><br><span class="line">         N[j] = t; <span class="comment">//此句可改进...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//失配</span></span><br><span class="line">         t = N[t];</span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>KMP算法借助next表的确可以避免大量不必要的比对操作，但是直觉来看，在最坏情况下，共有$\Omega(n)$个对齐位置，而且在每一位置都有可能需要比对$\Omega(m)$次。实际上，在最坏情况下,KMP算法也只需运行线性时间。</p>
<p>考查作为字符指针的变量i和j，若令$k=2i-j$并考查k在KMP算法过程中的变化趋势，while每迭代一轮，k都会严格递增。</p>
<p>实际上，对应于while循环内部的if-else分支，无非两种情况：</p>
<ul>
<li>若转入if分支，则$k=2i-j$ 必将增加</li>
<li>若转入else分支，尽管$i$不变，但在赋值$j=next[j]$之后$j$必然减小，所以$k=2i-j$必然增加</li>
</ul>
<p>纵观算法的整个过程，启动时有$i=j=0$,即$k=0$,算法结束时$i\leq n$且$j \geq 0$，故有$k\leq 2n$。在此期间尽管$k$从0开始持续地递增，但累计增幅不过$2n$,故while循环至多执行$2n$轮。另外,while()循环体内部不含有任何循环和扽之调用，故只需$O(1)$时间。也就是说，尽管可能有$\Omega(n)$对齐位置，但就分摊意义而言，在每一对齐位置仅需$O(1)$次比对。</p>
<p>next表的构造算法与KMP算法并无本质区别，所以仿照上述分析可知，next表的构造算法仅需$O(m)$时间。综上可知，KMP算法的总体运行时间为$O(n+m)$。</p>
<p>特别适用于顺序存储介质，在单次匹配概率越大的场合，优势越明显，否则，与蛮力算法的性能相差无几。</p>
<p>在算法执行过程中：</p>
<ul>
<li>观察量$i$始终等于已经做过的成功比对次数(含最左端虚拟通配符的比对)次数</li>
<li>观察量$i-j$始终不小于已经做过的失败比对次数</li>
</ul>
<p>循环中if判断的两个分支，分别对应于成功和失败比对。其中，只有成功的比对会修改i,即i加一，当且仅当当前的比对是成功的。考虑到i初始值始终为0，始终等于成功比对的次数。</p>
<p>观察量i-j的初始值也是0。对于成功分支，变量i和j会同时递增一个单位，故$i-j$的数值将保持不变。而在失败分支中，观察量i不变，另一方面，必有$next[j]&lt;j$，故在变量$j$替换为$next[j]$之后，观察量$i-j$亦必严格单调地增加。综合以上两种情况，观察量$i-j$必然可以作为失败次数的上界。</p>
<p>成功比对次数和失败比对次数之和即为所有比较次数。</p>
<h2 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h2><p>尽管以上KMP算法可保证线性的运行时间，但在某些情况下仍然有优化的余地。</p>
<p>考查模式串P=”000010”</p>
<p><img src="https://i.loli.net/2019/09/10/6BhE1GOXm3dAULb.png"></p>
<p>实际上，即便说$P[3]$与$T[3]$的比较还算必然，后续的这三次对比却都是不必要的，它们的失败结果早已注定。</p>
<p>在之前的next表中，我们利用了以往成功比对所提供的信息，将记忆力转化为预知力，但是失败比对的教训却被忽略了。</p>
<p>为了吸取教训，将集合$N[P,j)$的定义修改为：</p>
<p>$N(P,j)=\left{ 0\leq t&lt;j|P[0,t)=P[j-t,j)\right}$ 且$P[t]!=P[j]$</p>
<p>除对应于自匹配长度外，$t$只有还满足当前字符对不匹配的条件方能归入集合$N[P,j)$并作为next表项的候选。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildNext</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造模式串P的next表（改进版本）</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//“主”串指针</span></span><br><span class="line">   <span class="keyword">int</span>* N = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//next表</span></span><br><span class="line">   <span class="keyword">int</span> t = N[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m - <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; t || P[j] == P[t] ) &#123; <span class="comment">//匹配</span></span><br><span class="line">         N[j] = ( P[++j] != P[++t] ? t : N[t] ); <span class="comment">//注意此句与未改进之前的区别</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//失配</span></span><br><span class="line">         t = N[t];</span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h1><p>KMP算法的思路可概括为：当前比对一旦失配。即利用此前的比对(无论成功或失败)所提供的信息，尽可能长距离地移动模式串。无需显式地反复保存或更新比对的历史，而是独立于具体的文本串，事先根据模式串预测出所有可能出现的失配情况。</p>
<p>串匹配过程为多次失败的对齐和0/1次成功的对齐。就单个对齐位置的排除而言，平均只需常数次比对，且具体的比对位置和次序无所谓。然而就排除更多后续位置而言，不同的对比位置及次序，作用差异极大。其中，越是靠前/后的位置，作用越小/大。</p>
<p>BM算法中，模式串P与文本串T的对准位置依然自左向右推移，而在每一对准位置却是自右向左地逐一比对各个字符。在每一轮自右向左的比对过程中，一旦发现失配，则将P右移一定距离并再次与T对准，然后重新一轮自右向左的扫描比对。</p>
<p>BM算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//Boyer-Morre算法（完全版，兼顾Bad Character与Good Suffix）</span></span><br><span class="line">   <span class="keyword">int</span>* bc = buildBC ( P ); <span class="keyword">int</span>* gs = buildGS ( P ); <span class="comment">//构造BC表和GS表</span></span><br><span class="line">   <span class="keyword">size_t</span> i = <span class="number">0</span>; <span class="comment">//模式串相对于文本串的起始位置（初始时与文本串左对齐）</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="built_in">strlen</span> ( T ) &gt;= i + <span class="built_in">strlen</span> ( P ) ) &#123; <span class="comment">//不断右移（距离可能不止一个字符）模式串</span></span><br><span class="line">      <span class="keyword">int</span> j = <span class="built_in">strlen</span> ( P ) - <span class="number">1</span>; <span class="comment">//从模式串最末尾的字符开始</span></span><br><span class="line">      <span class="keyword">while</span> ( P[j] == T[i + j] ) <span class="comment">//自右向左比对</span></span><br><span class="line">         <span class="keyword">if</span> ( <span class="number">0</span> &gt; --j ) <span class="keyword">break</span>; <span class="comment">/*DSA*/</span>showProgress ( T, P, i, j ); <span class="built_in">printf</span> ( <span class="string">&quot;\n&quot;</span> ); getchar();</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; j ) <span class="comment">//若极大匹配后缀 == 整个模式串（说明已经完全匹配）</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//返回匹配位置</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则，适当地移动模式串</span></span><br><span class="line">         i += __max ( gs[j], j - bc[ T[i + j] ] ); <span class="comment">//位移量根据BC表和GS表选择大者</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">delete</span> [] gs; <span class="keyword">delete</span> [] bc; <span class="comment">//销毁GS表和BC表</span></span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中借助了整数i和j指示文本串中当前对齐位置T[i]和模式串中接受比对的字符P[j]。不过，一旦局部失配，根据bc表和gs表确定最大的安全移动距离。为此，需要通过预处理，根据模式串P整理出坏字符和好后缀两类信息。</p>
<h2 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h2><p>若当前模式串P当前在文本串中的对齐位置为i，且在这一轮自右向左将P和substr(T,i,m)的比对过程中，在P[j]处首次发现失配：$T[i+j] =X \neq Y=P[j]$，则将$X$称为坏字符。</p>
<p>若P与T的某一子串(包括$T[i+j]$在内)匹配，则必然在$T[i+j]=X$中匹配，反之，若与$T[i+j]$对准的字符不是X,则必然失配。只需找出P中的每一字符X，分别与$T[i+j]=X$对准，并执行一轮从右向左的扫描比对。对应每个这样的字符，P的位移量仅取决于原来失配位置$j$，以及$X$在P中的秩，而与$T$和$i$​无关。</p>
<p><strong>bc表</strong></p>
<p>若P中含有多个X,仅尝试p中最靠右的字符X(若存在)。如此可在确保不致遗漏匹配的前提下，始终单向地滑动模式串。若P中最靠右的字符X为$P[k]=X$,则P的右移量为$j-k$。</p>
<p>对于任一给定的模式串P，$k$值只取决于字符$T[i+j]=X$,因此可视为从字符表到整数(P中字符的秩)的一个函数</p>
<p>$bc(x)=$</p>
<ul>
<li>$k$，若$P[k]=x$,且对所有的$i&gt;k$都有$p[i]!=c$</li>
<li>$-1$,若P中不含字符$c$</li>
</ul>
<p>若当前对齐位置为$i$，则一旦出现坏字符$P[j]=Y$,则重新对齐于$i+=j-bc[T[i+j]]$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//*****************************************************************************************</span></span><br><span class="line"><span class="comment">//    0                       bc[&#x27;X&#x27;]                                m-1</span></span><br><span class="line"><span class="comment">//    |                       |                                      |</span></span><br><span class="line"><span class="comment">//    ........................X***************************************</span></span><br><span class="line"><span class="comment">//                            .|&lt;------------- &#x27;X&#x27; free ------------&gt;|</span></span><br><span class="line"><span class="comment">//*****************************************************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildBC</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造Bad Charactor Shift表：O(m + 256)</span></span><br><span class="line">   <span class="keyword">int</span>* bc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//BC表，与字符表等长</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j ++ ) bc[j] = <span class="number">-1</span>; <span class="comment">//初始化：首先假设所有字符均未在P中出现</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; j &lt; m; j ++ ) <span class="comment">//自左向右扫描模式串P</span></span><br><span class="line">      bc[ P[j] ] = j; <span class="comment">//将字符P[j]的BC项更新为j（单调递增）——画家算法</span></span><br><span class="line">   <span class="comment">/*DSA*/</span>printBC ( bc );</span><br><span class="line">   <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法在对BC表初始化后，对模式串做一遍线性扫描，并不断用当前字符的秩更新BC表中的对应项。因为是按照秩递增的顺序从左到右扫描，所以只要c在P中出现过，则最终的BC表将记录下其中最靠右的秩。</p>
<p>运行时间可划分为两个部分，分别消耗于其中的两个循环，前者是对字符表中每个字符进行初始化，时间不超过$O(|\sum|)$ 。后一循环对模式串P做一轮扫描，其中每个字符消耗$O(1)$时间，故共需$O(m)$时间。由此可知，BC表可在$O(|\sum|+m)$时间内构造出来，其中$|\sum|$为字符表的规模，m为模式串的长度。</p>
<p>暂且不计构造BC表的过程，BM算法本身进行串模式匹配所需时间与具体的输入十分相关。若将文本串和模式串的长度分别记作n和m，则在通常情况下实际运行时间往往低于$O(n)$。在最好情况下，每经过常数次比对就可以将模式串整体向右移动m个字符，此类情况下只需$O(n/m)$次比对算法即可终止，故运行时间不过$ O(n/m)$。</p>
<p>在最坏情况下，每轮迭代都需要在扫过整个P之后，方能确定右移一个字符，须经过m次比较，方能排除单个对齐位置，时间复杂度为$ O(nm) $。</p>
<p>单次匹配概率越大的场合，性能越接近蛮力算法。</p>
<p>针对坏字符在模式串中的位置太过于靠右，以至位移量为负的情况，建议将P右移一个字符，此后并不能保证坏字符出恢复匹配，可在P[j]的左侧找到最靠右的字符并将其与原坏字符对齐。</p>
<p>以上思路的实现方式等效于将原来一维的bc表，替换为二维的bc表，具体地，这是一张m*$|\sum|$ 的表格。尽管预处理时间和所需空间增长量并不大，但是匹配算法的控制流程却进一步复杂化。最重要的是，此类二维bc表若能发挥作用，则当时的好后缀必然很长，此类情况同时使用的gs表必然可以代替bc表。</p>
<h2 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h2><p>参照KMP算法的思路，坏字符策略仅仅利用了此前失败比对所提供的教训而忽视了成功的比对。类似于KMP算法，只不过前后颠倒而已。</p>
<p>每轮比对中的若干次成功匹配，都对应于模式串P的一个后缀，称为好后缀(good suffix)。</p>
<p>一般地，设本轮自右向左的扫描匹配终止于失配位置：</p>
<p>$T[i+j]=X \neq Y=P[j]$</p>
<p>若分别记</p>
<p>$W=substr(T,i+j+1,m-j-1)=T[i+j+1,m+i)$</p>
<p>$U=suffix(P,m-j-1)=P[j+1,m)$</p>
<p>则$U$为当前的好后缀，$W$为$T$中与之匹配的子串。好后缀的长度为m-j-1,故只要$j\leq m-2$,则$U$必然非空，$U=W$。</p>
<p>此时若存在某一整数，使得在将P整体右移j-k个单元，并使$P[k]$与$T[i+j]$相互对齐之后，$P$可以与文本串的某一子串(包括$T[m+j-1]$在内)匹配，亦即</p>
<p>$P=substr(T,i+j-k,m)=T[i+j-k,m+i+j-k)$</p>
<p>于是，若记：</p>
<p>$V(k)=substr(P,k+1,m-j-1)=P[k+1,m-j+k)$</p>
<p>必然有$V(k)=W=U$</p>
<p>也就是说，若值得将$P[k]$与$T[i+j]$对齐并做新的一轮比对，则P的子串首先必须和P自己的后缀U相匹配。</p>
<p>另外，还有一必要条件，P中这两个匹配的子串的前驱字符不得相等，即P[k]$\neq$ P[j],与之前类似，在此处必将再次失败。</p>
<p>若模式串存在多个满足上述必要条件的子串V(k),不妨选取其中最靠右者(对应最大的$k$,最小的右移距离$j-k$)。</p>
<p>若P中不存在任何子串与U完全匹配，则从P的所有前缀中，找出可与U的某一真后缀相匹配的最长者作为V(k)，并取$gs[j]=m-|V(k)|$。</p>
<p>与之前类似，位移量只取决于$j$和$P$本身，亦可预先计算并制表待查。</p>
<p><strong>gs表</strong></p>
<blockquote>
<p>蛮力算法</p>
</blockquote>
<p>根据以上定义，可导出gs表构造算法如下：</p>
<p>对于每个好后缀$P(j,m)$，按照从后向前($k$从$j-1$递减至0)的次序，将其与P的每个子串$P(k,m+k-j)$一一对齐，并核对是否出现匹配，一旦出现，对应的位移量即为$gs[j]$的取值。</p>
<p>这里共有$O(m)$个好后缀，可与$O(m)$个子串相互对齐，每次对齐后在最坏情况下需要比对$O(m)$次，因此该算法可能需要$O(m^3)$次。</p>
<p>实际上，仅需线性时间即可构造出gs表。</p>
<p><strong>ss表</strong></p>
<p>对于任一整数$j\in[0,m)$,在$P[0,j]$的所有后缀中，考查那些与P的某一后缀匹配者。若将其中最长者记作MS[j]，则$ss[j]$就是该串的长度$|MS[j]|$.特别地，在$MS[j]$不存在时，取$ss[j]=0$。</p>
<p>综上所述，可定义$ss[j]$如下：</p>
<p>$ss[j]=max{ 0\leq s\leq  j+1|P(j-s,j]=P[m-s,m)}$</p>
<p>特别地，当$j=m-1$时，必有$s=m$，此时，有$P(-1,m-1]=P[0,m)$</p>
<p>任一字符$P[j]$对应的$ss[j]$值，可分两种情况提供有效的信息：</p>
<ul>
<li>$ss[j]=j+1$ 也就是说MS[j]就是整个前缀，后缀长度应该大于$j+1$，所以此时对应于$P[m-j-1]$左侧的每个字符$P[i]$而言，$P[m-1]$下一步可与$P[j]$对齐，所以$m-j-1$都应是$gs[i]$取值的一个候选。</li>
<li>$ss[j] \leq j MS[j]$只是$P[0,j]$的一个真后缀。同时，既然$MS[j]$是极长的，故必有：$P[m-ss[j]-1]\neq P[j-ss[j]]$ ,此时的字符$m-j-1$也应是$gs[m-ss[j]-1]$取值的一个候选</li>
</ul>
<p>根据此前定义，每一位置i所对应的gs[i]值只可能来自于以上候选。</p>
<p><strong>ss表的构造</strong></p>
<p>由上可见，ss表的确是构造gs表的基础和关键，同样，若采用蛮力策略，则对每个字符$P[j]$都需要做一趟扫描对比，直到出现失配。如此，累计需要$O(m)$时间。</p>
<p>为了提高效率，不妨从后至前逆向扫描，并逐一地计算出各字符$P[j]$对应的$ss[j]$的值。</p>
<p>通过$lo,hi$来动态记录当前的极长匹配后缀：$P(lo,hi]=P[m-hi+lo,m)$</p>
<p>此时必有$P[j]=P[m-hi+j-1]$,故可利用此前已经计算的$ss[m-hi+j-1]$，分两种情况快速得导出$ss[j]$</p>
<ul>
<li>如图(a)所示，$ss[m-hi+j-1]\leq j-lo$,此时，$ss[m-hi+j-1]$也是$ss[j]$可能的最大取值，可直接得到$ss[j]=ss[m-hi+j-1]$。</li>
<li>如图(b)所示，$j-lo&lt;ss[m-hi+j-1]$，此时，至少仍有$P(lo,j]=P[m-hi+lo,m-hi+j)$,故只需将$p[j-ss[m-hi+j-1],lo]$与$P[m-hi+j-ss[m-hi+j-1],m-hi+lo]$做一比对，也可确定$ss[j]$。</li>
</ul>
<p><img src="https://i.loli.net/2019/09/11/JhYefNSm7dsBGEM.png"></p>
<p>由以上构思，可在$O(m)$时间内构造出ss表。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildSS</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造最大匹配后缀长度表：O(m)</span></span><br><span class="line">   <span class="keyword">int</span> m = <span class="built_in">strlen</span> ( P ); <span class="keyword">int</span>* ss = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//Suffix Size表</span></span><br><span class="line">   ss[m - <span class="number">1</span>]  =  m; <span class="comment">//对最后一个字符而言，与之匹配的最长后缀就是整个P串</span></span><br><span class="line"><span class="comment">// 以下，从倒数第二个字符起自右向左扫描P，依次计算出ss[]其余各项</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> lo = m - <span class="number">1</span>, hi = m - <span class="number">1</span>, j = lo - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line">      <span class="keyword">if</span> ( ( lo &lt; j ) &amp;&amp; ( ss[m - hi + j - <span class="number">1</span>] &lt;= j - lo ) ) <span class="comment">//情况一</span></span><br><span class="line">         ss[j] =  ss[m - hi + j - <span class="number">1</span>]; <span class="comment">//直接利用此前已计算出的ss[]</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//情况二</span></span><br><span class="line">         hi = j; lo = __min ( lo, hi );</span><br><span class="line">         <span class="keyword">while</span> ( ( <span class="number">0</span> &lt;= lo ) &amp;&amp; ( P[lo] == P[m - hi + lo - <span class="number">1</span>] ) ) <span class="comment">//二重循环？</span></span><br><span class="line">            lo--; <span class="comment">//逐个对比处于(lo, hi]前端的字符</span></span><br><span class="line">         ss[j] = hi - lo;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂且忽略内循环，首先考查外循环，若将j作为其控制变量，则不难验证</p>
<ol>
<li>$j$的初始值为$m-2$</li>
<li>每经过一步迭代，$j$都会递减一个单位</li>
<li>在其他任何语句中，$j$都没有作为左值被修改</li>
<li>一旦$j$减至负数，外循环随即终止</li>
</ol>
<p>由此可知，外循环至多迭代$O(m)$步，累计耗时$O(m)$。</p>
<p>尽管从表面的形式来看，外循环的每一步都有可能执行一趟内循环，但实际上所有的内循环累计运行时间也不超过$O(m)$。为此，只需将lo视为其控制变量，则不难验证：</p>
<ol>
<li>$lo$的初始值为$m-1$</li>
<li>每经过一步内循环的迭代，$lo$值都会递减一个单位</li>
<li>在其他部分，$lo$只能在<code>lo=__min ( lo, hi )</code> 一句中作为左值被修改，但仍是非增</li>
<li>一旦$lo$减至负数，内循环就不再启动</li>
</ol>
<p>由此可知，内循环至多迭代$O(m)$步，相应地，累计耗时不过$O(m)$。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildGS</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造好后缀位移量表：O(m)</span></span><br><span class="line">   <span class="keyword">int</span>* ss = buildSS ( P ); <span class="comment">//Suffix Size table</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ); <span class="keyword">int</span>* gs = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//Good Suffix shift table</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m; j ++ ) gs[j] = m; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; j &lt; UINT_MAX; j -- ) <span class="comment">//逆向逐一扫描各字符P[j]</span></span><br><span class="line">      <span class="keyword">if</span> ( j + <span class="number">1</span> == ss[j] ) <span class="comment">//若P[0, j] = P[m - j - 1, m)，则</span></span><br><span class="line">         <span class="keyword">while</span> ( i &lt; m - j - <span class="number">1</span> ) <span class="comment">//对于P[m - j - 1]左侧的每个字符P[i]而言（二重循环？）</span></span><br><span class="line">            gs[i++] = m - j - <span class="number">1</span>; <span class="comment">//m - j - 1都是gs[i]的一种选择</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j ++ ) <span class="comment">//画家算法：正向扫描P[]各字符，gs[j]不断递减，直至最小</span></span><br><span class="line">      gs[m - ss[j] - <span class="number">1</span>] = m - j - <span class="number">1</span>; <span class="comment">//m - j - 1必是其gs[m - ss[j] - 1]值的一种选择</span></span><br><span class="line">   <span class="keyword">delete</span> [] ss; <span class="keyword">return</span> gs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以j为外循环的控制变量，则可知外循环至多迭代$O(m)$步，以i作为内循环的控制变量，可知内循环累计至多迭代$O(m)$步，累计耗时$O(m)$。</p>
<p>在模式枚举类应用中，需要从文本串T中找出所有的模式串P，有时允许两次出现的位置不超过m个字符。比如在000000中查找000，若限制多次出现的模式串之间至少相距3个字符，则应找到2处匹配，若不加以限制，则应找到4处匹配。在这种情况下，最坏情况下复杂度可能达到$O(nm)$。</p>
<p>可通过Galil规则对上述情况改进，总体耗时不致于超过线性的规模。</p>
<h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><p>空间复杂度为$|bc[]|+|gs[]|=O(|\sum|+m)$</p>
<p>预处理的时间为$O(|\sum|+m)$</p>
<p>查找在最好情况下为$O(n/m)$，最差情况下为$O(n+m)$</p>
<p>在通常情况下，单次比对的成功概率直接取决于字符集的规模。当字符集规模较小时，单次比对的成功概率较高，蛮力算法的效率低。此时，KMP算法稳定的线性复杂度更能体现出优势，而采用BC表的BM算法并不能大跨度地向前移动。</p>
<p>反之，若字符串的规模较大，则单词比对的成功概率较小，蛮力算法也可接近线性复杂l度，此时，尽管KMP算法仍然保持线性复杂度，但相对而言的优势并不明显，而采用BC表的BM算法则会因为比对失败概率的增加，从而大跨度地向前移动。</p>
<table>
<thead>
<tr>
<th></th>
<th>最好情况</th>
<th>最坏情况</th>
<th>特点l</th>
</tr>
</thead>
<tbody><tr>
<td>蛮力算法</td>
<td>$ O(n)$</td>
<td>$ O( nm )$</td>
<td>适用于规模较大的字符集，通常情况下实际运行效率不低</td>
</tr>
<tr>
<td>KMP算法</td>
<td>$ O(n+m)$</td>
<td>$O(n+m)$</td>
<td>适用于规模较小的字符集，字符集规模较大时与蛮力算法不相上下</td>
</tr>
<tr>
<td>BM算法(bc)</td>
<td>$O(n/m )$</td>
<td>$O( nm)$</td>
<td>适用于规模较大的字符集，性能浮动范围大</td>
</tr>
<tr>
<td>BM算法(bc+gs)</td>
<td>$O(n/m)$</td>
<td>$ O(n+m)$</td>
<td>四种算法中最优</td>
</tr>
</tbody></table>
<h1 id="Karp-rabin算法"><a href="#Karp-rabin算法" class="headerlink" title="Karp-rabin算法"></a>Karp-rabin算法</h1><p>将任一有限字符串视作自然数，进而在字符串和自然数之间建立联系。若字符串规模$|\sum|$ 对应于一个$d+1$进制的整数。</p>
<p>以由大写英文字母组成的字母表为例，若将这些字符表依次映射为[1,26]内的自然数，则每个这样的字符串都将对应于一个26+1=27进制的整数，比如：</p>
<p>$CANTOR \leq 3,1,14,20,15,18\geq43,868,727(10)$</p>
<p>以上散列并非满射，但是不含’0’的任一$d+1$进制值自然数，唯一地对应于某个字符串。字符串经如此转换得到的散列码，称为其指纹。之所以取$d+1$而不是$d$，是为了回避’0’字符以保证这一映射为单射，否则若字符串中存在由’0’字符组成的前缀，则无论该前缀长度如何，都不会影响对应的整数取值。</p>
<p>由此可将判断模式串是否与文本匹配的问题转换为判断T中是否由某个子串相同的指纹的问题，具体地，只要逐一取出T中长度为m的子串，并将其对应的指纹与P所对应的指纹一一比对即可确定是否存在匹配位置，称为karp-robin算法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Karp-Rabin）</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), n = <span class="built_in">strlen</span> ( T ); <span class="comment">//assert: m &lt;= n</span></span><br><span class="line">   HashCode Dm = prepareDm ( m ), hashP = <span class="number">0</span>, hashT = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++ ) &#123; <span class="comment">//初始化</span></span><br><span class="line">      hashP = ( hashP * R + DIGIT ( P, i ) ) % M; <span class="comment">//计算模式串对应的散列值</span></span><br><span class="line">      hashT = ( hashT * R + DIGIT ( T, i ) ) % M; <span class="comment">//计算文本串（前m位）的初始散列值</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> k = <span class="number">0</span>; ; ) &#123; <span class="comment">//查找</span></span><br><span class="line">      <span class="keyword">if</span> ( hashT == hashP ) </span><br><span class="line">         <span class="keyword">if</span> ( check1by1 ( P, T, k ) ) <span class="keyword">return</span> k;</span><br><span class="line">      <span class="keyword">if</span> ( ++k &gt; n - m ) <span class="keyword">return</span> k; <span class="comment">//assert: k &gt; n - m，表示无匹配</span></span><br><span class="line">      <span class="keyword">else</span> updateHash ( hashT, T, m, k, Dm ); <span class="comment">//否则，更新子串散列码，继续查找</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法除了预先计算模式串指纹hash(P)等预处理，至多包含$|T|-|P|=n-m$次迭代，每轮都需计算当前子串的指纹。</p>
<p>然而，若字符集规模较大，模式串P较长，其对应的指纹将很大。若指纹的长度无法在常数时间内完成，总体需要$O(nm)$时间。</p>
<h2 id="散列压缩"><a href="#散列压缩" class="headerlink" title="散列压缩"></a>散列压缩</h2><p>通过对比压缩后的指纹，确定匹配位置，借助散列将指纹压缩至存储器支持的范围。比如，采用模余函数：$hash(key)=key % M$</p>
<p>经过散列压缩后指纹比对的时间将仅取决于散列表长，而与模式串长m无关。</p>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>hash()值相等，并非匹配的充分条件，压缩散列空间的时候必然引起冲突。文本串中不同子串的指纹可能相同，甚至都恰好与模式串相同。因此，通过hash()筛选之后，还须经过严格比对，方可确定是否匹配。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check1by1</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T, <span class="keyword">size_t</span> i )</span> </span>&#123; <span class="comment">//指纹相同时，逐位比对以确认是否真正匹配</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; j &lt; m; j++, i++ ) <span class="comment">//尽管需要O(m)时间</span></span><br><span class="line">      <span class="keyword">if</span> ( P[j] != T[i] ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//但只要散列得当，调用本例程并返回false的概率将极低</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适当选取散列函数可大大降低冲突的可能。</p>
<h2 id="指纹更新"><a href="#指纹更新" class="headerlink" title="指纹更新"></a>指纹更新</h2><p>可根据前一子串和后一子串的指纹，在常数时间内得到后一子串的指纹。整个算法过程中，消耗与子串计算的时间，平均每次仅为常数时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子串指纹快速更新算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHash</span> <span class="params">( HashCode&amp; hashT, <span class="keyword">char</span>* T, <span class="keyword">size_t</span> m, <span class="keyword">size_t</span> k, HashCode Dm )</span> </span>&#123;</span><br><span class="line">   hashT = ( hashT - DIGIT ( T, k - <span class="number">1</span> ) * Dm ) % M; <span class="comment">//在前一指纹基础上，去除首位T[k - 1]</span></span><br><span class="line">   hashT = ( hashT * R + DIGIT ( T, k + m - <span class="number">1</span> ) ) % M; <span class="comment">//添加末位T[k + m - 1]</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &gt; hashT ) hashT += M; <span class="comment">//确保散列码落在合法区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HashCode <span class="title">prepareDm</span> <span class="params">( <span class="keyword">size_t</span> m )</span> </span>&#123; <span class="comment">//预处理：计算R^(m - 1) % M （仅需调用一次，不必优化）</span></span><br><span class="line">   HashCode  Dm = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; m; i++ ) Dm = ( R * Dm ) % M; <span class="comment">//直接累乘m - 1次，并取模</span></span><br><span class="line">   <span class="keyword">return</span> Dm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>trinkle
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://twinkle0331.github.io/algorithm/string/" title="串">http://twinkle0331.github.io/algorithm/string/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Data-structure/" rel="tag"><i class="fa fa-tag"></i> Data structure</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/algorithm/pq/" rel="prev" title="优先级队列">
                  <i class="fa fa-chevron-left"></i> 优先级队列
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/algorithm/sorting/" rel="next" title="排序算法">
                  排序算法 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">trinkle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  <script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'none'
      },
      options: {
        renderActions: {
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              const target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js';
    script.defer = true;
    document.head.appendChild(script);
  } else {
    MathJax.startup.document.state(0);
    MathJax.typesetClear();
    MathJax.texReset();
    MathJax.typeset();
  }
</script>



</body>
</html>
