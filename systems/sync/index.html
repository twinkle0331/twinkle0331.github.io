<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"twinkle0331.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="进程并发执行可提高程序效率，但是并发执行过程是不确定性和不可重现的。在进程间有共享资源，而处理过程并不是整体执行，所以会存在和预期不一致的问题。借助生活中同步问题例子，我们设计了一系列方案并进行改进。">
<meta property="og:type" content="article">
<meta property="og:title" content="同步互斥">
<meta property="og:url" content="http://twinkle0331.github.io/systems/sync/index.html">
<meta property="og:site_name" content="trinkle">
<meta property="og:description" content="进程并发执行可提高程序效率，但是并发执行过程是不确定性和不可重现的。在进程间有共享资源，而处理过程并不是整体执行，所以会存在和预期不一致的问题。借助生活中同步问题例子，我们设计了一系列方案并进行改进。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2019/07/28/5d3d900c63a4430295.png">
<meta property="og:image" content="https://i.loli.net/2019/07/28/5d3d93271b56569969.png">
<meta property="og:image" content="https://i.loli.net/2019/07/28/5d3d96879981251704.png">
<meta property="og:image" content="https://i.loli.net/2019/07/28/5d3d97cd6d88056269.png">
<meta property="og:image" content="https://i.loli.net/2019/07/28/5d3da73e6bb3695538.png">
<meta property="article:published_time" content="2019-07-06T00:36:58.000Z">
<meta property="article:modified_time" content="2021-03-27T13:17:35.000Z">
<meta property="article:author" content="trinkle">
<meta property="article:tag" content="Operating Systems">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2019/07/28/5d3d900c63a4430295.png">


<link rel="canonical" href="http://twinkle0331.github.io/systems/sync/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>同步互斥 | trinkle</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="trinkle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">trinkle</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://twinkle0331.github.io/systems/sync/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trinkle">
      <meta itemprop="description" content="Stay foolish,stay hungry.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="trinkle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          同步互斥
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-06 08:36:58" itemprop="dateCreated datePublished" datetime="2019-07-06T08:36:58+08:00">2019-07-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Systems/" itemprop="url" rel="index"><span itemprop="name">Systems</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p> 进程并发执行可提高程序效率，但是并发执行过程是不确定性和不可重现的。在进程间有共享资源，而处理过程并不是整体执行，所以会存在和预期不一致的问题。借助生活中同步问题例子，我们设计了一系列方案并进行改进。</p>
<a id="more"></a>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="并发进程的正确性"><a href="#并发进程的正确性" class="headerlink" title="并发进程的正确性"></a>并发进程的正确性</h2><blockquote>
<p>程序正确性</p>
</blockquote>
<p>程序执行的结果是实现预期的功能，并且是确定的和可重现的</p>
<p>并发进程执行过程是不确定性和不可重现的，程序错误可能是间歇性发生的</p>
<ul>
<li>独立进程<ul>
<li>不和其他进程共享资源或状态</li>
<li><strong>确定性</strong> 输入状态决定结果</li>
<li><strong>可重现</strong> 能够重现起始条件</li>
<li>调度顺序不重要</li>
</ul>
</li>
<li>并发进程<ul>
<li>在多个进程间有资源共享</li>
<li>不确定性</li>
<li>不可重现</li>
</ul>
</li>
</ul>
<h2 id="进程并发执行的优点"><a href="#进程并发执行的优点" class="headerlink" title="进程并发执行的优点"></a>进程并发执行的优点</h2><p>进程需要与计算机中其他进程或设备进行协作</p>
<p><strong>共享资源</strong> </p>
<ul>
<li>多个用户共用一台计算机</li>
</ul>
<p><strong>加速</strong></p>
<ul>
<li>I/O操作和CPU计算可以并行</li>
<li>程序可划分成多个模块放在多个处理机上并行执行</li>
</ul>
<p><strong>模块化</strong></p>
<ul>
<li>将大程序分解成小程序，使系统易于复用和扩展</li>
</ul>
<h2 id="并发执行的问题"><a href="#并发执行的问题" class="headerlink" title="并发执行的问题"></a>并发执行的问题</h2><p>以并发执行创建新进程时的标识分配为例子，</p>
<p>调用函数<code>fork()</code>来创建一个新的进程（操作系统需要分配一个新的并且唯一的进程ID）</p>
<p>在内核中，这个系统调用会执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_pid &#x3D; next_pid++</span><br></pre></td></tr></table></figure>
<p>假定<code>next_pid</code>为100</p>
<p><strong>预期结果</strong></p>
<ul>
<li>一个进程ID为100</li>
<li>另一个进程ID为101</li>
<li><code>next_pid</code>应该增加到102</li>
</ul>
<p><strong>实际可能结果</strong></p>
<p><img src="https://i.loli.net/2019/07/28/5d3d900c63a4430295.png"></p>
<p>进程A和进程B的寄存器相互独立，失败原因：二者处理过程并不是整体执行</p>
<h2 id="原子操作-Atomic-Operation"><a href="#原子操作-Atomic-Operation" class="headerlink" title="原子操作(Atomic Operation)"></a>原子操作(Atomic Operation)</h2><p>一次不存在任何中断或失败的操作 </p>
<ul>
<li>要么操作成功完成 </li>
<li>要么操作没有执行</li>
</ul>
<p>不存在部分执行的状态</p>
<p>操作系统需要利用同步机制在并发执行的同时，保证一些操作是原子操作</p>
<h1 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h1><h2 id="现实生活中的同步问题"><a href="#现实生活中的同步问题" class="headerlink" title="现实生活中的同步问题"></a>现实生活中的同步问题</h2><table>
<thead>
<tr>
<th>时间</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody><tr>
<td>3：00</td>
<td>查看冰箱，没有面包了</td>
<td></td>
</tr>
<tr>
<td>3：05</td>
<td>离开家去商店</td>
<td></td>
</tr>
<tr>
<td>3：10</td>
<td>到达商店</td>
<td>查看冰箱，没有面包了</td>
</tr>
<tr>
<td>3：15</td>
<td>购买面包</td>
<td>离开家去商店</td>
</tr>
<tr>
<td>3：20</td>
<td>到家，把面包放进冰箱</td>
<td>到达商店</td>
</tr>
<tr>
<td>3：25</td>
<td></td>
<td>购买面包</td>
</tr>
<tr>
<td>3：30</td>
<td></td>
<td>到家，把面包放进冰箱</td>
</tr>
</tbody></table>
<p><strong>家庭采购问题的分析</strong></p>
<ul>
<li>有人去买面包</li>
<li>最多只有一个人买</li>
</ul>
<p>可能的解决办法：</p>
<ul>
<li>在冰箱上设置一个钥匙</li>
<li>去买面包之前锁住冰箱并且拿走钥匙</li>
</ul>
<p><strong>加锁导致的问题</strong></p>
<p>冰箱中还有其他食物时，别人无法取到</p>
<blockquote>
<p>方案一</p>
</blockquote>
<p>使用便签来避免购买太多面包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if(noBread) &#123;</span><br><span class="line">  if(noNote) &#123;</span><br><span class="line">    leave Note;</span><br><span class="line">    buy bread;</span><br><span class="line">    removen Note;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决方案只是间歇性的失败</strong></p>
<p>问题难以调试，生活中不会出现(无法察觉他人正在检查便签)</p>
<p>必须考虑调度器所做的事情</p>
<p><img src="https://i.loli.net/2019/07/28/5d3d93271b56569969.png"></p>
<p>进程A和进程B均检测到没有便签，都留下便签然后去买面包</p>
<blockquote>
<p>方案二</p>
</blockquote>
<p>先留便签，后检查面包和便签</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leave Note;</span><br><span class="line">if(noBread) &#123;</span><br><span class="line">  if(noNote) &#123;</span><br><span class="line">    buy bread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">remove bread;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/07/28/5d3d96879981251704.png"></p>
<p>进程A和进程B二者均留下便签，然而谁也不会去买面包</p>
<p>此时需要提及的一点是，方案二单进程运行也买不了面包，在检测标签的时候会检测到自己留下的标签，不会去买面包。</p>
<blockquote>
<p>方案三</p>
</blockquote>
<p>为便签增加标记，以区别不同人的便签，可在检查之前留便签</p>
<p>进程A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leave note_1;</span><br><span class="line">if (no note_2) &#123;</span><br><span class="line">   if (no bread) &#123; </span><br><span class="line">     buy bread; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line">remove note_1;</span><br></pre></td></tr></table></figure>
<p>进程B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leave note_2;</span><br><span class="line">if (no note_1) &#123;</span><br><span class="line">   if (no bread) &#123; </span><br><span class="line">     buy bread; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line">remove note_2;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/07/28/5d3d97cd6d88056269.png"></p>
<ul>
<li>二者均不会检查是否有面包，导致没有人去买面包</li>
<li>每个人检测到对方留下的便签以后都认为另外一个去买面包</li>
</ul>
<blockquote>
<p>方案四</p>
</blockquote>
<p>两者采用不同的处理流程</p>
<p>进程A</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">leave note_1;</span><br><span class="line">while(note_2) &#123;</span><br><span class="line">   do nothing;</span><br><span class="line">&#125; </span><br><span class="line">if(no bread)&#123;</span><br><span class="line">  buy bread;</span><br><span class="line">&#125;</span><br><span class="line">remove note_1;</span><br></pre></td></tr></table></figure>
<p>如果没有便签2,那么A可以去买面包，否则循环等待B直到离开</p>
<p>进程B</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">leave note_2;</span><br><span class="line">if(no note_1) &#123;</span><br><span class="line">   if(no bread)&#123;</span><br><span class="line">      buy bread; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line">remove note_2;</span><br></pre></td></tr></table></figure>
<p>如果没有便签1,那么B可以去买面包，否则B离开并且再试一次。</p>
<p>枚举所有可能后，可能确认有效。</p>
<p>分析</p>
<ul>
<li>它有效，但太复杂，难以验证有效性</li>
<li>A和B代码不同，每个进程的代码略有不同，更多进程的情况更为复杂</li>
<li>当A在等待时，它不能做其他事，这称为忙等待（busy-waiting）</li>
</ul>
<blockquote>
<p>方案五</p>
</blockquote>
<p>利用两个原子操作实现一个锁（lock），处理过程不会被打断</p>
<p><code>Lock.Acquire()</code></p>
<ul>
<li>在锁被释放前一直等待，然后获得锁</li>
<li>如果两个线程都在等待同一个锁，并且同时发现锁被释放了，那么只有一个能够获得锁</li>
</ul>
<p><code>Lock.Release()</code></p>
<ul>
<li>解锁并唤醒任何等待中的进程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">breadlock.Acquire(); &#x2F;&#x2F; 进入临界区</span><br><span class="line">if(noBread) &#123;</span><br><span class="line">  buy bread;</span><br><span class="line">&#125;</span><br><span class="line">breadlock.Release(); &#x2F;&#x2F; 退出临界区</span><br></pre></td></tr></table></figure>
<h2 id="进程的交叉关系"><a href="#进程的交叉关系" class="headerlink" title="进程的交叉关系"></a>进程的交叉关系</h2><table>
<thead>
<tr>
<th>相互感知的程序</th>
<th>交互关系</th>
<th>进程间的影响</th>
</tr>
</thead>
<tbody><tr>
<td>相互不感知(完全不了解其他进程的存在)</td>
<td>独立</td>
<td>一个进程的操作对其他进程的结果无影响</td>
</tr>
<tr>
<td>间接感知(双方都与第三方交互，如共享资源)</td>
<td>通过共享进行协作</td>
<td>一个进程的结果依赖于共享资源的状态</td>
</tr>
<tr>
<td>直接感知(双方直接交互，如通信)</td>
<td>通过通信进行协作</td>
<td>一个进程的结果依赖于从其他进程获得的信息</td>
</tr>
</tbody></table>
<p><strong>关系</strong>：</p>
<ol>
<li><strong>互斥（mutual exclusion）</strong>一个进程占用资源，其他进程不能使用</li>
<li><strong>死锁（deadlock）</strong>多个进程占用部分资源，形成循环等待</li>
<li><strong>饥饿（starvation）</strong> 其他进程可能轮流占用资源，一个进程一直得不到资源</li>
</ol>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>进程中访问临界资源的一段需要互斥执行的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">entry section</span><br><span class="line">  critical section</span><br><span class="line">exit section</span><br><span class="line">  remainder section</span><br></pre></td></tr></table></figure>
<p><strong>访问规则：</strong>(互斥访问)</p>
<ul>
<li><strong>空闲则入</strong></li>
<li><strong>忙则等待</strong> 有进程在临界区时，其他进程均不能进入临界区 </li>
<li><strong>有限等待</strong> 等待进入临界区的进程不能无限期等待(对等待时间有约定)</li>
<li><strong>让权等待（可选）</strong> 不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li>
</ul>
<p><strong>实现方法</strong>：</p>
<ol>
<li><strong>禁用中断</strong> 无法响应中断</li>
<li><strong>软件方法</strong> 共享变量协调，复杂</li>
<li><strong>更高级的抽象方法</strong> 借用操作系统服务来提供同步的服务(引入管理者)</li>
</ol>
<h2 id="禁用硬件中断同步方法"><a href="#禁用硬件中断同步方法" class="headerlink" title="禁用硬件中断同步方法"></a>禁用硬件中断同步方法</h2><p>没有中断，没有上下文切换，因此没有并发</p>
<ul>
<li>硬件将中断处理延迟到中断被启用之后</li>
<li>现代计算机体系结构都提供指令来实现禁用中断</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local_irq_save(unsigned long flags);</span><br><span class="line">critical section</span><br><span class="line">local_irq_restore(unsigned long flags);</span><br></pre></td></tr></table></figure>
<p>进入临界区：禁止所有中断，并保存标志<br>离开临界区：使能所有中断，并恢复标志</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>禁用中断后，进程无法被停止</li>
<li>可能导致其他进程没有执行机会，处于饥饿</li>
<li>临界区可能很长 无法确定响应中断的时间(可能存在硬件影响)</li>
<li>不得不用时使用</li>
</ul>
<h2 id="基于软件的同步方法"><a href="#基于软件的同步方法" class="headerlink" title="基于软件的同步方法"></a>基于软件的同步方法</h2><p>两个线程，T0和T1</p>
<p>线程Ti的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  enter section &#x2F;&#x2F; 进入区</span><br><span class="line">    critica sectio</span><br><span class="line">  exit section &#x2F;&#x2F;退出区</span><br><span class="line">    remainder section</span><br><span class="line">&#125;while(1);</span><br></pre></td></tr></table></figure>
<p>在进入区和退出区对变量修改来同步他们之间的行为。</p>
<p>线程可通过共享一些共有变量来同步他们的行为。</p>
<p><strong>第一次尝试</strong>(单标志法)</p>
<p>共享变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int turn &#x3D; 0;</span><br><span class="line">turn &#x3D; i; &#x2F;&#x2F; 表示允许进入临界区的线程ID</span><br></pre></td></tr></table></figure>
<p>线程Ti的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    while(turn !&#x3D; i) ; &#x2F;&#x2F; 不是i的话进入不了临界区</span><br><span class="line">    critical section</span><br><span class="line">    turn &#x3D; j;</span><br><span class="line">    remainder section</span><br><span class="line">&#125;while(1);</span><br></pre></td></tr></table></figure>
<p>该方案类似买面包方案四，同样有效。通过修改id交替进入，Ti不在临界区，Tj想要继续运行，但是必须等待Ti进入过临界区以后。满足“忙则等待”，但是有时不满足“空闲则入”</p>
<p><strong>第二次尝试</strong> (双标志法先检查)</p>
<p>先判断，后修改变量</p>
<p>共享变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int flag[2]; </span><br><span class="line">flag[0] &#x3D; flag[1] &#x3D; 0;</span><br><span class="line">flag[i] &#x3D;&#x3D; 1&#x2F;&#x2F;表示线程Ti是否在临界区</span><br></pre></td></tr></table></figure>
<p>线程Ti的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    while (flag[j] &#x3D;&#x3D; 1) ;</span><br><span class="line">    flag[i] &#x3D; 1;</span><br><span class="line">    critical section</span><br><span class="line">    flag[i] &#x3D; 0;	</span><br><span class="line">    remainder section</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure>
<p>对应买面包方案二，二者可能存在同时判断，同时设置，均进入临界区的情况，不满足“忙则等待”</p>
<p><strong>第三次尝试</strong>(双标志法后检查)</p>
<p>先修改变量，后判断</p>
<p>共享变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int flag[2]; </span><br><span class="line">flag[0] &#x3D; flag[1] &#x3D; 0;</span><br><span class="line">flag[i] &#x3D;&#x3D; 1&#x2F;&#x2F; 表示线程Ti想要进入临界区</span><br></pre></td></tr></table></figure>
<p>线程Ti的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    flag[i] &#x3D; 1;</span><br><span class="line">    while (flag[j] &#x3D;&#x3D; 1) ;</span><br><span class="line">    critical section</span><br><span class="line">    flag[i] &#x3D; 0;	</span><br><span class="line">    remainder section</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure>
<p>对应买面包的方案三，有可能谁都进入不了临界区，满足“忙则等待”，但是不满足“空闲则入”</p>
<blockquote>
<p>Peterson算法(双标志+单标志法)</p>
</blockquote>
<p>满足线程Ti和Tj之间互斥的经典的基于软件的解决方法（1981年）</p>
<p>先修改变量，后判断；后修改者等待；只适用于两个进程</p>
<p><strong>共享变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int turn;&#x2F;&#x2F;表示该谁进入临界区</span><br><span class="line">boolean flag[];&#x2F;&#x2F;表示进程是否准备好进入临界区</span><br></pre></td></tr></table></figure>
<p><strong>进入区代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">flag[i] &#x3D; true;</span><br><span class="line">turn &#x3D; j;&#x2F;&#x2F;写数据总有一前一后，不可能同时完成</span><br><span class="line">while (flag[j] &amp;&amp; turn &#x3D;&#x3D;j)</span><br></pre></td></tr></table></figure>
<p><strong>退出区代码</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag[i] &#x3D; false;</span><br></pre></td></tr></table></figure>
<p>线程Ti 的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">      flag[i] &#x3D; true;</span><br><span class="line">      turn &#x3D; j;</span><br><span class="line">      while ( flag[j] &amp;&amp; turn &#x3D;&#x3D; j);</span><br><span class="line">      CRITICAL SECTION</span><br><span class="line">      flag[i] &#x3D; false;</span><br><span class="line">      REMAINDER SECTION</span><br><span class="line">   &#125; while (true);</span><br></pre></td></tr></table></figure>
<p>j执行时i等待，退出后i可执行</p>
<p>piazza上给出了Peterson算法三个线程的反例</p>
<p>线程0，1，2</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">turn&#x3D;1，flag[1]&#x3D;false，flag[0] &#x3D; true，flag[2] &#x3D; true</span><br></pre></td></tr></table></figure>
<p>在线程T0和T2的peterson算法实现中，只要<code>flag[j]=true</code>和<code>turn=j</code>任意一个不满足，（理论上）T0，T2就可以进入临界区。由前面假设可得，<code>flag[1] = false</code>，此时<code>while(flag[j]&amp;&amp;turn==j)</code>不足以阻塞T0,T2，两个线程都满足进入临界区的条件，不满足临界区的“忙则等待”规则。</p>
<blockquote>
<p>Dekkers算法</p>
</blockquote>
<p>线程Ti 的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">flag[0]:&#x3D; false; flag[1]:&#x3D; false; turn:&#x3D; 0;&#x2F;&#x2F;or1 </span><br><span class="line">	</span><br><span class="line">do &#123;</span><br><span class="line">       flag[i] &#x3D; true;</span><br><span class="line">       while flag[j] &#x3D;&#x3D; true &#123; </span><br><span class="line">            if turn ≠ i &#123; </span><br><span class="line">               flag[i] :&#x3D; false </span><br><span class="line">               while turn ≠ i &#123; &#125; </span><br><span class="line">               flag[i] :&#x3D; true </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; </span><br><span class="line">        CRITICAL SECTION</span><br><span class="line">        turn :&#x3D; j</span><br><span class="line">        flag[i] &#x3D; false;</span><br><span class="line">        REMAINDER SECTION</span><br><span class="line">   &#125; while (true);</span><br></pre></td></tr></table></figure>
<p>判断复杂，i执行时发现j也想进入，turn此时不为i,则将i自己的标志位改为false，并等待turn修改为i再执行，便于扩展。</p>
<p>进入区：先修改flag，后判断是否有多个想进入；后修改者等待；<br>退出区：修改turn；<br>适用于多个进程；</p>
<p>把Dekkers算法中的flag[i] := false去掉后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">flag[<span class="number">0</span>]:= <span class="literal">false</span>; flag[<span class="number">1</span>]:= <span class="literal">false</span>; turn:= <span class="number">0</span>;<span class="comment">//or1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">     flag[i] = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">while</span> flag[j] == <span class="literal">true</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> turn ≠ i &#123;</span><br><span class="line">         <span class="keyword">while</span> turn ≠ i &#123; &#125;</span><br><span class="line">         flag[i] := <span class="literal">true</span></span><br><span class="line">       &#125; </span><br><span class="line">     &#125;</span><br><span class="line">     CRITICAL SECTION</span><br><span class="line">     turn := j</span><br><span class="line">     flag[i] = <span class="literal">false</span>;</span><br><span class="line">     REMAINDER SECTION</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>错误例子：</p>
<p>两个进程都进入do-while循环，而后<code>flag[0] = true</code>且<code>flag[1] = true</code>，同时进入<code>while flag[j] == true</code>循环。这时若果<code>turn=1</code>，则0号进程进入if后在<code>while turn ≠ i</code> 处死循环，1号进程在<code>while flag[j] == true</code> 处死循环。</p>
<p><strong>N线程的软件方法</strong></p>
<p><img src="https://i.loli.net/2019/07/28/5d3da73e6bb3695538.png"></p>
<p><strong>Eisenberg算法</strong></p>
<p>可参考<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Peterson's_algorithm">维基百科</a> ，该算法将n个进程形成一个圈，依照这个圈的顺序来分发资源。</p>
<p>首先这个算法需要维护这样的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shared enum states &#123;IDLE, WAITING, ACTIVE&#125; flags[n];</span><br><span class="line"></span><br><span class="line">shared int turn;</span><br><span class="line"></span><br><span class="line">int index;        &#x2F;* not shared! *&#x2F;</span><br></pre></td></tr></table></figure>
<p>其中，<code>flags[i]=IDLE</code>：进程Pi不想进入临界区；</p>
<p><code>flags[i]=WAITING</code>：进程Pi想进入临界区；</p>
<p><code>flags[i]=ACTIVE</code>：进程想进或已进临界区。</p>
<p>flags的所有元素初值都是IDLE；</p>
<p>turn的初值为0到n-1之间的任一正整数，它表示允许进入临界区的进程编号；</p>
<p>index为每个进程拥有的一个局部变量，其初值为0到n-1之间的任一正整数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">repeat &#123;</span><br><span class="line">    <span class="comment">/* announce that we need the resource */</span></span><br><span class="line">    flags[i] = WAITING; <span class="comment">//（0）语句</span></span><br><span class="line">	<span class="comment">//循环1开始</span></span><br><span class="line">    index = turn;</span><br><span class="line">    <span class="keyword">while</span> (index != i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[index] != IDLE) index = turn;<span class="comment">//条件1</span></span><br><span class="line">        <span class="keyword">else</span> index = index+<span class="number">1</span> mod n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环1结尾</span></span><br><span class="line">    flags[i] = ACTIVE; <span class="comment">//（1）语句</span></span><br><span class="line">	<span class="comment">//循环2开始</span></span><br><span class="line">    <span class="comment">/* find the first active process besides ourselves, if any */</span></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((index &lt; n) &amp;&amp; <span class="comment">//条件2 </span></span><br><span class="line">	((index == i) || (flags[index] != ACTIVE)))  <span class="comment">//条件3</span></span><br><span class="line">    &#123;</span><br><span class="line">        index = index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="comment">//循环2结尾</span></span><br><span class="line"><span class="comment">//最终判断</span></span><br><span class="line">&#125; until ((index &gt;= n)  <span class="comment">//条件4</span></span><br><span class="line">	&amp;&amp; ((turn == i)|| (flags[turn] == IDLE))); <span class="comment">//条件5</span></span><br></pre></td></tr></table></figure>
<p>我们考虑第i个进程：<br>turn是一个关键的变量，它决定谁现在能进入临界区。有2种情况：<br>1.turn是一个随机的值，此时没有任何人申请资源<br>2.turn是某个申请资源的进程的编号</p>
<p>我们要验证turn到底处于哪一种情况，如果是第一种情况，那么即使turn≠i，我们也可以进入临界区，如果是第二种情况，那么我们得等到turn号进程执行完成。</p>
<p>第零步，初始状态，申请之后，还处于IDLE状态</p>
<p>第一步，进入WAITING状态，并检查[turn,i)区间内有没有申请资源的进程，有则等待它们执行完毕，没有则进入第二步</p>
<p>第二步，进入ACTIVE状态，并试图寻找一个其它的处于ACTIVE状态的进程，如果没找到，则获得资源的控制权，如果找到了，则回到WAITING状态</p>
<p>为何能解决同步互斥问题？<br>首先有一个序，从turn开始，越前面的进程越优先获得资源。<br>其次，如果执行到一半，突然有序号在自己之前的进程申请资源，自己会放弃资源的申请，等待序号靠前的进程结束。</p>
<blockquote>
<p>正确性证明</p>
</blockquote>
<p><strong>互斥进入</strong></p>
<p> 实际上循环2就已经实现了互斥进入，即只能有一个进程进入临界区，即只有第一个设置ACTIVE的才有可能进入临界区。 这里的第一个是指在写之前flags全不是ACTIVE，写后第一个变为ACTIVE，如果有进程写了然后循环回去又改成了WAITING，则下一个第一个改ACTIVE的才有可能进入临界区。 因为先设置ACTIVE并还没有循环回去的进程会让其他进程在数ACTIVE数目时都发现不只自己，这样就进不到临界区。因此循环2保证了在临界区没有进程时最多一个进程可能进入临界区。然后，如果有一个进程进入了临界区，那么，该进程的flags必定为ACTIVE，继而阻止了其他所有进程在循环2中将index加到n，所以这时没有进程能再进去，除非临界区的进程退出临界区，改了自己的flags。</p>
<p>综上，互斥进入得证。</p>
<p><strong>空闲则入</strong></p>
<p>下面给出空闲则入的证明：</p>
<p>使用反证法：</p>
<p>如果不满足空闲则入，那么必然存在一种情况，所有进入竞争区的进程都在repeat循环里出不来</p>
<p>首先看repeat循环的特点是，</p>
<p>（a）只要进入了这个竞争区，flags就一定不是IDLE；</p>
<p>（b）最靠近turn的进程必然能够通过循环1</p>
<p> 因此，如果所有进程都出不去，那么经过充分而有限的时间t‘（我们假设每个进程都有机会获得CPU），所有竞争区的进程的flags必定都非IDLE，而且在更充分的时间t0后，所有进程在循环1中判断时，涉及的在竞争区内的进程的flags都非IDLE，那么这时，就只有最靠近turn的那个进程能够通过循环1。</p>
<p> 即使在这个充分而有限的时间t0内有新进程进入，根据假设，所有进程还是都出不去，那么仍然会有一个时间t1，使只有最靠近turn的那个进程通过循环1，由于进程总数是有限的，所以这种时间的增长是有限的，于是在一个有限的时间t后，只有最靠近turn的那个进程能够通过循环1。</p>
<p> 显然，此时这个进程可以通过循环2将index加到n，由于其距离turn最近，说明turn就是该进程或者turn的flags为IDLE，于是该进程进入临界区（即使此时turn对应的那个进程进入repeat改了flags也没关系，只是再次增大了t而已）</p>
<p>综上，假设错误，满足空闲则入.</p>
<p>由此，该算法正确 (只要保证调度过程不会有某一进程在无限时间内获取不到CPU的情况，显然这一点一般是可以保证的)</p>
<p>实际上，只有turn对应的进程没有指向进入repeat的一个进程，并且发生了很多次非常极端的情况时，上面的t才会比较长，而上面证明了t依然有限，所以该算法有效。</p>
<p><strong>基于软件的解决方法分析</strong></p>
<ul>
<li><strong>复杂</strong> 需要两个进程间的共享访问项</li>
<li><strong>需要忙等待</strong> 浪费CPU时间，需要频繁查询共享变量</li>
</ul>
<h2 id="高级抽象的同步方法"><a href="#高级抽象的同步方法" class="headerlink" title="高级抽象的同步方法"></a>高级抽象的同步方法</h2><p>硬件提供一些同步原语</p>
<ul>
<li>中断禁用</li>
<li>原子操作指令(从硬件上保证其原子性)</li>
</ul>
<p><strong>锁(Lock)</strong></p>
<p>一个抽象的数据结构</p>
<ul>
<li>一个二进制变量(锁定/解锁)</li>
<li><code>Lock::Acquire()</code><ul>
<li>锁被释放前一直等待，然后得到锁</li>
</ul>
</li>
<li><code>Lock::Release()</code><ul>
<li>释放锁，唤醒任何等待的进程</li>
</ul>
</li>
</ul>
<p>使用锁来控制临界区访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lock_next_pid-&gt;Acquire();</span><br><span class="line">new_pid &#x3D; next_pid++;</span><br><span class="line">lock_next_pid-&gt;Release();</span><br></pre></td></tr></table></figure>
<p><strong>原子操作指令</strong></p>
<p>现在CPU体系结构提供的特殊原子指令</p>
<blockquote>
<p>测试和置位指令(TS Test-and-Set)</p>
</blockquote>
<ul>
<li>从内存单元中读取值</li>
<li>测试该值是否为1(真或假)</li>
<li>内存单元值设置为1</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean *target)</span> </span>&#123;</span><br><span class="line">    boolean rv = *target;</span><br><span class="line">    *target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交换指令(Exchange)</p>
</blockquote>
<p>交换内存中的两个值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span> <span class="params">(boolean *a, boolean *b)</span></span>&#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TS指令实现自旋锁(Spinlock)</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Lock &#123;</span><br><span class="line">    int value &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">   while (test-and-set(value))</span><br><span class="line">      ; &#x2F;&#x2F;spin</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果锁被释放，那么TS指令读取0并设置为1</span><br><span class="line">&#x2F;&#x2F;锁将被设置为忙等待状态</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">    value &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果锁处于忙等待状态，那么TS指令读取1并将值设置为1。</p>
<ul>
<li>不改变锁的状态且需要循环</li>
</ul>
<p><strong>TS指令实现无忙等待锁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">   WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">   <span class="keyword">while</span> (test-<span class="keyword">and</span>-<span class="built_in">set</span>(value)) &#123;</span><br><span class="line">      add <span class="keyword">this</span> TCB to wait <span class="built_in">queue</span> q;</span><br><span class="line">      schedule();</span><br><span class="line">      <span class="comment">//通过调度让其余进程继续执行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">   value = <span class="number">0</span>;</span><br><span class="line">   remove one thread t from q;</span><br><span class="line">   wakeup(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原子操作指令锁特征</strong></p>
<ul>
<li>优点<ul>
<li>适用于单处理机或者共享内存的多处理机中任意数量的进程同步(禁用中断只适用于单处理机 多处理机的情况下 禁止单个处理机的中断 其他处理机仍然能够响应中断)</li>
<li>简单且容易证明</li>
<li>支持多临界区</li>
</ul>
</li>
<li>缺点<ul>
<li>忙等待锁会消耗处理机时间</li>
<li>可能导致饥饿,进程离开临界区时有多个等待进程的情况(并没有按照先来后到的顺序)</li>
</ul>
</li>
<li>死锁<ul>
<li>拥有临界区的低优先级进程，但请求访问临界区的高优先级进程获得处理机并等待临界区(低优先级等CPU,高优先级等临界区)</li>
</ul>
</li>
</ul>
<h1 id="同步方法总结"><a href="#同步方法总结" class="headerlink" title="同步方法总结"></a>同步方法总结</h1><p>锁是一种高级的同步抽象方法</p>
<ul>
<li>互斥可以使用锁来实现</li>
<li>需要硬件支持</li>
</ul>
<p><strong>常用三种同步实现方法总结</strong></p>
<ul>
<li>禁用中断(仅限于单处理机)</li>
<li>软件方法(共享变量 条件弱但是复杂) </li>
<li>原子操作指令(单处理机或多处理机均可)</li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>trinkle
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://twinkle0331.github.io/systems/sync/" title="同步互斥">http://twinkle0331.github.io/systems/sync/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Operating-Systems/" rel="tag"><i class="fa fa-tag"></i> Operating Systems</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/systems/ucore-lab6/" rel="prev" title="ucore lab6">
                  <i class="fa fa-chevron-left"></i> ucore lab6
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/systems/semaphore/" rel="next" title="信号量">
                  信号量 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">trinkle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  


</body>
</html>
