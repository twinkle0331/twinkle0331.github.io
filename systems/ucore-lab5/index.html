<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"twinkle0331.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="之前的实验均在内核态中执行，不涉及在用户态的操作，所以提供各种操作系统的内核线程只能在cpu核心态工作。然而应用程序员也需要在计算机系统上运行自己的应用软件，将应用软件都作为内核线程则无法保证系统的安全性。基于以上原因，ucore在lab5中提供用户态进程的创建和执行机制，给应用程序提供一个用户态的运行环境。">
<meta property="og:type" content="article">
<meta property="og:title" content="ucore lab5">
<meta property="og:url" content="http://twinkle0331.github.io/systems/ucore-lab5/index.html">
<meta property="og:site_name" content="trinkle">
<meta property="og:description" content="之前的实验均在内核态中执行，不涉及在用户态的操作，所以提供各种操作系统的内核线程只能在cpu核心态工作。然而应用程序员也需要在计算机系统上运行自己的应用软件，将应用软件都作为内核线程则无法保证系统的安全性。基于以上原因，ucore在lab5中提供用户态进程的创建和执行机制，给应用程序提供一个用户态的运行环境。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-07-04T09:11:38.000Z">
<meta property="article:modified_time" content="2021-03-27T13:17:35.000Z">
<meta property="article:author" content="trinkle">
<meta property="article:tag" content="ucore">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://twinkle0331.github.io/systems/ucore-lab5/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>ucore lab5 | trinkle</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="trinkle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">trinkle</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://twinkle0331.github.io/systems/ucore-lab5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trinkle">
      <meta itemprop="description" content="Stay foolish,stay hungry.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="trinkle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ucore lab5
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-04 17:11:38" itemprop="dateCreated datePublished" datetime="2019-07-04T17:11:38+08:00">2019-07-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Systems/" itemprop="url" rel="index"><span itemprop="name">Systems</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>之前的实验均在内核态中执行，不涉及在用户态的操作，所以提供各种操作系统的内核线程只能在cpu核心态工作。然而应用程序员也需要在计算机系统上运行自己的应用软件，将应用软件都作为内核线程则无法保证系统的安全性。基于以上原因，ucore在lab5中提供用户态进程的创建和执行机制，给应用程序提供一个用户态的运行环境。</p>
<a id="more"></a>

<h1 id="创建用户进程"><a href="#创建用户进程" class="headerlink" title="创建用户进程"></a>创建用户进程</h1><h2 id="应用程序的组成和编译"><a href="#应用程序的组成和编译" class="headerlink" title="应用程序的组成和编译"></a>应用程序的组成和编译</h2><p>以hello.c程序为例，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ulib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    cprintf(&quot;Hello world!!.\n&quot;);</span><br><span class="line">    cprintf(&quot;I am process %d.\n&quot;, getpid());</span><br><span class="line">    cprintf(&quot;hello pass.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行make后输出如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ cc user&#x2F;hello.c</span><br><span class="line"></span><br><span class="line">gcc -Iuser&#x2F; -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs&#x2F; -Iuser&#x2F;include&#x2F; -Iuser&#x2F;libs&#x2F; -c user&#x2F;hello.c -o obj&#x2F;user&#x2F;hello.o</span><br><span class="line"></span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools&#x2F;user.ld -o obj&#x2F;__user_hello.out  obj&#x2F;user&#x2F;libs&#x2F;initcode.o obj&#x2F;user&#x2F;libs&#x2F;panic.o obj&#x2F;user&#x2F;libs&#x2F;stdio.o obj&#x2F;user&#x2F;libs&#x2F;syscall.o obj&#x2F;user&#x2F;libs&#x2F;ulib.o obj&#x2F;user&#x2F;libs&#x2F;umain.o  obj&#x2F;libs&#x2F;hash.o obj&#x2F;libs&#x2F;printfmt.o obj&#x2F;libs&#x2F;rand.o obj&#x2F;libs&#x2F;string.o obj&#x2F;user&#x2F;hello.o</span><br><span class="line">……</span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools&#x2F;kernel.ld -o bin&#x2F;kernel  obj&#x2F;kern&#x2F;init&#x2F;entry.o obj&#x2F;kern&#x2F;init&#x2F;init.o …… -b binary …… obj&#x2F;__user_hello.out</span><br></pre></td></tr></table></figure>
<p>在make最后一步执行了一个ld命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把hello应用程序的执行码obj&#x2F;__user_hello.out连接在了ucore kernel的末尾。ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量_binary_obj___user_hello_out_start和_binary_obj___user_hello_out_size中，这样这个hello用户程序就能够和ucore内核一起被 bootloader 加载到内存里中，并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小。</span><br></pre></td></tr></table></figure>
<h2 id="用户进程的虚拟地址空间"><a href="#用户进程的虚拟地址空间" class="headerlink" title="用户进程的虚拟地址空间"></a>用户进程的虚拟地址空间</h2><p>在<code>tools/user.ld</code>描述了用户程序的用户虚拟空间的执行入口虚拟地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    &#x2F;* Load programs at this address: &quot;.&quot; means the current address *&#x2F;</span><br><span class="line">    . &#x3D; 0x800020;</span><br></pre></td></tr></table></figure>
<p>在<code>tools/kernel.ld</code>描述了操作系统的内核虚拟空间的起始入口虚拟地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    &#x2F;* Load the kernel at this address: &quot;.&quot; means the current address *&#x2F;</span><br><span class="line">    . &#x3D; 0xC0100000;</span><br></pre></td></tr></table></figure>
<p>这样ucore将用户进程的虚拟地址空间分为了两个部分，一部分是所有用户进程共享的内核地址空间，映射到同样的物理地址空间中。将内核代码放到此空间中，用户进程从用户态到内核态时，内核可以统一应对不同的内核程序。另外一部分是用户虚拟地址空间，映射到不同且没有交集的物理内存空间中。用户进程的执行代码和数据放到用户地址空间时确保各个进程不会非法访问到其他进程的物理空间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                          Permissions</span></span><br><span class="line"><span class="comment"> *                                                              kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     4G ------------------&gt; +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |         Empty Memory (*)        |</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            +---------------------------------+ 0xFB000000</span></span><br><span class="line"><span class="comment"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span></span><br><span class="line"><span class="comment"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span></span><br><span class="line"><span class="comment"> *                            |           User stack            |</span></span><br><span class="line"><span class="comment"> *                            +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            :                                 :</span></span><br><span class="line"><span class="comment"> *                            |         ~~~~~~~~~~~~~~~~        |</span></span><br><span class="line"><span class="comment"> *                            :                                 :</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                            |       User Program &amp; Heap       |</span></span><br><span class="line"><span class="comment"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *                            |  - - - - - - - - - - - - - - -  |</span></span><br><span class="line"><span class="comment"> *                            |    User STAB Data (optional)    |</span></span><br><span class="line"><span class="comment"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>
<h2 id="创建并执行用户进程"><a href="#创建并执行用户进程" class="headerlink" title="创建并执行用户进程"></a>创建并执行用户进程</h2><p>lab5中第一个进程是由第二个内核线程<code>initproc</code>通过把hello应用程序执行码覆盖到<code>initproc</code>的用户执行空间来创建的，相关代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_EXECVE(name, binary, size) (&#123;                          \</span></span><br><span class="line">            cprintf(<span class="string">&quot;kernel_execve: pid = %d, name = \&quot;%s\&quot;.\n&quot;</span>,        \</span><br><span class="line">                    current-&gt;pid, name);                                \</span><br><span class="line">            kernel_execve(name, binary, (<span class="keyword">size_t</span>)(size));                \</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_EXECVE(x) (&#123;                                             \</span></span><br><span class="line">            <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _binary_obj___user_#<span class="meta">#x##_out_start[],  \</span></span><br><span class="line">                _binary_obj___user_#<span class="meta">#x##_out_size[];                    \</span></span><br><span class="line">            __KERNEL_EXECVE(<span class="meta">#x, _binary_obj___user_##x##_out_start,     \</span></span><br><span class="line">                            _binary_obj___user_#<span class="meta">#x##_out_size);         \</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_EXECVE2(x, xstart, xsize) (&#123;                           \</span></span><br><span class="line">            <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> xstart[], xsize[];                     \</span><br><span class="line">            __KERNEL_EXECVE(<span class="meta">#x, xstart, (size_t)xsize);                 \</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_EXECVE2(x, xstart, xsize)        __KERNEL_EXECVE2(x, xstart, xsize)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user_main - kernel thread used to exec a user program</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">user_main(<span class="keyword">void</span> *arg) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST</span></span><br><span class="line">    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    KERNEL_EXECVE(<span class="built_in">exit</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    panic(<span class="string">&quot;user_main execve failed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>proc_init</code>函数中，通过<code>kernel_thread</code>来创建第二个内核线程<code>init_main</code>，<code>init_main</code>又调用<code>kernel_thread</code>来创建子进程<code>user_main</code> 。user_main在缺省的情况下执行宏<code>KERNEL_EXECVE(exit);</code> ，而这个宏最后是调用<code>kernel_execve</code> 来调用SYS_execve系统调用。由于ld在链接exit应用程序执行码时定义了两全局变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_binary_obj___user_exit_out_start：exit执行码的起始位置</span><br><span class="line">_binary_obj___user_exit_out_size中：exit执行码的大小</span><br></pre></td></tr></table></figure>
<p><code>kernel_execve</code>把这两个变量作为SYS_exec系统调用的参数，让ucore来创建此用户进程。当ucore收到此系统调用后，将依次调用如下函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector128(vectors.S)--&gt;__alltraps(trapentry.S)--&gt;trap(trap.c)--&gt;trap_dispatch(trap.c)--</span><br><span class="line">--&gt;syscall(syscall.c)--&gt;sys_exec（syscall.c）--&gt;do_execve(proc.c)</span><br></pre></td></tr></table></figure>
<p>最终通过<code>do_execve</code>函数来完成用户进程的创建工作。</p>
<p><code>do_execve</code>的流程分析如下：</p>
<p>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的 initproc是内核线程，所以mm为NULL，整个处理都不会做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)name, len, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> local_name[PROC_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(local_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_name));</span><br><span class="line">    <span class="built_in">memcpy</span>(local_name, name, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。<code>load_icode</code>函数完成了整个复杂的工作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int ret;</span><br><span class="line">if ((ret &#x3D; load_icode(binary, size)) !&#x3D; 0) &#123;</span><br><span class="line">goto execve_exit;</span><br><span class="line">&#125;</span><br><span class="line">set_proc_name(current, local_name);</span><br></pre></td></tr></table></figure>
<p><code>do_execv</code>函数调用<code>load_icode</code>（位于<code>kern/process/proc.c</code>中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好<code>proc_struct</code>结构中的成员变量<code>trapframe</code>中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的<code>trapframe</code>内容。</p>
<p>设置<code>trapframe</code>部分的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_icode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">	tf_cs=USER_CS;</span><br><span class="line">	tf_ds=tf_es=tf_ss=USER_DS;</span><br><span class="line">	tf_esp=USTACKTOP;</span><br><span class="line">	tf_eip=elf-&gt;e_entry;</span><br><span class="line">	tf_eflags=FL_IF;<span class="comment">//使能中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将中断帧全部设置为0，其次修改中断帧中内容如下：</p>
<ul>
<li>tf_cs：用户态代码段寄存器，设置为USER_CS</li>
<li>tf_ds，tf_es,tf_ss:用户态数据段寄存器，设置为USER_DS</li>
<li>tf_esp：设置为宏<code>USTACKTOP</code>(用户栈)，即<strong>0xB0000000</strong></li>
<li>tf_eip：用户态的指令指针，设置为用户程序的起始位置(即user.ld中<code>0x00800020</code>）</li>
<li>tf_eflags：设置使能中断</li>
</ul>
<blockquote>
<p>描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p>
</blockquote>
<p>当一个用户态进程被选择占用cpu执行后，执行<code>proc_init</code>，流程如下：</p>
<ol>
<li>关闭中断</li>
<li>将当前进程指针指向该进程</li>
<li>调用<code>switch_to</code>切换进程上下文，跳转到<code>forkrets</code></li>
<li>跳转到<code>__trapret</code>，恢复各段寄存器</li>
</ol>
<p>新建一个进程有两种方式：</p>
<ol>
<li>在用户态系统调用<code>sys_fork</code></li>
<li>在内核态函数调用<code>do_fork</code></li>
</ol>
<p>二者均会系统调用<code>sys_exec</code>来创建一个新进程，应用程序具体执行的第一条指令由<code>trapframe</code>中eip的值给定。在<code>__trapret</code>返回后即转到新进程中的第一条指令执行。</p>
<h1 id="进程退出和回收"><a href="#进程退出和回收" class="headerlink" title="进程退出和回收"></a>进程退出和回收</h1><p>进程执行完它的工作后就执行退出操作来释放进程占用的资源。进程自身无法回收所有的资源，只要进程还在执行，内核栈的空间无法释放，对应的进程控制块也无法释放，由其父进程来释放这两个资源。所以ucore首先由进程本身完成大部分资源的占用内存回收工作，然后由父进程完成剩余资源的回收工作。</p>
<p>为此在用户态函数库中提供了exit函数，访问sys_exit系统调用接口让操作系统来帮助当前进程执行退出过程中部分资源的回收。</p>
<p>进程退出操作流程如下：</p>
<p>首先sys_exit将退出码error_code传递给ucore，ucore通过执行do_exit来处理当前退出进程，回收大部分当前进程所占用的资源并通知父进程完成最后的回收工作。</p>
<p>具体流程如下：</p>
<p><strong>1.</strong> 如果current-&gt;mm != NULL，表示是用户进程，则开始回收此用户进程所占用的用户态虚拟内存空间；</p>
<p>a) 首先执行<code>lcr3(boot_cr3)</code>，切换到内核态的页表上，这样当前用户进程目前只能在内核虚拟地址空间执行了，这是为了确保后续释放用户态内存和进程页表的工作能够正常执行；</p>
<p>b) 如果当前进程控制块的成员变量mm的成员变量<code>mm_count</code>减1后为0（表明这个mm没有再被其他进程共享，可以彻底释放进程所占的用户虚拟空间了），则开始回收用户进程所占的内存资源：</p>
<p>i. 调用<code>exit_mmap</code>函数释放<code>current-&gt;mm-&gt;vma</code>链表中每个vma描述的进程合法空间中实际分配的内存，然后把对应的页表项内容清空，最后还把页表所占用的空间释放并把对应的页目录表项清空；</p>
<p>ii. 调用<code>put_pgdir</code>函数释放当前进程的页目录所占的内存；</p>
<p>iii. 调用<code>mm_destroy</code>函数释放mm中的vma所占内存，最后释放mm所占内存；</p>
<p>c) 此时设置<code>current-&gt;mm</code>为NULL，表示与当前进程相关的用户虚拟内存空间和对应的内存管理成员变量所占的内核虚拟内存空间已经回收完毕；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong> 这时，设置当前进程的执行状态<code>current-&gt;state=PROC_ZOMBIE</code>，当前进程的退出码<code>current-&gt;exit_code=error_code</code>。此时当前进程已经不能被调度了，需要此进程的父进程来做最后的回收工作（即回收描述此进程的内核栈和进程控制块）；</p>
<p><strong>3.</strong> 如果当前进程的父进程<code>current-&gt;parent</code>处于等待子进程状态：current-&gt;parent-&gt;wait_state==WT_CHILD，则唤醒父进程（即执行“wakup_proc(current-&gt;parent)”），让父进程帮助自己完成最后的资源回收；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current-&gt;state = PROC_ZOMBIE;</span><br><span class="line">current-&gt;exit_code = error_code;</span><br></pre></td></tr></table></figure>
<p><strong>4.</strong> 如果当前进程还有子进程，则需要把这些子进程的父进程指针设置为内核线程<code>initproc</code>，且各个子进程指针需要插入到<code>initproc</code>的子进程链表中。如果某个子进程的执行状态是<code>PROC_ZOMBIE</code>，则需要唤醒initproc来完成对此子进程的最后回收工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> intr_flag;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">local_intr_save(intr_flag);</span><br><span class="line">&#123;</span><br><span class="line">    proc = current-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">        wakeup_proc(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;cptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc = current-&gt;cptr;</span><br><span class="line">        current-&gt;cptr = proc-&gt;optr;</span><br><span class="line"></span><br><span class="line">        proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            initproc-&gt;cptr-&gt;yptr = proc;</span><br><span class="line">        &#125;</span><br><span class="line">        proc-&gt;parent = initproc;</span><br><span class="line">        initproc-&gt;cptr = proc;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (initproc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">                wakeup_proc(initproc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">local_intr_restore(intr_flag);</span><br></pre></td></tr></table></figure>
<p><strong>5.</strong> 执行<code>schedule()</code>函数,调度后选择新进程执行。</p>
<p>父进程通过<code>syswait</code>系统调用接口来让ucore完成最后的资源回收工作。</p>
<p><code>do_wait</code>具体流程如下：<br>**1.**如果pid!=0，表示只找一个进程id号为pid的退出状态的子进程，否则找任意一个处于退出状态的子进程；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        proc = find_proc(pid);</span><br><span class="line">        <span class="keyword">if</span> (proc != <span class="literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        proc = current-&gt;cptr;</span><br><span class="line">        <span class="keyword">for</span> (; proc != <span class="literal">NULL</span>; proc = proc-&gt;optr) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>**2.**如果此子进程的执行状态不为<code>PROC_ZOMBIE</code>，表明此子进程还没有退出，则当前进程只好设置自己的执行状态为<code>PROC_SLEEPING</code>，睡眠原因为<code>WT_CHILD</code>（即等待子进程退出），调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤1处执行；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if (haskid) &#123;</span><br><span class="line">        current-&gt;state &#x3D; PROC_SLEEPING;</span><br><span class="line">        current-&gt;wait_state &#x3D; WT_CHILD;</span><br><span class="line">        schedule();</span><br><span class="line">        if (current-&gt;flags &amp; PF_EXITING) &#123;</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        &#125;</span><br><span class="line">        goto repeat;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>**3.**如果此子进程的执行状态为<code>PROC_ZOMBIE</code>，表明此子进程处于退出状态，需要当前进程（即子进程的父进程）完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列<code>proc_list</code>和<code>hash_list</code>中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，消除了它所占用的所有资源。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local_intr_save(intr_flag);</span><br><span class="line">&#123;</span><br><span class="line">    unhash_proc(proc);</span><br><span class="line">    remove_links(proc);</span><br><span class="line">&#125;</span><br><span class="line">local_intr_restore(intr_flag);</span><br><span class="line">put_kstack(proc);</span><br><span class="line">kfree(proc);</span><br></pre></td></tr></table></figure>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>系统调用为用户进程提供操作系统服务的统一接口层，简化用户的实现。</p>
<h2 id="初始化中断向量描述符"><a href="#初始化中断向量描述符" class="headerlink" title="初始化中断向量描述符"></a>初始化中断向量描述符</h2><p>在ucore的<code>kern_init</code>中调用了<code>idt_init</code>来初始化中断向量描述符表，并设置专门用于用户进程访问系统调用的中断门。</p>
<p><code>idt_init</code>部分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">idt_init(void) &#123;</span><br><span class="line">    extern uintptr_t __vectors[];</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; sizeof(idt) &#x2F; sizeof(struct gatedesc); i ++) &#123;</span><br><span class="line">        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦用户执行<code>int 0x80</code> 后，CPU从用户态切换到内核态，保存相关寄存器并跳转到对应的中断服务例程处执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector128(vectors.S)--&gt;__alltraps(trapentry.S)--&gt;trap(trap.c)--&gt;trap_dispatch(trap.c)----&gt;syscall(syscall.c)</span><br></pre></td></tr></table></figure>
<h2 id="建立系统调用的用户库准备"><a href="#建立系统调用的用户库准备" class="headerlink" title="建立系统调用的用户库准备"></a>建立系统调用的用户库准备</h2><p>用户态的<code>syscall</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static inline int</span><br><span class="line">syscall(int num, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    uint32_t a[MAX_ARGS];</span><br><span class="line">    int i, ret;</span><br><span class="line">    for (i &#x3D; 0; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] &#x3D; va_arg(ap, uint32_t);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;int %1;&quot;</span><br><span class="line">        : &quot;&#x3D;a&quot; (ret)</span><br><span class="line">        : &quot;i&quot; (T_SYSCALL),</span><br><span class="line">          &quot;a&quot; (num),</span><br><span class="line">          &quot;d&quot; (a[0]),</span><br><span class="line">          &quot;c&quot; (a[1]),</span><br><span class="line">          &quot;b&quot; (a[2]),</span><br><span class="line">          &quot;D&quot; (a[3]),</span><br><span class="line">          &quot;S&quot; (a[4])</span><br><span class="line">        : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>eax中存放系统调用号</li>
<li>edx、ecx、ebx、edi、esi中按照顺序存放前五个参数</li>
<li>返回值存放在eax中</li>
</ul>
<p>应用程序调用的<code>exit/fork/wait/getpid</code>等库函数最后都会调用syscall函数，只是调用参数不同而已。</p>
<p>内核态的<code>syscall</code>为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">syscall(void) &#123;</span><br><span class="line">    struct trapframe *tf &#x3D; current-&gt;tf;</span><br><span class="line">    uint32_t arg[5];</span><br><span class="line">    int num &#x3D; tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    if (num &gt;&#x3D; 0 &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        if (syscalls[num] !&#x3D; NULL) &#123;</span><br><span class="line">            arg[0] &#x3D; tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[1] &#x3D; tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[2] &#x3D; tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[3] &#x3D; tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[4] &#x3D; tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax &#x3D; syscalls[num](arg);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(&quot;undefined syscall %d, pid &#x3D; %d, name &#x3D; %s.\n&quot;,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，传递参数的顺序和用户态syscall的顺序一致。</p>
<h1 id="进程执行-fork-exec-wait-exit"><a href="#进程执行-fork-exec-wait-exit" class="headerlink" title="进程执行 fork/exec/wait/exit"></a>进程执行 fork/exec/wait/exit</h1><h2 id="父进程复制自己的内存空间给子进程"><a href="#父进程复制自己的内存空间给子进程" class="headerlink" title="父进程复制自己的内存空间给子进程"></a>父进程复制自己的内存空间给子进程</h2><p>创建子进程的函数<code>do_fork</code>在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过<code>copy_range</code>函数（位于<code>kern/mm/pmm.c</code>中）实现的，请补充<code>copy_range</code>的实现，确保能够正确执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">copy_range(<span class="keyword">pde_t</span> *to, <span class="keyword">pde_t</span> *from, <span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> end, <span class="keyword">bool</span> share) &#123;</span><br><span class="line">    assert(start % PGSIZE == <span class="number">0</span> &amp;&amp; end % PGSIZE == <span class="number">0</span>);</span><br><span class="line">    assert(USER_ACCESS(start, end));</span><br><span class="line">    <span class="comment">//以页为单元进行复制</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//call get_pte to find process A&#x27;s pte according to the addr start</span></span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(from, start, <span class="number">0</span>), *nptep;</span><br><span class="line">        <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//call get_pte to find process B&#x27;s pte according to the addr start. If pte is NULL, just alloc a PT</span></span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nptep = get_pte(to, start, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER);</span><br><span class="line">        <span class="comment">//get page from ptep</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep);</span><br><span class="line">        <span class="comment">// alloc a page for process B</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">npage</span>=</span>alloc_page();</span><br><span class="line">        assert(page!=<span class="literal">NULL</span>);</span><br><span class="line">        assert(npage!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//memcopy传入参数为void*类型，故二者均初始化为void *类型</span></span><br><span class="line">		<span class="keyword">void</span>* src_kvaddr=page2kva(page);</span><br><span class="line">		<span class="keyword">void</span>* dst_kvaddr=page2kva(npage);</span><br><span class="line">		<span class="built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE);</span><br><span class="line">		ret = page_insert(to, npage, start, perm);</span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (start != <span class="number">0</span> &amp;&amp; start &lt; end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</p>
</blockquote>
<ul>
<li><p><code>do_fork</code>  调用<code>alloc_proc</code>后进程状态为 <code>UNINIT</code>，然后将原进程信息复制过去，再覆盖原来的内核栈、eax、esp、eflags。调用函数 <code>wakeup_proc</code> 之后进程状态为RUNNABLE。</p>
</li>
<li><p><code>do_execve</code> 清除当前内存布局，再调用<code>load_icode</code>从二进制elf文件中读入内存布局，进程的状态不发生改变。</p>
</li>
<li><p><code>do_wait</code> 当前进程无子进程时错误退出，若有子进程，则判定子进程的状态是否为则判定是否为ZOMBIE 。若是则释放子进程的资源，并返回子进程的退出状态码。</p>
</li>
<li><p><code>do_exit</code> 首先清除当前进程除内核栈和进程控制块以外的资源，状态设置为ZOMBIE。若存在正在等待的父进程则唤醒父进程，父进程的状态从 SLEEPING 转变为 RUNNABLE。随后将该进程所有的子进程的父进程设置为<code>initproc</code>，由initproc进行资源的回收。若<code>initproc</code>正在等待子进程，则唤醒<code>initproc</code>。</p>
</li>
</ul>
<blockquote>
<p>请给出ucore中一个用户态进程的执行状态生命周期图</p>
</blockquote>
<p>proc中的用户态进程执行状态生命周期图如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">alloc_proc                                 RUNNING</span><br><span class="line">      +                                   +--&lt;----&lt;--+</span><br><span class="line">      +                                   + proc_run +</span><br><span class="line">      V                                   +--&gt;----&gt;--+</span><br><span class="line">PROC_UNINIT -- proc_init/wakeup_proc --&gt; PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --&gt; PROC_SLEEPING --</span><br><span class="line">                                           A      +                                                           +</span><br><span class="line">                                           |      +--- do_exit --&gt; PROC_ZOMBIE                                +</span><br><span class="line">                                           +                                                                  +</span><br><span class="line">                                           -----------------------wakeup_proc----------------------------------</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>trinkle
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://twinkle0331.github.io/systems/ucore-lab5/" title="ucore lab5">http://twinkle0331.github.io/systems/ucore-lab5/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/ucore/" rel="tag"><i class="fa fa-tag"></i> ucore</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/systems/ucore-lab4/" rel="prev" title="ucore lab4">
                  <i class="fa fa-chevron-left"></i> ucore lab4
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/systems/sched/" rel="next" title="处理机调度">
                  处理机调度 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">trinkle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  


</body>
</html>
