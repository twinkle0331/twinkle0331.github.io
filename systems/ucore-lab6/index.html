<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Serif+SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"twinkle0331.github.io","root":"/","images":"/images","scheme":"Mist","version":"8.2.2","exturl":false,"sidebar":{"position":"right","display":"remove","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>
<meta name="description" content="lab5完成了用户进程的管理，可在用户态运行多个进程。但是lab5所采用的调度策略为简单的FIFO策略，未考虑到进程的特征，性能比较差。lab 6对ucore的调度部分进行了修改，设计了系统调度器框架，不涉及具体的调度算法。之后，ucore基于此框架实现了RR调度算法。另外，考虑到进程优先级的问题，又引入了stride调度算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="ucore lab6">
<meta property="og:url" content="http://twinkle0331.github.io/systems/ucore-lab6/index.html">
<meta property="og:site_name" content="trinkle">
<meta property="og:description" content="lab5完成了用户进程的管理，可在用户态运行多个进程。但是lab5所采用的调度策略为简单的FIFO策略，未考虑到进程的特征，性能比较差。lab 6对ucore的调度部分进行了修改，设计了系统调度器框架，不涉及具体的调度算法。之后，ucore基于此框架实现了RR调度算法。另外，考虑到进程优先级的问题，又引入了stride调度算法。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-07-05T00:20:08.000Z">
<meta property="article:modified_time" content="2021-03-27T13:17:35.000Z">
<meta property="article:author" content="trinkle">
<meta property="article:tag" content="ucore">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://twinkle0331.github.io/systems/ucore-lab6/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>
<title>ucore lab6 | trinkle</title>
  




  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="trinkle" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">trinkle</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top" role="button">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://twinkle0331.github.io/systems/ucore-lab6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="trinkle">
      <meta itemprop="description" content="Stay foolish,stay hungry.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="trinkle">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ucore lab6
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-07-05 08:20:08" itemprop="dateCreated datePublished" datetime="2019-07-05T08:20:08+08:00">2019-07-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Systems/" itemprop="url" rel="index"><span itemprop="name">Systems</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>lab5完成了用户进程的管理，可在用户态运行多个进程。但是lab5所采用的调度策略为简单的FIFO策略，未考虑到进程的特征，性能比较差。lab 6对ucore的调度部分进行了修改，设计了系统调度器框架，不涉及具体的调度算法。之后，ucore基于此框架实现了RR调度算法。另外，考虑到进程优先级的问题，又引入了stride调度算法。</p>
<a id="more"></a>

<blockquote>
<p>填写已有实验</p>
</blockquote>
<p>本实验依赖实验1/2/3/4/5。请把你做的实验2/3/4/5的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”“LAB5”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab6的测试应用程序，可能需对已完成的实验1/2/3/4/5的代码进行进一步改进。<br>由于<code>proc</code>数据结构有所扩展，所以在<code>proc.c</code>中<code>alloc_proc</code>初始化需添加以下内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *<span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    proc-&gt;rq = <span class="literal">NULL</span>;<span class="comment">//进程所属运行队列</span></span><br><span class="line">    list_init(&amp;(proc-&gt;run_link));<span class="comment">//运行队列的哨兵结构</span></span><br><span class="line">    proc-&gt;time_slice = <span class="number">0</span>;<span class="comment">//进程时间片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在响应时钟中断时让操作系统感知操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks ++;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        sched_class_proc_tick(current);<span class="comment">//设置当前进程的调度状态</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>在之前的ucore中，中断时调用<code>run_timer_list</code>，先检查<code>timer_list</code>中的进程时间是否到期，若到期则唤醒该进程，若没有则expires–;再调用<code>sche_proc_proc_tick</code>设置当前进程的调度状态。进程如果需要等待一段时间后再唤醒，则需要用到timer结构，timer记录唤醒的时间，每次中断时从timer_list中查找到期的进程进行唤醒。让人奇怪的在于,之前的ucore中定义了timer的数据结构，以及对应的函数，却没有什么进程会面临这种情况。现在的ucore只是简单初始化<code>timer_list</code>,后续也并没有使用到此数据结构。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the list of timer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> timer_list;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    list_init(&amp;timer_list);</span><br><span class="line"></span><br><span class="line">    sched_class = &amp;default_sched_class;</span><br><span class="line"></span><br><span class="line">    rq = &amp;__rq;</span><br><span class="line">    rq-&gt;max_time_slice = MAX_TIME_SLICE;</span><br><span class="line">    sched_class-&gt;init(rq);</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;sched class: %s\n&quot;</span>, sched_class-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p>进程调度算法涉及到进程状态的转换。在ucore的具体实现中，进程控制块结构<code>proc_struct</code> 中成员变量<code>state</code> 用于描述进程的运行状态。其中运行态和就绪态的状态值相同，均为<code>PROC_RUNNABLE</code> ,二者区别在于运行态的进程不会放在运行队列中。</p>
<p>进程的正常生命周期如下：</p>
<ol>
<li>进程首先在cpu初始化或sys_fork的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入uninit态。</li>
<li>当进程完全初始化后，该进程转为runnable态</li>
<li>当到达调度点时，由调度器 sched_class 根据运行队列rq的内容来判断一个进程是否应该被运行，即把处于runnable态的进程转换成running状态，从而占用CPU执行。</li>
<li>running态的进程通过wait等系统调用被阻塞，进入sleeping态。</li>
<li>sleeping态的进程被wakeup变成runnable态的进程。</li>
<li>running态的进程主动 exit 变成zombie态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为unused。</li>
<li>所有从runnable态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。</li>
</ol>
<h1 id="进程调度实现"><a href="#进程调度实现" class="headerlink" title="进程调度实现"></a>进程调度实现</h1><h2 id="内核抢占点"><a href="#内核抢占点" class="headerlink" title="内核抢占点"></a>内核抢占点</h2><p>对于用户进程而言，中断的产生可以随时打断用户进程的执行，转到操作系统内部，从而操作系统拥有了调度控制权，可以选择其他用户执行，所以用户进程是可以抢占的。ucore内核执行同样是可抢占的，在执行任意内核代码时，cpu控制权可强制剥夺。</p>
<p>但是以下几种例外情况不可剥夺：</p>
<ul>
<li>进行同步互斥操作，比如争抢一个信号量、锁；</li>
<li>进行磁盘读写等耗时的异步操作，由于等待完成的耗时太长，ucore会调用schedule让其他就绪进程执行。</li>
</ul>
<p>以上情况都是由于当前进程所需的某个资源得不到满足而无法继续下去，不得不主动放弃对cpu的控制权。</p>
<blockquote>
<p>调度点</p>
</blockquote>
<p>lab6涉及到的调度点：</p>
<ul>
<li><code>proc.c:do_exit</code>　户线程执行结束，主动放弃CPU</li>
<li><code>proc.c:do_wait</code>　用户线程等待子进程结束，主动放弃CPU</li>
<li><code>proc.c::cpu_idle</code>　idleproc内核线程选取一个就绪进程并切换</li>
<li><code>trap.c::trap</code>　　若时间片用完，则设置need_resched为1，让当前进程放弃CPU</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在进程的执行过程中，就绪进程的等待时间和执行进程的执行时间是调度考虑的主要部分。这两者随着时间的流逝和时间的发生动态变化。为了让操作系统感知进程状态变化的情况，引入timer时间感知操作，在进程运行或等待的过程中，调度器可以调整进程控制块中与进程调度相关的属性值。</p>
<p>ucore调度框架定义了以下接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 调度器的名字</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">//初始化运行队列</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq);</span><br><span class="line">    <span class="comment">//将进程p插入队列rq</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">//将进程p从队列中删除</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">//返回运行队列中下一个可执行的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="comment">// 时间处理</span></span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>proc.h中的proc_struct中调度相关信息有：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct proc_struct &#123;</span><br><span class="line">    &#x2F;&#x2F;该进程是否需要调度，只对当前进程有效</span><br><span class="line">    volatile bool need_resched;                 </span><br><span class="line">    &#x2F;&#x2F;运行队列</span><br><span class="line">    struct run_queue *rq;</span><br><span class="line">    &#x2F;&#x2F;该进程的调度链表结构</span><br><span class="line">    list_entry_t run_link;</span><br><span class="line">    &#x2F;&#x2F;该进程剩余的时间片，只对当前进程有效</span><br><span class="line">    int time_slice;</span><br><span class="line">    &#x2F;&#x2F;RR算法并不会用到以下成员</span><br><span class="line">    skew_heap_entry_t lab6_run_pool;</span><br><span class="line">    &#x2F;&#x2F;在优先队列中的节点</span><br><span class="line">    uint32_t lab6_stride;</span><br><span class="line">    &#x2F;&#x2F;该进程的调度优先级</span><br><span class="line">    uint32_t lab6_priority;</span><br><span class="line">    &#x2F;&#x2F;该进程的调度步进值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过数据结构run_queue来描述run_queue,主要结构为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct run_queue &#123;</span><br><span class="line">    &#x2F;&#x2F;某运行队列的头或尾</span><br><span class="line">    list_entry_t run_list;</span><br><span class="line">    &#x2F;&#x2F;内部的进程总数</span><br><span class="line">    unsigned int proc_num;</span><br><span class="line">    &#x2F;&#x2F;每个进程一轮占用的最多时间</span><br><span class="line">    int max_time_slice;</span><br><span class="line">    &#x2F;&#x2F;优先队列形式的进程容器</span><br><span class="line">    skew_heap_entry_t *lab6_run_pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在ucore中，运行队列中存储当前可调度的进程，只有状态为runnable的进程才可以进入运行队列，其中当前正在运行的进程不会进入运行队列。</p>
<h1 id="Round-Robin调度算法"><a href="#Round-Robin调度算法" class="headerlink" title="Round Robin调度算法"></a>Round Robin调度算法</h1><p>RR调度算法的调度思想是让所有运行队列中的进程分时轮流使用CPU时间。当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度。RR调度算法的就绪队列在组织结构上也是一个双向链表，只是增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。而且在进程控制块<code>proc_struct</code>中增加了一个成员变量<code>time_slice</code>，用来记录进程当前的可运行时间片段。在每个timer到期的时候，操作系统会递减当前执行进程的<code>time_slice</code>，当<code>time_slice</code>为0时，就意味着这个进程运行了一段时间（这个时间片段称为进程的时间片），需要把CPU让给其他进程执行，于是操作系统就需要让此进程重新回到rq的队列尾，且重置此进程的时间片为就绪队列的成员变量最大时间片<code>max_time_slice</code>值，然后再从rq的队列头取出一个新的进程执行。</p>
<p>RR调度算法具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RR_enqueue把某进程的进程控制块指针放入到rq队列末尾，如果进程控制块时间片为0，则需要把它重置为rq成员变量max_time_slice，等待分配下一个时间片再运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">FCFS_pick_next</span>(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>) &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RR_pick_next选区就绪进程队列rq中的队首队列元素，并根据队列元素找到对应的进程控制块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">FCFS_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq &#x3D;&#x3D; rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RR_dequeue把就绪进程队列rq的进程控制块指针的队列元素删除，并把表示就绪进程个数的proc_num减一。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static void</span><br><span class="line">RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    if (proc-&gt;time_slice &gt; 0) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    if (proc-&gt;time_slice &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        proc-&gt;need_resched &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次timer到时后，trap函数将会间接调用<code>RR_proc_tick</code>来把当前执行进程的时间片time_slice减一。如果time_slice降到零，则设置此进程成员变量<code>need_resched</code>标识为1，这样在下一次中断来后执行trap函数时，会由于当前进程程成员变量<code>need_resched</code>标识为1而执行schedule函数，从而把当前执行进程放回就绪队列末尾，而从就绪队列头取出在就绪队列上等待时间最久的那个就绪进程执行。</p>
<blockquote>
<p>sched_class中各个函数指针的用法</p>
</blockquote>
<ul>
<li><strong>init</strong> 初始化运行队列的参数。</li>
<li>**enqueue ** 将可调度的进程放入调度队列</li>
<li><strong>dequeue</strong> 将该进程从调度队列删除</li>
<li><strong>pick_next</strong>  根据调度策略选择下一个进程</li>
<li><strong>proc_tick</strong>响应时钟中断，减少当前进程时间片，若为0则重新调度</li>
</ul>
<blockquote>
<p>ucore的调度过程：</p>
</blockquote>
<ol>
<li>设置当前进程剩余时间片</li>
<li>每次时钟中断，当前进程剩余时间片减一</li>
<li>剩余时间片为0时，会将当前进程的 <code>need_resched</code> 设置为1</li>
<li>从trap函数可知，在<code>trap_dispatch</code>之后，由于<code>need_resched</code> = 1，因此进入schedule进入调度器<br>将当前进程加入到数据结构中，并且取出数据结构中优先级最高的进程。</li>
</ol>
<ul>
<li>若<code>sched_class_pick_next</code>返回不为null，则选择该进程</li>
<li>若<code>sched_class_pick_next</code>返回为null，则设置下一进程为idleproc，idleproc死循环查找可被调度的进程</li>
</ul>
<ol start="5">
<li>调用 <code>proc_run()</code> 进行进程切换</li>
</ol>
<blockquote>
<p>设计实现多级反馈队列调度算法</p>
</blockquote>
<p>多级反馈队列算法初步设计如下：</p>
<ul>
<li><strong>init</strong>  初始化所有队列，将优先级设置为最高</li>
<li><strong>enqueue</strong> 该进程时间片为0时判断进程是否处于zombie状态，若不是，则降低有限级放入对应队列中，将时间片设置为该优先级队列的时间片</li>
<li><strong>dequeue</strong> 将该进程从对应优先级调度队列删除</li>
<li><strong>pick_next</strong> 根据优先级算法啊判断是否需要转移队列</li>
<li><strong>proc_tick</strong> 与之前实现一致</li>
</ul>
<h1 id="Stride-调度算法"><a href="#Stride-调度算法" class="headerlink" title="Stride 调度算法"></a>Stride 调度算法</h1><p>RR算法所有进程得到的时间是相等的，而我们希望每个进程得到的时间资源与其优先级成正比关系，由此引入了<strong>Stride Scheduling</strong>算法。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>基本思想如下：</p>
<ol>
<li>为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。</li>
<li>每次需要调度时，从当前 runnable 态的进程中选择 stride最小的进程调度。</li>
<li>对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。</li>
<li>在一段固定的时间之后，回到 2.步骤，重新调度当前stride最小的进程。</li>
</ol>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>stride调度算法为动态优先级调度算法，线程的执行时间与步进值的倒数成正比，简单易于实现。</p>
<ul>
<li><strong>可控性</strong> 可以证明stride scheduling对进程的调度次数正比于其优先级</li>
<li><strong>确定性</strong> 在不考虑计时器时间的情况下，整个调度机制都是可预知和可实现的</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Stride Scheduling 需要用到<code>proc_struct</code>中的几个成员变量，在<code>alloc_proc</code>中再添加初始化部分如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;lab6_run_pool.parent = proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = <span class="literal">NULL</span>;</span><br><span class="line">proc-&gt;lab6_priority = <span class="number">0</span>;<span class="comment">//优先级</span></span><br><span class="line">proc-&gt;lab6_stride = <span class="number">0</span>;<span class="comment">//步进值</span></span><br></pre></td></tr></table></figure>
<p><strong>Stride Scheduling</strong>的具体实现在<code>alloc_proc</code>中。</p>
<p>首先定义BIG_STRIDE的值为0x7FFFFFFF,即32位有符号整数中最大的整数的表示形式。步进值定义为 <code>P.pass =BigStride/P.priority</code> ， 其中 <code>P.priority</code> 表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。<code>STRIDE_MAX-STRIDE_MIN&lt;=BIG_STRIDE</code>，为了使溢出次数尽可能少，同时保证对于任意两个Stride差值在32位有符号整数的表示范围内，将BIGSTRIDE取为32位有符号整数中的最大值，。</p>
<p>stride值在累加过程中很可能会溢出，为了避免溢出导致比较失败，stride scheduling采取无符号数来解决此问题。piazza上相关的讨论摘录如下：</p>
<p>设置无符号整数ab作为两个stride<br>假设开始的时候a=b，之后b先增加。如果b没有溢出，此时a-b&lt;0，之后应该轮到a增加，此时是成功的。</p>
<p>如果b溢出，首先看到<code>schedule/default_sched.c</code>中有一句 <code>#define BIG_STRIDE 0x7FFFFFFF</code>，因为stride每次的增量都是 <code>BIG_STRIDE / priority</code>，所以stride每次最大的增量不会超过<code>BIG_STRIDE</code> 。</p>
<p>在加上步进值以后b溢出了，那么b之前必然大于<code>0x7FFFFFFF</code>,和一个小于<code>0x7FFFFFFF</code>的数相加才会溢出。在b溢出之后，无符号表示中，a仍为原来的值，而b会小于<code>0x7FFFFFFF</code>。a-b无符号大于<code>0x7FFFFFFF</code>（因为b的步进值小于<code>0x7FFFFFFF</code>），也就是有符号小于0，仍然是成功的。</p>
<p>所以问题的关键就在于<code>#define BIG_STRIDE 0x7FFFFFFF</code><br>这个值必须是有符号整数的最大值，这个是保证stride不会出错的原因<br>举个例子，把BIG_STRIDE增大，BIG_STRIDE=0xE0000000<br>那么初始令a=b=0xE0000000，b先前进0xE0000000，b变为0xC0000000​，此时就有a-b&gt;0，stride算法就错了。</p>
<blockquote>
<p>有效的BIG_STRIDE取值范围</p>
</blockquote>
<p>开始有A=B,最大步进S</p>
<ol>
<li>B+S不溢出则需$0$&lt;A&lt;B+S&lt;2^ 31​,比较粗略的范围，即0&lt;S&lt;​2^31</li>
<li>B+S溢出代表B+S&gt;=2^32</li>
</ol>
<p>溢出后B’=B+S-2^32</p>
<p>此时为使A-B’&lt;0,需要A&gt;=B’+2^31</p>
<p>即A&gt;=B+S-2^32+2^31=B+S-2^31</p>
<p>又由A=B</p>
<p>有0&gt;=S-2^31</p>
<p>即S&lt;=2^31</p>
<p>综合有S&lt;2^31</p>
<p>即S&lt;=0x7FFFFFFF</p>
<p>【约定】</p>
<ul>
<li>根据课上向老师的思路，我们可以将4字节的int简化为1字节来讨论。</li>
<li>考虑有A、B两个进程，其stride值分别记作<code>unsigned a,b</code>。</li>
<li>增量步长pass记作s。</li>
<li>stride值溢出，指的是无符号数的溢出，即a &gt;= 256。</li>
<li>“无符号数的有符号比较”这一技巧，下面简称“技巧”。它指的是(signed)(a-b)。</li>
</ul>
<p>【已知结论】</p>
<ul>
<li><p>结论1：“stride值不溢出且a,b相差不超过127时，技巧是合理的。”</p>
</li>
<li><p>结论2：“若进程A的stride值溢出，则应转而执行进程B。”</p>
</li>
<li><p>结论3：“s&lt;=255。”</p>
</li>
</ul>
<p>说明如下——</p>
<p>结论1：若a=1, b=2，则显然signed(a-b) = -1&lt;0合理；</p>
<p>若a=1, b=200，则signed(a-b) = signed(-199) = 57&gt;0不合理；</p>
<p>若a=127, b=255，则signed(a-b) = signed(-128) = -128&lt;0合理；</p>
<p>若a=255, b=127，则signed(a-b) = signed(128) = -128&lt;0不合理。</p>
<p>故a, b至多相差127。</p>
<p>结论2：这是合理的做法。</p>
<p>结论3：否则，若s=256，则有a+s = a，进程A将永远进行下去，不合理。</p>
<p>【stride值溢出时的情况分析】</p>
<p>根据结论2，我们的“技巧”应保证：</p>
<p>对于至多相差127的任意a, b，若①signed(a-b) &lt;= 0（说明当前A在运行），且②a + s &gt;= 256（A的stride溢出），则有signed(a + s - b) &gt; 0（则应转为B来运行）。</p>
<p>假设a&lt;=127，则由于结论3，溢出后的a + s &lt; a，signed(a-b) &lt; 0，不满足要求。</p>
<p>故128 &lt;= a &lt;= b &lt;= 255。</p>
<p>假设128 &lt;= s &lt;= 255，由于我们需要对任意满足条件的a, b都成立，故不妨取a = 255，b = 255，则signed(a + s - b) = signed(s) &lt; 0，不满足要求。</p>
<p>故s &lt;= 127。</p>
<p>因此，<strong>若进程A发生stride值溢出，则增加s之前的情形为，128 &lt;= a &lt;= b &lt;= 255。</strong></p>
<p><strong>当步长s &lt;= 127时，可以使得在溢出后，“技巧”仍能保证算法的正确性。</strong></p>
<p>【最终结论：最大步长限制】</p>
<p>结合结论1，我们得到了如下结论：</p>
<p><strong>当（任意进程的）步长s &lt;= 127时，“技巧”可以保证算法的正确性。（无论是否发生stride值溢出。）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG_STRIDE    0x7FFFFFFF</span></span><br></pre></td></tr></table></figure>
<p>具体比较函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">proc_stride_comp_f(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool);</span><br><span class="line">     <span class="keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调度器中其余函数实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_init(struct run_queue *rq) &#123;</span><br><span class="line">     list_init(&amp;(rq-&gt;run_list));<span class="comment">//run_list供list操作使用</span></span><br><span class="line">     rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;<span class="comment">//run_pool供skew_heap操作使用</span></span><br><span class="line">     rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SKEW_HEAP</span></span><br><span class="line">     rq-&gt;lab6_run_pool =</span><br><span class="line">          skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     assert(list_empty(&amp;(proc-&gt;run_link)));<span class="comment">//确保不在run_list中</span></span><br><span class="line">     list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">          proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">     &#125;</span><br><span class="line">     proc-&gt;rq = rq;</span><br><span class="line">     rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SKEW_HEAP</span></span><br><span class="line">     rq-&gt;lab6_run_pool =</span><br><span class="line">          skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">     list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">stride_pick_next</span>(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>) &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SKEW_HEAP</span></span><br><span class="line">     <span class="keyword">if</span> (rq-&gt;lab6_run_pool == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">     <span class="comment">//堆顶即为stride最小的进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">     <span class="keyword">if</span> (le == &amp;rq-&gt;run_list)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(le, run_link);</span><br><span class="line">     le = list_next(le);</span><br><span class="line">     <span class="keyword">while</span> (le != &amp;rq-&gt;run_list)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(le, run_link);</span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">int32_t</span>)(p-&gt;lab6_stride - q-&gt;lab6_stride) &gt; <span class="number">0</span>)</span><br><span class="line">               p = q;</span><br><span class="line">          le = list_next(le);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     <span class="keyword">if</span> (p-&gt;lab6_priority == <span class="number">0</span>)</span><br><span class="line">          p-&gt;lab6_stride += BIG_STRIDE;</span><br><span class="line">     <span class="keyword">else</span> p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;time_slice --;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>本文作者： </strong>trinkle
  </li>
  <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://twinkle0331.github.io/systems/ucore-lab6/" title="ucore lab6">http://twinkle0331.github.io/systems/ucore-lab6/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/ucore/" rel="tag"><i class="fa fa-tag"></i> ucore</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/systems/sched/" rel="prev" title="处理机调度">
                  <i class="fa fa-chevron-left"></i> 处理机调度
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/systems/sync/" rel="next" title="同步互斥">
                  同步互斥 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>







<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">trinkle</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/mist/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.1.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="/js/local-search.js"></script>






  




  


</body>
</html>
